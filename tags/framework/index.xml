<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Framework on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/framework/index.xml</link>
    <description>Recent content in Framework on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/framework/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Material Design com Materialize</title>
      <link>https://tableless.github.io/hugo-public/material-design-com-materialize/</link>
      <pubDate>Wed, 30 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/material-design-com-materialize/</guid>
      <description>

&lt;p&gt;Há muito tempo quero falar um pouco sobre desenvolvimento de sites utilizando layouts baseados no Material Design do Google, mas entre &lt;strong&gt;fazer&lt;/strong&gt; e &lt;strong&gt;falar&lt;/strong&gt; há um abismo enorme. Minha verdadeira intenção é compartilhar um pouco a maneira mais fácil de desenvolver um layout utilizando todos aqueles conceitos que a Google tem implementado atualmente.&lt;/p&gt;

&lt;h2 id=&#34;primeiros-passos&#34;&gt;Primeiros Passos&lt;/h2&gt;

&lt;p&gt;O &lt;a href=&#34;http://materializecss.com/&#34; target=&#34;_blank&#34;&gt;Materialize&lt;/a&gt; é um Framework desenvolvido para facilitar e agilizar nosso desenvolvimento quando o assunto é Material Design. Além de ágil, possui uma infinidade de vantagens que permitem que na maioria das vezes dispensam o uso de outros frameworks para complementá-lo.&lt;/p&gt;

&lt;p&gt;Para baixar os arquivos do Materialize clique em &lt;a href=&#34;http://materializecss.com/getting-started.html&#34; target=&#34;_blank&#34;&gt;Getting Started&lt;/a&gt;, lá você verá uma documentação explicando como fazer o download dos arquivos e todas as maneiras que você tem para fazer isso, ou também pode usar a CDN dele como geralmente muitos fazem com o JQUERY. Os arquivos são bem distribudos e não diferem dos demais Frameworks que existem.&lt;/p&gt;

&lt;h3 id=&#34;vamos-para-as-vantagens-dele&#34;&gt;Vamos para as vantagens dele&lt;/h3&gt;

&lt;p&gt;Uma das principais vantagens é o fato de ser muito similar ao Material Design desenvolvido pela google. Outra vantagem que podemos observar são os amplos recursos de JQuery que ele possui como: Slider, Lightbox, Captions, Modais, Transitions, Waves entre muitos outros. Melhor do que falar é mostrar. Esses recursos ficam na categoria &lt;a href=&#34;http://materializecss.com/media.html&#34; target=&#34;_blank&#34;&gt;JAVASCRIPT&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O sistema de grid usado é bastante parecido com os frameworks já existentes, como o Bootstrap.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/09/materialize-css-framework-01.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;body&amp;gt;
      &amp;lt;div class=&#34;container&#34;&amp;gt; &amp;lt;!-- Container similar ao utilizado em outros Frameworks --&amp;gt;
            &amp;lt;div class=&#34;row&#34;&amp;gt; &amp;lt;!-- Row também similar ao utilizado em outros Frameworks --&amp;gt;
                 &amp;lt;div class=&#34;col s12 m4 l4&#34;&amp;gt;Eu sou uma coluna&amp;lt;/div&amp;gt; &amp;lt;!-- Coluna com 3 tamanhos--&amp;gt;
            &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;

&lt;h4 id=&#34;entendendo-as-colunas&#34;&gt;Entendendo as colunas&lt;/h4&gt;

&lt;p&gt;É muito simples, assim como o bootstrap que trabalha com 4 tamanhos de coluna, muito pequeno, pequeno, médio e grande, o materialize decidiu trabalhar com 3 tamanhos que são pequeno médio e grande, nada que assuste ou prejudique o andamento do projeto. Para saber mais entre no &lt;a href=&#34;http://materializecss.com/grid.html&#34; target=&#34;_blank&#34;&gt;menu CSS e acesse o submenu Grid&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;alguns-pequenos-diferenciais-que-ele-possui&#34;&gt;Alguns pequenos diferenciais que ele possui&lt;/h3&gt;

&lt;p&gt;Alguns diferenciais que ele possui são os botões, o modal, os cards, as collections e o mais importante talves de todos o menu lateral, vou mostrar alguns desses abaixo.&lt;/p&gt;

&lt;h4 id=&#34;cards&#34;&gt;Cards&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/09/Sem-Título-1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;sidenav&#34;&gt;Sidenav&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/09/menu.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;vendo-essa-belezinha-funcionar&#34;&gt;Vendo essa belezinha funcionar ^^&lt;/h3&gt;

&lt;p&gt;Eu poderia colocar um milhão de exemplos feitos aqui, mas não tenho os direitos autorais deles então caso queira ver o showcase do site acesse o link &lt;a href=&#34;http://materializecss.com/showcase.html&#34; target=&#34;_blank&#34;&gt;Showcase&lt;/a&gt; e veja. Mas para não deixar vocês sem nenhum exemplo deixo aqui um site feito por mim através do materialize, espero que gostem o link está na imagem e abaixo dela.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.loguei.com/&#34; target=&#34;_blank&#34;&gt;&lt;br /&gt; &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/09/263dfd28861105.55d5d38e09a6f.jpg&#34; alt=&#34;&#34; /&gt;&lt;br /&gt; &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.loguei.com/&#34; target=&#34;_blank&#34;&gt;blog.loguei.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bem, aqui terminamos esse maravilhoso assunto sobre um Framework bem simples e maneiro de usar. Espero ter ajudado um pouco a todos. Obrigado ^^.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rotas dinâmicas no Silex</title>
      <link>https://tableless.github.io/hugo-public/silex-rotas-dinamicas/</link>
      <pubDate>Mon, 13 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/silex-rotas-dinamicas/</guid>
      <description>

&lt;p&gt;Continuando nossa jornada sobre o &lt;strong&gt;Silex Framework&lt;/strong&gt;, neste post falarei sobre rotas dinâmicas. Se você não está familiarizado com o Silex, confira nosso primeiro post _&lt;a href=&#34;http://tableless.com.br/conhecendo-e-instalando-o-silex/&#34; target=&#34;_blank&#34;&gt;Conhecendo e instalando o Silex&lt;/a&gt;_.&lt;/p&gt;

&lt;p&gt;Rotas dinâmicas são a possibilidade de passar parâmetros nas rotas da sua aplicação. O Silex possui diversos métodos para facilitar o uso dessa dinâmica em suas rotas.&lt;/p&gt;

&lt;h2 id=&#34;utilização&#34;&gt;Utilização&lt;/h2&gt;

&lt;p&gt;Para tornar sua rota dinâmica, veja o código abaixo:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
use Silex\Application;
require &#39;vendor/autoload.php&#39;;
$app = new Application();
$app-&amp;gt;get(&#39;users/{name}&#39;, function($name){
    return &#39;Olá, &#39; . $name;
});
$app-&amp;gt;run();
&lt;/pre&gt;

&lt;p&gt;O que nos interessa nesse momento, são as linhas de 5 e 6. Na linha 5 definimos nossa rota &lt;em&gt;users&lt;/em&gt;, que receberá requisições do tipo &lt;code&gt;GET&lt;/code&gt;. Perceba que entre chaves &lt;code&gt;{}&lt;/code&gt;, incluímos um elemento chamado &lt;code&gt;name&lt;/code&gt;, ou seja, esse é o parâmetro da nossa rota &lt;em&gt;users&lt;/em&gt;. Agora tudo que passarmos na URL após chamada a rota, poderemos manipular em nosso &lt;em&gt;callback&lt;/em&gt;, mas para isso devemos passar o mesmo parâmetro da rota como parâmetro do nosso &lt;em&gt;callback&lt;/em&gt;, como mostrado na mesma linha 5. Na linha 6 apenas retornamos como saída o valor passado na rota. Por exemplo, se acessarmos no navegador o seguinte link &lt;code&gt;http://url_de_minha_app.com.br/users/Nando&lt;/code&gt;, teríamos como saída:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Olá, Nando&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Se você deseja passar mais parâmetros, apenas separe os mesmos com &lt;code&gt;/&lt;/code&gt;, como mostrado abaixo:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
...
$app-&amp;gt;get(&#39;users/{name}/{email}&#39;, function($name, $email){
    //Sua_logica_aqui
});
...
&lt;/pre&gt;

&lt;h2 id=&#34;valores-default&#34;&gt;Valores Default&lt;/h2&gt;

&lt;p&gt;Se você deseja definir um valor &lt;em&gt;default&lt;/em&gt; para seus parâmetros de rota, é muito simples. O Silex possui um método para isso. Através do método &lt;code&gt;value()&lt;/code&gt; você definirá valores padrões para estes parâmetros, e quando acessar suas rotas sem informar nenhum valor esperado, entra em ação os valores definidos por padrão. Para usar o método &lt;code&gt;value()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
...
$app-&amp;gt;get(&#39;users/{name}&#39;, function($name){
    return &#39;Olá, &#39; . $name;
})
-&amp;gt;value(&#39;name&#39;, NULL);
...
&lt;/pre&gt;

&lt;p&gt;Na linha 6 defino o método &lt;code&gt;value&lt;/code&gt; que têm como primeiro parâmetro o nome definido para o parâmetro da rota, e o segundo parâmetro do método &lt;code&gt;value&lt;/code&gt; recebe o valor &lt;em&gt;default&lt;/em&gt; que você desejar. Sempre que acessarmos a rota &lt;em&gt;users&lt;/em&gt; sem definir nenhum valor após a mesma, nosso parâmetro &lt;code&gt;name&lt;/code&gt; receberá o valor NULL. A partir daí você fica livre para tratar como quiser a lógica da sua aplicação.&lt;/p&gt;

&lt;h2 id=&#34;o-método-convert&#34;&gt;O método convert()&lt;/h2&gt;

&lt;p&gt;Se você deseja garantir o tipo do valor passado ou apenas deseja conversões simples com estes valores, o método &lt;code&gt;convert&lt;/code&gt; foi feito para tal operação. Para utilizá-lo:&lt;/p&gt;

&lt;pre&gt;...
$app-&amp;gt;get(&#39;users/{name}&#39;, function($name){
    return &#39;Olá, &#39; . $name;
})
-&amp;gt;value(&#39;name&#39;, NULL)
-&amp;gt;convert(&#39;name&#39;, function($name){ return (string) $name; });
...
&lt;/pre&gt;

&lt;p&gt;O método recebe 2 parâmetros: o primeiro é o nome do parâmetro informado na rota e o segundo um &lt;em&gt;callback&lt;/em&gt;, onde realizamos nossas conversões. Neste exemplo, garanto apenas que os valores passados na rota &lt;code&gt;users&lt;/code&gt; serão de fato do tipo &lt;code&gt;string&lt;/code&gt;, como mostrado na linha 6 do código acima.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Vimos como é simples trabalhar com rotas dinâmicas em nossas aplicações Silex, e com os métodos auxiliares nossa aplicação de rotas fica ainda mais robusta.&lt;/p&gt;

&lt;p&gt;Na sessão &lt;a href=&#34;http://silex.sensiolabs.org/doc/usage.html&#34; target=&#34;_blank&#34;&gt;&amp;#8216;Usage&amp;#8217;&lt;/a&gt; da documentação do Silex, você encontrará mais opções além das mostradas aqui.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Material Design Lite: O framework do Google</title>
      <link>https://tableless.github.io/hugo-public/material-design-lite-o-framework-google/</link>
      <pubDate>Wed, 08 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/material-design-lite-o-framework-google/</guid>
      <description>&lt;p&gt;Em 2014 o Google apresentou o Material Design: um guia para redefinir o visual de aplicativos. Vários aplicativos aderiram ao Material Design, como por exemplo, o WhatsApp, que mudou por completo o visual.&lt;/p&gt;

&lt;p&gt;Para facilitar ainda mais a vida do usuário, o Google &lt;a href=&#34;https://medium.com/google-developers/introducing-material-design-lite-3ce67098c031&#34; target=&#34;_blank&#34;&gt;anunciou &lt;/a&gt;uma ferramenta para introduzir o Material Design em websites, chamado de &lt;a href=&#34;http://www.getmdl.io/&#34; target=&#34;_blank&#34;&gt;Material Design Lite (MDL).&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Assim como qualquer outro &lt;em&gt;framework&lt;/em&gt;, o MDL oferece uma documentação e vários exemplos para facilitar a aplicação em websites. O nome &amp;#8220;Lite&amp;#8221; &amp;#8211;  segundo o Google &amp;#8211; dá-se pela extrema facilidade, pouca dependência e também pelo tamanho do pacote (aproximadamente 27KB gzipped).&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MDL torna fácil adicionar o estilo &amp;#8220;&lt;em&gt;material design&lt;/em&gt;&amp;#8221; aos seus websites. (&amp;#8230;) É um framework agnóstico, isto é, significa que pode ser usado com quaisquer uma das ferramentas que surgem rapidamente no horizonte front-end. MDL é leve de carregar e estritamente focado em aplicar o &amp;#8220;&lt;em&gt;material design&lt;/em&gt;&amp;#8221; aos websites.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;O MDL é compatível com todos os navegadores modernos: Google Chrome, Mozilla Firefox, Opera e o novo Microsoft Edge que acaba de chegar no Windows 10. E claro, o MDL é responsivo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/07/1-zh2u4rTfC1HqViInpog1Ng.jpeg&#34;&gt;&lt;img class=&#34;alignnone wp-image-49904 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/07/1-zh2u4rTfC1HqViInpog1Ng.jpeg&#34; alt=&#34;Google Material Design Lite para Website&#34; width=&#34;1092&#34; height=&#34;409&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Assim como aconteceu nos aplicativos, é bem provável que veremos daqui para frente muitos websites aderindo a concepção do MDL, e, segundo informações do artigo do Google, o pessoal de lá não vê a hora que isso aconteça.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mal podemos esperar para ver os belos, modernos, sites responsivos que você irá construir com Material Design Lite.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;O link do Google Developers para o artigo de divulgação do MDL no Medium é este &lt;a href=&#34;https://medium.com/google-developers/introducing-material-design-lite-3ce67098c031&#34; target=&#34;_blank&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Conhecendo e instalando o Silex</title>
      <link>https://tableless.github.io/hugo-public/conhecendo-e-instalando-o-silex/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/conhecendo-e-instalando-o-silex/</guid>
      <description>

&lt;p&gt;O &lt;a href=&#34;http://silex.sensiolabs.org/&#34; target=&#34;_blank&#34;&gt;Silex&lt;/a&gt; é um micro framework baseado nos componentes do &lt;a href=&#34;http://symfony.com/&#34; target=&#34;_blank&#34;&gt;Symfony&lt;/a&gt;. Foi desenvolvido por &lt;a href=&#34;http://fabien.potencier.org/&#34; target=&#34;_blank&#34;&gt;Fabien Potencier&lt;/a&gt;, o mesmo criador do Symfony.&lt;/p&gt;

&lt;p&gt;O Silex foi concebido para a criação de aplicações pequenas com foco na agilidade, extensibilidade e para ser facilmente testável. Ele provê um sistema de rotas muito poderoso, e se propõe a resolvê-las através dos Services e Providers, conceitos que veremos mais à frente. Você perceberá que ele é facilmente estendido e suas funcionalidades recebem uma vantagem através dessas integrações.&lt;/p&gt;

&lt;h2 id=&#34;instalação&#34;&gt;Instalação&lt;/h2&gt;

&lt;p&gt;Para instalar o Silex em nossos projetos é muito simples: precisamos apenas do &lt;a href=&#34;https://getcomposer.org&#34; target=&#34;_blank&#34;&gt;Composer&lt;/a&gt; para gerenciar nossas dependências.&lt;/p&gt;

&lt;p&gt;Mas afinal, o que é o Composer? O Composer é um gerenciador de dependências para aplicações PHP, baseado nas GEMs do Ruby e no NPM do Node.JS. Com o Composer você pode facilmente gerenciar a instalação de pacotes de terceiros, bem como preparar o seu pacote para que ele fique disponível para os desenvolvedores que utilizam essa ferramenta. Tudo que precisaremos é de um arquivo composer.json na raiz de nosso projeto. Utilizaremos &lt;code&gt;api-events&lt;/code&gt; como nome da nossa pasta.&lt;/p&gt;

&lt;p&gt;Na raiz dessa pasta crie um arquivo composer.json com o seguinte conteúdo:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;require&#34; : {
    &#34;silex/silex&#34; : &#34;^1.2&#34;
    }
}
&lt;/pre&gt;

&lt;p&gt;O composer.json é o arquivo que o Composer lê para poder realizar as tarefas de download e instalação dos pacotes especificados.&lt;/p&gt;

&lt;p&gt;Agora vamos instalar o Composer em nosso projeto. O Composer pode ser utilizado de duas maneiras: de forma local e de forma global. Abordarei aqui a forma local. Para instalá-lo em sistemas Unix, você precisará da &lt;em&gt;lib curl&lt;/em&gt; disponível. Se você utiliza o Windows, baixe o executável &lt;a href=&#34;https://getcomposer.org/Composer-Setup.exe&#34; target=&#34;_blank&#34;&gt;aqui&lt;/a&gt;. O seguinte comando, executado via terminal (e na raiz de nosso projeto), deve instalar o Composer para você:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/curl-composer.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-49783 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/curl-composer.png&#34; alt=&#34;Curl Composer&#34; width=&#34;902&#34; height=&#34;72&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O comando fará o download e irá compilar o composer.phar e arquivos &lt;a href=&#34;http://php.net/phar&#34;&gt;&lt;code&gt;.phar&lt;/code&gt;&lt;/a&gt;, que são extensões executáveis do PHP. Agora que temos o arquivo de configuração e o Composer em nosso projeto, podemos instalar nossas dependências, ou seja, o Silex propriamente dito. É muito simples realizar a instalação dos pacotes: na raiz do seu projeto, execute o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php composer.phar install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;É preciso que você tenha o &lt;a href=&#34;http://www.php-cli.com/&#34; target=&#34;_blank&#34;&gt;php-cli&lt;/a&gt; disponível em seu terminal. O comando acima verificará o arquivo &lt;code&gt;composer.json&lt;/code&gt; e logo em seguida fará o download do Silex, conforme requerido no arquivo &lt;code&gt;.json&lt;/code&gt; da versão 1.2. Após tudo concluído, você verá uma imagem semelhante a essa:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/packages-installed.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-49784 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/packages-installed.png&#34; alt=&#34;Silex - Packages instalados&#34; width=&#34;742&#34; height=&#34;769&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O Composer instalou o Silex bem como as dependências utilizadas pelo mesmo dentro da pasta &lt;code&gt;vendor&lt;/code&gt; do nosso projeto. Além do download, ele também mapeia os &lt;em&gt;namespaces&lt;/em&gt; dos pacotes e cria um _autoload._ Através deste &lt;em&gt;autoload&lt;/em&gt; teremos acesso a todos os pacotes baixados até o momento.&lt;/p&gt;

&lt;h2 id=&#34;silex-hello-world&#34;&gt;Silex: Hello World!&lt;/h2&gt;

&lt;p&gt;Agora que nossas dependências foram baixadas e instaladas, podemos começar a utilizar nosso micro framework: crie um arquivo &lt;code&gt;index.php&lt;/code&gt; na raiz da sua pasta e adicione a abertura do código PHP utilizando o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo &amp;quot;&amp;lt;?php &amp;quot; &amp;gt; index.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Abaixo segue o código do index na íntegra:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
use Silex\Application;
require &#39;vendor/autoload.php&#39;;
$app = new Application();
$app-&amp;gt;get(&#39;/&#39;, function(){
    return &#39;Hello World&#39;;
});
$app-&amp;gt;run();
&lt;/pre&gt;

&lt;p&gt;Na linha 2 informo ao meu script para utilizar o Silex com o namespace &lt;code&gt;Silex\Application&lt;/code&gt;. Para ter acesso aos namespaces dos pacotes baixados (como comentado anteriormente sobre o autoload) precisamos adicionar o mesmo em nosso index. Para isso utilizamos o &lt;code&gt;require&lt;/code&gt; na linha 3. Na linha 4 simplesmente instanciamos nosso micro framework. O já citado poderoso sistema de rotas pode ser visto das linhas 5 a 6, onde utilizamos o método &lt;code&gt;get&lt;/code&gt;. O método &lt;code&gt;get&lt;/code&gt; manipula as requisições GET vindas do _client_ e no nosso caso fazemos o seguinte:&lt;/p&gt;

&lt;p&gt;Quando o cliente realizar uma requisição do tipo GET em nossa rota raiz, referenciada através da &lt;code&gt;/&lt;/code&gt;, nós executaremos o que for passado dentro do &lt;em&gt;callback&lt;/em&gt;, o segundo parâmetro do método &lt;code&gt;get&lt;/code&gt; do &lt;code&gt;Silex\Application&lt;/code&gt;. Como queremos apenas realizar (imprimir) um &amp;#8220;Hello World&amp;#8221;, vamos retornar essa &lt;em&gt;string&lt;/em&gt; em nosso &lt;em&gt;callback&lt;/em&gt; para a rota raiz.&lt;/p&gt;

&lt;p&gt;E por fim, para que as respostas emitidas pelo Silex sejam enviadas ao browser ou a quem as solicitou, utilizamos o método &lt;code&gt;run&lt;/code&gt; em nossa linha 8. Ao rodar nosso app no browser, temos a seguinte resposta:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hello World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver o quão simples é utilizar esse micro framework através dos processos vistos até aqui. Para os próximos artigos, vamos nos aprofundar mais neste micro framework e ver como utilizá-lo melhor em casos reais.&lt;/p&gt;

&lt;p&gt;Por hora, pratique os conhecimentos aqui passados. Nos vemos em breve!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte Final</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-final/</link>
      <pubDate>Tue, 16 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-final/</guid>
      <description>

&lt;p&gt;Chegamos ao final da nossa série sobre Symfony. Se você não leu os outros, no final do artigo há uma &lt;a href=&#34;#other-posts-symfony&#34;&gt;listagem com todos os artigos&lt;/a&gt; já publicados dessa série.&lt;/p&gt;

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-09/&#34; target=&#34;_blank&#34;&gt;tutorial anterior&lt;/a&gt;, instalamos e configuramos o bundle StofDoctrineExtensionsBundle, para fazermos os slugs de nossos posts, agora vamos instalar e configurar o Bundle FOSUserBundle, para fazer a autenticação da área administrativa do nosso blog.&lt;/p&gt;

&lt;h2 id=&#34;instalação-do-bundle-fosuserbundle&#34;&gt;Instalação do bundle FOSUserBundle.&lt;/h2&gt;

&lt;p&gt;Para instalar o FOSUserBundle, temos que adicioná-lo em nosso composer.json. Abra o arquivo composer.json e adicione a linha abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&#34;friendsofsymfony/user-bundle&#34;: &#34;1.3.*&#34;
&lt;/pre&gt;

&lt;p&gt;Depois de adicionando o FOSUserBundle no composer, vamos instalá- lo. Entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ composer update
&lt;/pre&gt;

&lt;p&gt;Após o Download, o FOSUserBundle está instalado em nossa aplicação.&lt;/p&gt;

&lt;h2 id=&#34;configurando-o-fosuserbundle&#34;&gt;Configurando o FOSUserBundle.&lt;/h2&gt;

&lt;p&gt;A primeira configuração que devemos fazer, é registrar o novo bundle instalado, para isso entre no AppKernel, caminho: app/AppKernel.php&lt;/p&gt;

&lt;p&gt;Adicione a linha abaixo no registro de bundles:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;new FOS\UserBundle\FOSUserBundle(),
&lt;/pre&gt;

&lt;p&gt;Veja na linha 18:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;class AppKernel extends Kernel 
{ 
    public function registerBundles() 
    { 
        $bundles = array( 
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(), 
            new Symfony\Bundle\SecurityBundle\SecurityBundle(), 
            new Symfony\Bundle\TwigBundle\TwigBundle(), 
            new Symfony\Bundle\MonologBundle\MonologBundle(), 
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(), 
            new Symfony\Bundle\AsseticBundle\AsseticBundle(), 
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(), 
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(), 
            new Tableless\CoreBundle\TablelessCoreBundle(), 
            new Tableless\ModelBundle\TablelessModelBundle(), 
         new Knp\Bundle\PaginatorBundle\KnpPaginatorBundle(),
         new Stof\DoctrineExtensionsBundle\StofDoctrineExtensionsBundle(),
         new FOS\UserBundle\FOSUserBundle(),
        );

...
&lt;/pre&gt;

&lt;p&gt;Pronto, o FOSUserBundle está registrado.&lt;/p&gt;

&lt;p&gt;Agora vamos fazer as configurações no arquivo config.yml, caminho: app/config/config.yml.&lt;/p&gt;

&lt;p&gt;Para que o sistema de login venha traduzido, devemos descomentar a linha translator em framework, veja na linha 3 do código abaixo:&lt;/p&gt;

&lt;p&gt;De:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;framework:
    #esi:             ~
    #translator:      { fallback: &#34;%locale%&#34; }
&lt;/pre&gt;

&lt;p&gt;Para:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;framework:
    #esi:             ~
    translator:      { fallback: &#34;%locale%&#34; }
&lt;/pre&gt;

&lt;p&gt;No final do arquivo adicione as configurações abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;# FOSUser
fos_user:
    db_driver: orm # other valid values are &#39;mongodb&#39;, &#39;couchdb&#39; and &#39;propel&#39;
    firewall_name: main
    user_class: Tableless\UserBundle\Entity\User
&lt;/pre&gt;

&lt;p&gt;Perceba que na configuração acima, estamos indicando uma entidade User, porém ainda não existente, vamos criá-la.&lt;/p&gt;

&lt;h2 id=&#34;criando-o-bundle-userbundle&#34;&gt;Criando o bundle UserBundle.&lt;/h2&gt;

&lt;p&gt;Continuando com nossas configurações, podemos criar um novo bundle para que o mesmo fique responsável pelo gerenciamento dos usuários, em nosso caso, vamos criar o bundle, porém só vamos usar para configurar a entidade User, caso queiram fazer outras configurações, o bundle já está criado.&lt;/p&gt;

&lt;p&gt;Entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:bundle
&lt;/pre&gt;

&lt;p&gt;Digitamos a namespace:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Bundle namespace: Tableless/UserBundle
&lt;/pre&gt;

&lt;p&gt;O console nos sugere um nome, vamos deixar como está, apenas damos enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Bundle name [TablelessUserBundle]:
&lt;/pre&gt;

&lt;p&gt;No caminho, apenas damos enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Target directory [/media/candidosouza/Development/GITHUB/tableless/symfony/src]:
&lt;/pre&gt;

&lt;p&gt;Usaremos annotation para configurações:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Configuration format (yml, xml, php, or annotation): annotation
&lt;/pre&gt;

&lt;p&gt;Não vamos querer a geração de toda a estrutura de um bundle, apenas damos enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Do you want to generate the whole directory structure [no]? 
&lt;/pre&gt;

&lt;p&gt;Vamos confirmar a geração do novo bundle, damos enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Do you confirm generation [yes]? 
&lt;/pre&gt;

&lt;p&gt;E vamos registrar esse bundle, somente enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Confirm automatic update of your Kernel [yes]?
&lt;/pre&gt;

&lt;p&gt;E gerar as rotas, damos enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Confirm automatic update of the Routing [yes]?
&lt;/pre&gt;

&lt;p&gt;Pronto, nosso bundle UserBundle está criado, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/01.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/01.png&#34; alt=&#34;pasta&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49557&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nosso bundle está criado, vamos criar nossa entidade User.&lt;/p&gt;

&lt;h2 id=&#34;criando-a-entidade-user&#34;&gt;Criando a Entidade User.&lt;/h2&gt;

&lt;p&gt;Vamos entrar no bundle UserBundle, caminho src/Tableless/UserBundle/, e vamos criar uma pasta chamada Entity. Nessa pasta vamos criar uma classe User, que será nossa entidade, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/02.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/02.png&#34; alt=&#34;Entidade User&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49558&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A nossa entidade User tem que estender a entidade User do FOSUserBundle, vamos dar um use nessa classe e vamos apelida lá de BaseUser, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use FOS\UserBundle\Entity\User as BaseUser;
&lt;/pre&gt;

&lt;p&gt;Também temos que passar as configurações (mapear nossa entidade) via annotation, vamos dar um use na classe Mapping do Doctrine e apelida lá de ORM, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Doctrine\ORM\Mapping as ORM;
&lt;/pre&gt;

&lt;p&gt;Nossa Entidade terá apenas um atributo id, e um método construtor que chamará construtor pai de entidade BaseUser, juntamente com as respectivas annotations, veja nossa entidade User pronta:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\UserBundle\Entity;

use FOS\UserBundle\Entity\User as BaseUser;
use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity
 * @ORM\Table(name=&#34;fos_user&#34;)
 */
class User extends BaseUser
{
    /**
     * @ORM\Id
     * @ORM\Column(type=&#34;integer&#34;)
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;)
     */
    protected $id;

    public function __construct()
    {
        parent::__construct();
    }
}
&lt;/pre&gt;

&lt;h2 id=&#34;configurações-de-segurança&#34;&gt;Configurações de segurança.&lt;/h2&gt;

&lt;p&gt;Para configurar a parte de segurança, temos que editar o arquivo security.yml, responsável pela parte de segurança do Symfony, abra o arquivo, caminho: app/config/security.yml.&lt;/p&gt;

&lt;p&gt;Abrindo o arquivo, vamos perceber que o Symfony está configurando o provider via memória, vamos alterar o provider.&lt;/p&gt;

&lt;p&gt;De:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;providers:
    in_memory:
        memory: ~
&lt;/pre&gt;

&lt;p&gt;Para:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;providers:
    fos_userbundle:
        id: fos_user.user_provider.username
&lt;/pre&gt;

&lt;p&gt;Para criptografar a senha do usuário vamos configurar um encoder, incluindo o código abaixo, que usará o algoritmo sha512, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;encoders:
        FOS\UserBundle\Model\UserInterface: sha512
&lt;/pre&gt;

&lt;p&gt;Agora vamos configurar a parte de firewalls, onde estabeleceremos o pattern para ativação do firewalls, que pelo acesso da url será ativado, e qual o tipo de provider que será usado para o processo de autenticação, também passaremos o processo de autenticação apenas pelo formulário, não permitindo outro tipo de requisição, usando o csrf_provider. Vamos permitir o logout, e usuários anônimos nas áreas não restritas, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;firewalls:
        main:
            pattern: ^/
            form_login:
                provider: fos_userbundle
                csrf_provider: form.csrf_provider
            logout:       true
            anonymous:    true
&lt;/pre&gt;

&lt;p&gt;Temos que passar qual o tipo de acesso o usuário terá que ter, para acessar determinadas urls, ex: o usuário anônimo, só poderá acessar as urls: qualquer-url/login, qualquer-url/register, e qualquer-url/resetting, e apenas usuários administradores, poderão acessar a url: qualquer-url/admin/, para isso passaremos a configuração de controle de acesso, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;access_control:
        - { path: ^/login$, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/register, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/resetting, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/admin/, role: ROLE_ADMIN }
&lt;/pre&gt;

&lt;p&gt;Temos que configurar a hierarquia de usuários cadastrados, onde o admin, poderá ser qualquer usuário cadastrado, e o super admin, será o administrador com total acesso, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;role_hierarchy:
        ROLE_ADMIN:       ROLE_USER
        ROLE_SUPER_ADMIN: ROLE_ADMIN
&lt;/pre&gt;

&lt;p&gt;Veja o arquivo security.yml pronto:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;security:
    providers:
        fos_userbundle:
            id: fos_user.user_provider.username

    encoders:
        FOS\UserBundle\Model\UserInterface: sha512

    firewalls:
        main:
            pattern: ^/
            form_login:
                provider: fos_userbundle
                csrf_provider: form.csrf_provider
            logout:       true
            anonymous:    true

    access_control:
        - { path: ^/login$, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/register, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/resetting, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/admin/, role: ROLE_ADMIN }

    role_hierarchy:
        ROLE_ADMIN:       ROLE_USER
        ROLE_SUPER_ADMIN: ROLE_ADMIN
&lt;/pre&gt;

&lt;p&gt;Pronto as configurações de segurança, estão prontas.&lt;/p&gt;

&lt;p&gt;E para finalizar as configurações, temos que passar as rotas do FOSUserBundle onde ficarão registradas no sistema, para isso abra o arquivo routing.yml, caminho: app/config/routing.yml.&lt;/p&gt;

&lt;p&gt;Com o arquivo aberto vamos inserir as rotas abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;# FOSUser
fos_user_security:
    resource: &#34;@FOSUserBundle/Resources/config/routing/security.xml&#34;

fos_user_profile:
    resource: &#34;@FOSUserBundle/Resources/config/routing/profile.xml&#34;
    prefix: /profile

fos_user_register:
    resource: &#34;@FOSUserBundle/Resources/config/routing/registration.xml&#34;
    prefix: /register

fos_user_resetting:
    resource: &#34;@FOSUserBundle/Resources/config/routing/resetting.xml&#34;
    prefix: /resetting

fos_user_change_password:
    resource: &#34;@FOSUserBundle/Resources/config/routing/change_password.xml&#34;
    prefix: /profile
&lt;/pre&gt;

&lt;p&gt;Para que tudo ocorra bem, temos que atualizar o banco de dados, para criar a tabela dos usuários, entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php app/console doctrine:schema:update --force
&lt;/pre&gt;

&lt;p&gt;veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/03.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/03.png&#34; alt=&#34;Tabela do banco de dados&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49559&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;estilizando-as-templates-do-fosuserbundle&#34;&gt;Estilizando as templates do FOSUserBundle.&lt;/h2&gt;

&lt;p&gt;O FOSUserBundle está configurado e instalado em nosso sistema, para que possamos testá-lo, entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php app/console router:debug
&lt;/pre&gt;

&lt;p&gt;E veremos todas as rotas criadas em nosso sistema através FOSUserBundle, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/04.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/04.png&#34; alt=&#34;Router Debug&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49561&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Podemos entrar em todas as rotas, e perceberemos que está sem estilização, por exemplo: a rota /register/, se acessamos no navegador essa rota: url: &lt;a href=&#34;http://127.0.0.1:8000/register/&#34;&gt;http://127.0.0.1:8000/register/&lt;/a&gt; veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/05.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/05.png&#34; alt=&#34;tela de registro&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49562&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Está funcionando perfeitamente, porém sem estilização. Vou explicar como fazer para melhorarmos isso, porém não vou me aprofundar.&lt;/p&gt;

&lt;p&gt;As templates do FOSUserBundle estão todas na pasta friendsofsymfony dentro do diretório vendor/, porém, sabemos que nunca devemos mexer em nada no diretório vendor, entretanto podemos sobrescrever essas templates principais do FOSUserBundle, para isso vamos criar uma pasta chamada FOSUserBundle em app/Resources, e dentro da pasta criada, vamos criar outra pasta chamada views, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/06.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/06.png&#34; alt=&#34;Pasta views&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49563&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O FOSUserBundle, trabalha com um layout principal, para que possamos sobrescrevê-lo, dentro da pasta views, vamos criar um arquivo chamado layout.html.twig e estender a nossa template base já criada anteriormente. A tamplate layout.html.twig ficará dessa forma, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;{% extends &#39;::base.html.twig&#39; %}

{% block title %}Blog Administração{% endblock %}

{% block content %}
    {% block fos_user_content %}{% endblock %}
{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Pronto, se acessarmos novamente o url: &lt;a href=&#34;http://127.0.0.1:8000/register/&#34;&gt;http://127.0.0.1:8000/register/&lt;/a&gt;, teremos o resultado:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/07.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/07.png&#34; alt=&#34;Tela de registro pronta&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49564&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pronto, ficou melhor que anteriormente, porém podemos melhorar essa estilização, em meu caso vou deixar como está, mas caso queiram, é só criar um arquivo css com as devidas estilizações, e chamá- lo no base.html.twig que configuramos no &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-06/&#34; target=&#34;_blank&#34;&gt;tutorial 06&lt;/a&gt;, ou usar o próprio bootstrap, e fazer as alterações nos arquivos.&lt;/p&gt;

&lt;p&gt;Obs: Podemos sobrescrever todos os arquivos do FOSUserBundle, porém temos que criar os arquivos e as estruturas de pastas, como no original. &lt;a href=&#34;https://github.com/FriendsOfSymfony/FOSUserBundle/tree/1.3.x/Resources/views&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Veja o original&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dessa forma podemos usar as classes do bootstrap para a estilização nos arquivos sobrescritos que foram criados, caso queiram ter uma base, tem um projeto em meu Github, que foi criado dessa forma, &lt;a href=&#34;https://github.com/candidosouza/management-cars/tree/master/app/Resources/FOSUserBundle/views/Registration&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;veja&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;criando-um-administrador&#34;&gt;Criando um Administrador&lt;/h2&gt;

&lt;p&gt;Podemos criar os usuários pela url: &lt;a href=&#34;http://127.0.0.1:8000/register/&#34;&gt;http://127.0.0.1:8000/register/&lt;/a&gt;, porém os usuários criados serão usuários normais do sistema, para criar um super administrador entre no terminal, e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php app/console
&lt;/pre&gt;

&lt;p&gt;Podemos perceber que agora temos mais opções, pois instalamos o FOSUserBundle, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/08.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/08.png&#34; alt=&#34;Novos comandos&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49565&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;E para criar um usuário administrador digitamos:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php app/console fos:user:create
&lt;/pre&gt;

&lt;p&gt;damos um nome, um e-mail e senha, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/09.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/09.png&#34; alt=&#34;Criando usuário&#34; width=&#34;750&#34; height=&#34;150&#34; class=&#34;alignnone size-full wp-image-49566&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Porém o usuário criado, ainda é um usuário normal, vamos torná-lo um administrador, ainda no terminal, digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php app/console fos:user:promote
&lt;/pre&gt;

&lt;p&gt;Escolhemos o usuário que no meu caso é admin.&lt;/p&gt;

&lt;p&gt;Digitamos o Role que queremos, no meu caso ROLE_ADMIN&lt;/p&gt;

&lt;p&gt;E pronto, já temos um administrador do sistema.&lt;/p&gt;

&lt;h2 id=&#34;restringindo-o-acesso-no-sistema&#34;&gt;Restringindo o acesso no sistema.&lt;/h2&gt;

&lt;p&gt;Para que um usuário anônimo não tenha acesso a administração, ( em nosso caso a administração de autores e administração de posts), vamos entrar novamente em security.yml, caminho: app/config/security.yml, e vamos alterar o controle de acesso, dizendo que todo o usuário que entrar na rota /post/ e /author/ deverá ser um usuário cadastrado, veja na linha 5 e 6:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;access_control:
        - { path: ^/login$, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/register, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/resetting, role: IS_AUTHENTICATED_ANONYMOUSLY }
        - { path: ^/author/, role: ROLE_USER }
        - { path: ^/post/, role: ROLE_USER }
        - { path: ^/admin/, role: ROLE_ADMIN }
&lt;/pre&gt;

&lt;p&gt;Pronto, dessa forma todos os usuários que acessarem as urls: &lt;a href=&#34;http://127.0.0.1:8000/post/&#34;&gt;http://127.0.0.1:8000/post/&lt;/a&gt; e &lt;a href=&#34;http://127.0.0.1:8000/author/&#34;&gt;http://127.0.0.1:8000/author/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;deverão ser cadastrados como usuários, como autores do blog ou administradores.&lt;/p&gt;

&lt;p&gt;Obs: Quando o usuário anônimo acessar as urls citadas acima, serão redirecionados para a tela de login.&lt;/p&gt;

&lt;p&gt;Podemos fazer várias restrições, exemplo: vamos dizer que o usuário autor, pode: visualizar, criar, editar, e deletar um post, porém, ele não pode: criar, nem editar, menos ainda deletar outro autor, para isso entre no AuthorController, caminho: src/Tableless/CoreBundle/Controller/AuthorController.php&lt;/p&gt;

&lt;p&gt;Primeiramente damos um use em AccessDeniedException, na classe AuthorController, veja.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Symfony\Component\Security\Core\Exception\AccessDeniedException;
&lt;/pre&gt;

&lt;p&gt;Nos métodos createAction, newAction, editAction, updateAction e deleteAction, vamos restringir o acesso do usuário normal, onde verificaremos se ele é um administrador, e caso não seja, vamos gerar um erro, veja o código de verificação abaixo, onde introduziremos em todos os métodos citados acima, :&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;$securityContext = $this-&amp;gt;get(&#39;security.context&#39;);

        if (!$securityContext-&amp;gt;isGranted(&#39;ROLE_ADMIN&#39;)) {
            throw new AccessDeniedException(&#34; Somente o administrador pode acessar! &#34;);
        }
&lt;/pre&gt;

&lt;p&gt;Exemplo no createAction, nos demais métodos serão iguais, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
* Creates a new Author entity.
*
* @Route(&#34;/&#34;, name=&#34;author_create&#34;)
* @Method(&#34;POST&#34;)
* @Template(&#34;TablelessCoreBundle:Author:new.html.twig&#34;)
*/
public function createAction(Request $request)
{
   $securityContext = $this-&amp;gt;get(&#39;security.context&#39;);

   if (!$securityContext-&amp;gt;isGranted(&#39;ROLE_ADMIN&#39;)) {
      throw new AccessDeniedException(&#34; Somente o administrador pode acessar! &#34;);
   }

    $entity = new Author();
    $form = $this-&amp;gt;createCreateForm($entity);
    $form-&amp;gt;handleRequest($request);

    if ($form-&amp;gt;isValid()) {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();
        $em-&amp;gt;persist($entity);
        $em-&amp;gt;flush();

     return $this-&amp;gt;redirect($this-&amp;gt;generateUrl(&#39;author_show&#39;, array(&#39;id&#39; =&amp;gt; $entity&amp;gt; getId())));
   }

   return array(
   &#39;entity&#39; =&amp;gt; $entity,
       &#39;form&#39;   =&amp;gt; $form-&amp;gt;createView(),
   );
}
&lt;/pre&gt;

&lt;p&gt;Veja o erro caso o usuário não tenha acesso:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/10.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/10.png&#34; alt=&#34;Erro de usuário não autorizado&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-49583&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pronto!&lt;/p&gt;

&lt;p&gt;Podemos fazer outros tipos de restrições, podemos melhorar a segurança em nosso blog, porém no meu caso vou parar por aqui, com o exemplo acima, acredito que temos uma base de como fazer as demais restrições.&lt;/p&gt;

&lt;h2 id=&#34;dicas&#34;&gt;Dicas:&lt;/h2&gt;

&lt;p&gt;Nos tutoriais abordei o básico de como trabalhar com o Symfony 2. Recomendo sempre a documentação para auxílio.&lt;/p&gt;

&lt;p&gt;Gostaria de deixar algumas dicas para estudos, que não foram abordados:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://symfony.com/doc/current/book/service_container.html&#34; target=&#34;_blank&#34;&gt;Services&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://symfony.com/doc/current/book/performance.html&#34; target=&#34;_blank&#34;&gt;Performance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://symfony.com/doc/current/book/testing.html&#34; target=&#34;_blank&#34;&gt;Testing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://symfony.com/doc/current/book/http_cache.html&#34; target=&#34;_blank&#34;&gt;HTTP Cache:&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://symfony.com/doc/current/book/translation.html&#34; target=&#34;_blank&#34;&gt;Translation:&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;other-posts-symfony&#34;&gt;Conclusão.&lt;/h2&gt;

&lt;p&gt;Esta é a última parte da série “Iniciando com Symfony 2”, espero ter sido útil.&lt;/p&gt;

&lt;p&gt;Bons estudos!&lt;/p&gt;

&lt;p&gt;Links dos tutoriais anteriores:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – Instalação&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 02&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 03&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-05/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 05&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-06/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 06&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-07/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 07&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-08/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 08&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-09/&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 09&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O projeto encontra-se no &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 09</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-09/</link>
      <pubDate>Sun, 24 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-09/</guid>
      <description>

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-08/&#34; title=&#34;tutorial anterior&#34; target=&#34;_blank&#34;&gt;tutorial anterior&lt;/a&gt;, instalamos e configuramos o bundle Knp Paginator, para fazer a paginação de posts em nosso index, agora vamos instalar e configurar o Bundle StofDoctrineExtensionsBundle, para fazermos os slugs de nossos posts&lt;/p&gt;

&lt;h2 id=&#34;instalação-do-bundle-stofdoctrineextensionsbundle&#34;&gt;Instalação do bundle StofDoctrineExtensionsBundle&lt;/h2&gt;

&lt;p&gt;Para instalar o StofDoctrineExtensionsBundle, temos que adicioná-lo em nosso composer.json. Abra o arquivo composer.json e adicione a linha abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&#34;stof/doctrine-extensions-bundle&#34;: &#34;1.2.*@dev&#34;
&lt;/pre&gt;

&lt;p&gt;Depois de adicionando o StofDoctrineExtensionsBundle no composer, vamos instalá- lo. Entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ composer update
&lt;/pre&gt;

&lt;p&gt;Após o Download, o StofDoctrineExtensionsBundle está instalado em nossa aplicação.&lt;/p&gt;

&lt;h2 id=&#34;configurando-o-stofdoctrineextensionsbundle&#34;&gt;Configurando o StofDoctrineExtensionsBundle&lt;/h2&gt;

&lt;p&gt;A primeira configuração que devemos fazer, é registrar o novo bundle instalado, para isso entre no AppKernel, caminho: app/AppKernel.php&lt;/p&gt;

&lt;p&gt;Adicione a linha abaixo no registro de bundles:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;new Stof\DoctrineExtensionsBundle\StofDoctrineExtensionsBundle(),
&lt;/pre&gt;

&lt;p&gt;Veja na linha 17:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;class AppKernel extends Kernel 
{ 
    public function registerBundles() 
    { 
        $bundles = array( 
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(), 
            new Symfony\Bundle\SecurityBundle\SecurityBundle(), 
            new Symfony\Bundle\TwigBundle\TwigBundle(), 
            new Symfony\Bundle\MonologBundle\MonologBundle(), 
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(), 
            new Symfony\Bundle\AsseticBundle\AsseticBundle(), 
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(), 
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(), 
            new Tableless\CoreBundle\TablelessCoreBundle(), 
            new Tableless\ModelBundle\TablelessModelBundle(), 
        new Knp\Bundle\PaginatorBundle\KnpPaginatorBundle(),
        new Stof\DoctrineExtensionsBundle\StofDoctrineExtensionsBundle(),
        );

...

&lt;/pre&gt;

&lt;p&gt;Pronto, o StofDoctrineExtensionsBundle está registrado.&lt;/p&gt;

&lt;p&gt;Agora vamos fazer as configurações no arquivo config.yml, caminho: app/config/config.yml&lt;/p&gt;

&lt;p&gt;No final do arquivo adicione as configurações abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;stof_doctrine_extensions:
    orm:
        default:
            sluggable: true
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-a-entidade-post&#34;&gt;Configurando a entidade Post&lt;/h2&gt;

&lt;p&gt;Temos que configurar nossa entidade post, para que a mesma receba os slugs. Entre na entidade post, caminho: src/Tableless/ModelBundle/Entity/Post.php&lt;/p&gt;

&lt;p&gt;Vamos dar um use em Annotation, e apelidá-la de Gedmo veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Gedmo\Mapping\Annotation as Gedmo;
&lt;/pre&gt;

&lt;p&gt;Agora vamos criar uma propriedade privada chamada slug, com as suas annotations correspondentes, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
     * @var string
     *
     * @Gedmo\Slug(fields={&#34;title&#34;}, unique=false)
     * @ORM\Column(length=255)
     */
     private $slug;

...

&lt;/pre&gt;

&lt;p&gt;Temos que gerar os getters e setters, para isso vamos entrar no terminal e digitar:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:entities TablelessModelBundle:Post
&lt;/pre&gt;

&lt;p&gt;Pronto, em nossa entidade Post, temos os getters e setters, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
     * Set slug
     *
     * @param string $slug
     *
     * @return Post
     */
    public function setSlug($slug)
    {
        $this-&amp;gt;slug = $slug;

        return $this;
    }

    /**
     * Get slug
     *
     * @return string
     */
    public function getSlug()
    {
        return $this-&amp;gt;slug;
    }

...
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-o-banco-de-dados&#34;&gt;Configurando o Banco de Dados&lt;/h2&gt;

&lt;p&gt;Depois de nossa entidade configurada, temos que atualizar o banco de dados, porém se tivermos posts já criados, ocorrerá um erro em nosso blog. Caso não tenha nenhum post escrito poderá rodar o comando abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:schema:update –force
&lt;/pre&gt;

&lt;p&gt;Caso tenha escrito algum post para exemplo, como no meu caso, vamos excluir o banco de dados, e criá lo novamente. Entre no terminal e digite:&lt;/p&gt;

&lt;p&gt;Excluindo o banco de dados:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;$ php app/console doctrine:database:drop --force
&lt;/pre&gt;

&lt;p&gt;Criando o banco de dados novamente:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:database:create
&lt;/pre&gt;

&lt;p&gt;Criando as tabelas:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:schema:create
&lt;/pre&gt;

&lt;p&gt;Obs: Caso tenha posts escritos, e não queria excluir o banco de dados, poderá apenas atualizá-lo, porém terá que adicionar manualmente, slug por slug em cada post no banco de dados, senão ocorrerá erro na aplicação.&lt;/p&gt;

&lt;p&gt;Veja a estrutura do banco de dados:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/05/01.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/05/01.png&#34; alt=&#34;Banco de dados&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-48547&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;configurando-o-controller&#34;&gt;Configurando o Controller&lt;/h2&gt;

&lt;p&gt;Depois de termos feito as configurações citadas acima, vamos configurar nosso controller, para isso entre no IndexControlerController, caminho: src/Tableless/CoreBundle/Controller/IndexControlerController.php&lt;/p&gt;

&lt;p&gt;No nosso método showAction, estamos passando por parâmetro o $id, no momento não queremos mais buscar nossos posts pelo id, e sim pelo slug, vamos alterar:&lt;/p&gt;

&lt;p&gt;de:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;public function showAction($id)
&lt;/pre&gt;

&lt;p&gt;para:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;public function showAction($slug)
&lt;/pre&gt;

&lt;p&gt;Temos que mudar também a annotation da rota, veja:&lt;/p&gt;

&lt;p&gt;de:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;* @Route(&#34;/show/{id}&#34;, name=&#34;show&#34;)
&lt;/pre&gt;

&lt;p&gt;para:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;* @Route(&#34;/show/{slug}&#34;, name=&#34;show&#34;)
&lt;/pre&gt;

&lt;p&gt;Estamos passando para a variável $post, o método find, e recuperando o id, vamos mudar o find para findOneBy e passar um array de slug, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

$post = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;findOneBy([
            &#39;slug&#39; =&amp;gt; $slug
        ]);

...

&lt;/pre&gt;

&lt;p&gt;Veja o método showAction pronto:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

    /**
     * @Route(&#34;/post/{slug}&#34;, name=&#34;show&#34;)
     * @Template()
     */
    public function showAction($slug)
    {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();

        $post = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;findOneBy([
            &#39;slug&#39; =&amp;gt; $slug
        ]);

        if (!$post) {
            throw $this-&amp;gt;createNotFoundException(&#39;O post não existe! Volte para home!&#39;);
        }

        return [
            &#39;post&#39; =&amp;gt; $post,
        ];
    }
 
    ...
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-o-index&#34;&gt;Configurando o index&lt;/h2&gt;

&lt;p&gt;Em nossa index, estamos passando os links para que os posts sejam buscados pelo id, porém temos que alterá- los para que possamos buscar os posts pelo slug.&lt;/p&gt;

&lt;p&gt;Entre no index.html.twig, caminho: src/Tableless/CoreBundle/Resources/views/IndexController/Index.html.twig&lt;/p&gt;

&lt;p&gt;Vamos alterar os links:&lt;/p&gt;

&lt;p&gt;No meu caso a linha 21, 29 e 35:&lt;/p&gt;

&lt;p&gt;de:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;
&lt;/pre&gt;

&lt;p&gt;para:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;a href=&#34;{{ path(&#39;show&#39;, { slug: post.slug }) }}&#34;&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Testando nossa aplicação:&lt;/p&gt;

&lt;p&gt;Caso tenham seguido o tutorial e excluído o bando de dados, que foi criado novamente, como no meu caso. Antes de criarmos um post, temos que criar os autores novamente, depois sim criarmos os posts. No meu caso vou criar apena um post para exemplo.&lt;/p&gt;

&lt;p&gt;Depois do post criado, click no link e observe a url, verá o slug, que em nosso caso é o slug do titulo, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/05/02.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/05/02.png&#34; alt=&#34;Urls&#34; width=&#34;750&#34; height=&#34;50&#34; class=&#34;alignnone size-full wp-image-48548&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Pronto, nosso simples projeto está retornando o slug dos post em nossa url.&lt;/p&gt;

&lt;p&gt;Links dos tutoriais anteriores:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; title=&#34;instalação&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – Instalação&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; title=&#34;parte 02&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 02&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; title=&#34;parte 03&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 03&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; title=&#34;parte 04&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-05/&#34; title=&#34;parte 05&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 05&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-06/&#34; title=&#34;parte 06&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 06&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-07/&#34; title=&#34;parte 07&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 07&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-08/&#34; title=&#34;parte 08&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 08&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O projeto encontra-se no &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;github do projeto&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 08</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-08/</link>
      <pubDate>Tue, 28 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-08/</guid>
      <description>

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-07/&#34; title=&#34;Parte 07&#34; target=&#34;_blank&#34;&gt;tutorial anterior&lt;/a&gt;, criamos um upload de imagens para servirem de capa para nossos posts, agora vamos instalar e configurar um Bundle, disponibilizado pela comunidade, para fazer a paginação de nossa página index. Para isso temos que instalar o Knp Paginator em nossa aplicação.&lt;/p&gt;

&lt;h2 id=&#34;instalação-do-knp-paginator&#34;&gt;Instalação do Knp Paginator&lt;/h2&gt;

&lt;p&gt;Para instalar o Knp Paginator, temos que adicioná-lo em nosso composer.json. Abra o arquivo composer.json e adicione a linha abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&#34;knplabs/knp-paginator-bundle&#34;: &#34;2.4.*@dev&#34;
&lt;/pre&gt;

&lt;p&gt;Caso não o conheça, ou tenha dúvidas, leia este post (&lt;a href=&#34;http://tableless.com.br/composer-um-pouco-alem-basico/&#34; title=&#34;Composer&#34; target=&#34;_blank&#34;&gt;Composer para iniciantes&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Depois de adicionado o Knp Paginator no composer, vamos instalá- lo. Entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ composer update
&lt;/pre&gt;

&lt;p&gt;Após o Download, o Knp Paginator está instalado em nossa aplicação.&lt;/p&gt;

&lt;h2 id=&#34;configurando-o-knp-paginator&#34;&gt;Configurando o Knp Paginator&lt;/h2&gt;

&lt;p&gt;A primeira configuração que devemos fazer, é registrar o novo bundle instalado, para isso entre no AppKernel, caminho: app/AppKernel.php&lt;/p&gt;

&lt;p&gt;Adicione a linha abaixo no registro de bundles:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;new Knp\Bundle\PaginatorBundle\KnpPaginatorBundle(),
&lt;/pre&gt;

&lt;p&gt;Veja na linha 16:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new Tableless\CoreBundle\TablelessCoreBundle(),
            new Tableless\ModelBundle\TablelessModelBundle(),
        new Knp\Bundle\PaginatorBundle\KnpPaginatorBundle(),
        );
...
&lt;/pre&gt;

&lt;p&gt;Pronto o Knp Paginator está registrado.&lt;/p&gt;

&lt;p&gt;Agora vamos fazer as configurações padrões no Knp, para isso entre no arquivo config.yml, caminho: app/config/config.yml&lt;/p&gt;

&lt;p&gt;No final do arquivo adicione as configurações abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-yml&#34;&gt;knp_paginator:
    page_range: 5                      # default page range used in pagination control
    default_options:
        page_name: page                # page query parameter name
        sort_field_name: sort          # sort field query parameter name
        sort_direction_name: direction # sort direction query parameter name
        distinct: true                 # ensure distinct results, useful when ORM queries are using GROUP BY statements
    template:
        pagination: KnpPaginatorBundle:Pagination:sliding.html.twig     # sliding pagination controls template
        sortable: KnpPaginatorBundle:Pagination:sortable_link.html.twig # sort link template
&lt;/pre&gt;

&lt;p&gt;Essas configurações foram tiradas da &lt;a href=&#34;https://github.com/KnpLabs/KnpPaginatorBundle#configuration-example&#34; title=&#34;Documentação Knp Paginator&#34; target=&#34;_blank&#34;&gt;documentação do Knp Paginator&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;configurando-o-controller&#34;&gt;Configurando o Controller&lt;/h2&gt;

&lt;p&gt;Depois de termos feito as configurações de instalação do Knp Paginator, vamos configurar nosso controller, para isso entre no IndexControlerController, caminho: src/Tableless/CoreBundle/Controller/IndexControlerController.php&lt;/p&gt;

&lt;p&gt;Primeiramente para pegar o número de páginas, de acordo com a quantidade de posts temos que usar o request do symfony, então vamos dar um use em Request, veja na linha 8:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\CoreBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;
use Symfony\Component\HttpFoundation\Request;

...
&lt;/pre&gt;

&lt;p&gt;Em nossa indexAction temos que pegar a biblioteca do paginador, passar nosso posts, pegar as páginas via request, e quantidade de posts que queremos por páginas, e retorná- los em forma de array para que nossa view possa apresentar. Em meu caso vou usar apenas três posts por página.&lt;/p&gt;

&lt;p&gt;Veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
     * @Route(&#34;/&#34;, name=&#34;index&#34;)
     * @Template()
     */
    public function indexAction(Request $request)
    {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();

        $posts = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;findAllInOrder();

        /** @var  $paginator */
        $paginator  = $this-&amp;gt;get(&#39;knp_paginator&#39;);
        $pagination = $paginator-&amp;gt;paginate($posts, $request-&amp;gt;query-&amp;gt;get(&#39;page&#39;, 1), 3);

        return [
            &#39;pagination&#39; =&amp;gt; $pagination,
        ];
    }

…
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-a-view&#34;&gt;Configurando a View&lt;/h2&gt;

&lt;p&gt;Nosso controller está configurado, agora temos que configurar nossa view, para que a mesma apresente os posts, com a paginação.&lt;/p&gt;

&lt;p&gt;Entre na view index.html.twig, caminho: src/Tableless/CoreBundle/Resources/views/IndexController/index.html.twig&lt;/p&gt;

&lt;p&gt;Em nossa index, temos um for, que está recebendo a variável posts, vamos trocar a variável posts por pagination, que foi a variável que passamos em nosso controller, veja:&lt;/p&gt;

&lt;p&gt;de:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;{% for post in posts %}
&lt;/pre&gt;

&lt;p&gt;troque por:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;{% for post in pagination %}
&lt;/pre&gt;

&lt;p&gt;E onde queremos que nossa paginação fique, vamos colocar o código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;{{ knp_pagination_render(pagination) }}
&lt;/pre&gt;

&lt;p&gt;Veja nossa index.html.twig pronta&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;{% extends &#34;::base.html.twig&#34; %}

{% block title %}Simples Blog{% endblock %}

{% block content %}

    &amp;lt;div class=&#34;container&#34;&amp;gt;

        &amp;lt;div class=&#34;row&#34;&amp;gt;

            {{ knp_pagination_render(pagination) }}

            &amp;lt;div class=&#34;col-lg-12&#34;&amp;gt;


            {% for post in pagination %}

                &amp;lt;article class=&#34;col-lg-4&#34;&amp;gt;

                    &amp;lt;div class=&#34;thumbnail&#34;&amp;gt;

                        &amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;

                            &amp;lt;img class=&#34;img-responsive&#34; src=&#34;{{ asset(post.getCoverWeb) }}&#34; alt=&#34;{{ post.cover }}&#34; title=&#34;{{ post.cover }}&#34;/&amp;gt;

                        &amp;lt;/a&amp;gt;

                        &amp;lt;div class=&#34;caption&#34;&amp;gt;

                            &amp;lt;h3&amp;gt;&amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;

                            &amp;lt;p&amp;gt;Escrito por: {{ post.author.name }}&amp;lt;/p&amp;gt;

                            &amp;lt;p&amp;gt;{{ post.content|slice(0, 45) }} ...&amp;lt;/p&amp;gt;

                            &amp;lt;p&amp;gt;&amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;Leia mais...&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;

                        &amp;lt;/div&amp;gt;

                    &amp;lt;/div&amp;gt;

                &amp;lt;/article&amp;gt;

            {% endfor %}

        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
        {{ knp_pagination_render(pagination) }}

    &amp;lt;/div&amp;gt;

{% endblock %}

&lt;/pre&gt;

&lt;p&gt;Rode o servidor:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console server:run
&lt;/pre&gt;

&lt;p&gt;Entre na url:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000&#34;&gt;http://127.0.0.1:8000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Veja a imagem:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/04/011.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/04/011.png&#34; alt=&#34;Paginação&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-48300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;estilizando-a-paginação&#34;&gt;Estilizando a paginação&lt;/h2&gt;

&lt;p&gt;Podemos perceber, que a paginação está sem estilização, porém como estamos utilizando o bootstrap, vamos entrar no arquivo config.yml, caminho: app/config/config.yml&lt;/p&gt;

&lt;p&gt;E vamos alterar o pagination da tamplete do knp_paginator&lt;/p&gt;

&lt;p&gt;de:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;pagination: KnpPaginatorBundle:Pagination:sliding.html.twig
&lt;/pre&gt;

&lt;p&gt;para:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;pagination: KnpPaginatorBundle:Pagination:twitter_bootstrap_v3_pagination.html.twig
&lt;/pre&gt;

&lt;p&gt;Atualize a página, e pronto, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/04/021.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/04/021.png&#34; alt=&#34;Paginação estilizada&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-48301&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Pronto, nosso simples projeto está fazendo a paginação de posts, no próximo tutorial vamos configurar outro Bundle, onde faremos o slug para nossos posts, para que nossas urls, fiquem um pouco mais amigáveis.&lt;/p&gt;

&lt;p&gt;Links dos tutoriais anteriores:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; title=&#34;part 01&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – Instalação&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; title=&#34;parte 02&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 02&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; title=&#34;parte 03&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 03&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; title=&#34;parte 04&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-05/&#34; title=&#34;parte 05&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 05&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-06/&#34; title=&#34;parte 06&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 06&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-07/&#34; title=&#34;parte 07&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 07&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O projeto encontra-se no &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;GitHub do projeto&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 07</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-07/</link>
      <pubDate>Fri, 10 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-07/</guid>
      <description>

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-06/&#34; title=&#34;Iniciando com Symfony&#34; target=&#34;_blank&#34;&gt;tutorial anterior&lt;/a&gt;, estilizamos nossas páginas, index e show, e incluímos um imagem para apresentar nossos posts no index, porém colocamos esta imagem pelo código fonte, agora vamos fazer algumas configurações, para que, na criação dos posts, tenha a opção de fazer o upload de uma imagem, para ser apresentada como capa de nossos posts.&lt;/p&gt;

&lt;h2 id=&#34;configurando-a-entidade-post&#34;&gt;Configurando a entidade Post&lt;/h2&gt;

&lt;p&gt;Para criarmos um upload de imagem, vamos usar o componente http-foundation do Symfony, e usar sua classe UploadedFile em nossa entidade Post.&lt;/p&gt;

&lt;p&gt;Para isso, vamos entrar em nossa entidade Post, caminho: src/Tableless/ModelBundle/Entity/Post.php.&lt;/p&gt;

&lt;p&gt;Com a entidade Post aberta vamos dar um use em UploadedFile, veja na linha 7:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 
use Symfony\Component\Validator\Constraints as Assert; 
use Symfony\Component\HttpFoundation\File\UploadedFile; 


/** 
 * Post 
 * 
 * @ORM\Table(name=&#34;post&#34;)
…

&lt;/pre&gt;

&lt;p&gt;Precisamos criar dois atributos privados, $cover, e $file , e inserir as annotations correspondentes, o atributo $cover, receberá o nome da imagem, e o $file o aquivo com um limite de tamanho, veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;cover&#34;, type=&#34;string&#34;, length=255, nullable=true) 
     */ 
    private $cover; 
    
    /** 
     * @Assert\File(maxSize=&#34;1000000&#34;) 
     */ 
    private $file;

    ...
&lt;/pre&gt;

&lt;p&gt;Vamos fazer os Getters and Setters desses atributos.&lt;/p&gt;

&lt;p&gt;O setFile receberá um parâmetro $file, esse parâmetro será do tipo UploadedFile, e caso não passamos uma imagem, poderá ser nulo, veja os getters and setters criados:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

    /** 
     * Get cover 
     * 
     * @return string 
     */ 
    public function getCover() 
    { 
        return $this-&amp;gt;cover; 
    } 

    /** 
     * Set cover 
     * 
     * @param string $cover 
     * @return Image 
     */ 
    public function setCover($cover) 
    { 
        $this-&amp;gt;cover = $cover; 
    } 

    /** 
     * Get file. 
     * 
     * @return UploadedFile 
     */ 
    public function getFile() 
    { 
        return $this-&amp;gt;file; 
    } 

    /** 
     * Set file. 
     * 
     * @param UploadedFile $file 
     */ 
    public function setFile(UploadedFile $file = null) 
    { 
        $this-&amp;gt;file = $file; 
    }

    ...
&lt;/pre&gt;

&lt;p&gt;Precisamos obter o caminho relativo do upload, ou seja, a pasta para onde as imagens serão enviadas; para isso vamos criar o método protegido getUploadPath(), que nos retornará essa pasta. Veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

    /** 
     * Relative path. 
     * Get web path to upload directory. 
     * 
     * @return string 
     */ 
    protected function getUploadPath() 
    { 
        return &#39;uploads/covers&#39;; 
    }

    ...

&lt;/pre&gt;

&lt;p&gt;Temos que obter o caminho absoluto, para fazer o upload de nossas imagens, que ficará na pasta web, para isso vamos criar o método protegido getUploadAbsolutePath(), que nos retornará o caminho absoluto, e para chegarmos na pasta &amp;#8220;uploads/covers&amp;#8221;, vamos concatenar com o método getUploadPath() criado acima, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

    /** 
     * Absolute path. 
     * Get absolute path to upload directory. 
     * 
     * @return string 
     */ 
    protected function getUploadAbsolutePath() 
    { 
        return __DIR__ . &#39;/../../../../web/&#39; . $this-&amp;gt;getUploadPath(); 
    }

    ...

&lt;/pre&gt;

&lt;p&gt;Agora precisamos apresentar o caminho de nossas imagens para as views, vamos criar o método público getCoverWeb(), caso tenhamos uma imagem, ou seja, caso a imagem não seja nula, apresentamos a imagem nas views, para isso usaremos o método getUploadPath(), concatenado com o nome de nossa imagem, ou seja o método getCover(), veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

    /** 
     * Relative path. 
     * Get web path to a cover. 
     * 
     * @return null|string 
     */ 
    public function getCoverWeb() 
    { 
        return null === $this-&amp;gt;getCover() 
            ? null 
            : $this-&amp;gt;getUploadPath() . &#39;/&#39; . $this-&amp;gt;getCover(); 
    }

    ...

&lt;/pre&gt;

&lt;p&gt;Podemos precisar do caminho absoluto de nossa imagem, para isso vamos criar o método getCoverAbsolute(), para obtermos esse caminho quando precisarmos, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;...

    /** 
     * Get path on disk to a cover. 
     * 
     * @return null|string 
     *   Absolute path. 
     */ 
    public function getCoverAbsolute() 
    { 
        return null === $this-&amp;gt;getCover() 
            ? null 
            : $this-&amp;gt;getUploadAbsolutePath() . &#39;/&#39; . $this-&amp;gt;getCover(); 
    }

    ...
&lt;/pre&gt;

&lt;p&gt;Agora temos que criar um método que fará o upload da imagem, para isso criaremos um método como nome upload(), caso a imagem não seja nula, ele fará o upload usando alguns métodos prontos da classe UploadedFile, para mover a imagens, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;... 
  
    /** 
     * Upload a cover file. 
     */ 
    public function upload() 
    { 
        if (null === $this-&amp;gt;getFile()) { 
            return; 
        } 
        $filename = $this-&amp;gt;getFile()-&amp;gt;getClientOriginalName(); 
        $this-&amp;gt;getFile()-&amp;gt;move($this-&amp;gt;getUploadAbsolutePath(), $filename); 
        $this-&amp;gt;setCover($filename); 
        $this-&amp;gt;setFile(); 
    }


    ...

&lt;/pre&gt;

&lt;p&gt;Pronto, nossa entidade Post, agora está recebendo um upload de imagem.&lt;/p&gt;

&lt;p&gt;Veja o entidade Post pronta:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\ModelBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;
use Symfony\Component\HttpFoundation\File\UploadedFile;


/**
 * Post
 *
 * @ORM\Table(name=&#34;post&#34;)
 * @ORM\Entity(repositoryClass=&#34;Tableless\ModelBundle\Repository\PostRepository&#34;)
 */
class Post extends Timestampable
{
    /**
     * @var integer
     *
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;)
     */
    private $id;

    /**
     * @var string
     *
     * @ORM\Column(name=&#34;title&#34;, type=&#34;string&#34;, length=255)
     * @Assert\NotBlank
     */
    private $title;

    /**
     * @var string
     *
     * @ORM\Column(name=&#34;content&#34;, type=&#34;text&#34;)
     * @Assert\NotBlank
     */
    private $content;

    /**
     * @var Author
     *
     * @ORM\ManyToOne(targetEntity=&#34;Author&#34;, inversedBy=&#34;posts&#34;)
     * @ORM\JoinColumn(name=&#34;author_id&#34;, referencedColumnName=&#34;id&#34;, nullable=false)
     * @Assert\NotBlank
     */
    private $author;

    /**
     * @var string
     *
     * @ORM\Column(name=&#34;cover&#34;, type=&#34;string&#34;, length=255, nullable=true)
     */
    private $cover;

    /**
     * @Assert\File(maxSize=&#34;1000000&#34;)
     */
    private $file;


    /**
     * Get id
     *
     * @return integer 
     */
    public function getId()
    {
        return $this-&amp;gt;id;
    }

    /**
     * Set title
     *
     * @param string $title
     * @return Post
     */
    public function setTitle($title)
    {
        $this-&amp;gt;title = $title;

        return $this;
    }

    /**
     * Get title
     *
     * @return string 
     */
    public function getTitle()
    {
        return $this-&amp;gt;title;
    }

    /**
     * Set content
     *
     * @param string $content
     * @return Post
     */
    public function setContent($content)
    {
        $this-&amp;gt;content = $content;

        return $this;
    }

    /**
     * Get content
     *
     * @return string 
     */
    public function getContent()
    {
        return $this-&amp;gt;content;
    }

    /**
     * Set author
     *
     * @param \Tableless\ModelBundle\Entity\Author $author
     * @return Post
     */
    public function setAuthor(\Tableless\ModelBundle\Entity\Author $author)
    {
        $this-&amp;gt;author = $author;

        return $this;
    }

    /**
     * Get author
     *
     * @return \Tableless\ModelBundle\Entity\Author 
     */
    public function getAuthor()
    {
        return $this-&amp;gt;author;
    }

    // métodos criados

    /**
     * Get cover
     *
     * @return string
     */
    public function getCover()
    {
        return $this-&amp;gt;cover;
    }


    /**
     * Set cover
     *
     * @param string $cover
     * @return Image
     */
    public function setCover($cover)
    {
        $this-&amp;gt;cover = $cover;
    }

    /**
     * Get file.
     *
     * @return UploadedFile
     */
    public function getFile()
    {
        return $this-&amp;gt;file;
    }

    /**
     * Sets file.
     *
     * @param UploadedFile $file
     */
    public function setFile(UploadedFile $file = null)
    {
        $this-&amp;gt;file = $file;
    }

    /**
     * Relative path.
     * Get web path to upload directory.
     *
     * @return string
     */
    protected function getUploadPath()
    {
        return &#39;uploads/covers&#39;;
    }

    /**
     * Absolute path.
     * Get absolute path to upload directory.
     *
     * @return string
     */
    protected function getUploadAbsolutePath()
    {
        return __DIR__ . &#39;/../../../../web/&#39; . $this-&amp;gt;getUploadPath();
    }

    /**
     * Relative path.
     * Get web path to a cover.
     *
     * @return null|string
     */
    public function getCoverWeb()
    {
        return null === $this-&amp;gt;getCover()
            ? null
            : $this-&amp;gt;getUploadPath() . &#39;/&#39; . $this-&amp;gt;getCover();
    }

    /**
     * Get path on disk to a cover.
     *
     * @return null|string
     *   Absolute path.
     */
    public function getCoverAbsolute()
    {
        return null === $this-&amp;gt;getCover()
            ? null
            : $this-&amp;gt;getUploadAbsolutePath() . &#39;/&#39; . $this-&amp;gt;getCover();
    }

    /**
     * Upload a cover file.
     */
    public function upload()
    {
        if (null === $this-&amp;gt;getFile()) {
            return;
        }
        $filename = $this-&amp;gt;getFile()-&amp;gt;getClientOriginalName();
        $this-&amp;gt;getFile()-&amp;gt;move($this-&amp;gt;getUploadAbsolutePath(), $filename);
        $this-&amp;gt;setCover($filename);
        $this-&amp;gt;setFile();
    }
}
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-o-controller&#34;&gt;Configurando o controller&lt;/h2&gt;

&lt;p&gt;Para que nossos formulários de posts tenham acesso ao upload, temos que configurar o controller PostController.&lt;/p&gt;

&lt;p&gt;Entre no PostController, caminho: src/Tableless/CoreBundle/Controller/PostController.php, e no método createAction, insira o código $entity-&amp;gt;upload(); veja na linha 15:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * Creates a new Post entity. 
     * 
     * @Route(&#34;/&#34;, name=&#34;post_create&#34;) 
     * @Method(&#34;POST&#34;) 
     * @Template(&#34;TablelessCoreBundle:Post:new.html.twig&#34;) 
     */ 
    public function createAction(Request $request) 
    { 
        $entity = new Post(); 
        $form = $this-&amp;gt;createCreateForm($entity); 
        $form-&amp;gt;handleRequest($request); 

        if ($form-&amp;gt;isValid()) { 
            $entity-&amp;gt;upload(); 
            $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager(); 
            $em-&amp;gt;persist($entity); 
            $em-&amp;gt;flush(); 

            return $this-&amp;gt;redirect($this-&amp;gt;generateUrl(&#39;post_show&#39;, array(&#39;id&#39; =&amp;gt; $entity-&amp;gt;getId()))); 
        } 

        return array( 
            &#39;entity&#39; =&amp;gt; $entity, 
            &#39;form&#39;   =&amp;gt; $form-&amp;gt;createView(), 
        ); 
    }
&lt;/pre&gt;

&lt;p&gt;Temos que fazer o mesmo procedimento com o método updateAction na linha 23, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * Edits an existing Post entity. 
     * 
     * @Route(&#34;/{id}&#34;, name=&#34;post_update&#34;) 
     * @Method(&#34;PUT&#34;) 
     * @Template(&#34;TablelessModelBundle:Post:edit.html.twig&#34;) 
     */ 
    public function updateAction(Request $request, $id) 
    { 
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager(); 

        $entity = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;find($id); 

        if (!$entity) { 
            throw $this-&amp;gt;createNotFoundException(&#39;Unable to find Post entity.&#39;); 
        } 

        $deleteForm = $this-&amp;gt;createDeleteForm($id); 
        $editForm = $this-&amp;gt;createEditForm($entity); 
        $editForm-&amp;gt;handleRequest($request); 

        if ($editForm-&amp;gt;isValid()) { 
            $entity-&amp;gt;upload(); 
            $em-&amp;gt;flush(); 

            return $this-&amp;gt;redirect($this-&amp;gt;generateUrl(&#39;post_edit&#39;, array(&#39;id&#39; =&amp;gt; $id))); 
        } 

        return array( 
            &#39;entity&#39;      =&amp;gt; $entity, 
            &#39;edit_form&#39;   =&amp;gt; $editForm-&amp;gt;createView(), 
            &#39;delete_form&#39; =&amp;gt; $deleteForm-&amp;gt;createView(), 
        ); 
    } 

&lt;/pre&gt;

&lt;h2 id=&#34;configurando-os-formulários&#34;&gt;Configurando os formulários&lt;/h2&gt;

&lt;p&gt;Pronto, nossa entidade e controller de posts, estão configurados para receberem o upload, porém temos que configurar nossos formulários. Entre no PostType.php, para fazermos as configurações necessárias, caminho: src/Tableless/ModelBundle/Form/PostType, e no método buildForm adicione o &amp;#8216;file&amp;#8217;, veja na linha 10.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * @param FormBuilderInterface $builder 
     * @param array $options 
     */ 
    public function buildForm(FormBuilderInterface $builder, array $options) 
    { 
        $builder 
            -&amp;gt;add(&#39;title&#39;) 
            -&amp;gt;add(&#39;content&#39;) 
            -&amp;gt;add(&#39;file&#39;) 
            -&amp;gt;add(&#39;author&#39;) 
        ; 
    }
&lt;/pre&gt;

&lt;h2 id=&#34;atualizando-o-banco-de-dados&#34;&gt;Atualizando o banco de dados&lt;/h2&gt;

&lt;p&gt;Para vermos a mágica acontecer, só precisamos, atualizar nosso banco, para isso entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:schema:update --force 
&lt;/pre&gt;

&lt;p&gt;Pronto! Nosso upload de imagem, está pronto, veja a imagem:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/04/01.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/04/01.png&#34; alt=&#34;Botão de upload no formulário no symfony&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-48201&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;configurando-as-views&#34;&gt;Configurando as views&lt;/h2&gt;

&lt;p&gt;Agora temos que configurar nossas views para que as mesmas apresentem as imagens. Entre na view index.html.twig, caminho: src/Tablesless/CoreBundle/Resources/views/IndexController/index.html.twig, mude a linha 21.&lt;/p&gt;

&lt;p&gt;mude de:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;img class=&#34;img-responsive&#34; src=&#34;{{ asset(&#39;logo-tableless.png&#39;) }}&#34; alt=&#34;img&#34; title=&#34;img&#34;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;para:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;img class=&#34;img-responsive&#34; src=&#34;{{ asset(post.getCoverWeb) }}&#34; alt=&#34;{{ post.cover }}&#34; title=&#34;{{ post.cover }}&#34;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Vamos entrar em nossa view show.html.twig, caminho: caminho: src/Tablesless/CoreBundle/Resources/views/IndexController/show.html.twig, e vamos acrescentar a mesma linha acima do título, ou onde acharem melhor, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;article class=&#34;col-lg-12&#34; &amp;gt;

&amp;lt;img class=&#34;img-responsive&#34; src=&#34;{{ asset(post.getCoverWeb) }}&#34; alt=&#34;{{ post.cover }}&#34; title=&#34;{{ post.cover }}&#34;/&amp;gt;

&amp;lt;h1&amp;gt;{{ post.title }}&amp;lt;/h1&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Vamos fazer os testes, criando um novo post, e inserindo uma imagem.&lt;/p&gt;

&lt;p&gt;Observe a imagem na pasta web/uploads/cover.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/04/02.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/04/02.png&#34; alt=&#34;Pasta de upload no symfony&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-48205&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Pronto, nosso simples projeto está fazendo upload de imagens para cada post, no próximo tutorial vamos aprender a configurar um Bundle pronto, disponibilizado pela comunidade, onde faremos a paginação de resultados para nossa página index.&lt;/p&gt;

&lt;p&gt;Links dos tutoriais anteriores:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; title=&#34;instalação&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – Instalação&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; title=&#34;parte 02&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 02&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; title=&#34;parte 03&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 03&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; title=&#34;parte 04&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-05/&#34; title=&#34;parte 05&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 05&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-06/&#34; title=&#34;parte 06&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 06&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O projeto encontra-se no &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;GitHub do projeto&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 06</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-06/</link>
      <pubDate>Wed, 01 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-06/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/capa.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/capa.png&#34; alt=&#34;Symfony e Twig&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47950&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-05/&#34; title=&#34;iniciando com symfony 2 - parte 05&#34; target=&#34;_blank&#34;&gt;tutorial anterior&lt;/a&gt;, configuramos nosso projeto e criamos nossas páginas, home e show, porém as mesmas se encontram sem estilização, neste tutorial, vamos apenas estruturar nossas páginas de um modo simples e básico, porém funcional. Não entrarei em detalhes sobre o Bootstrap, não é meu objetivo, porém para iniciantes, recomendo a &lt;a href=&#34;http://getbootstrap.com/css/&#34; title=&#34;Doc. Bootstrap&#34; target=&#34;_blank&#34;&gt;documentação&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Sobre o Twig, falarei o básico do básico, somente o que vamos usar. Lembrando que ele já vem instalado e configurado no Symfony, porém podemos instalá-lo separadamente &lt;a href=&#34;https://packagist.org/packages/twig/twig&#34; title=&#34;Pacote do Twig&#34; target=&#34;_blank&#34;&gt;via Composer&lt;/a&gt; e configurá- lo em outros projetos, usando ou não outros frameworks.&lt;/p&gt;

&lt;h2 id=&#34;instalando-e-configurando-o-twitter-bootstrap-no-symfony&#34;&gt;Instalando e configurando o Twitter Bootstrap no Symfony&lt;/h2&gt;

&lt;p&gt;Vamos iniciar com a configuração do bootstrap.&lt;/p&gt;

&lt;p&gt;Temos algumas formas de instalar e configurar o arquivo css no symfony, em nosso caso vamos fazer uma configuração simples apenas para a didática, caso queiram se aprofundar mais no assunto, aconselho a &lt;a href=&#34;http://symfony.com/doc/current/cookbook/assetic/asset_management.html#including-css-stylesheets&#34; title=&#34;Assets no Symfony&#34; target=&#34;_blank&#34;&gt;documentação&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Primeiramente vamos criar uma pasta dentro da pasta Resource do bundle CoreBundle, caminho: src/Tableless/CoreBundle/Resouces, com o nome public, e dentro dessa nova pasta, vamos criar outra pasta com o nome css.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://getbootstrap.com/getting-started/#download&#34; title=&#34;Download do bootstrap&#34; target=&#34;_blank&#34;&gt;Baixe o bootstrap&lt;/a&gt;, e copie o arquivo bootstrap.min.css para a pasta css/, veja a imagem abaixo para comparação:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/011.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/011.png&#34; alt=&#34;Pasta para bootstrap&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47951&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Caso queiram, podem usar o arquivo bootstrap.css, em nosso caso vamos usar o .min.css.&lt;/p&gt;

&lt;p&gt;Para que o bootstrap seja carregado vamos entrar no terminal, e digitar:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console assets:install --symlink
&lt;/pre&gt;

&lt;p&gt;Desse forma estamos criando um link simbólico do arquivo na pasta web, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/022.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/022.png&#34; alt=&#34;Link simbólico&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47952&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Agora devemos carregar o aquivo bootstrap em nossa aplicação. Vamos entrar no arquivo base.html.twig, caminho: app/Resources/views/base.html.twig, e carregar o bootstrap, no bloco stylesheets, veja na linha 7.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt; 
&amp;lt;html&amp;gt; 
    &amp;lt;head&amp;gt; 
        &amp;lt;meta charset=&#34;UTF-8&#34; /&amp;gt;
        &amp;lt;title&amp;gt;{% block title %}Welcome!{% endblock %}&amp;lt;/title&amp;gt;
        {% block stylesheets %} 
                &amp;lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;{{ asset(&#39;bundles/tablelesscore/css/bootstrap.min.css&#39;) }}&#34; /&amp;gt;
        {% endblock %} 
        &amp;lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;{{ asset(&#39;favicon.ico&#39;) }}&#34; /&amp;gt;
    &amp;lt;/head&amp;gt; 
    &amp;lt;body&amp;gt; 
        {% block body %}{% endblock %} 
        {% block javascripts %}{% endblock %} 
   &amp;lt;/body&amp;gt; 
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;h2 id=&#34;iniciando-com-twig&#34;&gt;Iniciando com Twig&lt;/h2&gt;

&lt;p&gt;Pronto, o bootstrap está instalado e configurado.&lt;/p&gt;

&lt;p&gt;Neste momento vou criar quatro posts em off, apenas para visualização, recomendo que façam o mesmo, pois assim ficará fácil para estilizar.&lt;/p&gt;

&lt;p&gt;Vamos iniciar nossos trabalhos com o Twig.&lt;/p&gt;

&lt;p&gt;Ainda com o arquivo base.html.twig aberto, vamos fazer algumas configurações.&lt;/p&gt;

&lt;p&gt;O twig trabalha com blocos, que podem ser herdados pelas templates filhas, em nosso caso vamos criar um bloco com o nome &amp;#8220;content&amp;#8221;, para que nossas templates possam herdar. Para criar um bloco é bem simples, veja abaixo:&lt;/p&gt;

&lt;p&gt;Abre o bloco:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% block nome-do-bloco %} 
&lt;/pre&gt;

&lt;p&gt;Fecha o bloco:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Ok! Vamos criar nosso bloco, que ficará dentro de outro bloco já existente no arquivo base.html.twig, veja abaixo na linha 15.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&#34;UTF-8&#34; /&amp;gt;
    &amp;lt;title&amp;gt;{% block title %}Welcome!{% endblock %}&amp;lt;/title&amp;gt;
{% block stylesheets %}
        &amp;lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;{{ asset(&#39;bundles/tablelesscore/css/bootstrap.min.css&#39;) }}&#34; /&amp;gt;
    {% endblock %}
    &amp;lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;{{ asset(&#39;favicon.ico&#39;) }}&#34; /&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
{% block body %}

    {# Novo bloco criado #}
    {% block content %}{% endblock %}
    
{% endblock %}
{% block javascripts %}{% endblock %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Agora para concluirmos esse arquivo, vamos estruturar o html, já incluindo as classes do bootstrap, veja abaixo o arquivo base.html.twig pronto:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt; 
&amp;lt;html&amp;gt; 
    &amp;lt;head&amp;gt; 
        &amp;lt;meta charset=&#34;UTF-8&#34; /&amp;gt;
        &amp;lt;title&amp;gt;{% block title %}Welcome!{% endblock %}&amp;lt;/title&amp;gt; 
        {% block stylesheets %} 
                &amp;lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;{{ asset(&#39;bundles/tablelesscore/css/bootstrap.min.css&#39;) }}&#34; /&amp;gt;
        {% endblock %} 
        &amp;lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;{{ asset(&#39;favicon.ico&#39;) }}&#34; /&amp;gt; 
    &amp;lt;/head&amp;gt; 
    &amp;lt;body&amp;gt; 
        {% block body %} 
        &amp;lt;div class=&#34;container&#34;&amp;gt; 
            &amp;lt;header class=&#34;row&#34;&amp;gt; 
                &amp;lt;div class=&#34;col-lg-6&#34;&amp;gt; 
                    &amp;lt;h1&amp;gt;Simples Blog&amp;lt;/h1&amp;gt; 
                    &amp;lt;a href=&#34;#&#34; title=&#34;&#34;&amp;gt;Home&amp;lt;/a&amp;gt; | 
                    &amp;lt;a href=&#34;#&#34; title=&#34;&#34;&amp;gt;administração&amp;lt;/a&amp;gt;
                &amp;lt;/div&amp;gt; 
            &amp;lt;/header&amp;gt; 
        {% block content %} 
        {% endblock %} 
            &amp;lt;footer class=&#34;col-lg-12&#34;&amp;gt; 
                &amp;lt;p&amp;gt;&amp;copy; 2015 Tableless - Todos os direitos reservados&amp;lt;/p&amp;gt; 
            &amp;lt;/footer&amp;gt;
        &amp;lt;/div&amp;gt; 

        {% endblock %} 
        {% block javascripts %}{% endblock %} 
    &amp;lt;body&amp;gt; 
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Podemos perceber que os links estão sem caminho, para passarmos um link no Symfony precisamos do nome de nossas rotas, e para pegar esses nomes, vamos entrar no terminal.&lt;/p&gt;

&lt;p&gt;Abra o terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console router:debug
&lt;/pre&gt;

&lt;p&gt;Vamos ter uma lista dos nomes de nossas rotas, a primeira que vamos usar é a rota da home &amp;#8220;/&amp;#8221; , veja a imagem:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/032.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/032.png&#34; alt=&#34;Rotas&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47953&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Percebemos que o nome dessa rota, está muito extenso, vamos mudar isso, deixando o nome dessa rota e da rota de visualização do post, um pouco mais curto.&lt;/p&gt;

&lt;p&gt;Para isso, devemos entrar no controller indexController, caminho: src/Tableless/CoreBunde/ IndexControlerController.php&lt;/p&gt;

&lt;p&gt;Abra o arquivo, e nas annotations dos métodos indexAction e showAction, vamos colocar os nomes que queremos para nossas rotas. Exemplo: @Route(&amp;#8220;/&amp;#8221;, name=&amp;#8221;index&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Veja o exemplo na linha 2 e na linha 9 do código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;/** 
     * @Route(&#34;/&#34;, name=&#34;index&#34;) 
     * @Template() 
     */ 
    public function indexAction() 
    .... 

    /** 
     * @Route(&#34;/show/{id}&#34;, name=&#34;show&#34;) 
     * @Template() 
     */ 
    public function showAction($id) 
    ...
&lt;/pre&gt;

&lt;p&gt;Agora nossas rotas estão com os nomes mais curtos.&lt;/p&gt;

&lt;p&gt;Para vermos novamente entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;$ php app/console router:debug
&lt;/pre&gt;

&lt;p&gt;Veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/042.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/042.png&#34; alt=&#34;Rotas&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47976&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pronto! Agora podemos inserir nossos links.&lt;/p&gt;

&lt;p&gt;Para pegarmos o link da home, digitamos: {{ path(&amp;#8216;index&amp;#8217;) }}, e para o link da administração vou pegar o link da lista de post.&lt;/p&gt;

&lt;p&gt;Veja o arquivo base.html.twig pronto, os links estão na linha 17 e 18.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt; 
&amp;lt;html&amp;gt; 
    &amp;lt;head&amp;gt; 
        &amp;lt;meta charset=&#34;UTF-8&#34; /&amp;gt;
        &amp;lt;title&amp;gt;{% block title %}Welcome!{% endblock %}&amp;lt;/title&amp;gt; 
        {% block stylesheets %} 
                &amp;lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;{{ asset(&#39;bundles/tablelesscore/css/bootstrap.min.css&#39;) }}&#34; /&amp;gt;
        {% endblock %} 
        &amp;lt;link rel=&#34;icon&#34; type=&#34;image/x-icon&#34; href=&#34;{{ asset(&#39;favicon.ico&#39;) }}&#34; /&amp;gt; 
    &amp;lt;/head&amp;gt; 
    &amp;lt;body&amp;gt; 
        {% block body %} 
        &amp;lt;div class=&#34;container&#34;&amp;gt; 
            &amp;lt;header class=&#34;row&#34;&amp;gt; 
                &amp;lt;div class=&#34;col-lg-6&#34;&amp;gt; 
                    &amp;lt;h1&amp;gt;Simples Blog&amp;lt;/h1&amp;gt; 
                    &amp;lt;a href=&#34;{{ path(&#39;index&#39;) }}&#34; title=&#34;Home&#34;&amp;gt;Home&amp;lt;/a&amp;gt; | 
                    &amp;lt;a href=&#34;{{ path(&#39;post&#39;) }}&#34; title=&#34;Administração&#34;&amp;gt;administração&amp;lt;/a&amp;gt;
                &amp;lt;/div&amp;gt; 
            &amp;lt;/header&amp;gt; 
        {% block content %} 
        {% endblock %} 
            &amp;lt;footer class=&#34;col-lg-12&#34;&amp;gt; 
                &amp;lt;p&amp;gt;&amp;copy; 2015 Tableless - Todos os direitos reservados&amp;lt;/p&amp;gt; 
            &amp;lt;/footer&amp;gt;
        &amp;lt;/div&amp;gt; 

        {% endblock %} 
        {% block javascripts %}{% endblock %} 
    &amp;lt;body&amp;gt; 
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;h2 id=&#34;estruturando-e-estilizando-o-index&#34;&gt;Estruturando e estilizando o index&lt;/h2&gt;

&lt;p&gt;Nossa base está pronta, vamos agora para o arquivo index.html.twig, que é o index de nosso blog.&lt;/p&gt;

&lt;p&gt;Caminho: src/Tableless/CoreBundle/Resources/views/IndexController/index.html.twig&lt;/p&gt;

&lt;p&gt;Abra o arquivo para que possamos estruturá- lo.&lt;/p&gt;

&lt;p&gt;Podemos perceber que na primeira linha, nosso arquivo está estendendo o arquivo base.html.twig, que acabamos de estruturar.&lt;/p&gt;

&lt;p&gt;Em primeiro lugar vamos criar um título para nossa página.&lt;/p&gt;

&lt;p&gt;Para isso, digitamos o título que queremos dentro do bloco title.&lt;/p&gt;

&lt;p&gt;Para que nosso conteúdo, posicione- se no lugar correto, vamos renomear o bloco body, para content, que criamos no arquivo base, o h1 e dump, vamos excluir, veja nosso arquivo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% extends &#34;::base.html.twig&#34; %} 

{% block title %}Simples Blog{% endblock %} 

{% block content %} 
    
{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Nosso Controller IndexController está retornando um array de posts, através do método indexAction, para recuperarmos esse array via Twig, devemos fazer um &amp;#8220;for&amp;#8221; para recuperar cada dado do post.&lt;/p&gt;

&lt;p&gt;Obs: Se tivéssemos usando o php para recuperar esses dados, passaríamos um foreach, no caso do Twig para fazermos esse mesmo processo, usamos um for, veja abaixo o exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% for valor in array %}

{% endfor %}
&lt;/pre&gt;

&lt;p&gt;Para entender melhor o funcionamento do for, recomendo a &lt;a href=&#34;http://twig.sensiolabs.org/doc/tags/for.html&#34; title=&#34;twig for&#34; target=&#34;_blank&#34;&gt;documentação&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vamos entender melhor&lt;/p&gt;

&lt;p&gt;Nosso método indexAction, do controller indexController, está nos retornando um array, veja na linha 7.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;public function indexAction() 
    { 
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager(); 

        $posts = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;findAllInOrder(); 

        return [ 
            &#39;posts&#39; =&amp;gt; $posts, 
        ]; 
    } 

&lt;/pre&gt;

&lt;p&gt;Para recuperarmos esses dados no twig, vamos fazer:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% for post in posts %}

    {{ post.title }}
    {{ post.author.name }}
    {{ post.content | slice(0, 45) }}

{% endfor %}
&lt;/pre&gt;

&lt;p&gt;Perceba que ao recuperarmos o post.content, que é o conteúdo do nosso post, vamos passar um &amp;#8220;slice&amp;#8221;, que serve para cortar o texto, começando do 0 até 45 caracteres. Caso queiram mais de 45 caracteres, é só aumentar esse valor.&lt;/p&gt;

&lt;p&gt;Também, temos que estruturar nossa página com html, incluir as classes do bootstrap e criar os links. Em relação aos links, para acessarmos um post, temos que passar o &amp;#8220;id&amp;#8221; desse post no link.&lt;/p&gt;

&lt;p&gt;Vamos colocar uma imagem, escolham uma imagem, e coloque na pasta web, caminho: web/&lt;/p&gt;

&lt;p&gt;Para recuperarmos essa imagem, vamos usar o asset.&lt;/p&gt;

&lt;p&gt;Veja abaixo o exemplo do asset para imagem:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;img src=&#34;{{ asset(&#39;imagem.png&#39;) }}&#34; /&amp;gt; 
&lt;/pre&gt;

&lt;p&gt;Veja o index.html.twig pronto:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% extends &#34;::base.html.twig&#34; %} 

{% block title %}Simples Blog{% endblock %} 

{% block content %} 

    &amp;lt;div class=&#34;container&#34;&amp;gt; 

        &amp;lt;div class=&#34;row&#34;&amp;gt; 
 
            &amp;lt;div class=&#34;col-lg-12&#34;&amp;gt;

                {% for post in posts %} 

                    &amp;lt;article class=&#34;col-lg-4&#34;&amp;gt;

                        &amp;lt;div class=&#34;thumbnail&#34;&amp;gt;

                            &amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;

                                &amp;lt;img class=&#34;img-responsive&#34; src=&#34;{{ asset(&#39;logo-tableless.png&#39;) }}&#34; alt=&#34;img&#34; title=&#34;img&#34;/&amp;gt;

                            &amp;lt;/a&amp;gt; 

                            &amp;lt;div class=&#34;caption&#34;&amp;gt; 

                                &amp;lt;h3&amp;gt;&amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt; 

                                &amp;lt;p&amp;gt;Escrito por: {{ post.author.name }}&amp;lt;/p&amp;gt; 

                                &amp;lt;p&amp;gt;{{ post.content|slice(0, 45) }} ...&amp;lt;/p&amp;gt;

                                &amp;lt;p&amp;gt;&amp;lt;a href=&#34;{{ path(&#39;show&#39;, { &#39;id&#39;: post.id }) }}&#34;&amp;gt;Leia mais...&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;

                            &amp;lt;/div&amp;gt;

                        &amp;lt;/div&amp;gt; 

                    &amp;lt;/article&amp;gt;

                {% endfor %} 

            &amp;lt;/div&amp;gt;

        &amp;lt;/div&amp;gt; 

    &amp;lt;/div&amp;gt;

{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Vamos entrar no terminal, e subir nosso servidor.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console server:run
&lt;/pre&gt;

&lt;p&gt;Entre na url: &lt;a href=&#34;http://127.0.0.1:8000/&#34;&gt;http://127.0.0.1:8000/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nossa home está pronto, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/051.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/051.png&#34; alt=&#34;blog&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47980&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;estruturando-e-estilizando-o-show&#34;&gt;Estruturando e estilizando o show&lt;/h2&gt;

&lt;p&gt;Vamos estruturar o show.html.twig, que é responsável pela visualização de cada post.&lt;/p&gt;

&lt;p&gt;Abra o arquivo, caminho: src/Tableless/CoreBundle/Resources/views/IndexController/ show.html.twig, e vamos estruturá lo.&lt;/p&gt;

&lt;p&gt;Vamos colocar um título no bloco &amp;#8220;title&amp;#8221;, renomear o bloco body para content, fazer a estruturação com o html e passar as classes do bootstrap. Perceba que nesse caso não precisamos fazer um &amp;#8220;for&amp;#8221; com o twig, pois estamos recebendo somente um array, ou seja, um post.&lt;/p&gt;

&lt;p&gt;Temos que dar uma atenção para a data de criação, e a data de atualização, não estamos recebendo essas datas no formato correto. Para que possamos apresentar as datas, temos que passar um date() no twig, veja o exemplo abaixo&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{{ post.createdAt | date(&#39;d/m/Y - H:m:s&#39;) }}
&lt;/pre&gt;

&lt;p&gt;Veja o arquivo show.html.twig pronto:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% extends &#34;::base.html.twig&#34; %} 

{% block title %}Blog - {{ post.title }}{% endblock %} 

{% block content %} 

&amp;lt;div class=&#34;container&#34;&amp;gt; 

    &amp;lt;div class=&#34;row&#34;&amp;gt; 

        &amp;lt;article class=&#34;col-lg-12&#34;&amp;gt; 

            &amp;lt;h1&amp;gt;{{ post.title }}&amp;lt;/h1&amp;gt; 

            &amp;lt;p&amp;gt;Escrito por: {{ post.author.name }}&amp;lt;/p&amp;gt;

            &amp;lt;p&amp;gt;Postado em: {{ post.createdAt | date(&#39;d/m/Y - H:m:s&#39;) }}&amp;lt;/p&amp;gt;

            &amp;lt;p&amp;gt;{{ post.content }}&amp;lt;/p&amp;gt; 

        &amp;lt;/article&amp;gt; 

    &amp;lt;/div&amp;gt; 
    
&amp;lt;/div&amp;gt; 

{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Imagem da página pronta:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/061.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/061.png&#34; alt=&#34;Show post&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47981&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Nossa página de visualização de post, e nossa home, está estruturada e estilizada, temos que fazer a parte administrativa, tanto a administração de post, quanto de autores. Vou fazer essa parte em off. Os arquivos, encontram- se no github, os caminhos são:&lt;/p&gt;

&lt;p&gt;src/Tableless/CoreBundle/Resources/views/Author/&lt;/p&gt;

&lt;p&gt;src/Tableless/CoreBundle/Resources/views/Posts/&lt;/p&gt;

&lt;p&gt;Links dos tutoriais anteriores:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; title=&#34;instalação&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – Instalação&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; title=&#34;pt 02&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 02&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; title=&#34;pt 3&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 03&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; title=&#34;pt 4&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-05/&#34; title=&#34;pt 5&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 – parte 05&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O projeto &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;Github do projeto&#34; target=&#34;_blank&#34;&gt;encontra-se no GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 05</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-05/</link>
      <pubDate>Thu, 19 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-05/</guid>
      <description>

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; title=&#34;Iniciando com symfony2 - parte 4&#34; target=&#34;_blank&#34;&gt;tutorial anterior&lt;/a&gt;, criamos a entidade Author, e fizemos o relacionamento com os posts, neste tutorial vamos fazer as configurações adequadas para que possamos deixar nossa aplicação estruturada corretamente, e vamos criar e configurar a página index, onde os usuários terão acesso para visualizar e ler os posts.&lt;/p&gt;

&lt;h2 id=&#34;configurando&#34;&gt;Configurando&lt;/h2&gt;

&lt;p&gt;Vamos começar com as configurações.&lt;/p&gt;

&lt;p&gt;Entrando no bundle CoreBundle, caminho: src/Tableless/CoreBundle, exclua a pasta Controller.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/021.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/021.png&#34; alt=&#34;Excluindo a pasta controller&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47743&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ainda neste mesmo bundle vamos excluir a pasta view, caminho: src/Tableless/CoreBundle/Resources/view.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/031.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/031.png&#34; alt=&#34;Excluindo a pasta view&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47744&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Agora vamos entrar no bundle ModelBundle, caminho: src/Tableless/ModelBundle.&lt;/p&gt;

&lt;p&gt;E vamos mover a pasta Controller desse bundle para o bundle CoreBundle&lt;/p&gt;

&lt;p&gt;Vamos mover também a pasta view do ModelBundle para o bundle CoreBundle.&lt;/p&gt;

&lt;p&gt;Depois das mudanças, nossa estrutura de pastas ficará como na imagem abaixo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/041.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/041.png&#34; alt=&#34;Estrutura de pastas pronta&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47746&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;configurando-os-controllers&#34;&gt;Configurando os Controllers&lt;/h2&gt;

&lt;p&gt;Vamos continuar nossas configurações, agora vamos alterar nossos controllers para que os mesmos fiquem de acordo com a estrutura de pasta atual.&lt;/p&gt;

&lt;p&gt;Primeiramente, vamos excluir a rota do ModelBundle, pois não vamos usá-la.&lt;/p&gt;

&lt;p&gt;Entre no arquivo app/config/routing.yml e exclua as linhas abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-yml&#34;&gt;tableless_model:
    resource: &#34;@TablelessModelBundle/Controller/&#34;
    type:     annotation
    prefix:   /
&lt;/pre&gt;

&lt;p&gt;Deixando somente a rota tableless_core como mostrado na imagem abaixo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/05.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/05.png&#34; alt=&#34;Arquivo routing.yml&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47747&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Agora vamos excluir o DefaultController.php, pois não vamos usar esse controller.&lt;/p&gt;

&lt;p&gt;Abra o arquivo AuthorController.php, caminho: src/Tableless/CoreBundle/Controller/AuthorController.php&lt;/p&gt;

&lt;p&gt;Na linha 3, mude o namespace.&lt;/p&gt;

&lt;p&gt;De: Tableless\ModelBundle\Controller;&lt;/p&gt;

&lt;p&gt;Para: Tableless\CoreBundle\Controller;&lt;/p&gt;

&lt;p&gt;Na linha 43, mude a annotation:&lt;/p&gt;

&lt;p&gt;De: @Template(&amp;#8220;TablelessModelBundle:Author:new.html.twig&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Para: @Template(&amp;#8220;TablelessCoreBundle:Author:new.html.twig&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Agora vamos configurar o controller PostController, caminho: src/Tableless/CoreBundle/Controller/PostController.php, vamos fazer a mesma alteração.&lt;/p&gt;

&lt;p&gt;Na linha 3, mude o namespace.&lt;/p&gt;

&lt;p&gt;De: Tableless\ModelBundle\Controller;&lt;/p&gt;

&lt;p&gt;Para: Tableless\CoreBundle\Controller;&lt;/p&gt;

&lt;p&gt;Na linha 43, mude a annotation:&lt;/p&gt;

&lt;p&gt;De: @Template(&amp;#8220;TablelessModelBundle:Post:new.html.twig&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Para: @Template(&amp;#8220;TablelessCoreBundle:Post:new.html.twig&amp;#8221;)&lt;/p&gt;

&lt;p&gt;Para verificarmos se correu tudo bem, vamos fazer o teste.&lt;/p&gt;

&lt;p&gt;Rode o servidor&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ app/console server:run
&lt;/pre&gt;

&lt;p&gt;Entre nas urls:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/post/&#34;&gt;http://127.0.0.1:8000/post/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/author/&#34;&gt;http://127.0.0.1:8000/author/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Se tudo foi configurado corretamente, nossa aplicação voltará a funcionar perfeitamente, veja:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/06.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/06.png&#34; alt=&#34;Página index, e show&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47751&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;criando-um-controller&#34;&gt;Criando um Controller&lt;/h2&gt;

&lt;p&gt;Nesse momento vamos criar um index, para nossa aplicação, para que seja nossa pagina principal, e possamos visualizar os posts de forma correta.&lt;/p&gt;

&lt;p&gt;Podemos criar o controller codificando, porém para efeito de didática vamos criar através do console.&lt;/p&gt;

&lt;p&gt;Entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:controller
&lt;/pre&gt;

&lt;p&gt;Ao digitarmos o comando acima e darmos enter, entramos no assistente do console do Symfony e ele nos comunica: Primeiro, você precisa dar o nome do controlador que você deseja gerar. Você deve usar a notação de atalho como AcmeBlogBundle:Post&lt;/p&gt;

&lt;p&gt;Nesse momento digitamos:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Controller name: TablelessCoreBundle:IndexControler
&lt;/pre&gt;

&lt;p&gt;Ao darmos o nome do nosso controller e darmos enter, o assistente nos pergunta: Qual o formato que vamos configurar a nossa rota?&lt;/p&gt;

&lt;p&gt;E nos indica annotation, vamos deixar como está, e apenas damos enter:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;$ Routing format (php, xml, yml, annotation) [annotation]:
&lt;/pre&gt;

&lt;p&gt;A próxima pergunta é:&lt;/p&gt;

&lt;p&gt;Qual o formato que vamos usar para template?&lt;/p&gt;

&lt;p&gt;Ele mesmo nos indica o twig. Apenas damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;$ Template format (twig, php) [twig]:
&lt;/pre&gt;

&lt;p&gt;Após o enter ele nos pede o nome de nossas ações, que são os métodos que vamos criar para o nosso controller.&lt;/p&gt;

&lt;p&gt;A primeira ação (método) vamos chamar de indexAction, e damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New action name (press  to stop adding actions): indexAction
&lt;/pre&gt;

&lt;p&gt;O assistente nos pede a rota, vamos digitar “/” e damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Action route [/index]: /
&lt;/pre&gt;

&lt;p&gt;Nos pergunta o caminho da nossa template, e ele nos indica um caminho, vamos deixar como está e apenas damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Templatename (optional) [TablelessCoreBundle:IndexControler:index.html.twig]:
&lt;/pre&gt;

&lt;p&gt;Novamente o assistente nos pede para darmos um nome para uma nova ação (método), essa nova ação fará com que o post seja visualizado para a leitura, vamos dar o nome de showAction.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New action name (press  to stop adding actions): showAction
&lt;/pre&gt;

&lt;p&gt;O assistente nos pede a rota, e nos indica como “/show”, vamos deixar como está e damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Action route [/show]:
&lt;/pre&gt;

&lt;p&gt;Nos pergunta sobre caminho da template, e ele nos indica um caminho, vamos deixar como está e apenas damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Templatename (optional) [TablelessCoreBundle:IndexControler:show.html.twig]:
&lt;/pre&gt;

&lt;p&gt;Ao darmos enter, entramos no modo de criação de uma nova ação, porém não queremos nenhuma outra ação, então apenas damos um enter, para entrarmos no processo de finalização.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New action name (press  to stop adding actions):
&lt;/pre&gt;

&lt;p&gt;Ao entramos no processo de finalização o assistente nos pergunta se queremos confirmar a geração desse controller, ele nos indica sim, como queremos, apenas damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you confirm generation [yes]?
&lt;/pre&gt;

&lt;p&gt;Pronto! Nosso controller IndexController está criado, juntamente com suas templates, veja a imagem abaixo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/07.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/07.png&#34; alt=&#34;Index controller&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47775&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ao entrarmos na url: &lt;a href=&#34;http://127.0.0.1:8000/&#34;&gt;http://127.0.0.1:8000/&lt;/a&gt;, vamos entrar no nosso index, e receberemos a mensagem abaixo:&lt;/p&gt;

&lt;p&gt;Welcome to the IndexControler:index page&lt;/p&gt;

&lt;h2 id=&#34;criando-um-repositório&#34;&gt;Criando um repositório&lt;/h2&gt;

&lt;p&gt;Se entrarmos em nosso controller IndexController, caminho: src/Tableless/CoreBunde/ IndexController.php, vamos perceber que nossos métodos estão criados, porém não estão implementados, vamos implementá-los, mas queremos que nosso index apresente para o usuário os últimos posts escritos, para que sempre o post mais atual seja apresentado em primeiro lugar, para isso devemos criar um repositório para nossa entidade Post.&lt;/p&gt;

&lt;p&gt;Para isso, vamos entrar no bundle ModelBundle e crie uma pasta com o nome de Repository, dentro dessa pasta crie uma classe com o nome PostRepository.&lt;/p&gt;

&lt;p&gt;Com a classe PostRepository aberta, adicione o nemspace dessa classe, e de um extends na classe EntityRepository do Doctrine, não se esquecendo de dar um use nessa classe.&lt;/p&gt;

&lt;p&gt;use Doctrine\ORM\EntityRepository;&lt;/p&gt;

&lt;p&gt;Crie um método privado com o nome getQueryBuilder e acrescente a EntityManager para que possamos usar nossa entidade Post, veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;private function getQueryBuilder()
{
    $em = $this-&amp;gt;getEntityManager();

    $queryBuilder = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)
    -&amp;gt;createQueryBuilder(&#39;p&#39;);

    return $queryBuilder;
 }
&lt;/pre&gt;

&lt;p&gt;Agora vamos criar um método publico chamado findAllInOrder, e vamos chamar o método getQueryBuilder(), para ordená-lo da forma que queremos, para que seja mostrado o último post postado primeiro. Veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;public function findAllInOrder()
{
    $qb = $this-&amp;gt;getQueryBuilder()
    -&amp;gt;orderBy(&#39;p.createdAt&#39;, &#39;desc&#39;);

    return $qb-&amp;gt;getQuery()-&amp;gt;getResult();
}
&lt;/pre&gt;

&lt;p&gt;Veja a classe PostRepository pronta:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\ModelBundle\Repository;

use Doctrine\ORM\EntityRepository;

class PostRepository extends EntityRepository
{
    private function getQueryBuilder()
    {
        $em = $this-&amp;gt;getEntityManager();
        $queryBuilder = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)
            -&amp;gt;createQueryBuilder(&#39;p&#39;);
        return $queryBuilder;
    }

     public function findAllInOrder()
    {
        $qb = $this-&amp;gt;getQueryBuilder()
            -&amp;gt;orderBy(&#39;p.createdAt&#39;, &#39;desc&#39;);

        return $qb-&amp;gt;getQuery()-&amp;gt;getResult();
    }
} 

&lt;/pre&gt;

&lt;p&gt;Agora temos que indicar para a entidade Post via annotation, onde está a classe PostRepository, para isso vamos abrir a entidade Post, caminho:src/Tableless/ModelBundle/Entity/Post.php, e acrescentar a annotation (repositoryClass=&amp;#8221;Tableless\ModelBundle\Repository\PostRepository&amp;#8221;) na linha 12 de sua entidade, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
 * Post
 *
 * @ORM\Table(name=&#34;post&#34;)
 * @ORM\Entity(repositoryClass=&#34;Tableless\ModelBundle\Repository\PostRepository&#34;)
 */
class Post extends Timestampable
{
    ...
&lt;/pre&gt;

&lt;h2 id=&#34;implementando-o-controller&#34;&gt;Implementando o controller&lt;/h2&gt;

&lt;p&gt;Vamos voltar para nosso IndexController, para que possamos implementá- lo. Abra o IndexController , e no método indexAction() temos que chamar nossa entidade Post, para que através dela chamemos o método findAllInOrder() da classe PostRepository, e retornar o resultado em forma de array, veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;public function indexAction()
    {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();

        $posts = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;findAllInOrder();

        return [
            &#39;posts&#39; =&amp;gt; $posts,
        ];
    } 
&lt;/pre&gt;

&lt;p&gt;Também vamos implementar o método showAction(), para que seja buscado apena o post clickado pelo usuário, para isso devemos passar um parâmetro id, tanto no método, quanto na annotation para rota, para que seja buscado somente o post solicitado. Temos que chamar nossa entidade Post novamente, para que através dela chamemos o método find(), que já vem pré configurado pelo Doctrine, porém se o usuário requisitar um post que não existe, temos que passar uma mensagem de erro, para informá- lo, veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
     * @Route(&#34;/show/{id}&#34;)
     * @Template()
     */
    public function showAction($id)
    {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();

        $post = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;find($id);

        if (!$post) {
            throw $this-&amp;gt;createNotFoundException(&#39;O post não existe! Volte para home!&#39;);
        }

        return [
            &#39;post&#39; =&amp;gt; $post,
        ];
    }
&lt;/pre&gt;

&lt;p&gt;Veja o IndexController pronto:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\CoreBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Template;

class IndexControlerController extends Controller
{
     /**
     * @Route(&#34;/&#34;)
     * @Template()
     */
    public function indexAction()
    {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();

        $posts = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;findAllInOrder();

        return [
            &#39;posts&#39; =&amp;gt; $posts,
        ];
    }

     /**
     * @Route(&#34;/show/{id}&#34;)
     * @Template()
     */
    public function showAction($id)
    {
        $em = $this-&amp;gt;getDoctrine()-&amp;gt;getManager();

        $post = $em-&amp;gt;getRepository(&#39;TablelessModelBundle:Post&#39;)-&amp;gt;find($id);

        if (!$post) {
            throw $this-&amp;gt;createNotFoundException(&#39;O post não existe! Volte para home!&#39;);
        }

        return [
            &#39;post&#39; =&amp;gt; $post,
        ];
    }
}

&lt;/pre&gt;

&lt;p&gt;Para vemos como está ficando nossa aplicação, abra a index.html.twig, do IndexController, caminho: src/Tableless/CoreBundle/Resouces/views/IndexController/index.html.twig e vamos dar um dump em posts, veja abaixo, vamos adicionar a linha 8:&lt;/p&gt;

&lt;pre class=&#34;lang-twig&#34;&gt;{% extends &#34;::base.html.twig&#34; %}

{% block title %}TablelessCoreBundle:IndexControler:index{% endblock %}

{% block body %}
Welcome to the IndexControler:index page

    {{ dump(posts) }}
    
{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Vamos fazer a mesma modificação para o arquivo show.html.twig no mesmo diretório, porém ao em vez de dar um dump em posts, vamos dar um dump em post, sem o “s” no final, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;{% extends &#34;::base.html.twig&#34; %}

{% block title %}TablelessCoreBundle:IndexControler:show{% endblock %}

{% block body %}
Welcome to the IndexControler:show page

    {{ dump(post) }}
    
{% endblock %}
&lt;/pre&gt;

&lt;p&gt;Para vemos o resultado, entre nas urls:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/&#34;&gt;http://127.0.0.1:8000/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/show/{o&#34;&gt;http://127.0.0.1:8000/show/{o&lt;/a&gt; id do seu post}&lt;/p&gt;

&lt;p&gt;Veja as imagens para comparação:&lt;/p&gt;

&lt;p&gt;index &amp;#8211; url: &lt;a href=&#34;http://127.0.0.1:8000/&#34;&gt;http://127.0.0.1:8000/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/08.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/08.png&#34; alt=&#34;index&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47767&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pagina show – url: &lt;a href=&#34;http://127.0.0.1:8000/show/4&#34;&gt;http://127.0.0.1:8000/show/4&lt;/a&gt; -&amp;gt; {o id do seu post} no meu caso 4.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/09.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/09.png&#34; alt=&#34;show&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47768&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;No tutorial anterior, eu comentei que iriamos configurar nosso projeto e começarmos a trabalhar com o Twig, porém nossa configuração e a criação do index, deixou este tutorial extenso, mas no próximo tutorial, vamos trabalhar com o bootstrap e com o twig para que possamos visualizar nossos post em nossa home da forma adequada e bonita.&lt;/p&gt;

&lt;p&gt;Links dos tutoriais anteriores:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; title=&#34;instalação&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 &amp;#8211; Instalação&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; title=&#34;parte 02&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 &amp;#8211; parte 02&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; title=&#34;parte 03&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 &amp;#8211; parte 03&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-04/&#34; title=&#34;parte 04&#34; target=&#34;_blank&#34;&gt;Iniciando com Symfony 2 &amp;#8211; parte 04&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O projeto &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;Git do projeto&#34; target=&#34;_blank&#34;&gt;encontra-se no GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 04</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-04/</link>
      <pubDate>Wed, 04 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-04/</guid>
      <description>

&lt;p&gt;Anteriormente, &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-03/&#34; title=&#34;Iniciando com symfony - parte-03&#34; target=&#34;_blank&#34;&gt;criamos a entidade Post&lt;/a&gt;, vamos dar continuidade ao nosso simples projeto, criando uma entidade Author, faremos o relacionamento para que cada autor fique ligado ao post que criou.&lt;/p&gt;

&lt;h2 id=&#34;criando-a-entidade-author&#34;&gt;Criando a entidade Author&lt;/h2&gt;

&lt;p&gt;Vamos criar a entidade Author, entre no terminal e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:entity
&lt;/pre&gt;

&lt;p&gt;Vamos digitar o nome da entidade como : TablelessModelBundle:Author.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ The Entity shortcut name: TablelessModelBundle:Author
&lt;/pre&gt;

&lt;p&gt;Vamos mapeá-la usando annotation. Apenas damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Configuration format (yml, xml, php, or annotation) [annotation]:
&lt;/pre&gt;

&lt;p&gt;O assistente nos pergunta: Qual será o nome do nosso campo?&lt;/p&gt;

&lt;p&gt;Digitamos &amp;#8220;name&amp;#8221; e damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields): name
&lt;/pre&gt;

&lt;p&gt;Será do tipo string.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field type [string]:
&lt;/pre&gt;

&lt;p&gt;Com o tamanho de 100.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field length [255]: 100
&lt;/pre&gt;

&lt;p&gt;Quando o assistente nos perguntar novamente: Qual será o novo campo? Damos enter para entrarmos no processo de finalização. E nos pergunta, se queremos criar uma classe de repositório, ele nos indica não, vamos apenas dar um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Do you want to generate an empty repository class [no]?
&lt;/pre&gt;

&lt;p&gt;E para finalizar, o assistente pergunta se realmente queremos gerar a entidade. Como queremos, digitamos apenas enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you confirm generation [yes]?
&lt;/pre&gt;

&lt;p&gt;Nossa entidade Author está pronta.&lt;/p&gt;

&lt;p&gt;Ao entrarmos na pasta src/Tableless/ModelBundle/Entity/ vamos encontrá-la.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/02.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/02.png&#34; alt=&#34;Entidade Author criada&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47412&#34; srcset=&#34;uploads/2015/03/02.png 750w, uploads/2015/03/02-259x139.png 259w, uploads/2015/03/02-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Agora devemos adicionar a annotations, @ORM\Table(name=&amp;#8221;author&amp;#8221;) para o nome da nossa tabela, veja na linha 10:&lt;/p&gt;

&lt;p&gt;Veja toda a entidade Author:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 

/** 
 * Author 
 * 
 * @ORM\Table(name=&#34;author&#34;)
 * @ORM\Entity 
 */ 
class Author 
{ 
    /** 
     * @var integer 
     * 
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;) 
     * @ORM\Id 
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;) 
     */ 
    private $id; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;name&#34;, type=&#34;string&#34;, length=100) 
     */ 
    private $name; 

    /** 
     * Get id 
     * 
     * @return integer 
     */ 
    public function getId() 
    { 
        return $this-&amp;gt;id; 
    } 

    /** 
     * Set name 
     * 
     * @param string $name 
     * @return Author 
     */ 
    public function setName($name) 
    { 
        $this-&amp;gt;name = $name; 
        return $this; 
    } 

    /** 
     * Get name 
     * 
     * @return string 
     */ 
    public function getName() 
    { 
        return $this-&amp;gt;name; 
    } 
} 
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-o-projeto&#34;&gt;Configurando o projeto&lt;/h2&gt;

&lt;p&gt;Nesse momento vamos criar uma classe abstrata com o nome Timestampable, para que não fiquemos repetindo código, pois entidade Author também receberá uma data de criação e data de atualização.&lt;/p&gt;

&lt;p&gt;Vamos lá!&lt;/p&gt;

&lt;p&gt;Entre na pasta src/Tableless/ModelBundle/Entity/, e vamos criar uma classe abstrata com o nome Timestampable, para que possamos mapeá lá vamos usar a classe do Doctrine Mapping e vamos dar um apelido de ORM, e fazer as annotations correspondentes.&lt;/p&gt;

&lt;p&gt;Nesse momento, ficar explicando detalhe por detalhe levará muito tempo, e o tutorial ficará extenso, veja a classe Timestampable pronta abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 
use Symfony\Component\Validator\Constraints as Assert; 

/** 
 * Timestampable abstract class 
 * @ORM\MappedSuperclass 
 */ 
abstract class Timestampable 
{ 
    /** 
     * @var \DateTime 
     * 
     * @ORM\Column(name=&#34;created_at&#34;, type=&#34;datetime&#34;) 
     * @Assert\NotBlank 
     */ 
    private $createdAt; 

    /** 
     * @var \DateTime 
     * 
     * @ORM\Column(name=&#34;updated_at&#34;, type=&#34;datetime&#34;) 
     * @Assert\NotBlank 
     */ 
    private $updatedAt; 

    /** 
     * Construct 
     */ 
    public function __construct() 
    { 
        $this-&amp;gt;createdAt = new \DateTime(); 
        $this-&amp;gt;updatedAt = new \DateTime(); 
    } 

    /** 
     * Set createdAt 
     * 
     * @param $createdAt 
     */ 
    public function setCreatedAt($createdAt) 
    { 
        $this-&amp;gt;createdAt = $createdAt; 
    } 

    /** 
     * Get CreatedAt 
     * 
     * @return \DateTime 
     */ 
    public function getCreatedAt() 
    { 
        return $this-&amp;gt;createdAt; 
    } 

    /** 
     * Set UpdatedAt 
     * 
     * @param \DateTime $updatedAt 
     */ 
    public function setUpdatedAt($updatedAt) 
    { 
        $this-&amp;gt;updatedAt = $updatedAt; 
    } 
    /** 
     * Get UpdateAt 
     * 
     * @return \DateTime 
     */ 
    public function getUpdatedAt() 
    { 
        return $this-&amp;gt;updatedAt; 
    } 
}
&lt;/pre&gt;

&lt;p&gt;Vamos estender essa classe na entidade Author, veja abaixo na linha 13:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 

/** 
 * Author 
 * 
 * @ORM\Table(name=&#34;author&#34;)
 * @ORM\Entity 
 */ 
class Author extends Timestampable 
{ 
…
&lt;/pre&gt;

&lt;p&gt;Temos que validar os campos da entidade Author, vamos dar um use em Constraints e apelidá-la como Assert:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Symfony\Component\Validator\Constraints as Assert;
&lt;/pre&gt;

&lt;p&gt;vamos validar o campo name com @Assert\NotBlank, veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
* @var string 
* 
* @ORM\Column(name=&#34;name&#34;, type=&#34;string&#34;, length=100) 
* @Assert\NotBlank 
*/ 
private $name; 
&lt;/pre&gt;

&lt;p&gt;Veja a entidade Author depois da configuração:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 
use Symfony\Component\Validator\Constraints as Assert; 

/** 
 * Author 
 * 
 * @ORM\Table(name=&#34;author&#34;)
 * @ORM\Entity 
 */ 
class Author extends Timestampable 
{  
    /** 
     * @var integer 
     * 
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;) 
     * @ORM\Id 
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;) 
     */ 
    private $id; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;name&#34;, type=&#34;string&#34;, length=100) 
     * @Assert\NotBlank 
     */ 
    private $name; 


    /** 
     * Get id 
     * 
     * @return integer 
     */ 
    public function getId() 
    { 
        return $this-&amp;gt;id; 
    } 

    /** 
     * Set name 
     * 
     * @param string $name 
     * @return Author 
     */ 
    public function setName($name) 
    { 
        $this-&amp;gt;name = $name; 
 
        return $this; 
    } 

    /** 
     * Get name 
     * 
     * @return string 
     */ 
    public function getName() 
    { 
        return $this-&amp;gt;name; 
    } 
} 
&lt;/pre&gt;

&lt;h2 id=&#34;configurando-a-entidade-post&#34;&gt;Configurando a entidade Post&lt;/h2&gt;

&lt;p&gt;Como criamos um classe abstrata, vamos alterar a entidade Post para que ela estenda a entidade Timestampable.&lt;/p&gt;

&lt;p&gt;Exclua os atributos $createdAt e $updatedAt e os métodos setCreatedAt(), getCreatedAt(), setUpdatedAt(), getUpdatedAt() e o __contruct(), e vamos estender a classe Timestampable, depois de configurada, a entidade Post ficará assim:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 
use Symfony\Component\Validator\Constraints as Assert; 

/** 
 * Post 
 * 
 * @ORM\Table(name=&#34;post&#34;) 
 * @ORM\Entity 
 */ 
class Post extends Timestampable 
{ 
    /** 
     * @var integer 
     * 
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;) 
     * @ORM\Id 
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;) 
     */ 
    private $id; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;title&#34;, type=&#34;string&#34;, length=255) 
     * @Assert\NotBlank 
     */ 
    private $title; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;content&#34;, type=&#34;text&#34;) 
     * @Assert\NotBlank 
     */ 
    private $content; 

     /** 
     * Get id 
     * 
     * @return integer 
     */ 
    public function getId() 
    { 
        return $this-&amp;gt;id; 
    } 

    /** 
     * Set title 
     * 
     * @param string $title 
     * @return Post 
     */ 
    public function setTitle($title) 
    { 
        $this-&amp;gt;title = $title; 

     return $this; 
    } 

    /** 
     * Get title 
     * 
     * @return string 
     */ 
    public function getTitle() 
    { 
        return $this-&amp;gt;title; 
    } 

    /** 
     * Set content 
     * 
     * @param string $content 
     * @return Post 
     */ 
    public function setContent($content) 
    { 
        $this-&amp;gt;content = $content; 

        return $this; 
    } 

    /** 
     * Get content 
     * 
     * @return string 
     */ 
    public function getContent() 
    { 
        return $this-&amp;gt;content; 
    } 
} 
&lt;/pre&gt;

&lt;h2 id=&#34;atualizando-o-banco-de-dados&#34;&gt;Atualizando o banco de dados&lt;/h2&gt;

&lt;p&gt;Geramos a entidade Author e alteramos a entidade Post, dessa forma devemos atualizar nosso banco, para que o mesmo fique configurado de acordo com as entidades.&lt;/p&gt;

&lt;p&gt;Vamos ao terminal, e para atualizar o banco de dados vamos digitar o código:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:schema:update --force
&lt;/pre&gt;

&lt;p&gt;Teremos o resultado:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Updating database schema... 
 Database schema updated successfully! &#34;1&#34; queries were execute
&lt;/pre&gt;

&lt;p&gt;Entrando no banco de dados vamos perceber que a tabela author criada:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/03.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/03.png&#34; alt=&#34;Tabela Author&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47434&#34; srcset=&#34;uploads/2015/03/03.png 750w, uploads/2015/03/03-259x139.png 259w, uploads/2015/03/03-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;criando-o-crud-da-entidade-author&#34;&gt;Criando o CRUD da entidade Author&lt;/h2&gt;

&lt;p&gt;Depois da configuração das nossa entidade, vamos gerar o CRUD da entidade Author. Vamos digitar no console:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:crud
&lt;/pre&gt;

&lt;p&gt;Digitamos TablelessModelBundle:Author:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ The Entity shortcut name: TablelessModelBundle:Author
&lt;/pre&gt;

&lt;p&gt;O assistente nos pergunta se queremos gerar as ações de gravação, digitamos: yes.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you want to generate the &#34;write&#34; actions [no]? Yes
&lt;/pre&gt;

&lt;p&gt;Como vamos configurar? Vamos deixar como está, annotation, e damos enter&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Configuration format (yml, xml, php, or annotation) [annotation]:
&lt;/pre&gt;

&lt;p&gt;Como será a rota? Vamos deixar como ele nos indica, damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Routes prefix [/author]:
&lt;/pre&gt;

&lt;p&gt;Vamos confirmar a geração desse CRUD dando enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you confirm generation [yes]?
&lt;/pre&gt;

&lt;p&gt;Prontinho nosso CRUD da entidade Author está pronto, vamos testar.&lt;/p&gt;

&lt;p&gt;Inicie o servidor:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console server:run
&lt;/pre&gt;

&lt;p&gt;entre na url:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/author/&#34;&gt;http://127.0.0.1:8000/author/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vamos criar um autor com o nome Tableless&lt;/p&gt;

&lt;h2 id=&#34;relacionamento-com-doctrine&#34;&gt;Relacionamento com Doctrine&lt;/h2&gt;

&lt;p&gt;Vamos fazer um relacionamento no banco de dados, pois queremos que, ao criarmos um post, o mesmo esteja relacionado com o autor que o criou. Não entraremos em detalhes sobre relacionamento, caso tenha dúvidas, &lt;a href=&#34;http://doctrine-orm.readthedocs.org/en/latest/reference/association-mapping.html&#34; title=&#34;Documentação de relacionamento com Doctrine&#34; target=&#34;_blank&#34;&gt;consulte a documentação&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Vamos configurar novamente as entidades para que o relacionamento possa acontecer.&lt;/p&gt;

&lt;p&gt;Entre na entidade Post e acrescente o atributo $author com as seguintes annotations:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * @var Author 
     * 
     * @ORM\ManyToOne(targetEntity=&#34;Author&#34;, inversedBy=&#34;posts&#34;) 
     * @ORM\JoinColumn(name=&#34;author_id&#34;, referencedColumnName=&#34;id&#34;, nullable=false) 
     * @Assert\NotBlank 
     */ 
    private $author;
&lt;/pre&gt;

&lt;p&gt;Entre na entidade Author e acrescente o atributo $post, com as seguintes annotations:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * @var ArrayCollection 
     * 
     * @ORM\OneToMany(targetEntity=&#34;Post&#34;, mappedBy=&#34;author&#34;, cascade={&#34;remove&#34;}) 
     */ 
    private $post;
&lt;/pre&gt;

&lt;p&gt;Precisamos também dar um use na classe ArrayCollection, do Doctrine, pois um autor terá vários posts, e os posts serão buscados como array, insira o código:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Doctrine\Common\Collections\ArrayCollection;
&lt;/pre&gt;

&lt;p&gt;Vamos criar um construtor, porém a entidade Timestampable já tem um construtor, para resolver esse problema, vamos adicionar um parent::__construct(), veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * Constructor 
     */ 
    public function __construct() 
    { 
         parent::__construct();
    
        $this-&amp;gt;post = new ArrayCollection(); 
    }
&lt;/pre&gt;

&lt;p&gt;Agora vamos gerar os métodos necessários da entidade Author, entre no console e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:entities TablelessModelBundle:Author
&lt;/pre&gt;

&lt;p&gt;Temos que gerar também para a entidade Post:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:entities TablelessModelBundle:Post
&lt;/pre&gt;

&lt;p&gt;Entre novamente na entidade Author e acrescente o método abaixo no final da entidade:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * @return string 
     */ 
    public function __toString() 
    { 
        return $this-&amp;gt;getName(); 
    }
&lt;/pre&gt;

&lt;p&gt;Veja como ficou a entidade Author depois de configurarmos:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 
use Symfony\Component\Validator\Constraints as Assert; 
use Doctrine\Common\Collections\ArrayCollection; 

/** 
 * Author 
 * 
 * @ORM\Table(name=&#34;author&#34;) 
 * @ORM\Entity 
 */ 
class Author extends Timestampable 
{ 
   /** 
     * @var integer 
     * 
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;) 
     * @ORM\Id 
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;) 
     */ 
    private $id; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;name&#34;, type=&#34;string&#34;, length=100) 
     * @Assert\NotBlank 
     */ 
    private $name; 

    /** 
     * @var ArrayCollection 
     * 
     * @ORM\OneToMany(targetEntity=&#34;Post&#34;, mappedBy=&#34;author&#34;, cascade={&#34;remove&#34;}) 
     */ 
    private $post; 

    /** 
     * Constructor 
     */ 
    public function __construct() 
    { 
         parent::__construct();

        $this-&amp;gt;post = new ArrayCollection(); 
    } 

        /** 
     * Get id 
     * 
     * @return integer 
     */ 
    public function getId() 
    { 
        return $this-&amp;gt;id; 
    } 

    /** 
     * Set name 
     * 
     * @param string $name 
     * @return Author 
     */ 
    public function setName($name) 
    { 
        $this-&amp;gt;name = $name; 

        return $this; 
    } 

    /** 
     * Get name 
     * 
     * @return string

    */ 
    public function getName() 
    { 
        return $this-&amp;gt;name; 
    } 

    /** 
     * Add post 
     * 
     * @param \Tableless\ModelBundle\Entity\Post $post 
     * @return Author 
     */ 
    public function addPost(\Tableless\ModelBundle\Entity\Post $post) 
    { 
        $this-&amp;gt;post[] = $post; 

        return $this; 
    } 

    /** 
     * Remove post 
     * 
     * @param \Tableless\ModelBundle\Entity\Post $post 
     */ 
    public function removePost(\Tableless\ModelBundle\Entity\Post $post) 
    { 
        $this-&amp;gt;post-&amp;gt;removeElement($post); 
    } 

    /** 
     * Get post 
     * 
     * @return \Doctrine\Common\Collections\Collection 
     */ 
    public function getPost() 
    { 
        return $this-&amp;gt;post; 
    } 

    /** 
     * @return string 
     */ 
    public function __toString() 
    { 
        return $this-&amp;gt;getName(); 
    } 
} 

&lt;/pre&gt;

&lt;p&gt;Veja a entidade Post, após a configuração:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 

namespace Tableless\ModelBundle\Entity; 

use Doctrine\ORM\Mapping as ORM; 
use Symfony\Component\Validator\Constraints as Assert; 

/** 
 * Post 
 * 
 * @ORM\Table(name=&#34;post&#34;) 
 * @ORM\Entity 
 */ 
class Post extends Timestampable 
{ 
    /** 
     * @var integer 
     * 
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;) 
     * @ORM\Id 
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;) 
     */ 
    private $id; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;title&#34;, type=&#34;string&#34;, length=255) 
     * @Assert\NotBlank 
     */ 
    private $title; 

    /** 
     * @var string 
     * 
     * @ORM\Column(name=&#34;content&#34;, type=&#34;text&#34;) 
     * @Assert\NotBlank 
     */ 
    private $content; 

    /** 
     * @var Author 
     * 
     * @ORM\ManyToOne(targetEntity=&#34;Author&#34;, inversedBy=&#34;posts&#34;) 
     * @ORM\JoinColumn(name=&#34;author_id&#34;, referencedColumnName=&#34;id&#34;, nullable=false) 
     * @Assert\NotBlank
    */ 
    private $author; 


    /** 
     * Get id 
     * 
     * @return integer 
     */ 
    public function getId() 
    { 
        return $this-&amp;gt;id; 
    } 

    /** 
     * Set title 
     * 
     * @param string $title 
     * @return Post 
     */ 
    public function setTitle($title) 
    { 
        $this-&amp;gt;title = $title; 

        return $this; 
    } 

    /** 
     * Get title 
     * 
     * @return string 
     */ 
    public function getTitle() 
    { 
        return $this-&amp;gt;title; 
    } 

    /** 
     * Set content 
     * 
     * @param string $content 
     * @return Post 
     */ 
    public function setContent($content) 
    { 
        $this-&amp;gt;content = $content; 

        return $this; 
    } 

    /** 
     * Get content
     * 
     * @return string 
     */ 
    public function getContent() 
    { 
        return $this-&amp;gt;content; 
    } 

    /** 
     * Set author 
     * 
     * @param \Tableless\ModelBundle\Entity\Author $author 
     * @return Post 
     */ 
    public function setAuthor(\Tableless\ModelBundle\Entity\Author $author) 
    { 
        $this-&amp;gt;author = $author; 

        return $this; 
    } 

    /** 
     * Get author 
     * 
     * @return \Tableless\ModelBundle\Entity\Author 
     */ 
    public function getAuthor() 
    { 
        return $this-&amp;gt;author; 
    } 
} 
&lt;/pre&gt;

&lt;p&gt;Agora vamos atualizar o banco de dados para gerar o relacionamento, para isso apague todo o conteúdo das tabelas do banco de dados, caso não o faça, ocorrerá erro,&lt;/p&gt;

&lt;p&gt;Após apagar o conteúdo do banco, rode o comando no console:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:schema:update --force
&lt;/pre&gt;

&lt;h2 id=&#34;corrigindo-os-formulários&#34;&gt;Corrigindo os formulários&lt;/h2&gt;

&lt;p&gt;Entre na classe PostType, caminho: src/Tableless/ModelBundle/Form/PostType, e acrescente a linha abaixo, no método buildForm:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;-&amp;gt;add(&#39;author&#39;)
&lt;/pre&gt;

&lt;p&gt;Também vamos apagar as linhas:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;-&amp;gt;add(&#39;createdAt&#39;) 
 -&amp;gt;add(&#39;updatedAt&#39;) 
&lt;/pre&gt;

&lt;p&gt;Pois não precisamos inserir as datas, em que o post foi criado, ou alterado, isso acontecerá automaticamente!&lt;/p&gt;

&lt;p&gt;Depois das modificações, o método formBuilder ficará como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/** 
     * @param FormBuilderInterface $builder 
     * @param array $options 
     */ 
    public function buildForm(FormBuilderInterface $builder, array $options) 
    { 
        $builder 
            -&amp;gt;add(&#39;title&#39;) 
            -&amp;gt;add(&#39;content&#39;) 
            -&amp;gt;add(&#39;author&#39;) 
        ; 
    }
&lt;/pre&gt;

&lt;p&gt;Tudo configurado para que possamos criar nossos posts.&lt;/p&gt;

&lt;p&gt;Para verificarmos se está tudo correto, precisamos criar primeiramente um autor, depois criamos um post, onde teremos que selecionar um autor, para o mesmo.&lt;/p&gt;

&lt;p&gt;Veja abaixo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/03/04.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/03/04.png&#34; alt=&#34;autor&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47469&#34; srcset=&#34;uploads/2015/03/04.png 750w, uploads/2015/03/04-259x139.png 259w, uploads/2015/03/04-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lembrando que a url de autor é:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/author/&#34;&gt;http://127.0.0.1:8000/author/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;e a url de post é:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/post/&#34;&gt;http://127.0.0.1:8000/post/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Vamos terminar este tutorial, pois seu conteúdo está muito extenso, no próximo, vamos fazer as configurações necessárias em nossa simples aplicação, e vamos criar um index, para mostrar nossos posts, que configuraremos com o Bootstrap, e com o template engine twig. O projeto &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;GitHub do projeto&#34; target=&#34;_blank&#34;&gt;encontra-se no GitHub&lt;/a&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 03</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-03/</link>
      <pubDate>Wed, 18 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-03/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2-parte-02/&#34; title=&#34;Iniciando com Symfony - parte 2&#34; target=&#34;_blank&#34;&gt;Dando continuidade ao tutorial anterior&lt;/a&gt;, vamos continuar usando o componente console do Symfony, agora criaremos uma entidade, para acessar o banco de dados, usando o Doctrine ORM.&lt;/p&gt;

&lt;h2 id=&#34;banco-de-dados-com-doctrine-orm&#34;&gt;Banco de dados com Doctrine ORM&lt;/h2&gt;

&lt;p&gt;Quando falamos de banco de dados em projetos com Symfony, estamos falando de Doctrine ORM (Object Relational Mapper), onde criamos uma camada de persistência entre a aplicação e um banco de dados, que mapeia nossas tabelas com entidades, para que possamos acessar o banco.&lt;/p&gt;

&lt;p&gt;Não vou me aprofundar sobre Doctrine, porém, o que você precisa saber é que o Doctrine é um projeto espetacular e grandioso, muito usado pela comunidade, para projetos robustos.&lt;/p&gt;

&lt;h2 id=&#34;iniciando-com-doctrine-orm&#34;&gt;Iniciando com Doctrine ORM&lt;/h2&gt;

&lt;p&gt;O Doctrine já vem instalado e configurado no Symfony. Lembrando que você pode instalá-lo &lt;a href=&#34;https://packagist.org/packages/doctrine/orm&#34; title=&#34;Doctrine ORM&#34; target=&#34;_blank&#34;&gt;separadamente via Composer&lt;/a&gt;. &lt;a href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; title=&#34;Instalação do Symfony&#34; target=&#34;_blank&#34;&gt;No primeiro post que escrevi&lt;/a&gt; sobre a instalação do Symfony, nós configuramos as opções de banco de dados, o host, usuário e senha. Vale lembrar que são de configuração pessoais, configuradas em sua máquina.&lt;/p&gt;

&lt;p&gt;No meu caso, configurei de acordo com minhas configurações do MySQL. Também demos um nome para o banco de dados que vamos utilizar agora e que foi configurado com o nome “symfony”. Porém este não está criado, vamos criá-lo neste momento usando o componente console do Symfony em conjunto com o Doctrine.&lt;/p&gt;

&lt;p&gt;Vamos digitar no terminal para criar nosso banco:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:database:create
&lt;/pre&gt;

&lt;p&gt;E obteremos a resposta: Banco de dados criado para a conexão, com o nome &amp;#8216;symfony&amp;#8217;.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Created database for connection named &#39;symfony&#39;
&lt;/pre&gt;

&lt;h2 id=&#34;gerando-entidades&#34;&gt;Gerando Entidades&lt;/h2&gt;

&lt;p&gt;Agora que nosso banco foi gerado, vamos iniciar criando uma entidade. No Doctrine são objetos leves que contêm propriedades persistentes, que são salvos e recuperados do banco de dados por recursos de mapeamento de dados.&lt;/p&gt;

&lt;p&gt;Para gerarmos uma entidade vamos digitar no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:entity
&lt;/pre&gt;

&lt;p&gt;Neste momento o console nos dá a dica do que devemos fazer:&lt;/p&gt;

&lt;p&gt;&amp;#8220;Em primeiro lugar, você precisa dar o nome para a entidade que pretende gerar.&lt;/p&gt;

&lt;p&gt;Você deve usar a notação de atalho como AcmeBlogBundle:Post.&amp;#8221;&lt;/p&gt;

&lt;p&gt;Em nosso caso vamos digitar &amp;#8220;TablelessModelBundle:Post&amp;#8221;, para criar a entidade Post no bundle TablelessModelBundle.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ TablelessModelBundle:Post
&lt;/pre&gt;

&lt;p&gt;Feito isso, o console nos pergunda: Qual o formato que vamos usar para obter as informações de mapeamento? Por padrão ele nos indica annotation, vamos deixar como está e damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Configuration format (yml, xml, php, or annotation) [annotation]:
&lt;/pre&gt;

&lt;p&gt;As annotations são usadas pelo Doctrine para mapear as entidades, e obter informações por meio delas.&lt;/p&gt;

&lt;p&gt;Após darmos o enter, o console nos indica a inserir novos campos, (Obs: automaticamente, já foi gerado o &amp;#8220;id&amp;#8221; como primary key), e nos pergunta qual o nome do novo campo que vamos criar:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields):
&lt;/pre&gt;

&lt;p&gt;Você pode interromper, apenas dando um enter, em nosso caso vamos continuar, digitando o nosso primeiro campo que será &amp;#8220;title&amp;#8221;, o titulo de nosso post, damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields):title
&lt;/pre&gt;

&lt;p&gt;Nos pergunta qual o tipo, que vamos usar nesse campo, e ele nos indica “string”, vamos deixar como está, apenas damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field type [string]:
&lt;/pre&gt;

&lt;p&gt;A próxima pergunta é: Qual o comprimento desse campo? E por padrão nos indica &amp;#8220;255&amp;#8221;, você pode deixar assim, em nosso caso vamos digitar &amp;#8220;150&amp;#8221;, como é um título, para esse projeto não vejo necessidade de mais, damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field length [255]:150
&lt;/pre&gt;

&lt;p&gt;Criamos nosso primeiro campo na entidade, como é um post, vamos precisar além do titulo, um conteúdo, quando o post foi criado, e quando foi atualizado, então vamos criar nosso próximo campo, digitamos &amp;#8220;content&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields): content
&lt;/pre&gt;

&lt;p&gt;O tipo deste campo será um texto, digitamos &amp;#8220;text&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field type [string]:text
&lt;/pre&gt;

&lt;p&gt;Automaticamente, o console não nos pede o tamanho, pois é um campo do tipo text. Vamos para o nosso próximo campo, por convenção digitamos createdAt.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields): createdAt
&lt;/pre&gt;

&lt;p&gt;O tipo será uma data, então digitamos &amp;#8220;datetime&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field type [string]: datetime
&lt;/pre&gt;

&lt;p&gt;Vamos para o próximo campo. Nosso post, pode ser atualizado, e para sabermos qual foi a data de atualização vamos criar um campo para isso, digitamos &amp;#8220;updatedAt&amp;#8221;, também com o tipo &amp;#8220;datetime&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields): updatedAt
&lt;/pre&gt;

&lt;p&gt;Tipo&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Field type [string]: datetime
&lt;/pre&gt;

&lt;p&gt;Como vamos criar um simples blog, e não vamos fazer nada complexo, deixaremos somente estes campos, você pode criar mais campos como texto de introdução, etc, nesse momento vamos deixar assim, e quando o console nos perguntar novamente sobre um novo campo, não vamos digitar nada, apena vamos dar um enter, para entrarmos no processo de finalização.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ New field name (press  to stop adding fields):
&lt;/pre&gt;

&lt;p&gt;Após o enter, ele nos pergunta se queremos criar uma classe de repositório vazia para a nossa entidade Post, e por padrão, nos indica [não], no momento não vamos usar repositórios, abordaremos isso mais pra frente, novamente damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you want to generate an empty repository class [no]?
&lt;/pre&gt;

&lt;p&gt;Nesse momento o console nos pergunta, se confirmamos a geração da nossa entidade, por padrão ele nos indica [Sim], como queremos, damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you confirm generation [yes]? 
&lt;/pre&gt;

&lt;p&gt;Pronto, nossa primeira entidade está criada!&lt;/p&gt;

&lt;p&gt;Ao entrarmos em nosso projeto, notaremos que uma pasta &amp;#8220;Entity&amp;#8221; foi criada, e nela teremos nossa entidade &amp;#8220;Post&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/011.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/011.png&#34; alt=&#34;Criando entidades no symfony&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-46965&#34; srcset=&#34;uploads/2015/02/011.png 750w, uploads/2015/02/011-259x139.png 259w, uploads/2015/02/011-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nossa entidade Post criada:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\ModelBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * Post
 *
 * @ORM\Table()
 * @ORM\Entity
 */
class Post
{
    /**
     * @var integer
     *
     * @ORM\Column(name=&#34;id&#34;, type=&#34;integer&#34;)
     * @ORM\Id
     * @ORM\GeneratedValue(strategy=&#34;AUTO&#34;)
     */
    private $id;

    /**
     * @var string
     *
     * @ORM\Column(name=&#34;title&#34;, type=&#34;string&#34;, length=255)
     */
    private $title;

    /**
     * @var string
     *
     * @ORM\Column(name=&#34;content&#34;, type=&#34;text&#34;)
     */
    private $content;

    /**
     * @var \DateTime
     *
     * @ORM\Column(name=&#34;createdAt&#34;, type=&#34;datetime&#34;)
     */
    private $createdAt;

    /**
     * @var \DateTime
     *
     * @ORM\Column(name=&#34;updatedAt&#34;, type=&#34;datetime&#34;)
     */
    private $updatedAt;


    /**
     * Get id
     *
     * @return integer 
     */
    public function getId()
    {
        return $this-&amp;gt;id;
    }

    /**
     * Set title
     *
     * @param string $title
     * @return Post
     */
    public function setTitle($title)
    {
        $this-&amp;gt;title = $title;

        return $this;
    }

    /**
     * Get title
     *
     * @return string 
     */
    public function getTitle()
    {
        return $this-&amp;gt;title;
    }

    /**
     * Set content
     *
     * @param string $content
     * @return Post
     */
    public function setContent($content)
    {
        $this-&amp;gt;content = $content;

        return $this;
    }

    /**
     * Get content
     *
     * @return string 
     */
    public function getContent()
    {
        return $this-&amp;gt;content;
    }

    /**
     * Set createdAt
     *
     * @param \DateTime $createdAt
     * @return Post
     */
    public function setCreatedAt($createdAt)
    {
        $this-&amp;gt;createdAt = $createdAt;

        return $this;
    }

    /**
     * Get createdAt
     *
     * @return \DateTime 
     */
    public function getCreatedAt()
    {
        return $this-&amp;gt;createdAt;
    }

    /**
     * Set updatedAt
     *
     * @param \DateTime $updatedAt
     * @return Post
     */
    public function setUpdatedAt($updatedAt)
    {
        $this-&amp;gt;updatedAt = $updatedAt;

        return $this;
    }

    /**
     * Get updatedAt
     *
     * @return \DateTime 
     */
    public function getUpdatedAt()
    {
        return $this-&amp;gt;updatedAt;
    }
}

&lt;/pre&gt;

&lt;h2 id=&#34;configurando-a-entidade&#34;&gt;Configurando a entidade&lt;/h2&gt;

&lt;p&gt;Vamos fazer algumas modificações.&lt;/p&gt;

&lt;p&gt;Daremos o nome &amp;#8220;post&amp;#8221; pra nossa tabela quando ela for criada, para isso temos que configurar via annotation para que o Doctrine saiba. Para fazer isso vamos adicionar na linha 10 a annotation correspondente:&lt;/p&gt;

&lt;p&gt;Obs: As annotations do Doctrine, começam com &amp;#8220;@ORM&amp;amp;#8221;, o restante é documentação…&lt;/p&gt;

&lt;p&gt;Verifique a alteração na linha 10, vamos inserir: (name=”post”).&lt;/p&gt;

&lt;p&gt;Caso não façamos essa alteração, não ocorrerá erro, porém por padrão o Doctrine criará uma tabela com o nome da classe &amp;#8220;Post&amp;#8221;, com a letra “P” maiúscula.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
 * Post
 *
 * @ORM\Table(name=&#34;post&#34;)
 * @ORM\Entity
 */
class Post
{
...
&lt;/pre&gt;

&lt;p&gt;Mudaremos também o nome da coluna &amp;#8220;createdAt&amp;#8221; para &amp;#8220;creadet_at&amp;#8221; na linha 41 de nossa entidade, no caso do código abaixo, a linha 4.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
 * @var \DateTime
 *
 * @ORM\Column(name=&#34;created_at&#34;, type=&#34;datetime&#34;)
 */
 private $createdAt;
...
&lt;/pre&gt;

&lt;p&gt;E a linha 48, de &amp;#8220;updatedAt&amp;#8221; para &amp;#8220;updated_at&amp;#8221;, no código abaixo a linha 4.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
 * @var \DateTime
 *
 * @ORM\Column(name=&#34;updated_at&#34;, type=&#34;datetime&#34;)
 */
 private $updatedAt;
...
&lt;/pre&gt;

&lt;p&gt;Precisamos que, ao criarmos nosso post, seja inserido automaticamente a data de criação, e a data de atualização, para isso vamos criar um método construtor em nossa entidade, veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
 * Construct
 */
 public function __construct()
 {
    $this-&amp;gt;createdAt = new \DateTime();
    $this-&amp;gt;updatedAt = new \DateTime();
 }
&lt;/pre&gt;

&lt;h2 id=&#34;validando&#34;&gt;Validando&lt;/h2&gt;

&lt;p&gt;Agora vamos fazer uma validação, para que nossos campos &amp;#8220;title&amp;#8221; e &amp;#8220;content&amp;#8221;, não aceitem conteúdos nulos, em brancos. Para isso chamaremos a classe Constraints do Symfony, dando um &amp;#8220;use&amp;#8221; nesse objeto em nossa entidade, por padrão daremos o apelido de Assert para Constraints. Veja na linha 06:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

namespace Tableless\ModelBundle\Entity;

use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Validator\Constraints as Assert;

/**
 * Post
 *
 * @ORM\Table(name=&#34;post&#34;)
 * @ORM\Entity
 */
class Post
{
&lt;/pre&gt;

&lt;p&gt;Para que a validação seja feita colocaremos a annotation &amp;#8220;@Assert\NotBlank&amp;#8221; nos campos que queremos, veja na linha 5 e na linha 13:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;/**
 * @var string
 *
 * @ORM\Column(name=&#34;title&#34;, type=&#34;string&#34;, length=255)
 * @Assert\NotBlank
 */
 private $title;

 /**
 * @var string
 *
 * @ORM\Column(name=&#34;content&#34;, type=&#34;text&#34;)
 * @Assert\NotBlank
 */
 private $content;
&lt;/pre&gt;

&lt;p&gt;Pronto! Nossa entidade Post está criada e configurada, porém faremos modificações no fututo para que ela se adeque melhor em nosso projeto.&lt;/p&gt;

&lt;h2 id=&#34;gerando-crud-com-doctrine-orm&#34;&gt;Gerando CRUD com Doctrine ORM&lt;/h2&gt;

&lt;p&gt;Agora que nossa entidade está concluída, vamos fazer um CRUD, para que possamos inserir, atualizar, visualizar e deletar nossos posts.&lt;/p&gt;

&lt;p&gt;Porém antes, precisamos criar nossas tabelas, para fazer isso, vamos voltar para o terminal e digitar:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console doctrine:schema:create
&lt;/pre&gt;

&lt;p&gt;Receberemos a resposta do console:&lt;/p&gt;

&lt;p&gt;&amp;#8220;ATENÇÃO: Esta operação não deve ser executado em um ambiente de produção.&lt;/p&gt;

&lt;p&gt;Criação de esquema de banco de dados&amp;#8230;&lt;/p&gt;

&lt;p&gt;Esquema de banco de dados criado com sucesso!&amp;#8221;&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;ATTENTION: This operation should not be executed in a production environment.

Creating database schema...
Database schema created successfully!
&lt;/pre&gt;

&lt;p&gt;Vamos ao CRUD! Para fazer um CRUD com Doctrine, é extremamente fácil, vamos digitar no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:doctrine:crud
&lt;/pre&gt;

&lt;p&gt;Ao digitarmos o comando acima e darmos o enter, entramos no assistente para criarmos nosso CRUD, e ele nos pede para que informemos a entidade que queremos criar o CRUD, então digitamos: TablelessModelBundle:Post&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ The Entity shortcut name: TablelessModelBundle:Post
&lt;/pre&gt;

&lt;p&gt;Logo após, nos pergunta se queremos gerar as ações de &amp;#8220;gravação&amp;#8221;, ele nos indica [não], porém nós queremos, então digitamos &amp;#8220;yes&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you want to generate the &#34;write&#34; actions [no]? yes
&lt;/pre&gt;

&lt;p&gt;Nos pergunta como vamos configurar nosso CRUD, e nos indica [annotation], só damos um enter para prosseguir.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Configuration format (yml, xml, php, or annotation) [annotation]:
&lt;/pre&gt;

&lt;p&gt;Após o enter, nos pergunta como vai ser a rota que vamos usar, e nos indica [/post], vamos usar essa mesma, damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Routes prefix [/post]:
&lt;/pre&gt;

&lt;p&gt;Nos pergunta se confirmamos a geração, e nos indica [yes], sim queremos, damos enter para prosseguir.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you confirm generation [yes]?
&lt;/pre&gt;

&lt;p&gt;Pronto! CRUD criado, simples não!&lt;/p&gt;

&lt;p&gt;Nesse momento vamos fazer uma configuração somente para vermos nossa aplicação rodando, porém não vamos usar essa rota, é somente para vermos se está tudo certo. Entre no arquivo app/config/route.yml e vamos adicionar a rota desse CRUD:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;tableless_model:
    resource: &#34;@TablelessModelBundle/Controller/&#34;
    type:     annotation
    prefix:   /
&lt;/pre&gt;

&lt;p&gt;Agora vamos rodar nosso aplicação pelo console:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console server:run
&lt;/pre&gt;

&lt;p&gt;E vamos entrar no navegador com a url:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/post/&#34;&gt;http://127.0.0.1:8000/post/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para inserirmos um novo post, é só dar um clique, em &amp;#8220;Create a new entry&amp;#8221;.&lt;/p&gt;

&lt;p&gt;Eu inseri um post, com um texto “Lorem Ipsum”, apenas para reprodução das páginas, veja o resultado abaixo:&lt;/p&gt;

&lt;p&gt;Lista de posts = url: &lt;a href=&#34;http://127.0.0.1:8000/post/&#34;&gt;http://127.0.0.1:8000/post/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Novo post = url: &lt;a href=&#34;http://127.0.0.1:8000/post/new&#34;&gt;http://127.0.0.1:8000/post/new&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ver o post = url: &lt;a href=&#34;http://127.0.0.1:8000/post/1&#34;&gt;http://127.0.0.1:8000/post/1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Editar post = url: &lt;a href=&#34;http://127.0.0.1:8000/post/1/edit&#34;&gt;http://127.0.0.1:8000/post/1/edit&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/031.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/031.png&#34; alt=&#34;Páginas criadas&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47111&#34; srcset=&#34;uploads/2015/02/031.png 750w, uploads/2015/02/031-259x139.png 259w, uploads/2015/02/031-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ao navegar pelas páginas, verificará, que não tem estilização, porém está funcional, vamos fazer isso mais tarde, poderá verificar também seu banco de dados, e verá que foi criado um banco de dados com o nome &amp;#8220;symfony&amp;#8221;, nesse banco, encontrará a tabela &amp;#8220;post&amp;#8221; que criamos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/021.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/021.png&#34; alt=&#34;Table post no banco de dados&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-47098&#34; srcset=&#34;uploads/2015/02/021.png 750w, uploads/2015/02/021-259x139.png 259w, uploads/2015/02/021-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;concluindo&#34;&gt;Concluindo&lt;/h2&gt;

&lt;p&gt;Uma observação importante, estamos criando nossos códigos por linha de comando usando o console, é uma forma de mostrar a agilidade e produtividade, que o Symfony e o Doctrine nos permite, porém para entender o mínimo, o funcionamento do Symfony, ou de qualquer outro framework PHP, é de extrema importância saber PHP Orientado a Objetos, padrão MVC e outros Design Patterns. Fazer a reprodução codificando, sem usar o console, é uma boa forma de aprender e entender o funcionamento do Symfony.&lt;/p&gt;

&lt;p&gt;Este projeto &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;GitHub do projeto&#34; target=&#34;_blank&#34;&gt;encontra-se no gitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2 – Parte 02</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-02/</link>
      <pubDate>Mon, 09 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2-parte-02/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/symfony-logo-tableless.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/symfony-logo-tableless.png&#34; alt=&#34;Symfony logo&#34; width=&#34;720&#34; height=&#34;450&#34; class=&#34;alignnone size-full wp-image-46879&#34; srcset=&#34;uploads/2015/02/symfony-logo-tableless.png 720w, uploads/2015/02/symfony-logo-tableless-222x139.png 222w, uploads/2015/02/symfony-logo-tableless-400x250.png 400w&#34; sizes=&#34;(max-width: 720px) 100vw, 720px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Depois de já instalado o Symfony 2, como postado no &lt;a title=&#34;Iniciando com Symfony2&#34; href=&#34;http://tableless.com.br/iniciando-com-symfony-2/&#34; target=&#34;_blank&#34;&gt;artigo anterior que escrevi&lt;/a&gt;, vamos avançar nosso processo criando um simples blog.&lt;/p&gt;

&lt;p&gt;É claro que o Symfony é para projetos maiores, mas para efeito de didática, achei um bom começo, espero que gostem.&lt;/p&gt;

&lt;h2 id=&#34;bundle-o-coração-do-symfony&#34;&gt;Bundle o coração do symfony&lt;/h2&gt;

&lt;p&gt;O Symfony trabalha com bundle (pacote), que é um conjunto de códigos que pode ser reutilizado em outros projetos. Simplificando: são componentes prontos, que facilitam nossa vida na hora de desenvolver. Podemos criar um bundle do zero, como vamos fazer aqui, ou configurar um já pronto.&lt;/p&gt;

&lt;p&gt;Antes de criarmos de nosso primeiro bundle, vamos fazer uma pequena modificação no projeto. Não vamos precisar do bundle AppBundle, só usamos para a introdução.&lt;/p&gt;

&lt;p&gt;Exclua a pasta AppBundle como mostrado na imagem, caminho src/AppBundle.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/01.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/01.png&#34; alt=&#34;Imagem pastas app/AppBundle&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-46808&#34; srcset=&#34;uploads/2015/02/01.png 750w, uploads/2015/02/01-259x139.png 259w, uploads/2015/02/01-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vamos apagar o registro desse bundle que acabamos de excluir, pois todos os bundles são registrados no AppKernel para que possamos usá-los.&lt;/p&gt;

&lt;p&gt;Entre no arquivo app/AppKernel.php e apague a linha &amp;#8220;new AppBundle\AppBundle()&amp;#8221;, no meu caso a linha 19.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
//apague    new AppBundle\AppBundle(),    caso contrário acarretará em erro...
        );

        if (in_array($this-&amp;gt;getEnvironment(), array(&#39;dev&#39;, &#39;test&#39;))) {
            $bundles[] = new Symfony\Bundle\DebugBundle\DebugBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&amp;gt;load(__DIR__.&#39;/config/config_&#39;.$this-&amp;gt;getEnvironment().&#39;.yml&#39;);
    }
}

&lt;/pre&gt;

&lt;p&gt;Também devemos excluir a rota desse bundle.&lt;/p&gt;

&lt;p&gt;Entre no arquivo app/config/routing.yml e apague as linhas abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-yml&#34;&gt;app:
    resource: @AppBundle/Controller/
    type:     annotation
&lt;/pre&gt;

&lt;p&gt;Cuidado caso tenha feito alguma modificação desde a instalação, no meu caso, estou dando continuidade a partir da instalação, e apagando as linhas acima, meu arquivo routing.yml, ficou vazio.&lt;/p&gt;

&lt;h2 id=&#34;criando-um-bundle-utilizando-o-componente-console-do-symfony&#34;&gt;Criando um bundle utilizando o componente console do Symfony&lt;/h2&gt;

&lt;p&gt;Vamos criar nosso bundle! Podemos fazer isso codificando, porém o Symfony 2 nos traz um ferramenta poderosa e fantástica, o componente cosole, que já vem instalado em nossa aplicação, ou podemos instalá-lo separadamente pelo &lt;a href=&#34;https://packagist.org/packages/symfony/console&#34; title=&#34;Symfony Console&#34; target=&#34;_blank&#34;&gt;packagist&lt;/a&gt;, via composer.&lt;/p&gt;

&lt;p&gt;Vamos lá.&lt;/p&gt;

&lt;p&gt;Entre na pasta do projeto pelo terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ cd symfony
&lt;/pre&gt;

&lt;p&gt;Primeiramente, para vermos o que o console do symfony é capaz, vamos digitar no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console
&lt;/pre&gt;

&lt;p&gt;Com este comando seremos apresentados à uma lista de comandos que podemos efetuar em nossa aplicação pelo componente console do Symfony. Se instalarmos alguns componentes adicionais do symfony, essa lista pode aumentar, mas não é nosso caso agora, vamos dar continuidade!&lt;/p&gt;

&lt;p&gt;Para criarmos nosso bunble, digitamos no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:bundle
&lt;/pre&gt;

&lt;p&gt;Após darmos o enter aparecerá a seguinte tela, que é um assistente do Symfony para nos ajudar na geração do bundle:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/02.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/02.png&#34; alt=&#34;Criando bundle pelo symfony console&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-46838&#34; srcset=&#34;uploads/2015/02/02.png 750w, uploads/2015/02/02-259x139.png 259w, uploads/2015/02/02-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O symfony nos pede para digitarmos nossa namespace, que é o caminho completo do nosso bundle, primeiramente, temos que dar um nome para nosso vendor, caso não entenda, sugiro a &lt;a href=&#34;http://www.php-fig.org/psr/psr-4/&#34; title=&#34;PSR-04&#34; target=&#34;_blank&#34;&gt;leitura da PSR-4&lt;/a&gt;, em meus projetos particulares, coloco a sigla do meu nome como vendor &amp;#8220;CJSN&amp;#8221;, porém você pode colocar o nome do seu projeto, do seu cliente, etc&amp;#8230; Aqui vamos colocar Tableless, em seguida o nome de nosso bundle.&lt;/p&gt;

&lt;p&gt;Então digitamos&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Bundle namespace: Tableless/CoreBundle
&lt;/pre&gt;

&lt;p&gt;Ao darmos enter, o Symfony nos pergunta como esse bundle vai ser reconhecido em nosso projeto e nos sugere um nome: TablelessCoreBundle&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Bundle name [TablelessCoreBundle]:
&lt;/pre&gt;

&lt;p&gt;Você pode simplificar digitando apenas CoreBundle, em meu caso vou deixar como está, gosto assim em meus projetos, deixando-os padrão.&lt;/p&gt;

&lt;p&gt;E damos enter.&lt;/p&gt;

&lt;p&gt;Agora a pergunta é: Qual o caminho que queremos instalar nosso bundle?&lt;/p&gt;

&lt;p&gt;Por padrão vamos deixá-lo na pasta src/, somente damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Target directory [/home/candidosouza/tableless/symfony/src]:
&lt;/pre&gt;

&lt;p&gt;Como vamos fazer a configuração de nosso bundle?&lt;/p&gt;

&lt;p&gt;Digitamos annotation e enter:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Configuration format (yml, xml, php, or annotation): annotation
&lt;/pre&gt;

&lt;p&gt;A próxima pergunta é: Se queremos que ele gere toda a estrutura de diretórios de um bundle? Não, apenas damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you want to generate the whole directory structure [no]?
&lt;/pre&gt;

&lt;p&gt;Nos pergunta sobre a confirmação de geração do bundle, damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Do you confirm generation [yes]? 
&lt;/pre&gt;

&lt;p&gt;Desejamos adicionar as configurações no AppKernel? Sim queremos, somente digitamos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Confirm automatic update of your Kernel [yes]?
&lt;/pre&gt;

&lt;p&gt;E pergunta se queremos inserir rotas para esse bundle, digitamos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Confirm automatic update of the Routing [yes]? 
&lt;/pre&gt;

&lt;p&gt;E pronto, nosso bundle está criado, veja as imagems abaixo para comparação.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/03.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/03.png&#34; alt=&#34;Finalizando criação de bundle&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-46843&#34; srcset=&#34;uploads/2015/02/03.png 750w, uploads/2015/02/03-259x139.png 259w, uploads/2015/02/03-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/03-1.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/03-1.png&#34; alt=&#34;Imagem finalizada CoreBundle&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-46875&#34; srcset=&#34;uploads/2015/02/03-1.png 750w, uploads/2015/02/03-1-259x139.png 259w, uploads/2015/02/03-1-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para vermos se está tudo certo, podemos entrar em nosso navegador e digitar a rota exemplo criada pelo Symfony: @Route(&amp;#8220;/hello/{name}&amp;#8221;), então digitamos a url no navegador: &lt;a href=&#34;http://127.0.0.1:8000/hello/Tableless&#34;&gt;http://127.0.0.1:8000/hello/Tableless&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lembrando que o servidor deve estar iniciado, você pode ver isso no tutorial anterior. Aparecerá a mensagem &amp;#8220;Hello Tableless!&amp;#8221;, se você notar, verá que a debug toolbar, a barra de ferramentas do Symfony, não está aparecendo, mas não vamos nos preocupar com isso, pois não usaremos essa rota, ela é gerada apenas para exemplo.&lt;/p&gt;

&lt;p&gt;Após a crianção do nosso bundle, o CoreBundle, vamos repetir a operação, e criar um novo bundle, agora com o nome ModelBundle.&lt;/p&gt;

&lt;p&gt;Novamente digitamos&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console generate:bundle
&lt;/pre&gt;

&lt;p&gt;em seguida:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Tableless/ModelBundle
&lt;/pre&gt;

&lt;p&gt;E todo o processo anteriormente feito&amp;#8230;&lt;/p&gt;

&lt;p&gt;A primeira coisa a fazer depois de criarmos o ModelBundle, é excluir a rota gerada pelo Symfony, é claro que poderíamos ter feito isso na hora da criação, pelo terminal, quando ele nos faz a última pergunta: Confirmar atualização automática das Rotas[sim]?&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Confirm automatic update of the Routing [yes]? 
&lt;/pre&gt;

&lt;p&gt;Era só termos digitado &amp;#8220;no&amp;#8221;, mas para efeito de didática, e para não ficarmos duplicando código nesse tutorial, preferi deixar assim.&lt;/p&gt;

&lt;p&gt;Vamos entrar no arquivo app/config/route.yml e vamos apagar a rota gerada para esse bundle.&lt;/p&gt;

&lt;p&gt;Apague as linhas abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;tableless_model:
    resource: &#34;@TablelessModelBundle/Controller/&#34;
    type:     annotation
    prefix:   /
&lt;/pre&gt;

&lt;p&gt;Deixando somente a rota do CoreBundle criada anteriormente.&lt;/p&gt;

&lt;p&gt;Vamos excluir também, as pastas Controller, e views, pois não vamos usar esses arquivos nesse bundle.&lt;/p&gt;

&lt;p&gt;Caminhos das pastas a serem excluidas:&lt;/p&gt;

&lt;p&gt;src/Tableless/ModelBundle/Controller&lt;/p&gt;

&lt;p&gt;src/Tableless/ModelBundle/Resources/views&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/02/04.png&#34;&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/04.png&#34; alt=&#34;Excluindo pastas&#34; width=&#34;750&#34; height=&#34;403&#34; class=&#34;alignnone size-full wp-image-46859&#34; srcset=&#34;uploads/2015/02/04.png 750w, uploads/2015/02/04-259x139.png 259w, uploads/2015/02/04-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;concluindo&#34;&gt;Concluindo&lt;/h2&gt;

&lt;p&gt;Pronto, nosso simples projeto, está configurado e pronto para darmos inicio aos demais processos, neste momento em que se encontra o mesmo, vou comitar, e subir o projeto para o &lt;a href=&#34;https://github.com/candidosouza/tableless&#34; title=&#34;GitHub do projeto&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;. No próximo tutorial veremos como criar entidades com o Doctrine ORM em conjunto com o Symfony, para inserirmos nossos posts no banco de dados.&lt;/p&gt;

&lt;p&gt;Para finalizarmos, recomendo novamente a &lt;a href=&#34;http://symfony.com/doc/current/index.html&#34; title=&#34;Documentação do Symfony&#34; target=&#34;_blank&#34;&gt;documentação do Symfony&lt;/a&gt;, caso queiram fazer testes, estudar, se aprofundar mais no assunto!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com Symfony 2</title>
      <link>https://tableless.github.io/hugo-public/iniciando-com-symfony-2/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/iniciando-com-symfony-2/</guid>
      <description>

&lt;p&gt;O symfony é um framework fullstack de aplicações web para as necessidades de alto desempenho, é um conjunto de componentes PHP, para grandes e avançados projetos, porém podemos instalar seus componentes separadamente em casos de projetos menores. É muito respeitado pela comunidade, não é apenas um Framework popular, mas também é uma das melhores plataformas para construir projetos Open-Source. Muitos projetos PHP estão incorporando alguns dos componentes ou estão usando o framework full-stack, projetos como &lt;a title=&#34;DrupAl&#34; href=&#34;http://symfony.com/projects/drupal&#34; target=&#34;_blank&#34;&gt;Drupal&lt;/a&gt;, &lt;a title=&#34;Laravel&#34; href=&#34;http://symfony.com/projects/laravel&#34; target=&#34;_blank&#34;&gt;Laravel&lt;/a&gt;, entre outros, &lt;a title=&#34;Projetos com Symfony&#34; href=&#34;http://symfony.com/projects&#34; target=&#34;_blank&#34;&gt;veja a lista&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;iniciando&#34;&gt;Iniciando&lt;/h2&gt;

&lt;p&gt;Vou abordar nesse simples tutorial a instalação do Symfony, para que, em tutoriais futuros possamos dar continuidade a dicas mais avançadas.&lt;/p&gt;

&lt;p&gt;Primeiramente vamos criar uma pasta, para que nosso projeto se mantenha organizado, digitando o comando no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ mkdir tableless&lt;/pre&gt;

&lt;p&gt;Após a criação da pasta, vamos entrar na mesma, com o comando:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ cd tableless&lt;/pre&gt;

&lt;h2 id=&#34;instalação&#34;&gt;Instalação&lt;/h2&gt;

&lt;p&gt;Vamos instalar o Symfony via composer, caso não o conheça, ou tenha dúvidas, leia este post (&lt;a title=&#34;Composer para iniciantes&#34; href=&#34;//tableless.com.br/composer-para-iniciantes/&#34; target=&#34;_blank&#34;&gt;Composer para iniciantes&lt;/a&gt;). Para fazermos o Download do Symfony entramos no &lt;a title=&#34;Symfony Download&#34; href=&#34;http://symfony.com/download&#34; target=&#34;_blank&#34;&gt;site&lt;/a&gt; e copiamos o comando, como na imagem abaixo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/01/01.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46532&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/01/01.png&#34; alt=&#34;Download do Symfony&#34; width=&#34;750&#34; height=&#34;403&#34; srcset=&#34;uploads/2015/01/01.png 750w, uploads/2015/01/01-259x139.png 259w, uploads/2015/01/01-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vamos trocar o final do código, onde está path/ vamos colocar symfony/ que será a pasta onde instalaremos o Symfony, o comando ficará assim:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ composer create-project symfony/framework-standard-edition symfony/&lt;/pre&gt;

&lt;p&gt;Ao darmos enter, a instalação irá começar como na imagem abaixo, isso poderá demorar alguns minutos, já que o composer irá baixar a distribuição padrão do Symfony, juntamente com todas as suas bibliotecas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/01/02.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46533&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/01/02.png&#34; alt=&#34;Instalação do symfony&#34; width=&#34;750&#34; height=&#34;403&#34; srcset=&#34;uploads/2015/01/02.png 750w, uploads/2015/01/02-259x139.png 259w, uploads/2015/01/02-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Ao baixar todos os componentes, a instalação do symfony vai nos fazer diversas perguntas.&lt;/p&gt;

&lt;p&gt;1º &amp;#8211; Gostaria de instalar Acme demo bundle? [y/N] digitamos &amp;#8220;N&amp;#8221; e damos enter.&lt;/p&gt;

&lt;p&gt;O Acme demo bundle é apenas uma demonstração de alguns recursos que podemos trabalhar, e nesse caso não vamos instalar!&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Would you like to install Acme demo bundle? [y/N]:N&lt;/pre&gt;

&lt;p&gt;2º &amp;#8211; O symfony nos pergunta qual o drive de banco de dados que vamos utilizar.&lt;/p&gt;

&lt;p&gt;Em nosso caso vamos usar o PDO, que hoje é &lt;a title=&#34;PHP PDO&#34; href=&#34;http://php.net/manual/pt_BR/book.pdo.php&#34; target=&#34;_blank&#34;&gt;basicamente um padrão do PHP&lt;/a&gt;, e o próprio symfony nos recomenda, damos apenas um enter para continuar.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ database_driver (pdo_mysql):&lt;/pre&gt;

&lt;p&gt;3º &amp;#8211; Nos pergunta qual o host do banco de dados, como estamos em localhost apenas damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ database_host (127.0.0.1):&lt;/pre&gt;

&lt;p&gt;4º &amp;#8211; Qual a porta que vamos usar, por defult vamos deixar como está, e damos um Enter&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ database_port (null)&lt;/pre&gt;

&lt;p&gt;5º &amp;#8211; Qual o nome do banco de dados vamos usar, nesse caso, vamos deixar como está, mas você pode utilizar o nome que quiser, e damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ database_name (symfony):&lt;/pre&gt;

&lt;p&gt;6º &amp;#8211; Qual o nome do nosso usuário do banco, no meu caso vou deixar como está, meu usuário é root, damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ database_user (root):&lt;/pre&gt;

&lt;p&gt;7º &amp;#8211; Qual é nossa senha, no meu caso é root, deixo assim em ambiente de desenvolvimento, digito root e dou enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ database_password (null): root&lt;/pre&gt;

&lt;p&gt;8º &amp;#8211; Nos pergunta sobre nossos dados de e-mail, vamos apenas dar um enter, pois não vamos usar agora.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ mailer_transport (smtp):&lt;/pre&gt;

&lt;p&gt;9º &amp;#8211; Qual o host de e-mail, apenas damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ mailer_host (127.0.0.1):&lt;/pre&gt;

&lt;p&gt;10º &amp;#8211; Nos pergunta sobre o usuário de e-mail, damos enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ mailer_user (null):&lt;/pre&gt;

&lt;p&gt;11º &amp;#8211; Nos pergunta sobre a senha, enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ mailer_password (null):&lt;/pre&gt;

&lt;p&gt;12º &amp;#8211; Sobre localidade, e digitamos pt_BR, e enter&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ locale (en): pt_BR&lt;/pre&gt;

&lt;p&gt;13º &amp;#8211; Nos pergunta sobre a chave secreta de nossa aplicação, vamos deixar como está, apenas damos um enter.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ secret (ThisTokenIsNotSoSecretChangeIt):&lt;/pre&gt;

&lt;p&gt;Segue a imagem para comparação, se tudo ocorreu bem, ficará assim:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/01/03.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46534&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/01/03.png&#34; alt=&#34;Instalando Symfony&#34; width=&#34;750&#34; height=&#34;403&#34; srcset=&#34;uploads/2015/01/03.png 750w, uploads/2015/01/03-259x139.png 259w, uploads/2015/01/03-400x215.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;rodando-a-aplicação&#34;&gt;Rodando a aplicação&lt;/h2&gt;

&lt;p&gt;Pronto, o Symfony está instalado!&lt;/p&gt;

&lt;p&gt;Para vê-lo rodando vamos iniciar nosso servidor.&lt;/p&gt;

&lt;p&gt;A partir do PHP 5.4, o próprio vem com um servidor web embutido (&lt;a title=&#34;Manual Servidor PHP&#34; href=&#34;http://php.net/manual/pt_BR/features.commandline.webserver.php&#34; target=&#34;_blank&#34;&gt;PHP&amp;#8217;s built-in Web Server&lt;/a&gt;). Ele pode ser usado para executar suas aplicações PHP localmente durante o desenvolvimento, para testar ou para demonstrações de aplicativos. Desta forma, você não tem que se preocupar em configurar um servidor full-featured web como o Apache ou Nginx.&lt;/p&gt;

&lt;p&gt;Para iniciarmos o servidor do php digitamos no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php -S 127.0.0.1:8080&lt;/pre&gt;

&lt;p&gt;ou&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php -S 127.0.0.1:8080 -t public_html/&lt;/pre&gt;

&lt;p&gt;para indicar que seu index.php está na pasta public_html.&lt;/p&gt;

&lt;p&gt;Mas em nosso caso, não vamos utilizar os comandos citados acima, como estamos usando o Symfony, entramos em nossa pasta, que está instalado o projeto:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ cd symfony&lt;/pre&gt;

&lt;p&gt;e digitamos:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ php app/console server:run&lt;/pre&gt;

&lt;p&gt;e teremos a resposta:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ Server running on http://127.0.0.1:800&lt;/pre&gt;

&lt;p&gt;Abrimos nosso navegador e digitamos a url: &lt;a href=&#34;http://127.0.0.1:8000/&#34;&gt;http://127.0.0.1:8000/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;E Pronto!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/01/04.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46535&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/01/04.png&#34; alt=&#34;Página do Symfony&#34; width=&#34;736&#34; height=&#34;403&#34; srcset=&#34;uploads/2015/01/04.png 736w, uploads/2015/01/04-254x139.png 254w, uploads/2015/01/04-400x219.png 400w&#34; sizes=&#34;(max-width: 736px) 100vw, 736px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Irá aparecer um erro na tela, por não termos configurado as nossas rotas no Controller, porém sabemos que nossa aplicação está rodando. O Symfony gera uma rota de teste automaticamente, e para vermos se está tudo certo sem erros, então digitamos em nosso navegador a url:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://127.0.0.1:8000/app/example&#34;&gt;http://127.0.0.1:8000/app/example&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Aparecerá uma página em branco escrita Homepage, junto com a barra de debug do Symfony (a debug toolbar) utilizada em desenvolvimento, que estará no rodapé!&lt;/p&gt;

&lt;p&gt;O Symfony está rodando com sucesso!&lt;/p&gt;

&lt;h2 id=&#34;olhando-rapidamente-para-a-debug-toolbar&#34;&gt;Olhando rapidamente para a debug toolbar&lt;/h2&gt;

&lt;p&gt;A debug toolbar é uma barra de ferramentas do Symfony, fantástica, que nos traz informações valiosas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/01/061.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46590&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/01/061.png&#34; alt=&#34;Debug toolbar Symfony2&#34; width=&#34;750&#34; height=&#34;83&#34; srcset=&#34;uploads/2015/01/061.png 750w, uploads/2015/01/061-265x29.png 265w, uploads/2015/01/061-400x44.png 400w&#34; sizes=&#34;(max-width: 750px) 100vw, 750px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1 &amp;#8211; No início temos o ícone do Symfony, que ao colocarmos o ponteiro do mouse em cima, a barra nos mostra a versão do Symfony juntamente com um link para a documentação.&lt;/p&gt;

&lt;p&gt;2 &amp;#8211; Informações sobre o PHP, como versão e extensões usadas, e ao clicarmos, nos retorna uma página com um phpinfo(), onde estão todas as configurações do PHP de nossa máquina.&lt;/p&gt;

&lt;p&gt;3 &amp;#8211; Informações a respeito da requisição principal de nossa aplicação, indicando, que estamos em ambiente de desenvolvimento e o token de requisição.&lt;/p&gt;

&lt;p&gt;4 &amp;#8211; Informações sobre o status code, o Controller e Action de nossa página, o nome da rota que estamos acessando e se temos ou não uma sessão.&lt;/p&gt;

&lt;p&gt;5 &amp;#8211; Requisições de AJAX.&lt;/p&gt;

&lt;p&gt;6 &amp;#8211; Tempo em que nossa página demorou pra carregar.&lt;/p&gt;

&lt;p&gt;7 &amp;#8211; Quantidade de memória que a aplicação utilizou.&lt;/p&gt;

&lt;p&gt;8 &amp;#8211; Informações, quantidade de formulários.&lt;/p&gt;

&lt;p&gt;9 &amp;#8211; Informação sobre autenticação, usuários anônimos, admins, etc&amp;#8230;&lt;/p&gt;

&lt;p&gt;10 &amp;#8211; Informações sobre consultas no banco de dados, tempos de queries, &amp;#8230;&lt;/p&gt;

&lt;h2 id=&#34;configurações-básicas&#34;&gt;Configurações básicas&lt;/h2&gt;

&lt;p&gt;Vamos deixar nosso projeto um pouco mais limpo, excluindo os arquivos de UPGRADEs.md, que não tem relevância em nossa aplicação nesse momento.&lt;/p&gt;

&lt;p&gt;Podemos excluir os arquios:&lt;/p&gt;

&lt;p&gt;UPGRADE.md&lt;/p&gt;

&lt;p&gt;UPGRADE-2.2.md&lt;/p&gt;

&lt;p&gt;UPGRADE-2.3.md&lt;/p&gt;

&lt;p&gt;UPGRADE-2.4.md&lt;/p&gt;

&lt;p&gt;Também vamos modificar o conteúdo do nosso arquivo README.md, lembrando que a linguagem usada nesse arquivo é Markdown, para ser lida pelo GitHub, &lt;a title=&#34;Noções básicas de Markdown&#34; href=&#34;https://help.github.com/articles/markdown-basics/&#34; target=&#34;_blank&#34;&gt;nesse link&lt;/a&gt; você encontra algumas noções básicas.&lt;/p&gt;

&lt;p&gt;Apague todo o conteúdo do arquivo, que pode ser feito por um simples editor de texto, como bloco de notas, pela IDE de sua preferência, ou até mesmo pelo vim no terminal!&lt;/p&gt;

&lt;p&gt;E adicionamos o conteúdo abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-markdown&#34;&gt;Iniciando com Symfony 2
=======================

http://tableless.com.br/
-----------------------

**Tutorial do Portal Tableless**

&amp;gt;1º -  *Iniciando com Symfony 2*
&lt;/pre&gt;

&lt;p&gt;Podemos modificar o conteúdo do arquivo composer.json somente as linhas 2 e 5.&lt;/p&gt;

&lt;p&gt;De:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;name&#34;: &#34;symfony/framework-standard-edition&#34;,
&#34;description&#34;: &#34;The \&#34;Symfony Standard Edition\&#34; distribution&#34;,
&lt;/pre&gt;

&lt;p&gt;Para:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;name&#34;: &#34;tableless/iniciando-com-Symfony&#34;,
&#34;description&#34;: &#34;Tableless: Iniciando com Framework Symfony 2&#34;,
&lt;/pre&gt;

&lt;h2 id=&#34;controlando-nossa-aplicação&#34;&gt;Controlando nossa aplicação&lt;/h2&gt;

&lt;p&gt;Após essas simples configurações iniciais, podemos iniciar o Git em nosso projeto, para termos maior controle sobre nossa aplicação, não abordaremos conceitos sobre Git, mas em caso de &lt;a title=&#34;Comandos iniciais Git&#34; href=&#34;http://tableless.com.br/alguns-comandos-git/&#34; target=&#34;_blank&#34;&gt;dúvidas, Consulte&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;O projeto se encontra no &lt;a title=&#34;GitHub Candido Souza&#34; href=&#34;https://github.com/candidosouza/tableless&#34; target=&#34;_blank&#34;&gt;meu GitHub&lt;/a&gt;, assim ficará mais fácil para você analisar, estudar e comparar os códigos como o seu projeto! Lembrando que até o momento só instalamos o Symfony2, mas nos próximos tutoriais daremos continuidade ao nossos exemplos!&lt;/p&gt;

&lt;h2 id=&#34;concluindo&#34;&gt;Concluindo&lt;/h2&gt;

&lt;p&gt;Para finalizarmos, recomendo a &lt;a title=&#34;Documentação do Symfony&#34; href=&#34;http://symfony.com/doc/current/index.html&#34; target=&#34;_blank&#34;&gt;documentação do Symfony&lt;/a&gt;, ótima para estudos!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP Slim Framework</title>
      <link>https://tableless.github.io/hugo-public/php-slim-framework/</link>
      <pubDate>Wed, 04 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/php-slim-framework/</guid>
      <description>

&lt;p&gt;O Slim Framework é um microframework PHP que facilita sua vida na hora de fazer pequenas APIs.&lt;/p&gt;

&lt;p&gt;Vou falar sobre um problema que tive em um projeto em uma empresa que trabalho. Lá eu codifico com diferentes linguagens de programação em pequenos sistemas. Esses sistemas precisam ser acessados por 3 filiais e os usuários se logam com o mesmo login usado no E.R.P. que eles utilizam.&lt;/p&gt;

&lt;p&gt;Para simplificar meu trabalho resolvi criar uma API simples para autenticar os usuários. Como eu queria usar uma estrutura REST e não queria fazer tudo na unha e nem queria colocar um framework grande como Rails, Laravel, Zend ou Django. Pesquisei sobre microframeworks PHP e cheguei ao &lt;a href=&#34;http://www.sinatrarb.com/&#34;&gt;Sinatra&lt;/a&gt;, que já conhecia, e o &lt;a href=&#34;http://flask.pocoo.org/&#34;&gt;Flask&lt;/a&gt; (Python). Então encontrei o &lt;a href=&#34;http://www.slimframework.com/&#34;&gt;Slim&lt;/a&gt; um microframework PHP.&lt;/p&gt;

&lt;p&gt;Eu queria trabalhar com uma estrutura REST e o Slim já faz isso de forma muito simples criando rotas, como qualquer outro framework que trabalha com REST, a diferença é que um microframework é mais leve e não precisa de tantas configurações. É uma mão na roda para quem precisa escrever uma API. Para vocês terem ideia: em um dia consegui resolver meu problema de autenticação.&lt;/p&gt;

&lt;h2 id=&#34;código&#34;&gt;Código&lt;/h2&gt;

&lt;p&gt;Agora vamos ao código! O Slim pode ser instalado via &lt;a href=&#34;https://getcomposer.org/&#34;&gt;Composer&lt;/a&gt; ou fazendo o download do código fonte, para quem não conhece ele é um gerenciador de dependências para PHP assim como &lt;a href=&#34;http://bundler.io/&#34;&gt;Bundler&lt;/a&gt; é para o Ruby, nesse post vou mostrar a instalação via composer:&lt;/p&gt;

&lt;h3 id=&#34;passo-1-8211-instalação-do-composer&#34;&gt;Passo 1 &amp;#8211; Instalação do composer&lt;/h3&gt;

&lt;p&gt;Leia o post (&lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34;&gt;Composer para iniciantes&lt;/a&gt;) do &lt;a href=&#34;http://tableless.com.br/author/andrecardosodev/&#34;&gt;Andre Cardoso&lt;/a&gt;. Mas basicamente, para quem tem linux, é só abrir o terminal e digitar o código abaixo, se tiver windows, é só pegar o executável no site e instalar.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;curl -s https://getcomposer.org/installer | php&lt;/pre&gt;

&lt;h3 id=&#34;passo-2-8211-criar-o-arquivo-composer-json&#34;&gt;Passo 2 &amp;#8211; Criar o arquivo composer.json&lt;/h3&gt;

&lt;p&gt;Crie um diretorio para seu projeto(no meu caso eu chamei de api) e coloque um arquivo chamado composer.json dentro dela:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;mkdir api
cd api
&lt;/pre&gt;

&lt;p&gt;No arquivo composer.json adicione as seguintes linhas:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;require&#34;: {
        &#34;slim/slim&#34;: &#34;2.*&#34;
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;passo-3-8211-instalar-as-dependências&#34;&gt;Passo 3 &amp;#8211; Instalar as dependências&lt;/h3&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;composer install&lt;/pre&gt;

&lt;p&gt;Caso você não tenha o Composer, as suas variáveis de ambiente deverão ser assim:&lt;/p&gt;

&lt;pre&gt;php composer.phar install&lt;/pre&gt;

&lt;h3 id=&#34;passo-4-8211-criação-da-app&#34;&gt;Passo 4 &amp;#8211; Criação da app&lt;/h3&gt;

&lt;p&gt;Crie um arquivo &lt;code&gt;index.php&lt;/code&gt; e dentro dele coloque:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
require &#39;vendor/autoload.php&#39;;

//instancie o objeto
$app = new \Slim\Slim();

//defina a rota
get(&#39;/&#39;, function () { 
  echo &#34;Hello, World!&#34;; 
}); 
//rode a aplicação Slim 
$app-&amp;gt;run();&lt;/pre&gt;

&lt;p&gt;Se você acessar &lt;code&gt;http://localhost/api/&lt;/code&gt; você verá a mensagem &lt;strong&gt;&amp;#8220;Hello World!&amp;#8221;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Mas não é isso que queremos, queremos uma API REST que retorne um JSON. Então vamos ver um exemplo bem simples. O Slim também trabalha com templates, então dentro do diretório da nossa aplicação vamos criar um diretório chamado de &lt;code&gt;templates&lt;/code&gt; e dentro dele criaremos um arquivo chamado &lt;code&gt;default.php&lt;/code&gt;, neste arquivo coloque o seguintes conteúdo:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php 
header(&#39;Content-Type: application/json; charset=utf-8&#39;);
echo json_encode($data);
&lt;/pre&gt;

&lt;p&gt;Agora voltando ao nosso arquivo &lt;code&gt;index.php&lt;/code&gt; edite-o deixando da seguinte forma:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
require &#39;vendor/autoload.php&#39;;

//instancie o objeto
$app = new \Slim\Slim(array(
&#39;templates.path&#39; =&amp;gt; &#39;templates&#39;
));

//defina a rota
$app-&amp;gt;get(&#39;/&#39;, function () use ($app){ 
  //defina
  $data = array(&#34;data&#34;=&amp;gt;array(&#34;Hello&#34;=&amp;gt;&#34;World!&#34;)); 
  //set o arquivo de template
  $app-&amp;gt;render(&#39;default.php&#39;,$data,200); 
}); 

//rode a apliçicação Slim
$app-&amp;gt;run();&lt;/pre&gt;

&lt;p&gt;Quando você acessar a url novamente você verá algo como:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{&#34;Hello&#34;:&#34;World!&#34;}
&lt;/pre&gt;

&lt;p&gt;Agora vamos incrementar mais. No mesmo arquivo &lt;code&gt;index.php&lt;/code&gt; antes de &lt;code class=&#34;lang-php&#34;&gt;$app-&amp;gt;run();&lt;/code&gt; adicione:&lt;/p&gt;

&lt;pre&gt;$app-&amp;gt;group(&#39;/users&#39;,function() use ($app){

  //rota para a home
  $app-&amp;gt;get(&#39;/&#39;,function() use ($app){
    //exemplo de lista de usuarios
    $users = array(
     &#39;users&#39;=&amp;gt;array(
       &#39;jo&#39;=&amp;gt;&#39;senhadejo&#39;,
       &#39;luca&#39;=&amp;gt;&#39;senhaluca&#39;,
       &#39;yasmin&#39;=&amp;gt;&#39;senhayasmin&#39;,
       &#39;eric&#39;=&amp;gt;&#39;seric&#39;
     )
    );
    $data = array(
      &#39;data&#39;=&amp;gt;$users
      );
    $app-&amp;gt;render(&#39;default.php&#39;,$data,200);
  });

  //rota para login
  $app-&amp;gt;post(&#39;/login/&#39;,function() use ($app){
    if(isset($_POST))
    {
      $data = $_POST;
      $app-&amp;gt;render(&#39;default.php&#39;,$data,200);
    }
    else
    {
      $app-&amp;gt;render(404);
    }
  });

});
&lt;/pre&gt;

&lt;p&gt;Caso você esteja acessando o sistema por subdiretório crie um arquivo chamado &lt;code&gt;.htaccess&lt;/code&gt; com o seguinte conteúdo:&lt;/p&gt;

&lt;pre&gt;RewriteEngine On
RewriteBase /api/
RewriteRule ^index\.php$ - [L]
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule . /api/index.php [L]
&lt;/pre&gt;

&lt;p&gt;Perceba que adicionei o método group no arquivo &lt;code&gt;index.php.&lt;/code&gt; O Slim trabalha também com grupos de rotas, então é possível criar vários grupos com rotas próprias, dessa forma podemos organizar o código e não ter que ficar digitando o mesmo código várias vezes. Com o grupo de rotas chamado /users tudo que tiver dentro dele deverá vir precedido de /users ex: (/users/login/, /users/update/).&lt;/p&gt;

&lt;p&gt;Acessando &lt;code&gt;http://localhost/api/users/&lt;/code&gt; você verá uma lista de usuários, caso acesse &lt;code&gt;http://localhost/api/users/login/&lt;/code&gt; você verá uma página de erro. Isso ocorre porque setamos apenas uma rota POST para /users/login/ e como você acessou via GET o sistema redirecionou pois não existe a rota GET para /users/login/.&lt;/p&gt;

&lt;p&gt;Daqui para frente é só continuar implementando coisas novas, criando uma classe para conectar ao banco de dados, utilizando outros verbos HTTP, novos templates e etc. Você pode criar classes e usá-las normalmente é só incluí-las com o require e instanciar o objeto;&lt;/p&gt;

&lt;p&gt;O post termina aqui. O link para documentação do Slim é esse &lt;a href=&#34;http://docs.slimframework.com/&#34;&gt;http://docs.slimframework.com/&lt;/a&gt; divirtam-se e mãos a obra! ;D&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>