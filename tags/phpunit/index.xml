<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phpunit on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/phpunit/index.xml</link>
    <description>Recent content in Phpunit on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/phpunit/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PHPUnit – persistência e configurações avançadas</title>
      <link>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</link>
      <pubDate>Thu, 08 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</guid>
      <description>

&lt;p&gt;Neste artigo você verá como utilizar o &lt;a title=&#34;PHPUnit - site oficial&#34; href=&#34;http://phpunit.de/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; para realizar testes com persistência de dados utilizando o &lt;a title=&#34;Projeto Doctrine&#34; href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;Doctrine&lt;/a&gt; um &lt;a title=&#34;O que é um ORM?&#34; href=&#34;http://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional&#34; target=&#34;_blank&#34;&gt;ORM&lt;/a&gt; open-source e como definir configurações avançadas para personalizar sua suíte de testes e gerar relatórios de testes executados bem como cobertura do código de produção.&lt;/p&gt;

&lt;h2 id=&#34;começando&#34;&gt; Começando&lt;/h2&gt;

&lt;p&gt;Para começar o projeto crie um arquivo chamado &lt;em&gt;composer.json&lt;/em&gt;. Nele listaremos todos os pacotes/bibliotecas de terceiros que utilizaremos. Para este post utilizaremos o Doctrine e vários elementos do Zend Framework 2 além de é claro o próprio PHPUnit. Abaixo segue a lista de todas as bibliotecas que serão utilizadas.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;require&#34; : {
    &#34;doctrine/common&#34; : &#34;*&#34;,
    &#34;doctrine/dbal&#34;: &#34;*&#34;,
    &#34;doctrine/orm&#34; : &#34;*&#34;,
    &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;,
    &#34;zendframework/zend-stdlib&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-filter&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-servicemanager&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-crypt&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-math&#34;: &#34;2.3.*@dev&#34;
 }&lt;/pre&gt;

&lt;p&gt;Seguindo as recomendações da &lt;a title=&#34;FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt;, utilizaremos a &lt;a title=&#34;PSR-0&#34; href=&#34;http://www.php-fig.org/psr/psr-0/&#34; target=&#34;_blank&#34;&gt;PSR-0&lt;/a&gt; que trata sobre a forma de carregarmento de classes na aplicação que estamos desenvolvendo. Com isso trabalharemos com namespaces e não precisaremos utilizar require ou include nas classes que utilizaremos. Para que o projeto tenha suas classes carregadas conforme a PSR-0 podemos informar isso no arquivo &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;autoload&#34; : {
    &#34;psr-0&#34;: {
        &#34;Tableless\\&#34;: &#34;src/&#34;
    }
 }&lt;/pre&gt;

&lt;p&gt;Isto nos diz que o namespace “Tableless” estará presente na pasta &lt;em&gt;src&lt;/em&gt; e para isto se faz necessária a criação da pasta &lt;em&gt;src&lt;/em&gt; e dentro da mesma a pasta &lt;em&gt;Tableless&lt;/em&gt;. Há outra maneira de registrar o namespace através do _boostrap._&lt;em&gt;php&lt;/em&gt; que seria algo como:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; $load = require __DIR__ . &#39;/vendor/autoload.php&#39;;
 $load-&amp;gt;add(&#39;Tableless&#39;, __DIR__ . &#39;/src&#39;);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p class=&#34;lang-php&#34;&gt;
  O arquivo &lt;em&gt;bootstrap.php &lt;/em&gt;é comumente utilizado para realizar as configurações iniciais em vários frameworks. Basicamente ele inclui o &lt;em&gt;autoload.php&lt;/em&gt; gerado pelo composer e podem ser definidas as mais diversas configurações globais de sua aplicação no mesmo.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isso baixamos o composer utilizando o comando &lt;strong&gt;curl -sS &lt;a href=&#34;https://getcomposer.org/installer&#34;&gt;https://getcomposer.org/installer&lt;/a&gt; | php&lt;/strong&gt; e em seguida instalamos as dependências através do comando &lt;strong&gt;php composer.phar install&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41342&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png&#34; alt=&#34;Instalando composer e dependências&#34; width=&#34;403&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png 403w, uploads/2014/03/02-instalando-composer-e-dependencias-218x168.png 218w, uploads/2014/03/02-instalando-composer-e-dependencias.png 791w&#34; sizes=&#34;(max-width: 403px) 100vw, 403px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Com a instalação das dependências agora temos a nova estrutura contendo uma pasta &lt;em&gt;vendor&lt;/em&gt; contendo todas as bibliotecas de terceiros, um novo arquivo &lt;em&gt;composer.lock&lt;/em&gt; e &lt;em&gt;composer.phar&lt;/em&gt; os quais já foram descritos em outro artigo sobre PHPUnit com composer e que pode ser acessado &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41343&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/03-nova-estrutura-490x310.png&#34; alt=&#34;Nova Estrutura&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/03-nova-estrutura-490x310.png 490w, uploads/2014/03/03-nova-estrutura-265x168.png 265w, uploads/2014/03/03-nova-estrutura-400x252.png 400w, uploads/2014/03/03-nova-estrutura.png 1086w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;próximo-passo&#34;&gt;Próximo passo&lt;/h2&gt;

&lt;p&gt;Agora temos de criar um arquivo que será o pontapé inicial da aplicação, arquivo este comumente nomeado de bootstrap conforme já mencionado anteriormente. Nele são configurados onde se encontram as entidades – que serão explicadas mais a frente deste tutorial, configuração do banco de dados entre outras configurações. Como neste exemplo será utilizado o Doctrine, precisamos configurar o mesmo.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado &lt;em&gt;bootstrap.php&lt;/em&gt; na raiz de seu projeto, o fonte do &lt;em&gt;bootstrap.php&lt;/em&gt; está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
// Carregando o autoload que o composer gerou
require __DIR__ . &#39;/vendor/autoload.php&#39;;
// indicando tudo que usaremos no bootstrap
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Tools\Setup;
use Doctrine\ORM\Mapping\Driver\AnnotationDriver;
use Doctrine\Common\Annotations\AnnotationReader;
use Doctrine\Common\Annotations\AnnotationRegistry;
/**
* Definindo se é modo desenvolvimento
* 
* Caso true: o cache do Doctrine é realizado em formato de array
* Caso false: o cache é conforme configuração (memcache, APC..)
* 
* Somente trabalharemos aqui com o modo TRUE, cache em array
*/
$config = Setup::createConfiguration( true );
// pasta onde encontram-se nossas entidades
$entitypath = array( __DIR__ . &#39;/src/Tableless/Entity&#39; );
// registrando as entidades
$driver = new AnnotationDriver(new AnnotationReader(), $entitypath);
$config-&gt;setMetadataDriverImpl($driver);
/**
* indicando que trabalharemos com o modo annotations para
* as entidades. Pode ser também via arquivo yaml e xml
* 
*/
AnnotationRegistry::registerFile(__DIR__ 
. &#39;/vendor/doctrine/orm/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php&#39;);
// configurando a conexão com o banco de dados
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_mysql&#39;,    
    &#39;user&#39; =&gt; &#39;root&#39;,
    &#39;password&#39; =&gt; &#39;root&#39;,
    &#39;dbname&#39; =&gt; &#39;tableless_tdd&#39;,
);
// E finalmente criando o manipulador de entidades
$entityManager = EntityManager::create($conn, $config);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Até agora você viu várias vezes a palavra “Entidade” mas o que ela significa? Entidade é um objeto que tem um significado conceitual dentro de um domínio. Em outras palavras, cada entidade no Doctrine é a representação de uma tabela no banco de dados e cada registro é uma instância desta entidade. A entidade não manipula o banco de dados, apenas representa-o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pronto, a nível de produção já temos a configuração, agora criaremos a estrutura e configurações para testes.&lt;/p&gt;

&lt;p&gt;Na raiz de seu projeto crie uma pasta chamada &lt;em&gt;tests&lt;/em&gt;, dentro dela uma pasta chamada &lt;em&gt;src&lt;/em&gt; e dentro da src uma pasta chamada &lt;em&gt;Tableless&lt;/em&gt;. Perceba que o namespace ficará na mesma estrutura do código de produção, desta forma para utilizarmos uma entidade chamada &lt;em&gt;User&lt;/em&gt; por exemplo, usaremos a seguinte declaração: &lt;strong&gt;use Tableless\Entity\User;&lt;/strong&gt;. Para a classe de testes de User se for necessária declarar em algum lugar será desta forma: &lt;strong&gt;use Tableless\Entity\UserTest;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41345&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/04-estrutura-inicial-testes-398x310.png&#34; alt=&#34;Estrutura inicial testes&#34; width=&#34;398&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/04-estrutura-inicial-testes-398x310.png 398w, uploads/2014/03/04-estrutura-inicial-testes-215x168.png 215w, uploads/2014/03/04-estrutura-inicial-testes-400x311.png 400w, uploads/2014/03/04-estrutura-inicial-testes.png 542w&#34; sizes=&#34;(max-width: 398px) 100vw, 398px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a criação das pastas necessárias falta a criação do bootstrap de testes e de um arquivo de configurações de execução do PHPUnit.&lt;/p&gt;

&lt;p&gt;Começando com o bootstrap, o código novamente está comentado explicando porque determinadas coisas estão sendo feitas. Crie o arquivo &lt;em&gt;bootstrap.php&lt;/em&gt; dentro da pasta de testes (&lt;em&gt;tests&lt;/em&gt;).&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&lt;?php
// utilizando o bootstrap de produção
require __DIR__ . &#39;/../bootstrap.php&#39;;
use Doctrine\ORM\EntityManager;
/*
* Sobrescrevendo a conexão com banco de dados.
* 
* Isto faz-se necessário para que ao rodar os testes 
* o banco de produção não sofra alterações
*/
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_sqlite&#39;,
    &#39;dbname&#39; =&gt; &#39;:memory:&#39;,
);
return $entityManager = EntityManager::create($conn, $config);
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;O bootstrap de testes se faz necessário para sobrescrever a conexão com o banco de dados, caso contrário, todos os testes realizariam alterações no banco de dados de produção e isto jamais deve acontecer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isto agora é o momento de criar o arquivo xml de configurações do PHPUnit. Crie um arquivo chamado &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;phpunit.xm&lt;/i&gt;l dentro de sua pasta &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;tests&lt;/i&gt; e adicione o conteúdo abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;

&amp;lt;!-- Indicando qual é o diretório onde as classes de teste se encontram --&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&#34;Tableless TDD Test Suite&#34;&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;src/&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;

&amp;lt;!-- Adicionando filtros, basicamente whitelist (diretórios que serão executados), 
dentro temos o exclude (diretórios que não serão executados pelos testes) --&amp;gt;

&amp;lt;filter&amp;gt;
    &amp;lt;whitelist&amp;gt;
        &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;../src/&amp;lt;/directory&amp;gt;
        &amp;lt;exclude&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;./vendor/&amp;lt;/directory&amp;gt;
        &amp;lt;/exclude&amp;gt;
    &amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;/phpunit&amp;gt;&lt;/pre&gt;

&lt;p&gt;Quase pronto, se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; dentro da raiz do projeto teremos a mensagem de que nenhum teste foi executado como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41346&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/05-nenhum-teste-490x310.png&#34; alt=&#34;Nenhum Teste&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/05-nenhum-teste-490x310.png 490w, uploads/2014/03/05-nenhum-teste-265x168.png 265w, uploads/2014/03/05-nenhum-teste-400x253.png 400w, uploads/2014/03/05-nenhum-teste.png 803w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; Como estamos trabalhando com um arquivo de configurações, para rodarmos o phpunit seguindo as definições do arquivo precisamos utilizar o parâmetro &lt;strong&gt;-c&lt;/strong&gt; seguido do nome do arquivo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Obviamente que nenhum teste ainda foi executado porque não temos nenhuma classe de testes. Vamos começar então. Crie uma pasta &lt;em&gt;Entity&lt;/em&gt; dentro de &lt;em&gt;tests/src&lt;/em&gt;. Dentro desta pasta crie um arquivo chamado &lt;em&gt;UsertTest.php&lt;/em&gt;. A nova estrutura de testes deve estar como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41347&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/06-nova-estrutura-de-testes-379x310.png&#34; alt=&#34;Nova estrutura de testes&#34; width=&#34;379&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/06-nova-estrutura-de-testes-379x310.png 379w, uploads/2014/03/06-nova-estrutura-de-testes-205x168.png 205w, uploads/2014/03/06-nova-estrutura-de-testes-400x326.png 400w, uploads/2014/03/06-nova-estrutura-de-testes.png 695w&#34; sizes=&#34;(max-width: 379px) 100vw, 379px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;UserTest.php&lt;/em&gt; adicione o namespace do mesmo que é Tableless\Entity.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;namespace Tableless\Entity;&lt;/pre&gt;

&lt;p&gt;Agora definimos quais classes utilizaremos para este teste. Como estamos testando a entidade &lt;em&gt;User&lt;/em&gt; precisaremos utilizar o Tableless\Entity\User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;&lt;/pre&gt;

&lt;p&gt;No entanto aí tem um detalhe. A entidade User ainda não existe, mas a criaremos dentro de instantes pois ainda temos uma classe que devemos criar antes mesmo da &lt;em&gt;User&lt;/em&gt;. Ela se chama &lt;em&gt;TestCase&lt;/em&gt; e deve estar no namespace Tableless\Test. Crie em &lt;em&gt;src/Tableless&lt;/em&gt; (não em tests/src/Tableless) uma pasta chamada Test e dentro dela um arquivo chamado &lt;em&gt;TestCase.php&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41348&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/07-criando-test-case-426x310.png&#34; alt=&#34;Criando o TestCase&#34; width=&#34;426&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/07-criando-test-case-426x310.png 426w, uploads/2014/03/07-criando-test-case-230x168.png 230w, uploads/2014/03/07-criando-test-case-400x291.png 400w, uploads/2014/03/07-criando-test-case.png 602w&#34; sizes=&#34;(max-width: 426px) 100vw, 426px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Neste arquivo copie e cole o código abaixo que está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
namespace Tableless\Test;

use Doctrine\ORM\Tools\SchemaTool;
use PHPUnit_Framework_TestCase as PHPUnit;

abstract class TestCase extends PHPUnit
{
    protected $entityManager = null;

    /**
    * Executado antes de cada teste unitário
    */
    public function setup() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Cria a base de dados necessária com suas determinadas tabelas
        $tool-&amp;gt;createSchema($classes);

        parent::setup();
    } 

    /**
    * Executado após a execução de cada um dos testes unitários
    */
    public function tearDown() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Desfaz o banco criado no setUp
        $tool-&amp;gt;dropSchema($classes);

        parent::tearDown();
    }

    /**
    * 
    * @return \Doctrine\ORM\EntityManager
    */
    public function getEntityManager() 
    {
        if (! $this-&amp;gt;entityManager) {
            $this-&amp;gt;entityManager = require __DIR__ . &#39;/../../../tests/bootstrap.php&#39;;
        } 
        return $this-&amp;gt;entityManager; 
    } 
}&lt;/pre&gt;

&lt;p&gt;Pronto, já estamos com tudo o que precisamos para começar escrever os testes. Detalhe que esta configuração foi criada para que fosse possível utilizar e testar a persistência de dados utilizando o Doctrine. Para demais testes em controllers, services, views, forms ou o que mais você desejar esta configuração realizada até o momento permanece podendo ser acrescida de novos elementos, tudo depende da necessidade.&lt;/p&gt;

&lt;h2 id=&#34;criando-o-primeiro-teste&#34;&gt;Criando o primeiro teste&lt;/h2&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt; começaremos a definir nossos testes. Lembre-se que a ideia do TDD é que o teste seja criado antes do código de produção, e assim faremos.&lt;/p&gt;

&lt;p&gt;Pra início de conversa utilizaremos a classe &lt;em&gt;TestCase&lt;/em&gt; previamente criada e a entidade User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;
use Tableless\Test\TestCase;&lt;/pre&gt;

&lt;p&gt;A classe de testes atual (UserTest) extende de TestCase e adicionaremos o atributo protegido $entity.&lt;/p&gt;

&lt;pre&gt;class UserTest extends TestCase
{
    protected $entity;
}&lt;/pre&gt;

&lt;p&gt;Assim como a classe TestCase, nossa classe UserTest também possuirá um métdo setUp e um tearDown que servirão para as configurações da mesma. De momento apenas setaremos o valor default do atributo entity no setUp.&lt;/p&gt;

&lt;pre&gt;public function setUp()
{
    $this-&amp;gt;entity = &#39;Tableless\Entity\User&#39;;
};&lt;/pre&gt;

&lt;p&gt;Agora segue o nosso primeiro teste: Novamente há comentários explicando cada ação.&lt;/p&gt;

&lt;pre&gt;public function testIfIsSavingAsExpected()
{
    // Criando os dados necessários para salvar o usuário
    $userData = array(
        &#39;id&#39; =&amp;gt; 1,
        &#39;name&#39; =&amp;gt; &#39;Nome do usuário&#39;,
        &#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;,
        &#39;password&#39; =&amp;gt; &#39;xpto&#39;,
        &#39;profilePic&#39; =&amp;gt; &#39;image.png&#39;
    );
    /* o Id é gerado automaticamente pelo Doctrine, neste caso estou forçando
    * um Id desejado, mas somente para o teste, para o código de produção
    * isto não se faz necessário
    */

    // Instanciando a entidade usuário definindo todos os atributos à ela
    $user = new User( $userData );

    // salvando o usuário no banco de dados
    $this-&amp;gt;getEntityManager()-&amp;gt;persist( $user );
    $this-&amp;gt;getEntityManager()-&amp;gt;flush();

    // Obtendo o usuário salvo
    $registeredUser = $this-&amp;gt;getEntityManager()
            -&amp;gt;getRepository($this-&amp;gt;entity)
            -&amp;gt;findOneBy(array(&#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;));

    // Garantindo que tudo funcionou conforme o esperado
    $this-&amp;gt;assertInstanceOf($this-&amp;gt;entity, $registeredUser);
    $this-&amp;gt;assertEquals($userData[&#39;name&#39;], $registeredUser-&amp;gt;getName());
}&lt;/pre&gt;

&lt;p&gt;Se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; da raiz de nosso projeto deveremos ver o seguinte erro: “PHP Fatal error: Class &amp;#8216;Tableless\Entity\User &amp;#8230;&amp;#8217;” isto porque ainda não existe a entidade &lt;em&gt;User&lt;/em&gt; pois realizamos o primeiro passo do TDD, o “Red”. Em seguida realizaremos o passo “Green” que consiste em criarmos o código que faça o teste passar e por último o passo “Refactor” que é onde faremos algumas melhorias no código. No código exemplo não existirá duplicidade e/ou partes inconsistentes com isso o Refactor realizará apenas algumas pequenas melhorias, nada mais.&lt;/p&gt;

&lt;p&gt;Crie na pasta &lt;em&gt;src&lt;/em&gt; (não em tests/src) uma pasta chamada &lt;em&gt;Entity&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;User.php&lt;/em&gt;. Eis a estrutura da entidade &lt;em&gt;User&lt;/em&gt;. Por ser um arquivo muito extenso, colocarei apenas o link do mesmo que encontra-se no github. &lt;a title=&#34;Tableless\Entity\user&#34; href=&#34;https://gist.github.com/andrebian/11389706&#34; target=&#34;_blank&#34;&gt;Tableless\Entity\User&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perceba que existem comentários acima de cada um dos atributos da classe. Isto se dá por estarmos utilizando o Annotations do Doctrine para que os mesmos sejam lidos e mapeados no banco de dados. Em outras palavras, o Doctrine lê a anotação e cria a estrutura da tabela conforme as definições nos comentários. Há a possibilidade de realizar tais definições via xml e também via yaml o que não veremos neste tutorial.&lt;/p&gt;

&lt;p&gt;Agora se rodarmos nosso teste novamente o mesmo passará. Ou seja, já temos um código minimamente testado com um início de noção de persistência de dados, veremos uma pequena melhora no código agora e em seguida algumas configurações para a execução dos testes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41349&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/08-primeiro-teste-passando-575x310.png&#34; alt=&#34;Primeiro teste passando&#34; width=&#34;575&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/08-primeiro-teste-passando-575x310.png 575w, uploads/2014/03/08-primeiro-teste-passando-312x168.png 312w, uploads/2014/03/08-primeiro-teste-passando-400x215.png 400w, uploads/2014/03/08-primeiro-teste-passando.png 797w&#34; sizes=&#34;(max-width: 575px) 100vw, 575px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;definindo-hash-para-senha&#34;&gt;Definindo hash para senha&lt;/h2&gt;

&lt;p&gt;Primeiramente no teste adicionaremos uma asserção de que a senha do usuário registrado não é igual a senha que definimos, em string pura. Adicione o trecho de código abaixo em seu teste logo após $this-&amp;gt;assertEquals($userData[&amp;#8216;name&amp;#8217;], $registeredUser-&amp;gt;getName());&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;// verificando se hash de senha funcionou
$this-&amp;gt;assertNotEquals($userData[&#39;password&#39;], $registeredUser-&amp;gt;getPassword());&lt;/pre&gt;

&lt;p&gt;Ao rodarmos o teste o mesmo deve quebrar pois ainda não criamos um hash para a senha, desta forma a senha fornecida está em string pura no banco de dados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41350&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/09-teste-falhando-hash-523x310.png&#34; alt=&#34;Teste falhando hash&#34; width=&#34;523&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/09-teste-falhando-hash-523x310.png 523w, uploads/2014/03/09-teste-falhando-hash-283x168.png 283w, uploads/2014/03/09-teste-falhando-hash-400x237.png 400w, uploads/2014/03/09-teste-falhando-hash.png 800w&#34; sizes=&#34;(max-width: 523px) 100vw, 523px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, na classe Tableless\Entity\User usaremos as seguintes classes do Zend:&lt;/p&gt;

&lt;pre&gt;use Zend\Math\Rand;
use Zend\Crypt\Key\Derivation\Pbkdf2;&lt;/pre&gt;

&lt;p&gt;em setPassword deixaremos adicionaremos a chamada ao método encryptPassword&lt;/p&gt;

&lt;pre&gt;public function setPassword( $password )
{
    $this-&amp;gt;password = $this-&amp;gt;encryptPassword($password);
    return $this;
}&lt;/pre&gt;

&lt;p&gt;E criaremos o método encryptPassword.&lt;/p&gt;

&lt;pre&gt;public function encryptPassword( $password )
{
   return base64_encode(
    Pbkdf2::calc(&#39;sha256&#39;, $password, $this-&amp;gt;salt, 
            10000, strlen($password*2)));
}&lt;/pre&gt;

&lt;p&gt;Agora rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; o teste passa novamente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41351&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/10-teste-passando-hash-375x310.png&#34; alt=&#34;teste passando hash&#34; width=&#34;375&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/10-teste-passando-hash-375x310.png 375w, uploads/2014/03/10-teste-passando-hash-203x168.png 203w, uploads/2014/03/10-teste-passando-hash-400x330.png 400w, uploads/2014/03/10-teste-passando-hash.png 795w&#34; sizes=&#34;(max-width: 375px) 100vw, 375px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Assim finalizamos o básico da realização de testes utilizando persitência de dados. A partir de agora veremos algumas configurações avançadas que lhe ajudarão muito no feedback dos testes.&lt;/p&gt;

&lt;h2 id=&#34;algumas-configurações-avançadas&#34;&gt;Algumas configurações avançadas&lt;/h2&gt;

&lt;p&gt;Através do arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; podemos definir algumas configurações avançadas para a execução dos testes. Começando pela declaração &lt;phpunit&gt;. Atualmente encontra-se desta forma:&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que utilizaremos um arquivo de bootstrap e dizemos qual arquivo é e também que queremos coloração no output. Caso colors=”true” não estivesse presente nossa visão ficaria desta forma.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41352&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/11-colors-482x310.png&#34; alt=&#34;Colors&#34; width=&#34;482&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/11-colors-482x310.png 482w, uploads/2014/03/11-colors-261x168.png 261w, uploads/2014/03/11-colors-400x257.png 400w, uploads/2014/03/11-colors.png 806w&#34; sizes=&#34;(max-width: 482px) 100vw, 482px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos definir erros e avisos sendo tratados como exceções.&lt;/p&gt;

&lt;pre&gt;&amp;lt;phpunit 
    convertErrorsToExceptions=&#34;true&#34; 
    convertNoticesToExceptions=&#34;true&#34;
    convertWarningsToExceptions=&#34;true&#34;
    colors=&#34;true&#34;
    bootstrap=&#34;bootstrap.php&#34;
&amp;gt;&lt;/pre&gt;

&lt;p&gt;E muitas outras opções. Para conhecer todas as opções de configurações acesse &lt;a title=&#34;Visualizar as configurações do PHPUnit&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/appendixes.configuration.html&#34; target=&#34;_blank&#34;&gt;este link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Certamente que a configuração a seguir é uma que empolga muitos desenvolvedores, logs e coverage. Com logs e coverage você identifica quais testes passaram, quais tiveram exceções, quais não passaram e o mais legal de tudo, o percentual de cobertura de testes que há em seu código de produção. Basicamente ao rodar um teste unitário, ele cobre uma pequena parte de seu código de produção, habilitando coverage você pode verificar quais linhas estão realmente garantidas por testes e quais você ainda tem de trabalhar mais tempo para garantir um mínimo de cobertura necessário para perfeito funcionamento mas principalmente para garantia de evolução de seu software.&lt;/p&gt;

&lt;p&gt;Para criar logs utilizamos a tag logging no arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; logo após o fechamento da tag &lt;/filter&gt;.&lt;/p&gt;

&lt;pre&gt;&amp;lt;logging&amp;gt;
    &amp;lt;log type=&#34;testdox-text&#34; target=&#34;data/testdox.txt&#34; /&amp;gt;
&amp;lt;/logging&amp;gt;&lt;/pre&gt;

&lt;p&gt;O log acima está gravando em formato de texto um checklist dos testes que existem em todas as classes de teste dentro da suite de testes marcando com x os que foram executados.&lt;/p&gt;

&lt;p&gt;Rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; será criada a pasta &lt;em&gt;tests/data&lt;/em&gt; contento o arquivo &lt;em&gt;testdox.txt&lt;/em&gt; O nome do arquivo é de sua escolha.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41353&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/12-testdox-569x310.png&#34; alt=&#34;Testdox&#34; width=&#34;569&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/12-testdox-569x310.png 569w, uploads/2014/03/12-testdox-308x168.png 308w, uploads/2014/03/12-testdox-400x217.png 400w, uploads/2014/03/12-testdox.png 891w&#34; sizes=&#34;(max-width: 569px) 100vw, 569px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Também é possível gerar o testdox em formato html, basta alterar testdox-text para testdox-html e testdox.txt para testdox.html mas o mais comum é ser utilizado em formato txt mesmo.&lt;/p&gt;

&lt;p&gt;Existe também a possibilidade de habilitar o testdox em tempo de execução. Basta apenas adicionar o parâmetro &amp;#8211;testdox ao rodar os testes. O resultado será como abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --testdox
PHPUnit 3.7.35 by Sebastian Bergmann.
Configuration read from /home/andre/Documents/Posts/tableless/phpunit-persistencia-de-dados-e-configuracoes-avancadas/sources/tests/phpunit.xml
Tableless\Entity\User
  [x] If is saving as expected
Generating code coverage report in HTML format ... done&lt;/pre&gt;

&lt;h2 id=&#34;agrupamento-de-testes&#34;&gt;Agrupamento de testes&lt;/h2&gt;

&lt;p&gt;Por certas vezes necessitamos agrupar testes para que rodemos somente determinada sequência sem que os demais sejam executados. Isto é útil para quando temos de realizar uma pequena alteração e não se faça necessário a execução de todos os testes já criados tornando o feedback mais rápido. Comumente isto é utilizado quando se deseja realizar um ajuste pontual e ao ser finalizado todos os testes são executados novamente.&lt;/p&gt;

&lt;p&gt;O PHPUnit nos permite trabalhar com grupos os quais veremos sua definição a seguir.&lt;/p&gt;

&lt;p&gt;Crie uma pasta chamada &lt;em&gt;Filter&lt;/em&gt; em &lt;em&gt;tests/src/Tableless&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;CurrencyTest.php&lt;/em&gt;. O conteúdo deste arquivo está abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
namespace Tableless\Filter;
use Tableless\Test\TestCase;
/**
* @group Filter
*/
class CurrencyTest extends TestCase 
{
    public function testIfClassExists()
    {
        $this-&amp;gt;assertTrue(class_exists(&#39;Tableless\Filter\Currency&#39;));
    }
}&lt;/pre&gt;

&lt;p&gt;Perceba que antes de ser declarado o nome da classe existe uma anotação @group Filter. É isto que define o grupo ao qual este teste pertence. Faça o mesmo para o teste já existente (tests/src/Tableless/Entity/UserTest.php) anotando-o como @group Entity.&lt;/p&gt;

&lt;pre&gt;...
/**
* @group Entity
*/
class UserTest extends TestCase
...&lt;/pre&gt;

&lt;p&gt;Agora que temos a definição dos grupos podemos rodar nossos testes somente de 1 grupo, de um conjunto de grupos ou de todos os grupos sem distinção. Existem duas formas de rodar os testes por grupos, através de parâmetro informado no momento da execução dos testes ou através do arquivo xml de configurações do PHPUnit, veremos ambas.&lt;/p&gt;

&lt;h3 id=&#34;via-parâmetro&#34;&gt;Via parâmetro&lt;/h3&gt;

&lt;h4 id=&#34;somente-um-grupo&#34;&gt;Somente um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity
&lt;/pre&gt;

&lt;h4 id=&#34;mais-de-um-grupo&#34;&gt;Mais de um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity,Filter
&lt;/pre&gt;

&lt;p&gt;Para que todos os grupos de testes sejam executados basta que não seja informado o parâmetro &amp;#8211;group.&lt;/p&gt;

&lt;h3 id=&#34;via-arquivo-de-configuração&#34;&gt;Via arquivo de configuração&lt;/h3&gt;

&lt;p&gt;No arquivo tests/phpunit.xml adicione uma tag &lt;groups&gt; e dentro dela liste os grupos desejados.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;groups&amp;gt;
    &amp;lt;include&amp;gt;
        &amp;lt;group&amp;gt;Entity&amp;lt;/group&amp;gt;
    &amp;lt;/include&amp;gt;
&amp;lt;/groups&amp;gt;&lt;/pre&gt;

&lt;p&gt;Você deve estar imaginando, se existe uma tag &lt;strong&gt;include &lt;/strong&gt;deve existir uma tag &lt;strong&gt;exclude &lt;/strong&gt;também. Imaginou certo! Dentro de include você adiciona todos os grupos que deseja que sejam executados nos testes já em exclude, todos que NÃO devem ser executados. O excclude é ideal para testes que foram marcados como incompletos ou pulados (skipped).&lt;/p&gt;

&lt;p&gt;Após adicionar as tags referentes aos grupos de testes no arquivo xml de configurações não se faz mais necessário informar o parâmetro  &amp;#8211;group, basta rodar normalmente.&lt;/p&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/pre&gt;

&lt;h2 id=&#34;agora-sim-o-mais-legal-de-todos-coverage-em-html&#34;&gt;Agora sim, o mais legal de todos, Coverage em Html!&lt;/h2&gt;

&lt;p&gt;Dentro de &lt;logging&gt; adicione uma nova tag chamada &lt;log&gt; conforme o exemplo abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;log 
    type=&#34;coverage-html&#34; 
    target=&#34;data/coverage&#34; 
    charset=&#34;UTF-8&#34; 
    yui=&#34;true&#34; 
    highlight=&#34;true&#34;
    lowUpperBound=&#34;35&#34;
    highUpperBound=&#34;70&#34; /&amp;gt;&lt;/pre&gt;

&lt;p&gt;Basicamente estamos definindo que o coverage será em formato html, que o considerado baixo coverage será de 35% e um bom coverage se dará a partir de 70%. O highlight serve para destacar as linhas que foram cobertas com verde, não cobertas com vermelho e ignoradas permanecem com a cor padrão. Rode o teste novamente.&lt;/p&gt;

&lt;p&gt;Agora no browser entre em seu localhost na pasta do projeto em que está trabalhando. Em seguida entre na pasta &lt;em&gt;tests&lt;/em&gt;, após isto em &lt;em&gt;data&lt;/em&gt; e por último em coverage. Surpreenda-se!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41354&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/13-coverage-588x223.png&#34; alt=&#34;Coverage&#34; width=&#34;588&#34; height=&#34;223&#34; srcset=&#34;uploads/2014/03/13-coverage-588x223.png 588w, uploads/2014/03/13-coverage-329x125.png 329w, uploads/2014/03/13-coverage-660x251.png 660w, uploads/2014/03/13-coverage-400x152.png 400w, uploads/2014/03/13-coverage.png 1324w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Navegando pelos arquivos você identificará o que já está bom e o que precisa ser mais testado. Neste nosso caso chegar a 100% é muito fácil, basta lermos todos os dados do usuário.&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt;, dentro do único teste que temos adicione os seguintes asserts:&lt;/p&gt;

&lt;pre&gt;$this-&amp;gt;assertEquals(1, $registeredUser-&amp;gt;getId());
$this-&amp;gt;assertEquals(&#39;usuario@dominio.com&#39;, $registeredUser-&amp;gt;getEmail());
$this-&amp;gt;assertNotNull($registeredUser-&amp;gt;getSalt());
$this-&amp;gt;assertEquals(&#39;image.png&#39;, $registeredUser-&amp;gt;getProfilePic());&lt;/pre&gt;

&lt;p&gt;Rode os testes novamente e corra pro abraço!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41355&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/14-coverage-100-588x237.png&#34; alt=&#34;Coverage 100%&#34; width=&#34;588&#34; height=&#34;237&#34; srcset=&#34;uploads/2014/03/14-coverage-100-588x237.png 588w, uploads/2014/03/14-coverage-100-329x132.png 329w, uploads/2014/03/14-coverage-100-660x266.png 660w, uploads/2014/03/14-coverage-100-400x161.png 400w, uploads/2014/03/14-coverage-100.png 1303w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lembrando novamente que para entendimento deste tutorial se faz necessário a leitura dos conteúdos anteriores sobre o tema, sendo eles &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar/&#34; title=&#34;TDD, por que usar?&#34;&gt;TDD, por que usar?&lt;/a&gt;  e &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;PHPUnit, como iniciar sem dores&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;bonus&#34;&gt;Bonus.&lt;/h2&gt;

&lt;p&gt;O que fizemos até o momento foi preparar o ambiente de testes e executá-los mas este ambiente ainda não está totalmente pronto para o código de produção pois precisamos de conexão com um banco de dados além de mais uma configuração do Doctrine para que possamos criar o banco de dados a partir de nossas entidades. Ou seja, lembra daquele processo de criar o banco de dados, definir as tabelas e relacionamentos todos antes do código? Com o Doctrine isto não se faz mais necessário, pode ser feito da forma descrita (e tradicional) mas há outra forma bem legal que é uma mão na roda e que mostrarei agora.&lt;/p&gt;

&lt;p&gt;Primeiramente precisamos criar um arquivo de configuração para o cli (Command Line Interface) do Doctrine. Na pasta raiz de sua aplicação crie um arquivo chamado &lt;em&gt;cli-config.php&lt;/em&gt; e cole o seguinte conteúdo:&lt;/p&gt;

&lt;pre&gt;//cli-config.php
require &#39;bootstrap.php&#39;;

return \Doctrine\ORM\Tools\Console\ConsoleRunner::createHelperSet($entityManager);&lt;/pre&gt;

&lt;div id=&#34;LC3&#34;&gt;
  Após a criação deste arquivo podemos rodar o seguinte comando &lt;b&gt;./vendor/bin/doctrine&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;Aparecerão várias opções de uso que vão desde checagem de status de conexão, validação das entidades, além de outras funcionalidades. Uma coisa que o doctrine não faz realmente é criar a base de dados pois isto depende de cada base pois Mysql é de um jeito, Postgres é de outro, SQL Server é de outro ainda, então esta tarefa ainda é manual.&lt;/p&gt;

&lt;p&gt;Para fins didáticos criei uma base chamada tableless_tdd no mysql como definido no arquivo bootstrap.php da raiz do projeto. Você pode alterar o nome se quiser, bem como o próprio banco, experimente o Sqlite se quiser.&lt;/p&gt;

&lt;p&gt;Com a base criada rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;. Se estiver tudo ok aparecerá algo como a imagem abaixo. Nela informa que o mapeamento das entidades está correto mas o banco ainda não está sincronizado, para sincronizar rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;. Isto lerá todas as entidades contidas em src/Tableless/Entity e criará a estrutura de tabelas a partir delas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41356&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/15-doctrine-validate-500x310.png&#34; alt=&#34;Doctrine Validate Schema&#34; width=&#34;500&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/15-doctrine-validate-500x310.png 500w, uploads/2014/03/15-doctrine-validate-271x168.png 271w, uploads/2014/03/15-doctrine-validate-400x247.png 400w, uploads/2014/03/15-doctrine-validate.png 797w&#34; sizes=&#34;(max-width: 500px) 100vw, 500px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41357&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/16-doctrine-create-validate-459x310.png&#34; alt=&#34;Doctrine create validate&#34; width=&#34;459&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/16-doctrine-create-validate-459x310.png 459w, uploads/2014/03/16-doctrine-create-validate-249x168.png 249w, uploads/2014/03/16-doctrine-create-validate-400x269.png 400w, uploads/2014/03/16-doctrine-create-validate.png 820w&#34; sizes=&#34;(max-width: 459px) 100vw, 459px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Atualmente possuímos somente a entidade User que indica que uma tabela users será criada no banco de dados. Após a finalização da execução do comando anterior seu banco de dados já estará com a nova estrutura. Ao realizar qualquer alteração na entidade User ou mesmo criar novas entidades você precisará rodar o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:update&lt;/strong&gt; com isso aparecerá uma mensagem informando que já há uma estrutura no banco de dados e lhe pede confirmação sobre o que fazer. Você pode ignorar, ver as alterações ou forçar se tiver certeza do que está fazendo ou mesmo se já visualizou as alterações que serão realizadas e está ciente de que está tudo certo. Basta ler as intruções que o próprio Doctrine fornece que você saberá o que fazer, é muito intuitivo.&lt;/p&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;Agora que você já configurou o Doctrine, já conhece como criar testes unitários resta apenas aperfeiçoar a cada dia. Não existe uma receita, tudo requer empenho e dedicação mas que no final quando você ver aquelas barrinhas verdes mostrando 100% de cobertura se sentirá cada vez mais empolgado e com um código mais estável mas o principal, com um código que pode facilmente evoluir.&lt;/p&gt;

&lt;p&gt;Para baixar o código-fonte gerado neste artigo acesse este link do &lt;a title=&#34;Baixar o código-fonte&#34; href=&#34;https://github.com/andrebian/tdd-persistencia-de-dados&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHPUnit, como iniciar sem dores</title>
      <link>https://tableless.github.io/hugo-public/phpunit-como-iniciar-sem-dores/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-como-iniciar-sem-dores/</guid>
      <description>

&lt;p&gt;Como já mencionei em um artigo anterior, o &lt;a title=&#34;Ir ao repositório do PHPUnit&#34; href=&#34;https://github.com/sebastianbergmann/phpunit/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; é um framework de testes unitários para a linguagem PHP. Ele provê um ecossistema para a execução de testes de forma automatizada.&lt;/p&gt;

&lt;p&gt;Neste artigo veremos a sua instalação utilizando o gerenciador de pacotes &lt;a title=&#34;Ir à página oficial do Composer&#34; href=&#34;http://getcomposer.org/&#34; target=&#34;_blank&#34;&gt;composer&lt;/a&gt;, configuração e estrutura de pastas e alguns testes simples sem persistência de dados.&lt;/p&gt;

&lt;h2 id=&#34;instalando-o-phpunit&#34;&gt;Instalando o PHPUnit&lt;/h2&gt;

&lt;p&gt;Para iniciar a instalação do PHPUnit precisamos primeiramente de um diretório que será nosso diretório de trabalho neste exemplo. Após criado o diretório é necessário criar um arquivo chamado &lt;a title=&#34;Ir ao modelo do arquivo composer.json&#34; href=&#34;http://getcomposer.org/doc/04-schema.md&#34; target=&#34;_blank&#34;&gt;&lt;i&gt;composer&lt;/i&gt;&lt;i&gt;.json&lt;/i&gt;&lt;/a&gt; para que seja definida a necessidade do PHP Unit no projeto. O arquivo _composer_&lt;em&gt;.json&lt;/em&gt; é responsável por declarar todas as bibliotecas que serão necessárias para o projeto em questão, em suma todas soluções de terceiros, incluindo suas soluções genéricas que encontrem-se no &lt;a title=&#34;Ir ao Packagist, repositório do composer&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;repositório do composer&lt;/a&gt; serão gerenciadas conforme a especificação do arquivo &lt;em&gt;composer.json.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;O arquivo para este artigo deverá conter o seguinte conteúdo:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;require-dev&#34;: {
        &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que estamos registrando como uma dependência de nosso projeto o PHPUnit em sua versão 3.7 sempre solicitando a última atualização. Para que sempre seja utilizada a última versão do PHPUnit basta remover a sequência &amp;#8220;3.7.*&amp;#8221; por simplesmente &amp;#8220;*&amp;#8221;. O mesmo é possível com qualquer biblioteca gerenciada pelo composer.&lt;/p&gt;

&lt;p&gt;Agora já estão prontas as declarações de nossas dependências basta baixar o gerenciador de dependência &lt;a title=&#34;Baixar o composer&#34; href=&#34;http://getcomposer.org/download/&#34; target=&#34;_blank&#34;&gt;composer&lt;/a&gt; e rodar o comando&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;php composer.phar install.&lt;/pre&gt;

&lt;p&gt;Isto irá de maneira automática baixar todas as dependências que foram especificadas no arquivo composer.json, e neste exemplo trata-se apenas do PHPUnit no entanto o próprio PHP Unit requer algumas bibliotecas de terceiros então outras bibliotecas estarão disponíveis além do mesmo dentro da pasta &lt;em&gt;vendor&lt;/em&gt; que será criada.&lt;/p&gt;

&lt;div id=&#34;attachment_40041&#34; style=&#34;width: 407px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40041 &#34; alt=&#34;PHPUnit - Instalação a partir do composer&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/01-composer-install-397x310.png&#34; width=&#34;397&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/01-composer-install-397x310.png 397w, uploads/2013/12/01-composer-install-215x168.png 215w, uploads/2013/12/01-composer-install.png 881w&#34; sizes=&#34;(max-width: 397px) 100vw, 397px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Instalação a partir do composer
  &lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;attachment_40049&#34; style=&#34;width: 394px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40049 &#34; alt=&#34;PHPUnit - Estrutura de pastas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/02-estrutura-pastas-384x310.png&#34; width=&#34;384&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/02-estrutura-pastas-384x310.png 384w, uploads/2013/12/02-estrutura-pastas-208x168.png 208w, uploads/2013/12/02-estrutura-pastas.png 784w&#34; sizes=&#34;(max-width: 384px) 100vw, 384px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Estrutura de pastas
  &lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Existe uma convenção de padrões definidos pela &lt;a title=&#34;Ir à página do Framework Interop Group&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; chamada &lt;a title=&#34;Ver todas as PSRs&#34; href=&#34;https://github.com/php-fig/fig-standards/tree/master/accepted&#34; target=&#34;_blank&#34;&gt;PSR (Proposal Standards Recommendation)&lt;/a&gt;. Para facilitar será utilizada a definição do Autoloader para o exemplo que está descrito na PSR-0. Após a correta instalação via composer devem ser criadas os diretórios &lt;em&gt;src&lt;/em&gt; e dentro dele &lt;em&gt;Application&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Com a definição do Autoloader a nova estrutura do composer é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;autoload&#34;: {
        &#34;psr-0&#34;: {&#34;Application\\&#34;: &#34;src/&#34;}
    },
    &#34;require-dev&#34;: {
        &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;No arquivo composer.json agora é dito que o autoloader deve reconhecer o namespace &amp;#8220;Application&amp;#8221; que encontra-se dentro do diretorio &lt;em&gt;src&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div id=&#34;attachment_40044&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40044 &#34; alt=&#34;PHPUnit - Nova estrutura de pastas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/4-nova-estrutura-pastas-588x303.png&#34; width=&#34;588&#34; height=&#34;303&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Nova estrutura de pastas
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;iniciando-com-um-simples-teste&#34;&gt;Iniciando com um simples teste&lt;/h2&gt;

&lt;p&gt;Como o PHPUnit já está instalado corretamente no projeto agora vem a parte legal que é criar pequenos testes (unitários, obviamente) e colocar em prática o vermelho-verde-refatora já mencionado no meu post anterior &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar&#34; title=&#34;Ler mais sobre TDD&#34;&gt;TDD, por que usar?&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Primeiramente deve ser criada a pasta &lt;em&gt;tests&lt;/em&gt; que servirá para acomodar todos os casos de teste a serem executados.&lt;/p&gt;

&lt;p&gt;Começando com um teste simples, e na verdade este artigo somente mostrará o uso simplificado pois a finalidade do mesmo é apenas mostrar o caminho das pedras, como começar, instalar, configurar e rodar os primeiros testes. A partir daí cabe à necessidade de cada desenvolvedor.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Aqui será criado um arquivo PHPNativeElements onde serão testados algumas funções nativas do PHP e seus comportamentos. Obviamente que este caso de teste calha somente em modo didático pois tais testes e classe testada terá muito mais de uma única responsabilidade, é somente em caráter demonstrativo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Criado o arquivo _PHPNativeElementsTest.php_ dentro do diretório tests, siga o exemplo abaixo.&lt;/p&gt;

&lt;div id=&#34;attachment_40045&#34; style=&#34;width: 383px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40045  &#34; alt=&#34;PHPUnit - Estrutura inicial do primeiro teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/5-estrutura-primeiro-teste-373x310.png&#34; width=&#34;373&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/5-estrutura-primeiro-teste-373x310.png 373w, uploads/2013/12/5-estrutura-primeiro-teste-202x168.png 202w, uploads/2013/12/5-estrutura-primeiro-teste.png 738w&#34; sizes=&#34;(max-width: 373px) 100vw, 373px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Estrutura inicial do primeiro teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt; Para que seja reconhecido como um teste o arquivo deve conter a sufixo Test.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;executando-de-forma-simples&#34;&gt;Executando de forma simples&lt;/h2&gt;

&lt;p&gt;Como o PHPUnit foi instalado a partir do composer, é a partir da estrutura montada pelo mesmo que este será executado digitando no terminal&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;./vendor/bin/phpunit&lt;/pre&gt;

&lt;p&gt;Com isto uma tela de ajuda deve aparecer com todas as opções disponíveis para a utilização do PHPUnit. Seguem as definições do comando que será executado neste primeiro momento.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #000080&#34;&gt;./vendor/bin/phpunit&lt;/span&gt; &lt;span style=&#34;color: #333333&#34;&gt;&amp;#8211;colors&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;#8211;debug&lt;/span&gt; &lt;span style=&#34;color: #800000&#34;&gt;tests/PHPNativeElements &lt;/span&gt;onde:&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #000080&#34;&gt;./vendor/bin/phpunit&lt;/span&gt;: o próprio executável do PHPUnit&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #333333&#34;&gt;&amp;#8211;colors&lt;/span&gt;: habilita coloração ( assim podemos ver os estágios vermelho-verde de forma mais simples)&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #008000&#34;&gt;&amp;#8211;debug&lt;/span&gt;: habilita o modo debug para detalhamento das ações que estão sendo tomadas durante os testes – Esta ação serve como ótima documentação como já mencionado em meu artigo anterior.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #800000&#34;&gt;tests/PHPNativeElements&lt;/span&gt;: o nome da classe de testes a ser testada.&lt;/p&gt;

&lt;p&gt;Ao rodarmos o comando acima a mensagem resultante deverá ser a de que não há testes disponíveis na classe testada.&lt;/p&gt;

&lt;div id=&#34;attachment_40050&#34; style=&#34;width: 484px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40050  &#34; alt=&#34;PHPUnit - Falta de testes&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/6-falta-de-testes-474x310.png&#34; width=&#34;474&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/6-falta-de-testes-474x310.png 474w, uploads/2013/12/6-falta-de-testes-256x168.png 256w, uploads/2013/12/6-falta-de-testes.png 881w&#34; sizes=&#34;(max-width: 474px) 100vw, 474px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Informação de que ainda não há testes
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;fazendo-o-primeiro-teste-passar&#34;&gt;Fazendo o primeiro teste passar&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;O TDD define que o desenvolvimento deve ser orientado a testes, com isso, criaremos primeiramente a expectativa na nossa classe de testes e em seguida a implementação no código de produção.&lt;/p&gt;

&lt;p&gt;Após o método &lt;em&gt;tearDown&lt;/em&gt; que já encontra-se na classe &lt;em&gt;PHPNativeElementsTest&lt;/em&gt; crie um método chamado &lt;em&gt;testOperacaoMatematica&lt;/em&gt;. Assim como a classe de teste possui uma convenção com os métodos também é necessário especificar qual trata-se de um teste a partir do prefixo &lt;em&gt;test.&lt;/em&gt; Por este motivo nosso primeiro caso de teste se chamar testOperacaoMatematica. Caso não contenha o prefixo test e, não sendo os métodos setUp e tearDown, o PHPUnit simplesmente não executa o método.&lt;/p&gt;

&lt;p&gt;Como estamos utilizando o Autoloader, em nossa classe de teste usaremos o namespace &amp;#8220;_Application_&lt;em&gt;NativeElements\Math&amp;#8221;&lt;/em&gt; para carregar a nossa classe que será testada a partir da classe de testes. Como atributo de nossa classe de teste adicionaremos &amp;#8220;$math&amp;#8221; e nele instanciaremos a classe _Application_&lt;em&gt;NativeElements\Math&lt;/em&gt; dentro do método &lt;em&gt;setUp&lt;/em&gt;.&lt;/p&gt;

&lt;div id=&#34;attachment_40052&#34; style=&#34;width: 434px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40052 &#34; alt=&#34;PHPUnit - Nova estrutura da classe de teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/7-nova-estrutura-classe-de-testes1-424x310.png&#34; width=&#34;424&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/7-nova-estrutura-classe-de-testes1-424x310.png 424w, uploads/2013/12/7-nova-estrutura-classe-de-testes1-230x168.png 230w, uploads/2013/12/7-nova-estrutura-classe-de-testes1.png 804w&#34; sizes=&#34;(max-width: 424px) 100vw, 424px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Nova estrutura da classe de teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Ao rodarmos novamente o PHPUnit o teste simplesmente quebra. Isto porque a classe&lt;/p&gt;

&lt;p&gt;_Application_&lt;em&gt;NativeElements\Math&lt;/em&gt; ainda não existe. Este é o próximo passo, o código que fará o testes passar.&lt;/p&gt;

&lt;div id=&#34;attachment_40053&#34; style=&#34;width: 498px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40053 &#34; alt=&#34;PHPUnit - Quebra do teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/8-quebra-do-teste-488x310.png&#34; width=&#34;488&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/8-quebra-do-teste-488x310.png 488w, uploads/2013/12/8-quebra-do-teste-264x168.png 264w, uploads/2013/12/8-quebra-do-teste.png 875w&#34; sizes=&#34;(max-width: 488px) 100vw, 488px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Quebra do teste por não existir a classe testada
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Criamos o arquivo&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Math.php&lt;/em&gt; dentro do diretório &lt;em&gt;Application/NativeElements&lt;/em&gt; e no mesmo a classe &lt;em&gt;Math&lt;/em&gt; definindo como namespace &lt;em&gt;Application\NativeElements&lt;/em&gt;. Por hora nenhum método é criado nesta nova classe.&lt;/p&gt;

&lt;div id=&#34;attachment_40056&#34; style=&#34;width: 514px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40056 &#34; alt=&#34;PHPUnit - Classe de produção, nela os problemas criados nos testes serão solucionados&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/9-class-504x310.png&#34; width=&#34;504&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/9-class-504x310.png 504w, uploads/2013/12/9-class-273x168.png 273w, uploads/2013/12/9-class.png 955w&#34; sizes=&#34;(max-width: 504px) 100vw, 504px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Classe de produção, nela os problemas criados nos testes serão solucionados
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Rodando nosso teste novamente ele quebra mais uma vez. Agora o que está faltando é o método testado (&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sum&lt;/em&gt; ).&lt;/p&gt;

&lt;div id=&#34;attachment_40057&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40057 &#34; alt=&#34;PHPUnit - Faltando método sum&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/10-method-missing-588x289.png&#34; width=&#34;588&#34; height=&#34;289&#34; srcset=&#34;uploads/2013/12/10-method-missing-588x289.png 588w, uploads/2013/12/10-method-missing-329x162.png 329w, uploads/2013/12/10-method-missing-628x310.png 628w, uploads/2013/12/10-method-missing.png 880w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Faltando método sum
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Ao criar o método sum e sua lógica estando correta o teste atual passará, então passamos do estágio vermelho para o estágio verde. Como este exemplo é uma simples operação matemática muito provavelmente não será necessária uma refatoração. No entanto sendo um lógica mais complexa o ideal é que sempre comece testando pequenos passos, que são chamados de baby steps ou passos de bebê. Ao se deparar com uma situação complexa em que o resultado depende de N variáveis, trata-se sempre o meio mais simples e os testes passando passa-se a procurar solucionar uma nova condição para o resultado.&lt;/p&gt;

&lt;div id=&#34;attachment_40058&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40058 &#34; alt=&#34;PHPUnit - Método com a lógica necessária e primeiro teste passando&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/11-pass-588x262.png&#34; width=&#34;588&#34; height=&#34;262&#34; srcset=&#34;uploads/2013/12/11-pass-588x262.png 588w, uploads/2013/12/11-pass-329x146.png 329w, uploads/2013/12/11-pass-660x294.png 660w, uploads/2013/12/11-pass.png 1364w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Método com a lógica necessária e primeiro teste passando
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Agora basta adicionar os asserts para as demais operações matemáticas.&lt;/p&gt;

&lt;div id=&#34;attachment_40059&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40059 &#34; alt=&#34;PHPUnit - Outros métodos de operações matemáticas simples&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/12-other-methods-588x272.png&#34; width=&#34;588&#34; height=&#34;272&#34; srcset=&#34;uploads/2013/12/12-other-methods-588x272.png 588w, uploads/2013/12/12-other-methods-329x152.png 329w, uploads/2013/12/12-other-methods-660x305.png 660w, uploads/2013/12/12-other-methods.png 1358w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Outros métodos de operações matemáticas simples
  &lt;/p&gt;
&lt;/div&gt;

&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;

&lt;blockquote&gt;
&lt;p&gt;Como pode ser percebido, como terceiro parâmetro do assert foi adicionada uma mensagem opcional, isso para que ao dar erro da asserção tal mensagem seja exibida, conforme a imagem seguinte.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div id=&#34;attachment_40060&#34; style=&#34;width: 507px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40060 &#34; alt=&#34;PHPUnit - Mensagem de erro de asserção&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/13-message-497x310.png&#34; width=&#34;497&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/13-message-497x310.png 497w, uploads/2013/12/13-message-269x168.png 269w, uploads/2013/12/13-message.png 809w&#34; sizes=&#34;(max-width: 497px) 100vw, 497px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Mensagem de erro de asserção
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;refatorando&#34;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Agora voltando ao código originado na classe&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Math&lt;/em&gt;, dá pra perceber que há muita repetição pois todos os métodos recebem dois valores e retornam uma operação correspondente. Como utilizando TDD temos segurança em desenvolver, podemos tranquilamente remover tais repetições criando uma interface onde é previamente definida a operação a ser realizada e retorna o resultado desta operação. Obviamente com esta atitude o teste também sofrerá alterações e isso é algo comum pois uma aplicação está sempre evoluindo.&lt;/p&gt;

&lt;p&gt;Frenta à necessidade de refatoração novamente começamos a partir do teste e ele fica como na imagem a seguir:&lt;/p&gt;

&lt;div id=&#34;attachment_40061&#34; style=&#34;width: 498px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40061 &#34; alt=&#34;PHPUnit - Alterações na classe de teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/14-test-refactor-488x310.png&#34; width=&#34;488&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/14-test-refactor-488x310.png 488w, uploads/2013/12/14-test-refactor-264x168.png 264w, uploads/2013/12/14-test-refactor.png 899w&#34; sizes=&#34;(max-width: 488px) 100vw, 488px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Alterações na classe de teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Com a refatoração nossa classe Math é modificada e criada uma interface:&lt;/p&gt;

&lt;div id=&#34;attachment_40063&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40063 &#34; alt=&#34;PHPUnit - refatoração da classe Math&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/15-refactor-588x284.png&#34; width=&#34;588&#34; height=&#34;284&#34; srcset=&#34;uploads/2013/12/15-refactor-588x284.png 588w, uploads/2013/12/15-refactor-329x159.png 329w, uploads/2013/12/15-refactor-640x310.png 640w, uploads/2013/12/15-refactor.png 1354w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Refatoração da classe Math
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;E agora rodando novamente o teste após a refatoração, simplesmente continuamos com tudo verde, ou seja, alteramos muito a forma de implementação de uma classe e ela continua executando seu papel como deve.&lt;/p&gt;

&lt;div id=&#34;attachment_40064&#34; style=&#34;width: 587px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40064 &#34; alt=&#34;PHPUnit - Teste passando após refatoração&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/16-refactor-pass-577x310.png&#34; width=&#34;577&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/16-refactor-pass-577x310.png 577w, uploads/2013/12/16-refactor-pass-313x168.png 313w, uploads/2013/12/16-refactor-pass.png 818w&#34; sizes=&#34;(max-width: 577px) 100vw, 577px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Teste passando após refatoração
  &lt;/p&gt;
&lt;/div&gt;

&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;

&lt;blockquote&gt;
&lt;p&gt;Este é apenas um exemplo didático de refatoração, mas mesmo com ele dá pra perceber como houve a anulação de código repetido e para um futura manutenção basta que mexa-se em um local somente para que surta efeitos à todas as operações matemáticas.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Neste artigo foi abordado apenas a instalação do PHPUnit e a execução de um teste muito simples. Para testes mais avançados serão criados novos artigos sempre em sequência para que o estudo de desenvolvimento orientado a testes siga um fluxo sadio. Já fora criado um artigo explicando os por ques de se utilizar e não se utilizar TDD que encontra-se neste&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar&#34; title=&#34;Ler mais sobre TDD&#34;&gt;link&lt;/a&gt; e é o primeiro artigo da sequência.&lt;/p&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Os próximos artigos seguirão a sequência abaixo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configurações avançadas – Apenas uma breve abordagem de como realizar configurações avançadas na execução do PHPUnit gerando reports como coverage.&lt;/li&gt;
&lt;li&gt;Persistência – Será utilizado o ORM Doctrine para complementarmos o projeto&lt;/li&gt;
&lt;li&gt;Mockery – Utilizando objetos simulados para atender certos comportamentos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Você pode baixar o código-fonte dos exemplos apresentados aqui no &lt;a title=&#34;Ir para o repositório de exemplos desenvolvidos neste artigo&#34; href=&#34;https://github.com/andrebian/phpunit-como-iniciar-sem-dores&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TDD, por que usar?</title>
      <link>https://tableless.github.io/hugo-public/tdd-por-que-usar/</link>
      <pubDate>Tue, 17 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/tdd-por-que-usar/</guid>
      <description>

&lt;p&gt;TDD é o desenvolvimento de software orientado a testes, ou em inglês, &lt;a title=&#34;Test Driven Development&#34; href=&#34;http://pt.wikipedia.org/wiki/Test_Driven_Development&#34; target=&#34;_blank&#34;&gt;Test Driven Development&lt;/a&gt;. Mas mais do que simplesmente testar seu código, TDD é uma filosofia, uma cultura. Neste artigo você conhecerá um pouco sobre sua motivação e também saberá os fatores que contribuem e dificultam sua prática.&lt;/p&gt;

&lt;h2 id=&#34;por-que-muitos-não-praticam&#34;&gt;Por que muitos não praticam?&lt;/h2&gt;

&lt;p&gt;Muitos fatores contribuem para que inúmeros programadores deixem de utilizar TDD logo no início. Alguns deles são:&lt;/p&gt;

&lt;h3 id=&#34;dificuldade-em-começar&#34;&gt;Dificuldade em começar&lt;/h3&gt;

&lt;p&gt;Apesar de uma extensa e clara documentação, iniciar o desenvolvimento orientado a testes pode ser um trabalho árduo para muitos pelo simples fato de que geralmente muitos iniciantes tentam praticá-lo em código já existente. Este definitivamente não é o caminho. A principal característica do desenvolvimento orientado a testes é que ele seja orientado a testes. Em outras palavras o código que realizará sua lógica deve ser criado somente após a criação do teste e isso torna-se algo de difícil aceitação pois ainda não se tem nada e já se faz necessário testar.&lt;/p&gt;

&lt;h3 id=&#34;curva-de-apendizado&#34;&gt;Curva de apendizado&lt;/h3&gt;

&lt;p&gt;Complementando o item anterior, este é outro motivo que faz programadores desistirem do desenvolvimento orientado a testes. Como qualquer nova tecnologia, para a pratica de TDD leva-se um bom tempo dependendo disponibilidade e principalmente da vontade do programador.&lt;/p&gt;

&lt;p&gt;Tempo&lt;/p&gt;

&lt;p&gt;Engana-se quem pensa que produzirá mais código pelo simples fato de utilizar TDD. O TDD na verdade chega a desacelerar a produção de código. Quando falo em produção de código, me refiro à quantidade de linhas escritas. Mas nisso tudo há vantagens e elas serão descritas mais a frente.&lt;/p&gt;

&lt;h3 id=&#34;cultura&#34;&gt;Cultura&lt;/h3&gt;

&lt;p&gt;Muito fala-se de TDD no Brasil, mas ao questionarmos programadores de diversas empresas muitos apresentam os motivos citados acima para não utilizá-lo. Existem sim muitas empresas e programadores que levam a prática a sério e a evangelizam justamente por conhecerem as vantagens que o TDD nos traz.&lt;/p&gt;

&lt;h2 id=&#34;nem-tudo-é-tão-ruim&#34;&gt;Nem tudo é tão ruim&lt;/h2&gt;

&lt;p&gt;Vistos alguns pontos que dificultam programadores a aderirem ao TDD, listamos agora alguns benefícios que esta prática nos fornece.&lt;/p&gt;

&lt;h3 id=&#34;qualidade-do-código&#34;&gt;Qualidade do código&lt;/h3&gt;

&lt;p&gt;Um dos principais ensinamentos, senão o principal, do TDD é que se algo não é possível de ser testado então foi desenvolvido de forma errada. Parece um pouco drástico mas não é. Em pouco tempo utilizando testes o programador percebe mudanças relevantes em sua forma de programar. Em suma o uso de TDD ajuda o programador a elaborar um código com cada vez mais qualidade criando objetos concisos e com menos dependências.&lt;/p&gt;

&lt;h3 id=&#34;raciocínio&#34;&gt;Raciocínio&lt;/h3&gt;

&lt;p&gt;Para que o código torne-se mais conciso, tenha menos acoplamentos e dependências o programador deve forçar seu raciocínio a níveis elevados. É muito difícil criar algo que realmente tenha um bom design. Utilizando TDD o programador praticamente obriga-se a olhar seu código de outra forma normalmente jamais vista antes. Aí é que está a parte legal da coisa toda.&lt;/p&gt;

&lt;h3 id=&#34;segurança&#34;&gt;Segurança&lt;/h3&gt;

&lt;p&gt;Ponto importantíssimo para qualquer software nos dias de hoje. Mas não se engane, não estou falando de segurança da informação e sim de segurança ao desenvolver. Pense em uma situação em que o programador tenha um código que desenvolvera ha cerca de um ano. Como normalmente vivemos em um mundo com inúmeros softwares desenvolvidos ao longo de cada ano, torna-se muito difícil lembrar de tudo a respeito de um que merece nossa atenção em determinado momento. Normalmente deve-se realizar um trabalho bastante cauteloso para nova implementação em um software que encontra-se em produção. Toda e qualquer alteração deve ser minunciosamente testada e garantida que não afetará demais módulos do software. Fazer isto manualmente é realmente complicado pois até então não sabe-se (ou lembra-se) ao certo quem afeta quem no sistema. Com a prática de TDD cada pequeno passo do software está devidamente testado. Ou seja, com este cenário o programador pode realizar qualquer alteração sem medo e sem culpa.&lt;/p&gt;

&lt;p&gt;Como cada pequeno passo tomado pelo sistema está testado ao qualquer módulo ou funcionalidade sofrer alteração, com poucos segundos descobre-se se houveram quebras e o melhor de tudo, onde foram essas quebras. Com isso em mãos a correção das quebras torna-se uma tarefa simples sem frustrar o cliente e o usuário.&lt;/p&gt;

&lt;h3 id=&#34;trabalho-em-equipe&#34;&gt;Trabalho em equipe&lt;/h3&gt;

&lt;p&gt;Por prover mais segurança o trabalho em equipe torna-se muito mais proveitoso eliminando discussões e dúvidas desnecessárias. Ao entrar no desenvolvimento do projeto o novo desenvolvedor tem apenas o trabalho de entender qual task deve ser realizada e ler os testes das features já desenvolvidas. Ao rodar os testes pela primeira vez o programador descobre se está no caminho de ter um entregável mais rapidamente e com segurança. Existem empresas em que um novo programador tem entregáveis logo no primeiro dia de trabalho. Sem testes normalmente haveria um período de adaptação para prévio entendimento do que há no sistema no momento de seu ingresso ao time de desenvolvimento.&lt;/p&gt;

&lt;h3 id=&#34;documentação&#34;&gt;Documentação&lt;/h3&gt;

&lt;p&gt;Ao criar testes descritivos estes servem como uma excelente documentação para o software. Quando qualquer programador for rodar os testes, basta habilitar o modo verbose que uma “história” é contada eliminando o árduo trabalho de documentar um software onde nos meios tradicionais tende a defasar-se. O problema é que a documentação tradicional raramente segue o mesmo ritmo do desenvolvimento. Com os testes unitários a “documentação” é gerada antes mesmo da nova feature ser implementada e permanece fiel a qualquer alteração.&lt;/p&gt;

&lt;h2 id=&#34;o-que-resume-se-disto-tudo&#34;&gt;O que resume-se disto tudo?&lt;/h2&gt;

&lt;p&gt;Até aqui temos os pontos negativos e positivos do desenvolvimento orientado a testes. Agora vamos aprender um pouco sobre o que é TDD.&lt;/p&gt;

&lt;p&gt;O TDD (Test Driven Development) baseia-se em três passos, vermelho-verde-refatora. O vermelho é a escrita do primeiro teste antes mesmo da lógica existir. O verde é o ponto em que a lógica para que o teste previamente criado passe. Esta lógica deve ser desenvolvida da forma mais simples possível eliminando complexidades desnecessárias fazendo com que a evolução do código ocorra de forma segura. O refatora é a melhoria do código. Neste ponto são removidas duplicações, múltiplas responsabilidades e o código fica cada vez mais próximo de sua versão final.&lt;/p&gt;

&lt;p&gt;Para que o processo vermelho-verde-refatora seja de fato implementado, utiliza-se baby steps ou passos de bebê. Esta técnica consiste em realizar um pequeno passo de cada vez, se uma lógica é complexa de ser desenvolvida ela é dividida em muitas pequenas partes que evoluem até sua solução final. Obviamente que esta técnica é aplicável preferencialmente em processos complexos que dependem de muitas variáveis. Para processos simples nem sempre é a mais indicada.&lt;/p&gt;

&lt;p&gt;Os testes devem ser unitários. Isto implica em um teste automatizado certificar-se de apenas uma funcionalidade do código utilizando para isso quantos asserts forem necessários. Por serem testes automatizados são fácil e rapidamente executados eliminando testes manuais que encarecem o software em vários aspectos. Devido à dinâmica de tais testes é possível vincular o software com ferramentas de integração contínua como Jenkins reduzindo ainda mais o custo (tempo de desenvolvimento) do mesmo.&lt;/p&gt;

&lt;p&gt;Concluindo&lt;/p&gt;

&lt;p&gt;Como ficou claro a prática do desenvolvimento orientado a testes pode ser penosa para quem está começando mas muito satisfatória para quem já a tem como parte de seu dia a dia. Ao utilizar TDD o programador “perde” em linhas de código por hora mas ganha horas, dias, quem sabe até semanas na prevenção de novos erros e correção dos que ocorrem durante a implementação de uma nova feature. Detalhe que o método TDD parte do princípio que o teste sempre deve ser implementado antes do código de produção.&lt;/p&gt;

&lt;p&gt;Em suma tudo vai depender to porte do projeto em que se está trabalhando, da cultura da empresa e da vontade de programadores mas sabe-se que quem utiliza TDD reconhece suas vantagens.&lt;/p&gt;

&lt;p&gt;Agora que você já tem uma noção do que é TDD, suas vantagens e desvantagens, sugiro a ler sobre &lt;a title=&#34;xUnit - Framework de testes unitários&#34; href=&#34;http://www.martinfowler.com/bliki/Xunit.html&#34; target=&#34;_blank&#34;&gt;xUnit&lt;/a&gt;. O xUnit é um framework de testes disponível para várias linguagens de programação. Em PHP temos o &lt;a title=&#34;PHPUnit - Framework de testes unitários para PHP&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/automating-tests.html&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt;, em java o &lt;a title=&#34;jUnit - Framework de testes unitários para Java&#34; href=&#34;http://junit.org/&#34; target=&#34;_blank&#34;&gt;jUnit&lt;/a&gt; e demais linguagens possuem seus frameworks que tem a mesma finalidade, criar um ecossistema para que o programador desenvolva orientando-se a testes.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>