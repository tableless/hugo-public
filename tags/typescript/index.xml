<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Typescript on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/typescript/index.xml</link>
    <description>Recent content in Typescript on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/typescript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Angular 2, vale a pena?</title>
      <link>https://tableless.github.io/hugo-public/angular-2-vale-pena/</link>
      <pubDate>Fri, 02 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/angular-2-vale-pena/</guid>
      <description>

&lt;p&gt;Ultimamente, com o boom do JavaScript, os desenvolvedores front end se depararam com a difícil questão: qual framework e/ou biblioteca usar em meu projeto? A resposta é: depende do que você está procurando. Construir uma SPA completa? Uma aplicação híbrida? Ou apenas um simples formulário? O objetivo aqui não é enumerar as diferenças entre todas as várias ferramentas existentes no mercado, e sim focar no Angular, a que considero mais completa e que pode atender a todos os objetivos de um projeto.&lt;/p&gt;

&lt;p&gt;O Angular, apesar de ter sido pensado inicialmente para lidar apenas com formulários, é hoje uma das ferramentas mais largamente utilizada para desenvolvimento front end, porém, sempre teve seus problemas, dentre eles, os problemas de performance. E é esse um dos principais motivos que levou a equipe do Angular a desenvolver, do zero, a sua versão 2.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&#34;https://angular-2-training-book.rangle.io/handout/why_angular_2.html&#34; target=&#34;_blank&#34;&gt;rangle.io&lt;/a&gt; listou as principais diferenças entre o Angular 1 e o 2:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;“_Transitional Architecture_” se refere ao estilo de programação no Angular 1 de forma a se aproximar o máximo possível do Angular 2, mas com &lt;em&gt;Controllers&lt;/em&gt; e _Diretivas,_ ao invés de classes TypeScript.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-56319 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2016/10/Captura-de-Tela-2016-10-27-às-10.28.09.png&#34; alt=&#34;Comparação Angular 1 e 2 do rangle.io&#34; width=&#34;718&#34; height=&#34;274&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;mas-e-aí-vale-ou-não-a-pena&#34;&gt;Mas e aí, vale ou não a pena?&lt;/h2&gt;

&lt;h3 id=&#34;adoção&#34;&gt;Adoção&lt;/h3&gt;

&lt;p&gt;A preocupação da maioria das pessoas é simplesmente não saber se Angular 2 vai realmente “vingar”, e acabam ficando com receio de migrar. Fazendo uma simples pesquisa no Google Trends, é possível comparar a popularidade do termo Angular 2, comparado a VueJS e ReactJS, as ferramentas que estão mais em alta atualmente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-56321 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2016/10/trends.jpg&#34; alt=&#34;Comparação entre AngularJS, VueJS e ReactJS&#34; width=&#34;1118&#34; height=&#34;357&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mobile&#34;&gt;Mobile&lt;/h3&gt;

&lt;p&gt;Se você pretende desenvolver aplicativos híbridos, cá está mais um excelente motivo para usar Angular 2, a equipe do Ionic está finalizando o desenvolvimento da sua segunda versão, que é totalmente escrita em Angular 2.&lt;/p&gt;

&lt;h3 id=&#34;typescript&#34;&gt;TypeScript&lt;/h3&gt;

&lt;p&gt;Uma vez que a maioria dos navegadores não estão habilitados para rodar ES6 e ES7, surgiram alguns pré-compiladores, que geram todo o código para o JavaScript “entendível” pelo navegador. Mas o Typescript vai um pouco mais longe.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-56324 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2016/10/v94tyy.jpg&#34; alt=&#34;Meme TypeScript&#34; width=&#34;512&#34; height=&#34;358&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O TypeScript, criado pela Microsoft (isso mesmo), é um “_superset_” do JavaScript, que, além de implementar as funcionalidades do ES6+, traz uma série de “poderes” no desenvolvimento. Uma das coisas que eu gosto bastante, é a capacidade de &lt;em&gt;autocomplete&lt;/em&gt; nas IDEs (se você tiver uma que suporte, como o Sublime Text ou VSCode). Mas acredito que o mais interessante é a parte de organização do código. O TypeScript tem uma sintaxe muito mais clara e fácil de entender. Abaixo um mesmo código escrito em TypeScript e JavaScript:&lt;/p&gt;

&lt;p&gt;TypeScript:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class HelloWorld {
  text: string;
  constructor(text: string) {
    this.text = text;
  }
}
let txt = new HelloWorld(&#34;Olá mundo!&#34;);
console.log(txt);
&lt;/pre&gt;

&lt;p&gt;JavaScript:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var HelloWorld = (function () {
  function HelloWorld(text) {
    this.text = text;
  }
return HelloWorld;
}());
var txt = new HelloWorld(&#34;Olá mundo!&#34;);
console.log(txt);&lt;/pre&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;Um ponto muito importante de destaque é a performance. O Angular 1, de fato, oferece uma experiência de baixa performance devido a excessivas interações com a DOM. O Angular 2 vem pra resolver esse problema de uma vez por todas. O gráfico abaixo, feito pela &lt;a href=&#34;https://auth0.com/blog/more-benchmarks-virtual-dom-vs-angular-12-vs-mithril-js-vs-the-rest/&#34; target=&#34;_blank&#34;&gt;auth0&lt;/a&gt;, mostra, na prática o resultado do &lt;em&gt;benchmark&lt;/em&gt; que eles realizaram:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-56328 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2016/10/angular2-grafico.png&#34; alt=&#34;angular2 grafico por auth0&#34; width=&#34;615&#34; height=&#34;338&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;O Angular 2 veio pra ficar, além de ser uma ferramenta que evoluiu, ter uma grande empresa como o Google por trás só ajuda. A adoção deste framework só tende a crescer mais, e, sim, vale muito a pena usar em seus projetos.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gerenciando módulos no TypeScript</title>
      <link>https://tableless.github.io/hugo-public/gerenciando-modulos-no-typescript/</link>
      <pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/gerenciando-modulos-no-typescript/</guid>
      <description>

&lt;p&gt;Como vimos no &lt;a href=&#34;http://tableless.com.br/diga-ola-ao-typescript-e-adeus-ao-javascript/&#34;&gt;artigo anterior&lt;/a&gt;, com TypeScript podemos programar de forma orientada a objetos, criando classes, interfaces, get/set etc, e compilar tudo isso para JavaScript. Neste artigo veremos como criar módulos e separar classes e funcionalidades em arquivos distintos, de forma a tornar o nosso projeto mais organizado.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Para instalar o TypeScript, você precisa ter o Node.js, juntamente com o NPM. Execute o comando &lt;code&gt;npm install typescript -g&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Existem diversas formas de trabalhar com módulos no typeScript, sendo as 3 mais comuns descritas a seguir:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Combinando tudo em um arquivo somente&lt;/strong&gt;: Esta é a forma mais fácil de utilizar TypeScript. Primeiro criamos vários arquivos separados, com a extensão &lt;code&gt;ts&lt;/code&gt; e depois executamos o comando &lt;code&gt;tsc&lt;/code&gt; para juntar tudo em um único arquivo. Veja que todos os arquivos TypeScript serão agrupados, o que pode não ser uma boa prática de programação, principalmente para projetos muito extensos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inclusão dinâmica pelo webserver&lt;/strong&gt;: Neste método todos os arquivos &lt;code&gt;ts&lt;/code&gt; terão o seu correspondente &lt;code&gt;js&lt;/code&gt;, na qual serão carregados de forma dinâmica, via ajax. Como estamos utilizando um carregamento dinâmico, precisamos utilizar a biblioteca RequireJS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inclusão dinâmica pelo node&lt;/strong&gt;: Nesta forma criamos uma estrutura para ser executada diretamente pelo Node.JS, utilizando o padrão commonjs. Não usaremos este conceito aqui porque queremos ilustrar como utilizar o TypeScript em um site.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;combinando-todos-os-arquivos-em-um-só&#34;&gt;Combinando todos os arquivos em um só&lt;/h2&gt;

&lt;p&gt;Esta forma é a mais simples e pode ser usada na maioria dos seus projetos web. Vamos inicialmente criar a pasta &lt;code&gt;teste1&lt;/code&gt; e nela criaremos duas pastas: &lt;code&gt;src&lt;/code&gt; e &lt;code&gt;build&lt;/code&gt;. A pasta src contém o código fonte da aplicação, os arquivos TypeScript. A pasta build conterá o código JavaScript gerado pelo TypeScript. Na pasta &lt;code&gt;src&lt;/code&gt;, criaremos 3 arquivos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pessoa.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;class Pessoa{
    nome : string;
    constructor(nome:string){
        this.nome = nome;
    }
}
&lt;/pre&gt;

&lt;p&gt;Este primeiro arquivo é uma classe simples, com um parâmetro e o método construtor. A próxima classe será chamada de &lt;code&gt;Aluno&lt;/code&gt;, que irá estender da classe &lt;code&gt;Pessoa&lt;/code&gt;. Como a classe Aluno usa a classe Pessoa (que está em outro arquivo), precisamos importá-la e isso é feito da seguinte forma: &lt;code&gt;/// &amp;lt;reference path=&amp;quot;&amp;quot; /&amp;gt;&lt;/code&gt;. O parâmetro &lt;code&gt;path&lt;/code&gt; é justamente a classe que se deseja referenciar. Então temos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aluno.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;

class Aluno extends Pessoa{
    matricula : string;
    
    constructor(nome:string,matricula:string){
        super(nome);
        this.matricula=matricula;
    }
}
&lt;/pre&gt;

&lt;p&gt;Nesta classe referenciamos na primeira linha a classe &lt;code&gt;Pessoa&lt;/code&gt;, informando o nome do arquivo &lt;code&gt;pessoa.ts&lt;/code&gt;. Depois criamos a classe &lt;code&gt;Aluno&lt;/code&gt;, que herda de Pessoa. Na classe &lt;code&gt;Aluno&lt;/code&gt; criamos o parâmetro &lt;code&gt;matricula&lt;/code&gt;, e no seu construtor usamos a palavra &lt;code&gt;super&lt;/code&gt; para referenciar o construtor da classe pai, que neste caso é &lt;code&gt;Pessoa&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Com as duas classes prontas, podemos finalmente criar o arquivo &lt;code&gt;index.ts&lt;/code&gt;, que é o arquivo principal do projeto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;aluno.ts&#34; /&amp;gt

var a = new Aluno(&#34;Joãozinho&#34;,&#34;0001&#34;);
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Veja que não é preciso adicionar a classe pessoa. Ela será adicionada na classe aluno&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Veja que o arquivo principal faz uma referência a classe &lt;code&gt;Aluno&lt;/code&gt;, do arquivo &lt;code&gt;aluno.ts&lt;/code&gt;. Com os três arquivos prontos, podemos usar o comando &lt;code&gt;tsc&lt;/code&gt; para compilar tudo em um único arquivo. Este comando é executado a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts05.png&#34; alt=&#34;ts05&#34; width=&#34;819&#34; height=&#34;580&#34; class=&#34;aligncenter size-full wp-image-52470&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nesta imagem usamos o comando &lt;code&gt;tree&lt;/code&gt; do DOS apenas para mostrar que o arquivo &lt;code&gt;script.js&lt;/code&gt; foi criado. O principal comando é o:&lt;/p&gt;

&lt;pre&gt;tsc ./src/index.ts --out ./build/script.js
&lt;/pre&gt;

&lt;p&gt;Este comando possui como primeiro parâmetro o arquivo ts inicial que neste caso é o &lt;code&gt;index.ts&lt;/code&gt;. O parâmetro &lt;code&gt;--out&lt;/code&gt; indica o nome do arquivo que será gerado pela compilação do TypeScript em JavaScript. Este arquivo é exibido a seguir:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build/script.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;var Pessoa = (function () {
    function Pessoa(nome) {
        this.nome = nome;
    }
    return Pessoa;
})();
/// &amp;lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Aluno = (function (_super) {
    __extends(Aluno, _super);
    function Aluno(nome, matricula) {
        _super.call(this, nome);
        this.matricula = matricula;
    }
    return Aluno;
})(Pessoa);
/// &amp;lt;reference path=&#34;aluno.ts&#34; /&amp;gt;
var a = new Aluno(&#34;Joãozinho&#34;, &#34;0001&#34;);
&lt;/pre&gt;

&lt;h2 id=&#34;utilizando-módulos&#34;&gt;Utilizando módulos&lt;/h2&gt;

&lt;p&gt;O uso de módulos na aplicação faz com que as classes não pertençam mais ao escopo global, como Pessoa e Aluno pertenciam no exemplo anterior. Vamos fazer uma refatoração no código e adicionar a criação de módulos no escopo da aplicação. Suponha que a classe Pessoa pertença ao módulo &amp;#8220;comum&amp;#8221; e que a classe Aluno pertença ao módulo &amp;#8220;ensino&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pessoa.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;u&gt;&lt;strong&gt;module&lt;/strong&gt;&amp;lt;/u&gt; comum {
    &lt;strong&gt;&amp;lt;u&gt;export&amp;lt;/u&gt;&lt;/strong&gt; class Pessoa{
        nome : string;
        constructor(nome:string){
            this.nome = nome;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Deixamos sublinhado as 2 palavras que são novidade neste código. A primeira é a palavra &lt;code&gt;module&lt;/code&gt;, seguida do nome do seu módulo que neste caso é &amp;#8220;comum&amp;#8221;. Dentro do módulo &amp;#8220;comum&amp;#8221; temos a classe Pessoa, e nela usamos a palavra &lt;code&gt;export&lt;/code&gt; que diz ao módulo que esta classe é pública ao módulo. Podemos incluir no módulo classes, variáveis, métodos etc. Para expôr estas classes a outros módulos, usamos export.&lt;/p&gt;

&lt;p&gt;A classe Aluno é refatorada para o seguinte código:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aluno.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;
module ensino{
    export class Aluno extends &lt;strong&gt;&amp;lt;u&gt;comum.Pessoa&amp;lt;/u&gt;&lt;/strong&gt;{
        matricula : string;
        
        constructor(nome:string,matricula:string){
            super(nome);
            this.matricula=matricula;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;A classe Aluno agora é do módulo &lt;code&gt;ensino&lt;/code&gt; e como novidade temos a referência da classe Pessoa como &lt;code&gt;comum.Pessoa&lt;/code&gt;. Isso é necessário já que estamos modularizando a aplicação. Finalmente, a classe &lt;code&gt;index.ts&lt;/code&gt; é refatorada para:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;aluno.ts&#34; /&amp;gt;

var a = new ensino.Aluno(&#34;Joãozinho&#34;,&#34;0001&#34;);
&lt;/pre&gt;

&lt;p&gt;Como novidade temos a chamada da classe Aluno como &lt;code&gt;ensino.Aluno&lt;/code&gt;. Com estas mudanças, podemos executar novamente a compilação:&lt;/p&gt;

&lt;pre&gt;tsc ./src/index.ts --out ./build/script.js
&lt;/pre&gt;

&lt;p&gt;e obteremos o seguinte resultado:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build/script.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;var comum;
(function (comum) {
    var Pessoa = (function () {
        function Pessoa(nome) {
            this.nome = nome;
        }
        return Pessoa;
    })();
    comum.Pessoa = Pessoa;
})(comum || (comum = {}));
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// $lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;
var ensino;
(function (ensino) {
    var Aluno = (function (_super) {
        __extends(Aluno, _super);
        function Aluno(nome, matricula) {
            _super.call(this, nome);
            this.matricula = matricula;
            console.log(this.matricula);
        }
        return Aluno;
    })(comum.Pessoa);
    ensino.Aluno = Aluno;
})(ensino || (ensino = {}));
/// $lt;reference path=&#34;aluno.ts&#34; /&amp;gt;
var a = new ensino.Aluno(&#34;Joãozinho&#34;, &#34;0001&#34;);
&lt;/pre&gt;

&lt;h2 id=&#34;módulos-em-diretórios&#34;&gt;Módulos em diretórios&lt;/h2&gt;

&lt;p&gt;Geralmente a organização de módulos é feita em diretórios, para que todos os arquivos não fiquem em somente um único diretório. No caso anterior, poderíamos (na verdade deveríamos) criar os diretórios &lt;code&gt;src/comum&lt;/code&gt; e &lt;code&gt;src/ensino&lt;/code&gt; e reorganizar as classes de acordo com a imagem a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts06.png&#34; alt=&#34;ts06&#34; width=&#34;186&#34; height=&#34;256&#34; class=&#34;aligncenter size-full wp-image-52476&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A única mudança que precisamos realizar no código é no &lt;code&gt;reference&lt;/code&gt;, que deverá ser:&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;../comum/pessoa.ts&#34; /&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Na classe aluno, como temos que subir um nível para encontrar o diretório &amp;#8220;comum&amp;#8221;, usamos &amp;#8220;../&amp;#8221;.&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;ensino/aluno.ts&#34; /&amp;gt;
&lt;/pre&gt;

&lt;p&gt;No arquivo index.ts, não precisamos usar &amp;#8220;../&amp;#8221; pois estamos no mesmo nível do diretório &lt;code&gt;ensino&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;módulos-externos-com-requirejs&#34;&gt;Módulos externos com requirejs&lt;/h2&gt;

&lt;p&gt;Até este momento todos os módulos estão em um único arquivo de saída, o &lt;code&gt;build/script.js&lt;/code&gt;. Agora desejamos criar uma forma de carregar os módulos sob demanda, ou seja,&lt;/p&gt;

&lt;p&gt;ao invés de carregar tudo de uma vez, vamos carregando os arquivos javascript na medida que eles forem sendo requisitados. Para isso precisamos criar uma estrutura um pouco mais complexa, e também precisaremos utilizar um framework qualquer para carregar módulos. Neste caso usamos o &lt;code&gt;Requirejs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;criando-a-estrutura-inicial&#34;&gt;Criando a estrutura inicial&lt;/h3&gt;

&lt;p&gt;Crie uma nova pasta e copie os arquivos Pessoa.ts, Aluno.ts e index.ts com a mesma estrutura anterior. Ao invés de criarmos o diretório &amp;#8220;build&amp;#8221;, crie o diretório &amp;#8220;public&amp;#8221;, conforme a imagem a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts07.png&#34; alt=&#34;ts07&#34; width=&#34;181&#34; height=&#34;292&#34; class=&#34;aligncenter size-full wp-image-52478&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;redefinido-as-classes&#34;&gt;Redefinido as classes&lt;/h3&gt;

&lt;p&gt;Ao utilizarmos módulos externos precisamos alterar a forma como referenciamos as classes. Ou seja, não usaremos mais o &lt;code&gt;&amp;lt;reference path=&amp;quot;../comum/pessoa.ts&amp;quot; /&amp;gt;&lt;/code&gt; conforme aprendemos, e não será necessário neste momento definir um módulo. Vamos aos ajustes:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;comum/pessoa.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;export class Pessoa{
    nome : string;
    constructor(nome:string){
        this.nome = nome;
    }
}
&lt;/pre&gt;

&lt;p&gt;O que temos agora é o fim do &lt;code&gt;module&lt;/code&gt; e o uso do &lt;code&gt;export&lt;/code&gt; antes do nome da classe. Na classe Aluno, temos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ensino/aluno.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;u&gt;&lt;strong&gt;import comum = require(&#34;../comum/pessoa&#34;)&lt;/strong&gt;&amp;lt;/u&gt;

export class Aluno extends comum.Pessoa{
    matricula : string;
    
    constructor(nome:string,matricula:string){
        super(nome);
        this.matricula=matricula;
    }
}
&lt;/pre&gt;

&lt;p&gt;Alem do fim da palavra &lt;code&gt;module&lt;/code&gt; e do uso do &lt;code&gt;export&lt;/code&gt;, temos uma importante alteração na primeira linha do arquivo &lt;em&gt;aluno.ts&lt;/em&gt;. Estamos utilizando a seguinte sintaxe:&lt;/p&gt;

&lt;pre&gt;import MODULO = require(&#34;caminho&#34;);
&lt;/pre&gt;

&lt;p&gt;Aqui tivemos uma inversão do uso do nome do módulo. Se antes definimos o nome do módulo como &amp;#8220;comum&amp;#8221; na classe &amp;#8220;pessoa&amp;#8221;, agora definimos na própria classe &amp;#8220;aluno&amp;#8221;. Como temos agora o &lt;code&gt;import comum&lt;/code&gt;, podemos usar &lt;code&gt;comum.Pessoa&lt;/code&gt;. O arquivo &lt;code&gt;index.js&lt;/code&gt; é refatorado para:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;import ensino = require(&#34;ensino/aluno&#34;)

var a = new ensino.Aluno(&#34;Joãozinho&#34;,&#34;0001&#34;);
&lt;/pre&gt;

&lt;h3 id=&#34;instalando-o-requirejs&#34;&gt;Instalando o requirejs&lt;/h3&gt;

&lt;p&gt;Precisamos instalar o requirejs no projeto, e podemos fazer isso com npm, através do comando &lt;code&gt;npm i requirejs --save&lt;/code&gt;. Este comando irá instalar o ``Como vimos no &lt;a href=&#34;http://tableless.com.br/diga-ola-ao-typescript-e-adeus-ao-javascript/&#34;&gt;artigo anterior&lt;/a&gt;, com TypeScript podemos programar de forma orientada a objetos, criando classes, interfaces, get/set etc, e compilar tudo isso para JavaScript. Neste artigo veremos como criar módulos e separar classes e funcionalidades em arquivos distintos, de forma a tornar o nosso projeto mais organizado.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Para instalar o TypeScript, você precisa ter o Node.js, juntamente com o NPM. Execute o comando &lt;code&gt;npm install typescript -g&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Existem diversas formas de trabalhar com módulos no typeScript, sendo as 3 mais comuns descritas a seguir:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Combinando tudo em um arquivo somente&lt;/strong&gt;: Esta é a forma mais fácil de utilizar TypeScript. Primeiro criamos vários arquivos separados, com a extensão &lt;code&gt;ts&lt;/code&gt; e depois executamos o comando &lt;code&gt;tsc&lt;/code&gt; para juntar tudo em um único arquivo. Veja que todos os arquivos TypeScript serão agrupados, o que pode não ser uma boa prática de programação, principalmente para projetos muito extensos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inclusão dinâmica pelo webserver&lt;/strong&gt;: Neste método todos os arquivos &lt;code&gt;ts&lt;/code&gt; terão o seu correspondente &lt;code&gt;js&lt;/code&gt;, na qual serão carregados de forma dinâmica, via ajax. Como estamos utilizando um carregamento dinâmico, precisamos utilizar a biblioteca RequireJS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inclusão dinâmica pelo node&lt;/strong&gt;: Nesta forma criamos uma estrutura para ser executada diretamente pelo Node.JS, utilizando o padrão commonjs. Não usaremos este conceito aqui porque queremos ilustrar como utilizar o TypeScript em um site.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;combinando-todos-os-arquivos-em-um-só-1&#34;&gt;Combinando todos os arquivos em um só&lt;/h2&gt;

&lt;p&gt;Esta forma é a mais simples e pode ser usada na maioria dos seus projetos web. Vamos inicialmente criar a pasta &lt;code&gt;teste1&lt;/code&gt; e nela criaremos duas pastas: &lt;code&gt;src&lt;/code&gt; e &lt;code&gt;build&lt;/code&gt;. A pasta src contém o código fonte da aplicação, os arquivos TypeScript. A pasta build conterá o código JavaScript gerado pelo TypeScript. Na pasta &lt;code&gt;src&lt;/code&gt;, criaremos 3 arquivos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pessoa.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;class Pessoa{
    nome : string;
    constructor(nome:string){
        this.nome = nome;
    }
}
&lt;/pre&gt;

&lt;p&gt;Este primeiro arquivo é uma classe simples, com um parâmetro e o método construtor. A próxima classe será chamada de &lt;code&gt;Aluno&lt;/code&gt;, que irá estender da classe &lt;code&gt;Pessoa&lt;/code&gt;. Como a classe Aluno usa a classe Pessoa (que está em outro arquivo), precisamos importá-la e isso é feito da seguinte forma: &lt;code&gt;/// &amp;lt;reference path=&amp;quot;&amp;quot; /&amp;gt;&lt;/code&gt;. O parâmetro &lt;code&gt;path&lt;/code&gt; é justamente a classe que se deseja referenciar. Então temos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aluno.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;

class Aluno extends Pessoa{
    matricula : string;
    
    constructor(nome:string,matricula:string){
        super(nome);
        this.matricula=matricula;
    }
}
&lt;/pre&gt;

&lt;p&gt;Nesta classe referenciamos na primeira linha a classe &lt;code&gt;Pessoa&lt;/code&gt;, informando o nome do arquivo &lt;code&gt;pessoa.ts&lt;/code&gt;. Depois criamos a classe &lt;code&gt;Aluno&lt;/code&gt;, que herda de Pessoa. Na classe &lt;code&gt;Aluno&lt;/code&gt; criamos o parâmetro &lt;code&gt;matricula&lt;/code&gt;, e no seu construtor usamos a palavra &lt;code&gt;super&lt;/code&gt; para referenciar o construtor da classe pai, que neste caso é &lt;code&gt;Pessoa&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Com as duas classes prontas, podemos finalmente criar o arquivo &lt;code&gt;index.ts&lt;/code&gt;, que é o arquivo principal do projeto.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;aluno.ts&#34; /&amp;gt

var a = new Aluno(&#34;Joãozinho&#34;,&#34;0001&#34;);
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Veja que não é preciso adicionar a classe pessoa. Ela será adicionada na classe aluno&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Veja que o arquivo principal faz uma referência a classe &lt;code&gt;Aluno&lt;/code&gt;, do arquivo &lt;code&gt;aluno.ts&lt;/code&gt;. Com os três arquivos prontos, podemos usar o comando &lt;code&gt;tsc&lt;/code&gt; para compilar tudo em um único arquivo. Este comando é executado a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts05.png&#34; alt=&#34;ts05&#34; width=&#34;819&#34; height=&#34;580&#34; class=&#34;aligncenter size-full wp-image-52470&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nesta imagem usamos o comando &lt;code&gt;tree&lt;/code&gt; do DOS apenas para mostrar que o arquivo &lt;code&gt;script.js&lt;/code&gt; foi criado. O principal comando é o:&lt;/p&gt;

&lt;pre&gt;tsc ./src/index.ts --out ./build/script.js
&lt;/pre&gt;

&lt;p&gt;Este comando possui como primeiro parâmetro o arquivo ts inicial que neste caso é o &lt;code&gt;index.ts&lt;/code&gt;. O parâmetro &lt;code&gt;--out&lt;/code&gt; indica o nome do arquivo que será gerado pela compilação do TypeScript em JavaScript. Este arquivo é exibido a seguir:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build/script.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;var Pessoa = (function () {
    function Pessoa(nome) {
        this.nome = nome;
    }
    return Pessoa;
})();
/// &amp;lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Aluno = (function (_super) {
    __extends(Aluno, _super);
    function Aluno(nome, matricula) {
        _super.call(this, nome);
        this.matricula = matricula;
    }
    return Aluno;
})(Pessoa);
/// &amp;lt;reference path=&#34;aluno.ts&#34; /&amp;gt;
var a = new Aluno(&#34;Joãozinho&#34;, &#34;0001&#34;);
&lt;/pre&gt;

&lt;h2 id=&#34;utilizando-módulos-1&#34;&gt;Utilizando módulos&lt;/h2&gt;

&lt;p&gt;O uso de módulos na aplicação faz com que as classes não pertençam mais ao escopo global, como Pessoa e Aluno pertenciam no exemplo anterior. Vamos fazer uma refatoração no código e adicionar a criação de módulos no escopo da aplicação. Suponha que a classe Pessoa pertença ao módulo &amp;#8220;comum&amp;#8221; e que a classe Aluno pertença ao módulo &amp;#8220;ensino&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pessoa.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;u&gt;&lt;strong&gt;module&lt;/strong&gt;&amp;lt;/u&gt; comum {
    &lt;strong&gt;&amp;lt;u&gt;export&amp;lt;/u&gt;&lt;/strong&gt; class Pessoa{
        nome : string;
        constructor(nome:string){
            this.nome = nome;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Deixamos sublinhado as 2 palavras que são novidade neste código. A primeira é a palavra &lt;code&gt;module&lt;/code&gt;, seguida do nome do seu módulo que neste caso é &amp;#8220;comum&amp;#8221;. Dentro do módulo &amp;#8220;comum&amp;#8221; temos a classe Pessoa, e nela usamos a palavra &lt;code&gt;export&lt;/code&gt; que diz ao módulo que esta classe é pública ao módulo. Podemos incluir no módulo classes, variáveis, métodos etc. Para expôr estas classes a outros módulos, usamos export.&lt;/p&gt;

&lt;p&gt;A classe Aluno é refatorada para o seguinte código:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;aluno.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;
module ensino{
    export class Aluno extends &lt;strong&gt;&amp;lt;u&gt;comum.Pessoa&amp;lt;/u&gt;&lt;/strong&gt;{
        matricula : string;
        
        constructor(nome:string,matricula:string){
            super(nome);
            this.matricula=matricula;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;A classe Aluno agora é do módulo &lt;code&gt;ensino&lt;/code&gt; e como novidade temos a referência da classe Pessoa como &lt;code&gt;comum.Pessoa&lt;/code&gt;. Isso é necessário já que estamos modularizando a aplicação. Finalmente, a classe &lt;code&gt;index.ts&lt;/code&gt; é refatorada para:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;aluno.ts&#34; /&amp;gt;

var a = new ensino.Aluno(&#34;Joãozinho&#34;,&#34;0001&#34;);
&lt;/pre&gt;

&lt;p&gt;Como novidade temos a chamada da classe Aluno como &lt;code&gt;ensino.Aluno&lt;/code&gt;. Com estas mudanças, podemos executar novamente a compilação:&lt;/p&gt;

&lt;pre&gt;tsc ./src/index.ts --out ./build/script.js
&lt;/pre&gt;

&lt;p&gt;e obteremos o seguinte resultado:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;build/script.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;var comum;
(function (comum) {
    var Pessoa = (function () {
        function Pessoa(nome) {
            this.nome = nome;
        }
        return Pessoa;
    })();
    comum.Pessoa = Pessoa;
})(comum || (comum = {}));
var __extends = (this &amp;&amp; this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// $lt;reference path=&#34;pessoa.ts&#34; /&amp;gt;
var ensino;
(function (ensino) {
    var Aluno = (function (_super) {
        __extends(Aluno, _super);
        function Aluno(nome, matricula) {
            _super.call(this, nome);
            this.matricula = matricula;
            console.log(this.matricula);
        }
        return Aluno;
    })(comum.Pessoa);
    ensino.Aluno = Aluno;
})(ensino || (ensino = {}));
/// $lt;reference path=&#34;aluno.ts&#34; /&amp;gt;
var a = new ensino.Aluno(&#34;Joãozinho&#34;, &#34;0001&#34;);
&lt;/pre&gt;

&lt;h2 id=&#34;módulos-em-diretórios-1&#34;&gt;Módulos em diretórios&lt;/h2&gt;

&lt;p&gt;Geralmente a organização de módulos é feita em diretórios, para que todos os arquivos não fiquem em somente um único diretório. No caso anterior, poderíamos (na verdade deveríamos) criar os diretórios &lt;code&gt;src/comum&lt;/code&gt; e &lt;code&gt;src/ensino&lt;/code&gt; e reorganizar as classes de acordo com a imagem a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts06.png&#34; alt=&#34;ts06&#34; width=&#34;186&#34; height=&#34;256&#34; class=&#34;aligncenter size-full wp-image-52476&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A única mudança que precisamos realizar no código é no &lt;code&gt;reference&lt;/code&gt;, que deverá ser:&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;../comum/pessoa.ts&#34; /&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Na classe aluno, como temos que subir um nível para encontrar o diretório &amp;#8220;comum&amp;#8221;, usamos &amp;#8220;../&amp;#8221;.&lt;/p&gt;

&lt;pre&gt;/// &amp;lt;reference path=&#34;ensino/aluno.ts&#34; /&amp;gt;
&lt;/pre&gt;

&lt;p&gt;No arquivo index.ts, não precisamos usar &amp;#8220;../&amp;#8221; pois estamos no mesmo nível do diretório &lt;code&gt;ensino&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;módulos-externos-com-requirejs-1&#34;&gt;Módulos externos com requirejs&lt;/h2&gt;

&lt;p&gt;Até este momento todos os módulos estão em um único arquivo de saída, o &lt;code&gt;build/script.js&lt;/code&gt;. Agora desejamos criar uma forma de carregar os módulos sob demanda, ou seja,&lt;/p&gt;

&lt;p&gt;ao invés de carregar tudo de uma vez, vamos carregando os arquivos javascript na medida que eles forem sendo requisitados. Para isso precisamos criar uma estrutura um pouco mais complexa, e também precisaremos utilizar um framework qualquer para carregar módulos. Neste caso usamos o &lt;code&gt;Requirejs&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;criando-a-estrutura-inicial-1&#34;&gt;Criando a estrutura inicial&lt;/h3&gt;

&lt;p&gt;Crie uma nova pasta e copie os arquivos Pessoa.ts, Aluno.ts e index.ts com a mesma estrutura anterior. Ao invés de criarmos o diretório &amp;#8220;build&amp;#8221;, crie o diretório &amp;#8220;public&amp;#8221;, conforme a imagem a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts07.png&#34; alt=&#34;ts07&#34; width=&#34;181&#34; height=&#34;292&#34; class=&#34;aligncenter size-full wp-image-52478&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;redefinido-as-classes-1&#34;&gt;Redefinido as classes&lt;/h3&gt;

&lt;p&gt;Ao utilizarmos módulos externos precisamos alterar a forma como referenciamos as classes. Ou seja, não usaremos mais o &lt;code&gt;&amp;lt;reference path=&amp;quot;../comum/pessoa.ts&amp;quot; /&amp;gt;&lt;/code&gt; conforme aprendemos, e não será necessário neste momento definir um módulo. Vamos aos ajustes:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;comum/pessoa.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;export class Pessoa{
    nome : string;
    constructor(nome:string){
        this.nome = nome;
    }
}
&lt;/pre&gt;

&lt;p&gt;O que temos agora é o fim do &lt;code&gt;module&lt;/code&gt; e o uso do &lt;code&gt;export&lt;/code&gt; antes do nome da classe. Na classe Aluno, temos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ensino/aluno.ts&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;u&gt;&lt;strong&gt;import comum = require(&#34;../comum/pessoa&#34;)&lt;/strong&gt;&amp;lt;/u&gt;

export class Aluno extends comum.Pessoa{
    matricula : string;
    
    constructor(nome:string,matricula:string){
        super(nome);
        this.matricula=matricula;
    }
}
&lt;/pre&gt;

&lt;p&gt;Alem do fim da palavra &lt;code&gt;module&lt;/code&gt; e do uso do &lt;code&gt;export&lt;/code&gt;, temos uma importante alteração na primeira linha do arquivo &lt;em&gt;aluno.ts&lt;/em&gt;. Estamos utilizando a seguinte sintaxe:&lt;/p&gt;

&lt;pre&gt;import MODULO = require(&#34;caminho&#34;);
&lt;/pre&gt;

&lt;p&gt;Aqui tivemos uma inversão do uso do nome do módulo. Se antes definimos o nome do módulo como &amp;#8220;comum&amp;#8221; na classe &amp;#8220;pessoa&amp;#8221;, agora definimos na própria classe &amp;#8220;aluno&amp;#8221;. Como temos agora o &lt;code&gt;import comum&lt;/code&gt;, podemos usar &lt;code&gt;comum.Pessoa&lt;/code&gt;. O arquivo &lt;code&gt;index.js&lt;/code&gt; é refatorado para:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;import ensino = require(&#34;ensino/aluno&#34;)

var a = new ensino.Aluno(&#34;Joãozinho&#34;,&#34;0001&#34;);
&lt;/pre&gt;

&lt;h3 id=&#34;instalando-o-requirejs-1&#34;&gt;Instalando o requirejs&lt;/h3&gt;

&lt;p&gt;Precisamos instalar o requirejs no projeto, e podemos fazer isso com npm, através do comando &lt;code&gt;npm i requirejs --save&lt;/code&gt;. Este comando irá instalar o`&lt;code&gt;no diretório&lt;/code&gt;node_modules&lt;code&gt;do seu projeto. Se isso não acontecer, execute antes o comando&lt;/code&gt;npm init&lt;code&gt;para inicializar o repositório npm no projeto. Após instalar o requirejs, copie o arquivo&lt;/code&gt;node_modules/requirejs/require.js&lt;code&gt;para a pasta&lt;/code&gt;public/js`. Se você não está confortável com o uso do npm para instalar o requirejs, utilize o seguinte CDN:&lt;/p&gt;

&lt;pre&gt;&amp;lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.22/require.min.js&#34; data-main=&#34;js/index.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;h3 id=&#34;configurando-o-arquivo-index-html&#34;&gt;Configurando o arquivo index.html&lt;/h3&gt;

&lt;p&gt;O arquivo &lt;code&gt;index.html&lt;/code&gt; é configurado da seguinte forma:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;public/index.html&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;TypeScript Modules&amp;lt;/title&amp;gt;
        &amp;lt;script src=&#34;js/require.js&#34; data-main=&#34;js/index.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        Olá Mundo....
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Neste simples arquivo apenas incluímos o &lt;code&gt;require.js&lt;/code&gt; que foi copiado do &lt;code&gt;node_modules&lt;/code&gt; e usamos o atributo &lt;code&gt;data-main=&amp;quot;js/index.js&amp;quot;&lt;/code&gt; para informar o arquivo no qual será carregado inicialmente.&lt;/p&gt;

&lt;h3 id=&#34;compilando-a-aplicação&#34;&gt;Compilando a aplicação&lt;/h3&gt;

&lt;p&gt;Aliás este arquivo ainda não foi criado, já que não executamos o comando &lt;code&gt;tsc&lt;/code&gt;. O comando para compilar o JavaScript para que o requirejs possa entendê-lo é o seguinte:&lt;/p&gt;

&lt;pre&gt;tsc ./src/index.ts --outDir ./public/js/ --module &#34;amd&#34;
&lt;/pre&gt;

&lt;p&gt;Neste comando indicamos como primeiro parâmetro &lt;code&gt;./src/index.ts&lt;/code&gt; o arquivo inicial no qual será compilado. O parâmetro &lt;code&gt;--outDir ./public/js/&lt;/code&gt; indica o diretório de saída da compilação, neste caso será o diretório &lt;code&gt;public/js&lt;/code&gt;, o mesmo onde se encontra o arquivo require.js. O terceiro parâmetro &lt;code&gt;--module &amp;quot;amd&amp;quot;&lt;/code&gt; indica a forma como o tsc vai compilar os arquivos, onde AMD significa &lt;code&gt;Asynchronous Module Definition&lt;/code&gt;. Após executar este comando, os arquivos jsvascript serão criados na pasta &lt;code&gt;public/js&lt;/code&gt; conforme a imagem a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts08.png&#34; alt=&#34;ts08&#34; width=&#34;1171&#34; height=&#34;580&#34; class=&#34;aligncenter size-full wp-image-52480&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;executando-no-navegador&#34;&gt;Executando no navegador&lt;/h3&gt;

&lt;p&gt;Chegou o momento de testar o carregamento dinâmico das classes javascript, e para isso você precisa usar um servidor web. Se você possui um servidor web como o apache, basta copiar a pasta &lt;code&gt;public&lt;/code&gt; para o diretório web e testá-la. Caso negativo, podemos usar o &lt;strong&gt;live-server&lt;/strong&gt; que é facilmente instalado através do node: &lt;code&gt;npm i live-server /g&lt;/code&gt;. Após instalar, acesse o diretório public pela linha de comando e digite o comando &lt;code&gt;live-server&lt;/code&gt;. O navegador será aberto automaticamente e o arquivo &lt;code&gt;index.html&lt;/code&gt; será carregado.&lt;/p&gt;

&lt;p&gt;Você verá a mensagem &lt;em&gt;Olá mundo&lt;/em&gt;, mas o que estamos interessados é no carregamento dos arquivos javascript da aplicação. Para isso, se estiver no Chrome, tecle F12, navegue até a aba Networking e recarregue a aplicação com F5. Você obterá um resultado semelhante a figura a seguir. &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts09.png&#34; alt=&#34;ts09&#34; width=&#34;960&#34; height=&#34;677&#34; class=&#34;aligncenter size-full wp-image-52481&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Neste artigo criamos duas formas para utilizar TypeScript no qual os arquivos estão inicialmente separados. A primeira é utilizando o padrão do TypeScript e o &lt;code&gt;/// &amp;lt;reference path=&amp;quot;arquivo.ts&amp;quot; /&amp;gt;&lt;/code&gt; e a segunda é usando &lt;code&gt;requirejs&lt;/code&gt; para carregar os arquivos javascript via ajax. Para que você possa se aprofundar ainda mais neste conceito, que é complexo, sugiro a leitura da documentação: &lt;a href=&#34;http://www.typescriptlang.org/Handbook#modules&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.typescriptlang.org/Handbook#modules&#34;&gt;http://www.typescriptlang.org/Handbook#modules&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Diga olá ao TypeScript e adeus ao JavaScript</title>
      <link>https://tableless.github.io/hugo-public/diga-ola-ao-typescript-e-adeus-ao-javascript/</link>
      <pubDate>Mon, 14 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/diga-ola-ao-typescript-e-adeus-ao-javascript/</guid>
      <description>

&lt;p&gt;Acredito que este artigo tenha chamado a sua atenção pelo título. Como assim??? adeus ao JavaScript??? A linguagem que está bombando em 2015 (e claro, 2016!). Posso estar sendo um pouco ousado aqui, mas eu tenho em mente que, neste momento, o JavaScript para mim é agora &amp;#8220;linguagem de máquina&amp;#8221; ou o famoso bytecode. Porquê? Bom, você conhece um código javascript minificado+comprimido+&amp;#8221;esculachado&amp;#8221;&amp;#8230; Não estou retirando aqui toda a beleza do JavaScript, e consequente importância, mas na evolução que vem acontecendo a cada dia no mundo web, felizmente chegamos ao ponto que podemos tratar o javascript como uma linguagem tipada e semelhante ao c/java/php e derivados.&lt;/p&gt;

&lt;p&gt;Neste ponto entra uma questão pessoal. Ou você vai adorar TypeScript ou vai achar completamente inútil, já que a sua principal característica é trazer uma &amp;#8220;tipagem&amp;#8221; a linguagem, e no pacote uma forma de programar em javascript mais parecida com Java e suas vertentes. Se você gosta de tipar suas váriaveis e métodos, criar classes, interfaces, usar Orientação a Objetos, o TypeScript foi feito para você e, claro, pode dizer adeus ao JavaScript.&lt;/p&gt;

&lt;p&gt;Lembre-se que TypeScript está sendo usada extensivamente no novo framework Angular2, então se vc ainda não sabe o que é TypeScript, chegou o momento de conhecer.&lt;/p&gt;

&lt;h2 id=&#34;o-que-é-typescript&#34;&gt;O que é TypeScript?&lt;/h2&gt;

&lt;p&gt;O TypeScript possibilita que você escreva código JavaScript na forma que foi acostumado quando aprendeu Orientação a Objetos. Você lembra dessas aulas, em criar métodos que retornassem um valor com tipo definido, em criar classes e mais classes para o seu programa, em criar interfaces para desacoplar tudo que quisesse, entre diversas outras técnicas. Com TypeScript tudo isso é possível, porque no final ele pega o seu lindo código cheio de classes e transforma em JavaScript puro, no qual o browser vai compreender. No próprio site é definido que o TypeScript compila para JavaScript, o que é um termo tecnicamente errado &amp;#8211; mas cada vez mais aceito, dado que aquele código &amp;#8220;malucão&amp;#8221; em JavaScript pode ser encarado como código de máquina.&lt;/p&gt;

&lt;p&gt;No exemplo a seguir, criamos uma interface e uma classe, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;interface IComponent{
    getId() : string;
}

class Button implements IComponent{
    id:string;
    getId():string{
        return this.id;
    }
}&lt;/pre&gt;

&lt;p&gt;Este é um código 100% TypeScript que você pode criar em um editor de textos ou ide, no qual criamos uma interface chamada &lt;code&gt;IComponent&lt;/code&gt;e uma classe que chamamos de &lt;code&gt;Button&lt;/code&gt;. Esta classe implementa a interface e por isso o método &lt;code&gt;getId()&lt;/code&gt; deve ser criado. Se você salvar este arquivo como um arquivo javascript e adicionar em um documento HTML, nenhum &lt;strong&gt;browser&lt;/strong&gt; vai entender isso, quem sabe num futuro distante. Mas isso nao é um problema, pois o TypeScript possui um &amp;#8220;compilador&amp;#8221; que irá pegar o seu código e transformar em algo do tipo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var Button = (function () {
    function Button() {
    }
    Button.prototype.getId = function () {
        return this.id;
    };
    return Button;
})();&lt;/pre&gt;

&lt;p&gt;Este código feioso aí em cima é 100% javascript compreensível em qualquer navegador web. Tem gente que prefere escrever assim, vai entender né. Mas como essa mágica funciona? Vamos explicar a seguir.&lt;/p&gt;

&lt;h2 id=&#34;testando-o-typescript&#34;&gt;Testando o TypeScript&lt;/h2&gt;

&lt;p&gt;Abra uma nova aba no seu browser e acesse: &lt;a href=&#34;http://www.typescriptlang.org/Playground&#34;&gt;http://www.typescriptlang.org/Playground&lt;/a&gt;. O Playground é um pequeno editor TypeScript que, além de checar possíveis erros de sintaxe, também compila automaticamente o código para Javascript, no qual você pode testá-lo. Não omita o Playground no seu aprendizado, ele pode te ajudar muito, como na figura a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts01.png&#34; alt=&#34;ts01&#34; width=&#34;856&#34; height=&#34;277&#34; class=&#34;alignleft size-full wp-image-52433&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Caso não queira utilizar o Playground, pode-se instalar o TypeScript no seu ambiente de desenvolvimento através do node. O comando a seguir deve ser compreensível para você:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;$ npm install typescript -g&lt;/pre&gt;

&lt;p&gt;Após instalar o TypeScript no ambiente, você pode usar o comando &lt;code&gt;tsc&lt;/code&gt; para compilar um arquivo que geralmente está na extensão &lt;code&gt;ts&lt;/code&gt; para &lt;code&gt;js&lt;/code&gt;. Por exemplo, crie o arquivo &lt;code&gt;script.ts&lt;/code&gt; com o código TypeScript descrito anteriormente e execute o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;tsc --out script.js script.ts&lt;/pre&gt;

&lt;p&gt;Editores de texto como o Sublime Text, Atom, VS Code, também tem a capacidade de compilar o arquivo em JavaScript, bastando apenas adicionar plugins relativos ao TypeScript. O &lt;code&gt;VS Code&lt;/code&gt;, em particular, apresentou um bom comportamento frente aos outros, como pode-se perceber na imagem a seguir.&lt;/p&gt;

&lt;div id=&#34;attachment_52436&#34; style=&#34;width: 549px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts02.png&#34; alt=&#34;Visual Studio Code&#34; width=&#34;539&#34; height=&#34;639&#34; class=&#34;size-full wp-image-52436&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Visual Studio Code
  &lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;attachment_52438&#34; style=&#34;width: 566px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts03.png&#34; alt=&#34;Sublime Text 2.0.2&#34; width=&#34;556&#34; height=&#34;765&#34; class=&#34;size-full wp-image-52438&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Sublime Text 2.0.2
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Mas neste artigo vamos nos contentar com o TypeScript Playground, e deixe os editores para a sua escolha pessoal (fique a vontade em perguntar como configurar o TypeScript no Sublime, é um pouco mais trabalhoso).&lt;/p&gt;

&lt;p&gt;Agora que apresentamos o TypeScript e suas maravilhas, vamos compreender um pouco mais desta linguagem.&lt;/p&gt;

&lt;h2 id=&#34;tipos-de-variáveis&#34;&gt;Tipos de variáveis&lt;/h2&gt;

&lt;p&gt;Uma das funcionalidades do TypeScript é criar variáveis com tipos definidos, assim como é feito no Java.&lt;/p&gt;

&lt;h3 id=&#34;tipos-primitivos&#34;&gt;Tipos primitivos&lt;/h3&gt;

&lt;p&gt;Existem 3 tipos primitivos que podemos associar a uma variável. As variáveis são criadas através da palavra reservada &lt;code&gt;var&lt;/code&gt;, e o tipo é informado da seguinte forma:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var NOMDE_DA_VARIAVEL : TIPO = VALOR
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;boolean: Pode assumir os valores &lt;code&gt;true&lt;/code&gt; ou &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;number: Assume qualquer número, como inteiro ou ponto flutuante.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string: Tipo texto, pode ser atribuído com aspas simples ou duplas.&lt;/p&gt;

&lt;h3 id=&#34;arrays&#34;&gt;Arrays&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Arrays no TS podem ser criados através de duas formas. A primeira delas, usa-se &lt;code&gt;[]&lt;/code&gt; na definição do tipo da variável, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var list:number[] = [1, 2, 3];
&lt;/pre&gt;

&lt;p&gt;A segunda é mais conhecida como &amp;#8220;generics&amp;#8221; e usa &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; para definir o tipo, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var list:Array&amp;lt;number&amp;gt; = [1,2,3];
&lt;/pre&gt;

&lt;p&gt;Pode-se usar tipos complexos na criação de arrays, como no exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Pessoa{
    nome:string;
    constructor(nome:string){
        this.nome = nome;
    }
    sayHello():string{
        return &#34;Hello, &#34; + this.nome;
    }
}

var fulano = new Pessoa(&#34;fulano&#34;);
var beltrano = new Pessoa(&#34;beltrano&#34;);

var pessoas:Pessoa[]= new Array();
pessoas.push(fulano);
pessoas.push(beltrano);

pessoas.forEach( (p:Pessoa)=&amp;gt;
    console.log(p.sayHello())
    );
&lt;/pre&gt;

&lt;p&gt;Neste exemplo, criamos uma classe chamada &lt;code&gt;Pessoa&lt;/code&gt;, adicionando a propriedade &lt;code&gt;nome&lt;/code&gt;, o método construtor e o método &lt;code&gt;sayHello&lt;/code&gt;. Depois, criamos duas variáveis &lt;code&gt;fulano&lt;/code&gt; e &lt;code&gt;beltrano&lt;/code&gt;, e adicionamos à variável &lt;code&gt;pessoas&lt;/code&gt;, que é um array de vaiáveis do tipo &lt;code&gt;Pessoa&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Após usar o método &lt;code&gt;push&lt;/code&gt; para adicionar as variáveis no array, usamos o método &lt;code&gt;forEach&lt;/code&gt; para percorrer cada item deste array e exibir uma mensagem no console do navegador.&lt;/p&gt;

&lt;h3 id=&#34;enum&#34;&gt;Enum&lt;/h3&gt;

&lt;p&gt;Enums são velhos conhecidos do C#, e usados como &amp;#8220;datatype&amp;#8221;, que podem definir um status por exemplo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;enum Color {Red, Green, Blue};
var c: Color = Color.Green;
&lt;/pre&gt;

&lt;p&gt;ou&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;enum Color {Red = 1, Green = 2, Blue = 3};
var c: Color = Color.Green;
&lt;/pre&gt;

&lt;p&gt;Quando criamos um enum, usamos o &amp;#8220;poder&amp;#8221; da ide para que possamos programar de forma mais fácil, conforme a figura a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts04.png&#34; alt=&#34;ts04&#34; width=&#34;697&#34; height=&#34;145&#34; class=&#34;alignleft size-full wp-image-52451&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;any&#34;&gt;Any&lt;/h3&gt;

&lt;p&gt;Uma variável do tipo &lt;code&gt;Any&lt;/code&gt; pode assumir qualquer valor.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var notSure: any = 4;
notSure = &#34;maybe a string instead&#34;;
notSure = false; // okay, definitely a boolean

var list:any[] = [1, true, &#34;free&#34;];
list[1] = 100;
&lt;/pre&gt;

&lt;h3 id=&#34;void&#34;&gt;Void&lt;/h3&gt;

&lt;p&gt;O &lt;code&gt;void&lt;/code&gt; é usado para determinar que um método não retorna nenhum valor, conforme o exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function warnUser(): void {
    alert(&#34;This is my warning message&#34;);
}
&lt;/pre&gt;

&lt;h2 id=&#34;classes&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;O conceito de classes no TypeScript é o mesmo de uma classe em qualquer linguagem orientada a objetos. As classes no TypeScript seguem o padrão ECMAScript 6 que em teoria será o &amp;#8220;futuro&amp;#8221; do JavaScript. A classe possui uma sintaxe muito familiar com c#, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &#34;Hello, &#34; + this.greeting;
    }
}
var greeter = new Greeter(&#34;world&#34;);
&lt;/pre&gt;

&lt;p&gt;O construtor é definido pela palavra &lt;code&gt;constructor&lt;/code&gt;. Métodos não necessitam da palavra &lt;code&gt;function&lt;/code&gt;, bastando apenas usar ``Acredito que este artigo tenha chamado a sua atenção pelo título. Como assim??? adeus ao JavaScript??? A linguagem que está bombando em 2015 (e claro, 2016!). Posso estar sendo um pouco ousado aqui, mas eu tenho em mente que, neste momento, o JavaScript para mim é agora &amp;#8220;linguagem de máquina&amp;#8221; ou o famoso bytecode. Porquê? Bom, você conhece um código javascript minificado+comprimido+&amp;#8221;esculachado&amp;#8221;&amp;#8230; Não estou retirando aqui toda a beleza do JavaScript, e consequente importância, mas na evolução que vem acontecendo a cada dia no mundo web, felizmente chegamos ao ponto que podemos tratar o javascript como uma linguagem tipada e semelhante ao c/java/php e derivados.&lt;/p&gt;

&lt;p&gt;Neste ponto entra uma questão pessoal. Ou você vai adorar TypeScript ou vai achar completamente inútil, já que a sua principal característica é trazer uma &amp;#8220;tipagem&amp;#8221; a linguagem, e no pacote uma forma de programar em javascript mais parecida com Java e suas vertentes. Se você gosta de tipar suas váriaveis e métodos, criar classes, interfaces, usar Orientação a Objetos, o TypeScript foi feito para você e, claro, pode dizer adeus ao JavaScript.&lt;/p&gt;

&lt;p&gt;Lembre-se que TypeScript está sendo usada extensivamente no novo framework Angular2, então se vc ainda não sabe o que é TypeScript, chegou o momento de conhecer.&lt;/p&gt;

&lt;h2 id=&#34;o-que-é-typescript-1&#34;&gt;O que é TypeScript?&lt;/h2&gt;

&lt;p&gt;O TypeScript possibilita que você escreva código JavaScript na forma que foi acostumado quando aprendeu Orientação a Objetos. Você lembra dessas aulas, em criar métodos que retornassem um valor com tipo definido, em criar classes e mais classes para o seu programa, em criar interfaces para desacoplar tudo que quisesse, entre diversas outras técnicas. Com TypeScript tudo isso é possível, porque no final ele pega o seu lindo código cheio de classes e transforma em JavaScript puro, no qual o browser vai compreender. No próprio site é definido que o TypeScript compila para JavaScript, o que é um termo tecnicamente errado &amp;#8211; mas cada vez mais aceito, dado que aquele código &amp;#8220;malucão&amp;#8221; em JavaScript pode ser encarado como código de máquina.&lt;/p&gt;

&lt;p&gt;No exemplo a seguir, criamos uma interface e uma classe, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;interface IComponent{
    getId() : string;
}

class Button implements IComponent{
    id:string;
    getId():string{
        return this.id;
    }
}&lt;/pre&gt;

&lt;p&gt;Este é um código 100% TypeScript que você pode criar em um editor de textos ou ide, no qual criamos uma interface chamada &lt;code&gt;IComponent&lt;/code&gt;e uma classe que chamamos de &lt;code&gt;Button&lt;/code&gt;. Esta classe implementa a interface e por isso o método &lt;code&gt;getId()&lt;/code&gt; deve ser criado. Se você salvar este arquivo como um arquivo javascript e adicionar em um documento HTML, nenhum &lt;strong&gt;browser&lt;/strong&gt; vai entender isso, quem sabe num futuro distante. Mas isso nao é um problema, pois o TypeScript possui um &amp;#8220;compilador&amp;#8221; que irá pegar o seu código e transformar em algo do tipo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var Button = (function () {
    function Button() {
    }
    Button.prototype.getId = function () {
        return this.id;
    };
    return Button;
})();&lt;/pre&gt;

&lt;p&gt;Este código feioso aí em cima é 100% javascript compreensível em qualquer navegador web. Tem gente que prefere escrever assim, vai entender né. Mas como essa mágica funciona? Vamos explicar a seguir.&lt;/p&gt;

&lt;h2 id=&#34;testando-o-typescript-1&#34;&gt;Testando o TypeScript&lt;/h2&gt;

&lt;p&gt;Abra uma nova aba no seu browser e acesse: &lt;a href=&#34;http://www.typescriptlang.org/Playground&#34;&gt;http://www.typescriptlang.org/Playground&lt;/a&gt;. O Playground é um pequeno editor TypeScript que, além de checar possíveis erros de sintaxe, também compila automaticamente o código para Javascript, no qual você pode testá-lo. Não omita o Playground no seu aprendizado, ele pode te ajudar muito, como na figura a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts01.png&#34; alt=&#34;ts01&#34; width=&#34;856&#34; height=&#34;277&#34; class=&#34;alignleft size-full wp-image-52433&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Caso não queira utilizar o Playground, pode-se instalar o TypeScript no seu ambiente de desenvolvimento através do node. O comando a seguir deve ser compreensível para você:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;$ npm install typescript -g&lt;/pre&gt;

&lt;p&gt;Após instalar o TypeScript no ambiente, você pode usar o comando &lt;code&gt;tsc&lt;/code&gt; para compilar um arquivo que geralmente está na extensão &lt;code&gt;ts&lt;/code&gt; para &lt;code&gt;js&lt;/code&gt;. Por exemplo, crie o arquivo &lt;code&gt;script.ts&lt;/code&gt; com o código TypeScript descrito anteriormente e execute o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;tsc --out script.js script.ts&lt;/pre&gt;

&lt;p&gt;Editores de texto como o Sublime Text, Atom, VS Code, também tem a capacidade de compilar o arquivo em JavaScript, bastando apenas adicionar plugins relativos ao TypeScript. O &lt;code&gt;VS Code&lt;/code&gt;, em particular, apresentou um bom comportamento frente aos outros, como pode-se perceber na imagem a seguir.&lt;/p&gt;

&lt;div id=&#34;attachment_52436&#34; style=&#34;width: 549px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts02.png&#34; alt=&#34;Visual Studio Code&#34; width=&#34;539&#34; height=&#34;639&#34; class=&#34;size-full wp-image-52436&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Visual Studio Code
  &lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;attachment_52438&#34; style=&#34;width: 566px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts03.png&#34; alt=&#34;Sublime Text 2.0.2&#34; width=&#34;556&#34; height=&#34;765&#34; class=&#34;size-full wp-image-52438&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Sublime Text 2.0.2
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Mas neste artigo vamos nos contentar com o TypeScript Playground, e deixe os editores para a sua escolha pessoal (fique a vontade em perguntar como configurar o TypeScript no Sublime, é um pouco mais trabalhoso).&lt;/p&gt;

&lt;p&gt;Agora que apresentamos o TypeScript e suas maravilhas, vamos compreender um pouco mais desta linguagem.&lt;/p&gt;

&lt;h2 id=&#34;tipos-de-variáveis-1&#34;&gt;Tipos de variáveis&lt;/h2&gt;

&lt;p&gt;Uma das funcionalidades do TypeScript é criar variáveis com tipos definidos, assim como é feito no Java.&lt;/p&gt;

&lt;h3 id=&#34;tipos-primitivos-1&#34;&gt;Tipos primitivos&lt;/h3&gt;

&lt;p&gt;Existem 3 tipos primitivos que podemos associar a uma variável. As variáveis são criadas através da palavra reservada &lt;code&gt;var&lt;/code&gt;, e o tipo é informado da seguinte forma:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var NOMDE_DA_VARIAVEL : TIPO = VALOR
&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;boolean: Pode assumir os valores &lt;code&gt;true&lt;/code&gt; ou &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;number: Assume qualquer número, como inteiro ou ponto flutuante.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;string: Tipo texto, pode ser atribuído com aspas simples ou duplas.&lt;/p&gt;

&lt;h3 id=&#34;arrays-1&#34;&gt;Arrays&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Arrays no TS podem ser criados através de duas formas. A primeira delas, usa-se &lt;code&gt;[]&lt;/code&gt; na definição do tipo da variável, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var list:number[] = [1, 2, 3];
&lt;/pre&gt;

&lt;p&gt;A segunda é mais conhecida como &amp;#8220;generics&amp;#8221; e usa &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; para definir o tipo, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var list:Array&amp;lt;number&amp;gt; = [1,2,3];
&lt;/pre&gt;

&lt;p&gt;Pode-se usar tipos complexos na criação de arrays, como no exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Pessoa{
    nome:string;
    constructor(nome:string){
        this.nome = nome;
    }
    sayHello():string{
        return &#34;Hello, &#34; + this.nome;
    }
}

var fulano = new Pessoa(&#34;fulano&#34;);
var beltrano = new Pessoa(&#34;beltrano&#34;);

var pessoas:Pessoa[]= new Array();
pessoas.push(fulano);
pessoas.push(beltrano);

pessoas.forEach( (p:Pessoa)=&amp;gt;
    console.log(p.sayHello())
    );
&lt;/pre&gt;

&lt;p&gt;Neste exemplo, criamos uma classe chamada &lt;code&gt;Pessoa&lt;/code&gt;, adicionando a propriedade &lt;code&gt;nome&lt;/code&gt;, o método construtor e o método &lt;code&gt;sayHello&lt;/code&gt;. Depois, criamos duas variáveis &lt;code&gt;fulano&lt;/code&gt; e &lt;code&gt;beltrano&lt;/code&gt;, e adicionamos à variável &lt;code&gt;pessoas&lt;/code&gt;, que é um array de vaiáveis do tipo &lt;code&gt;Pessoa&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Após usar o método &lt;code&gt;push&lt;/code&gt; para adicionar as variáveis no array, usamos o método &lt;code&gt;forEach&lt;/code&gt; para percorrer cada item deste array e exibir uma mensagem no console do navegador.&lt;/p&gt;

&lt;h3 id=&#34;enum-1&#34;&gt;Enum&lt;/h3&gt;

&lt;p&gt;Enums são velhos conhecidos do C#, e usados como &amp;#8220;datatype&amp;#8221;, que podem definir um status por exemplo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;enum Color {Red, Green, Blue};
var c: Color = Color.Green;
&lt;/pre&gt;

&lt;p&gt;ou&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;enum Color {Red = 1, Green = 2, Blue = 3};
var c: Color = Color.Green;
&lt;/pre&gt;

&lt;p&gt;Quando criamos um enum, usamos o &amp;#8220;poder&amp;#8221; da ide para que possamos programar de forma mais fácil, conforme a figura a seguir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2015/12/ts04.png&#34; alt=&#34;ts04&#34; width=&#34;697&#34; height=&#34;145&#34; class=&#34;alignleft size-full wp-image-52451&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;any-1&#34;&gt;Any&lt;/h3&gt;

&lt;p&gt;Uma variável do tipo &lt;code&gt;Any&lt;/code&gt; pode assumir qualquer valor.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var notSure: any = 4;
notSure = &#34;maybe a string instead&#34;;
notSure = false; // okay, definitely a boolean

var list:any[] = [1, true, &#34;free&#34;];
list[1] = 100;
&lt;/pre&gt;

&lt;h3 id=&#34;void-1&#34;&gt;Void&lt;/h3&gt;

&lt;p&gt;O &lt;code&gt;void&lt;/code&gt; é usado para determinar que um método não retorna nenhum valor, conforme o exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function warnUser(): void {
    alert(&#34;This is my warning message&#34;);
}
&lt;/pre&gt;

&lt;h2 id=&#34;classes-1&#34;&gt;Classes&lt;/h2&gt;

&lt;p&gt;O conceito de classes no TypeScript é o mesmo de uma classe em qualquer linguagem orientada a objetos. As classes no TypeScript seguem o padrão ECMAScript 6 que em teoria será o &amp;#8220;futuro&amp;#8221; do JavaScript. A classe possui uma sintaxe muito familiar com c#, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return &#34;Hello, &#34; + this.greeting;
    }
}
var greeter = new Greeter(&#34;world&#34;);
&lt;/pre&gt;

&lt;p&gt;O construtor é definido pela palavra &lt;code&gt;constructor&lt;/code&gt;. Métodos não necessitam da palavra &lt;code&gt;function&lt;/code&gt;, bastando apenas usar`&lt;code&gt;. Perceba que, no exemplo apresentado, não definimos visibilidade das propriedades da classe, nem o tipo de retorno do método&lt;/code&gt;greet`. É claro que podemos definir estes parâmetros, conforme o próximo exemplo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Greeter {
    private greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    public greet() : string {
        return &#34;Hello, &#34; + this.greeting;
    }
}

var greeter = new Greeter(&#34;world&#34;);
&lt;/pre&gt;

&lt;h3 id=&#34;visibilidade-de-métodos-e-propriedades&#34;&gt;Visibilidade de métodos e propriedades&lt;/h3&gt;

&lt;p&gt;Métodos e propriedades de uma classe podem assumir a visibilidade: private, public e protected.&lt;/p&gt;

&lt;h3 id=&#34;herança&#34;&gt;Herança&lt;/h3&gt;

&lt;p&gt;A herança entre uma classe e outra é definida pela palavra &lt;code&gt;extends&lt;/code&gt;. Pode-se sobrecarregar métodos e usar a palavra &lt;code&gt;super&lt;/code&gt; para chamar o método da classe pai, conforme o exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Animal {
    name:string;
    constructor(theName: string) { this.name = theName; }
    move(meters: number = 0) {
        alert(this.name + &#34; moved &#34; + meters + &#34;m.&#34;);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(meters = 5) {
        alert(&#34;Slithering...&#34;);
        super.move(meters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(meters = 45) {
        alert(&#34;Galloping...&#34;);
        super.move(meters);
    }
}

var sam = new Snake(&#34;Sammy the Python&#34;);
var tom: Animal = new Horse(&#34;Tommy the Palomino&#34;);

sam.move();
tom.move(34);
&lt;/pre&gt;

&lt;p&gt;Neste exemplo usamos o &lt;code&gt;super&lt;/code&gt; da classe &lt;code&gt;Snake&lt;/code&gt; para chamar o método construtor da classe pai &lt;code&gt;Animal&lt;/code&gt;. Se isso não for claro para você, dê uma estudada em OO para que possa compreender melhor, pois estas características são da Orientação em Objetos como um todo, e não do TypeScript.&lt;/p&gt;

&lt;h2 id=&#34;accessors-ou-métodos-get-set&#34;&gt;Accessors (ou métodos get/set)&lt;/h2&gt;

&lt;p&gt;Os Accessors visam proteger as propriedades de uma classe, pois você já deve saber que expor propriedades de uma classe não é algo legal 🙂&lt;/p&gt;

&lt;p&gt;Os accessors do TypeScript são feitos pelas palavras &lt;code&gt;get&lt;/code&gt; e &lt;code&gt;set&lt;/code&gt;, e claro, deixe a sua propriedade como &lt;code&gt;private&lt;/code&gt;. Veja o exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Pessoa {
    private _password: string;

    get password(): string {
        return this._password;
    }
    
    set password(p : string) {
        if (p != &#34;123456&#34;) {
            this._password = p;
        }
        else {
            alert(&#34;Ei, senha não pode ser 123456&#34;);
        }
    }
}

var p = new Pessoa();
p.password = &#34;123456&#34;; //vai exibir o erro
&lt;/pre&gt;

&lt;h3 id=&#34;métodos-estáticos&#34;&gt;Métodos estáticos&lt;/h3&gt;

&lt;p&gt;É possível criar métodos estáticos definindo a palavra &lt;code&gt;static&lt;/code&gt; antes do método. Existem dezenas de aplicações para métodos estáticos, sendo uma delas não precisar instanciar uma classe, como no exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class SystemAlert{
    
    static alert(message:string):void{
        alert(message);
    }
    
    static warm (message:string):void{
        alert(&#34;Atenção: &#34; + message);
    }
    
    static error(message:string):void{
        alert(&#34;Erro: &#34; + message);
    }
    
}

SystemAlert.alert(&#34;Oi&#34;);
SystemAlert.error(&#34;Não foi possível conectar na base de dados&#34;);
&lt;/pre&gt;

&lt;h2 id=&#34;interfaces&#34;&gt;Interfaces&lt;/h2&gt;

&lt;p&gt;Uma interface define um contrato para a classe. A interface é criada da seguinte forma:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;interface Ponto{
 x: number;
 y: number;
 x: number;
}
&lt;/pre&gt;

&lt;p&gt;Para implementar a interface, usamos &lt;code&gt;implements&lt;/code&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Ponto3d implements Ponto{
   (aqui implementamos x,y,z)
}
&lt;/pre&gt;

&lt;h2 id=&#34;funções&#34;&gt;Funções&lt;/h2&gt;

&lt;p&gt;Vamos exemplificar algumas particularidades de uma função em TypeScript. A função pode ser criada fora de uma classe ou dentro, sendo as observações que faremos a seguir podem ser aplicadas em ambas.&lt;/p&gt;

&lt;p&gt;Tome nota apenas que, em uma classe, não precisamos usar a palavra &lt;code&gt;function&lt;/code&gt; para definir uma função, mas fora da classe precisamos.&lt;/p&gt;

&lt;h3 id=&#34;parâmetros-com-valores-padrão&#34;&gt;Parâmetros com valores padrão&lt;/h3&gt;

&lt;p&gt;Pode-se definir um valor padrão para um parâmetro de uma função da seguinte forma:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function buildName(firstName: string, lastName : string = &#34;Smith&#34;) {
}
//ou
class Foo{
  buildName(firstName: string, lastName : string = &#34;Smith&#34;) {
  }
}
&lt;/pre&gt;

&lt;h3 id=&#34;parâmetros-opcionais&#34;&gt;Parâmetros opcionais&lt;/h3&gt;

&lt;p&gt;Use o caractere &lt;code&gt;?&lt;/code&gt; para definir um parâmetro opcional.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Foo{
  buildName(firstName: string, lastName? : string) {
     if (lastName){
           // blablabla
     }
  }
}
&lt;/pre&gt;

&lt;h3 id=&#34;parâmetros-rest&#34;&gt;Parâmetros REST&lt;/h3&gt;

&lt;p&gt;Pode-se repassar um array de valores diretamente para um parâmetro. É válido lembrar que este modo só pode ser usado no último parâmetro da sua função. Exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Foo{
 static alertName(firstName: string, ...restOfName: string[]) {
    alert(firstName + &#34; &#34; + restOfName.join(&#34; &#34;));
 }
}
Foo.alertName(&#34;Fulano&#34;,&#34;de&#34;,&#34;Tal&#34;);
&lt;/pre&gt;

&lt;h3 id=&#34;parâmetros-no-formato-json&#34;&gt;Parâmetros no formato JSON&lt;/h3&gt;

&lt;p&gt;Umas das maiores facilidades do Javascript é repassar parâmetros no formato JSON. Com TypeScript é possível utilizar este mesmo comportamento, conforme o exemplo a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class Ponto{
    
    private _x : number = 0;
    private _y : number = 0;
    private _z : number = 0;
    
    constructor( p: {x:number;y:number;z?:number;}){
        this._x = p.x;
        this._y = p.y;
        if (p.z)
            this._z = p.z;
    }
    
    is3d():boolean{
        return this._z!=0;
    }
    
}

var p1 = new Ponto({x:10,y:20});

alert(p1.is3d());
&lt;/pre&gt;

&lt;p&gt;Observe que no construtor da classe &lt;code&gt;Ponto&lt;/code&gt; criamos o parâmetro &lt;code&gt;p&lt;/code&gt; e na definição do seu tipo repassamos um objeto anônimo com três parâmetros, sendo que o parâmetro &lt;code&gt;z&lt;/code&gt; é opcional.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Neste artigo vimos algumas funcionalidades do TypeScript, sendo ainda existem diversos tópicos a serem abordados. Gostaria de lhe encorajar a testar esta nova linguagem, e caso tenha dúvidas, não deixe de comentar abaixo. Sugira também novos artigos sobre TypeScript, estaremos avaliando cada pedido!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>