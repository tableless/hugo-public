<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Http on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/http/index.xml</link>
    <description>Recent content in Http on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/http/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Criando seu próprio servidor HTTP do zero (ou quase) – Parte Final</title>
      <link>https://tableless.github.io/hugo-public/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-final/</link>
      <pubDate>Tue, 27 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-final/</guid>
      <description>

&lt;p&gt;Os servidores HTTP são parte fundamental da Web como conhecemos, sendo responsáveis por fornecer todo o conteúdo que acessamos através de nossos navegadores. Durante esse tutorial, entenderemos como funciona a comunicação entre o navegador e o servidor e como a informação é entregue ao usuário.&lt;/p&gt;

&lt;p&gt;Caso não tenha acompanhado os últimos posts, recomendo que leia as Partes &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-i/&#34;&gt;um&lt;/a&gt;, &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-ii/&#34;&gt;dois&lt;/a&gt; e &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-iii/&#34;&gt;três&lt;/a&gt; antes de prosseguir a leitura deste post.&lt;/p&gt;

&lt;p&gt;Essa é a última parte do tutorial, mas antes de prosseguir vamos recapitular o que vimos até agora então: Nós conhecemos o protocolo HTTP/1.1, qual o padrão de requisição e resposta, entendemos um pouco de &lt;em&gt;sockets&lt;/em&gt; e por fim montamos um mini servidor que recebe requisições HTTP, e devolve a página solicitada.&lt;/p&gt;

&lt;p&gt;É claro que nosso servidor não é perfeito, além da função &lt;em&gt;main&lt;/em&gt; ter ficado gigante, nosso servidor só responde a uma requisição e para! O ideal é que o servidor permaneça em execução para receber novas requisições e também possa receber várias requisições simultâneas, afinal de contas é para isso que um servidor web serve =D&lt;/p&gt;

&lt;h2 id=&#34;organizando-o-código&#34;&gt;Organizando o código&lt;/h2&gt;

&lt;p&gt;Pra ficar simples, vamos separar a requisição da resposta em duas classes diferentes que vou chamar de RequisicaoHTTP e RespostaHTTP&lt;/p&gt;

&lt;p&gt;RequisicaoHTTP.java&lt;/p&gt;

&lt;pre&gt;import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class RequisicaoHTTP {

    private String protocolo;
    private String recurso;
    private String metodo;
    private boolean manterViva = true;
    private long tempoLimite = 3000;
    private Map&amp;lt;String, List&amp;gt; cabecalhos;

    public static RequisicaoHTTP lerRequisicao(InputStream entrada) throws IOException {
        RequisicaoHTTP requisicao = new RequisicaoHTTP();
        BufferedReader buffer = new BufferedReader(new InputStreamReader(entrada));
        System.out.println(&#34;Requisição: &#34;);
        /* Lê a primeira linha
         contem as informaçoes da requisição
         */
        String linhaRequisicao = buffer.readLine();
        //quebra a string pelo espaço em branco
        String[] dadosReq = linhaRequisicao.split(&#34; &#34;);
        //pega o metodo
        requisicao.setMetodo(dadosReq[0]);
        //paga o caminho do arquivo
        requisicao.setRecurso(dadosReq[1]);
        //pega o protocolo
        requisicao.setProtocolo(dadosReq[2]);
        String dadosHeader = buffer.readLine();
        //Enquanto a linha nao for nula e nao for vazia
        while (dadosHeader != null &amp;&amp; !dadosHeader.isEmpty()) {
            System.out.println(dadosHeader);
            String[] linhaCabecalho = dadosHeader.split(&#34;:&#34;);
            requisicao.setCabecalho(linhaCabecalho[0], linhaCabecalho[1].trim().split(&#34;,&#34;));
            dadosHeader = buffer.readLine();
        }
        //se existir a chave Connection no cabeçalho
        if (requisicao.getCabecalhos().containsKey(&#34;Connection&#34;)) {
            //seta o manterviva a conexao se o connection for keep-alive
            requisicao.setManterViva(requisicao.getCabecalhos().get(&#34;Connection&#34;).get(0).equals(&#34;keep-alive&#34;));
        }
        return requisicao;
    }

    public void setCabecalho(String chave, String... valores) {
        if (cabecalhos == null) {
            cabecalhos = new TreeMap&amp;lt;&amp;gt;();
        }
        cabecalhos.put(chave, Arrays.asList(valores));
    }

    //getters e setters vão aqui
}
&lt;/pre&gt;

&lt;p&gt;Veja que simplesmente copiei a parte onde liamos a requisição e imprimíamos na tela, dentro de um método estático lerRequisicao() que retorna um objeto RequisicaoHTTP. Perceba ainda que esse método recebe o InputStream de onde iremos ler a requisição como parâmetro. Além do mais iremos colocar os dados do cabeçalho em um Mapa&lt;chave,valor&gt; para facilitar o manuseio desses dados posteriormente caso seja necessário.&lt;/p&gt;

&lt;p&gt;Até o momento os únicos dados que utilizávamos da requisição era a primeira linha que contém o caminho do arquivo, a partir de agora vamos usar o Connection (se existir) para saber se manteremos a conexão viva ou não, veja que há uma propriedade tempoLimite que por padrão é 3000 milissegundos (3 segundos), que vamos utilizar para controlar quanto tempo uma conexão deve permanecer ativa. O resto é só você implementar (os métodos &lt;em&gt;getters&lt;/em&gt; e &lt;em&gt;setters&lt;/em&gt; eu omiti).&lt;/p&gt;

&lt;p&gt;RespostaHTTP.java&lt;/p&gt;

&lt;pre&gt;import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class RespostaHTTP {

    private String protocolo;
    private int codigoResposta;
    private String mensagem;
    private byte[] conteudoResposta;
    private Map&amp;lt;String, List&amp;gt; cabecalhos;
    private OutputStream saida;

    public RespostaHTTP() {

    }

    public RespostaHTTP(String protocolo, int codigoResposta, String mensagem) {
        this.protocolo = protocolo;
        this.codigoResposta = codigoResposta;
        this.mensagem = mensagem;
    }

    /**
     * Envia os dados da resposta ao cliente.
     *
     * @throws IOException
     */
    public void enviar() throws IOException {
        //escreve o headers em bytes
        saida.write(montaCabecalho());
        //escreve o conteudo em bytes
        saida.write(conteudoResposta);
        //encerra a resposta
        saida.flush();
    }

    /**
     * Insere um item de cabeçalho no mapa
     *
     * @param chave
     * @param valores lista com um ou mais valores para esta chave
     */
    public void setCabecalho(String chave, String... valores) {
        if (cabecalhos == null) {
            cabecalhos = new TreeMap&amp;lt;&amp;gt;();
        }
        cabecalhos.put(chave, Arrays.asList(valores));
    }

    /**
     * pega o tamanho da resposta em bytes
     *
     * @return retorna o valor em bytes do tamanho do conteudo da resposta
     * convertido em string
     */
    public String getTamanhoResposta() {
        return getConteudoResposta().length + &#34;&#34;;
    }

    /**
     * converte o cabecalho em string.
     *
     * @return retorna o cabecalho em bytes
     */
    private byte[] montaCabecalho() {
        return this.toString().getBytes();
    }

    @Override
    public String toString() {
        StringBuilder str = new StringBuilder();
        str.append(protocolo).append(&#34; &#34;).append(codigoResposta).append(&#34; &#34;).append(mensagem).append(&#34;\r\n&#34;);
        for (Map.Entry&amp;lt;String, List&amp;gt; entry : cabecalhos.entrySet()) {
            str.append(entry.getKey());
            String stringCorrigida = Arrays.toString(entry.getValue().toArray()).replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;);
            str.append(&#34;: &#34;).append(stringCorrigida).append(&#34;\r\n&#34;);
        }
        str.append(&#34;\r\n&#34;);
        return str.toString();
    }
}
&lt;/pre&gt;

&lt;p&gt;Veja que para a resposta utilizamos o mesmo conceito, estamos montando o cabeçalho na requisição em um Mapa&lt;chave, valor&gt;, criei também outros métodos para auxiliar na geração dos dados pertinentes ao cabeçalho, e sobrescrevi o método toString() para converter o mapa no formato padrão da resposta HTTP, e por fim, o método enviar para enviar a requisição ao servidor.&lt;/p&gt;

&lt;p&gt;Servidor.java&lt;/p&gt;

&lt;pre&gt;import java.io.File;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.file.Files;
import java.util.Date;

public class Servidor {

    public static void main(String[] args) throws IOException {
        /* cria um socket &#34;servidor&#34; associado a porta 8000
         já aguardando conexões
         */
        ServerSocket servidor = new ServerSocket(8000);
        //aceita a primeita conexao que vier
        Socket socket = servidor.accept();
        //verifica se esta conectado
        if (socket.isConnected()) {
            //imprime na tela o IP do cliente
            System.out.println(socket.getInetAddress());
            //cria um BufferedReader a partir do InputStream do cliente

            RequisicaoHTTP requisicao = RequisicaoHTTP.lerRequisicao(socket.getInputStream());

            //se o caminho foi igual a / entao deve pegar o /index.html
            if (requisicao.getRecurso().equals(&#34;/&#34;)) {
                requisicao.setRecurso(&#34;index.html&#34;);
            }
            //abre o arquivo pelo caminho
            File arquivo = new File(requisicao.getRecurso().replaceFirst(&#34;/&#34;, &#34;&#34;));

            RespostaHTTP resposta;

            //se o arquivo existir então criamos a reposta de sucesso, com status 200
            if (arquivo.exists()) {
                resposta = new RespostaHTTP(requisicao.getProtocolo(), 200, &#34;OK&#34;);
            } else { 
                //se o arquivo não existe então criamos a reposta de erro, com status 404
                resposta = new RespostaHTTP(requisicao.getProtocolo(), 404, &#34;Not Found&#34;);
            }
            //lê todo o conteúdo do arquivo para bytes e gera o conteudo de resposta
            resposta.setConteudoResposta(Files.readAllBytes(arquivo.toPath()));
            //converte o formato para o GMT espeficicado pelo protocolo HTTP
            String dataFormatada = Util.formatarDataGMT(new Date());
            //cabeçalho padrão da resposta HTTP/1.1
            resposta.setCabecalho(&#34;Location&#34;, &#34;http://localhost:8000/&#34;);
            resposta.setCabecalho(&#34;Date&#34;, dataFormatada);
            resposta.setCabecalho(&#34;Server&#34;, &#34;MeuServidor/1.0&#34;);
            resposta.setCabecalho(&#34;Content-Type&#34;, &#34;text/html&#34;);
            resposta.setCabecalho(&#34;Content-Length&#34;,resposta.getTamanhoResposta());
            //cria o canal de resposta utilizando o outputStream
            resposta.setSaida(socket.getOutputStream());
            resposta.enviar();

        }
    }
}

&lt;/pre&gt;

&lt;p&gt;Agora o código do nosso servidor está pequeno mas ainda não é o suficiente &amp;#8211; continua recebendo uma requisição e respondendo apenas uma vez. Vamos ver mais um conceito:&lt;/p&gt;

&lt;h2 id=&#34;threads&#34;&gt;Threads&lt;/h2&gt;

&lt;p&gt;As &lt;em&gt;threads&lt;/em&gt;, de maneira geral, são segmentos de código que são executados &amp;#8220;paralelamente&amp;#8221; (ou pelo menos quase) dentro de um mesmo programa. Para exemplificar melhor, pense nisso: imagine que ao abrir um software de grandes proporções, ele tenha que carregar todas as bibliotecas necessárias, mas ao mesmo tempo tem que mostrar ao usuário o progresso do carregamento. A ideia que temos é que esses dois trechos de código são executados paralelamente. Isso é possível graças às _threads._ Neste exemplo, temos duas &lt;em&gt;threads&lt;/em&gt; executando: uma que carrega as bibliotecas e outra que mostra o progresso para o usuário. Dentro de um programa, pode-se ter quantas threads quisermos, e enquanto o programa estiver executando, essas &lt;em&gt;threads&lt;/em&gt; podem ser criadas, executadas, terminadas, permitir que novas &lt;em&gt;threads&lt;/em&gt; e outros. Quem faz esse controle é a máquina virtual (JVM).&lt;/p&gt;

&lt;p&gt;Olha que legal, um servidor recebe várias conexões simultâneas, onde por essas conexões passarão as requisições. Praticamente, todas essas requisições são processadas da mesma maneira, logo, para cada conexão que esse servidor recebe, ele cria uma nova &lt;em&gt;thread&lt;/em&gt;, permitindo tratar as requisições de um cliente. Veja só, se temos 5 computadores solicitando uma página, então teremos 5 threads processando essas requisições, e por aí vai.&lt;/p&gt;

&lt;p&gt;Agora fica fácil analisar qual segmento do código queremos executar paralelamente. A partir desse segmento iremos montar uma estrutura de Thread, da seguinte maneira:&lt;/p&gt;

&lt;p&gt;ThreadConexao.java&lt;/p&gt;

&lt;pre&gt;import java.io.File;
import java.io.IOException;
import java.net.Socket;
import java.net.SocketTimeoutException;
import java.nio.file.Files;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ThreadConexao implements Runnable {

    private final Socket socket;
    private boolean conectado;

    public ThreadConexao(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        conectado = true;
        //imprime na tela o IP do cliente
        System.out.println(socket.getInetAddress());
        while (conectado) {
            try {
                //cria uma requisicao a partir do InputStream do cliente
                RequisicaoHTTP requisicao = RequisicaoHTTP.lerRequisicao(socket.getInputStream());
                //se a conexao esta marcada para se mantar viva entao seta keepalive e o timeout
                if (requisicao.isManterViva()) {
                    socket.setKeepAlive(true);
                    socket.setSoTimeout(requisicao.getTempoLimite());
                } else {
                    //se nao seta um valor menor suficiente para uma requisicao
                    socket.setSoTimeout(300);
                }

                //se o caminho foi igual a / entao deve pegar o /index.html
                if (requisicao.getRecurso().equals(&#34;/&#34;)) {
                    requisicao.setRecurso(&#34;index.html&#34;);
                }
                //abre o arquivo pelo caminho
                File arquivo = new File(requisicao.getRecurso().replaceFirst(&#34;/&#34;, &#34;&#34;));

                RespostaHTTP resposta;

                //se o arquivo existir então criamos a reposta de sucesso, com status 200
                if (arquivo.exists()) {
                    resposta = new RespostaHTTP(requisicao.getProtocolo(), 200, &#34;OK&#34;);
                } else {
                    //se o arquivo não existe então criamos a reposta de erro, com status 404
                    resposta = new RespostaHTTP(requisicao.getProtocolo(), 404, &#34;Not Found&#34;);
                    arquivo = new File(&#34;404.html&#34;);
                }
                //lê todo o conteúdo do arquivo para bytes e gera o conteudo de resposta
                resposta.setConteudoResposta(Files.readAllBytes(arquivo.toPath()));
                //converte o formato para o GMT espeficicado pelo protocolo HTTP
                String dataFormatada = Util.formatarDataGMT(new Date());
                //cabeçalho padrão da resposta HTTP/1.1
                resposta.setCabecalho(&#34;Location&#34;, &#34;http://localhost:8000/&#34;);
                resposta.setCabecalho(&#34;Date&#34;, dataFormatada);
                resposta.setCabecalho(&#34;Server&#34;, &#34;MeuServidor/1.0&#34;);
                resposta.setCabecalho(&#34;Content-Type&#34;, &#34;text/html&#34;);
                resposta.setCabecalho(&#34;Content-Length&#34;, resposta.getTamanhoResposta());
                //cria o canal de resposta utilizando o outputStream
                resposta.setSaida(socket.getOutputStream());
                resposta.enviar();
            } catch (IOException ex) {
                //quando o tempo limite terminar encerra a thread
                if (ex instanceof SocketTimeoutException) {
                    try {
                        conectado = false;
                        socket.close();
                    } catch (IOException ex1) {
                        Logger.getLogger(ThreadConexao.class.getName()).log(Level.SEVERE, null, ex1);
                    }
                }
            }

        }
    }

}
&lt;/pre&gt;

&lt;p&gt;A estrutura de uma &lt;em&gt;thread&lt;/em&gt; é bem simples: uma classe que implementa a interface Runnable. Essa interface possui um único método a ser implementado, o método run(). Esse método é o nosso segmento de código que queremos que seja executado em paralelo. Veja que nele temos o código que tínhamos na &lt;em&gt;main&lt;/em&gt; com apenas algumas modificações para controlar o tempo máximo de conexão (o tempo que a conexão deve se manter ativa).&lt;/p&gt;

&lt;h2 id=&#34;threadpools&#34;&gt;ThreadPools&lt;/h2&gt;

&lt;p&gt;Por fim, temos que falar um pouco sobre as Thread Pools, que tem o trabalho de controlar a criação de &lt;em&gt;threads&lt;/em&gt;. Claro que podemos criar quantas &lt;em&gt;threads&lt;/em&gt; quisermos, mas, às vezes, a situação requer um certo controle, ainda mais quando um servidor web pode receber milhares ou até milhões de requisições por segundo. Por isso, precisamos gerenciar essas &lt;em&gt;threads&lt;/em&gt; de maneira eficiente, para que nosso servidor não sobrecarregue. Para isso, o Java tem os Executors, que criam um ambiente de execução de múltiplas &lt;em&gt;threads&lt;/em&gt;. Existem diversos tipos de ExecutorService. No nosso caso, iremos utilizar o fixo, que significa limitarmos a criação de &lt;em&gt;threads&lt;/em&gt; a um número fixo. Se o número de &lt;em&gt;threads&lt;/em&gt; criadas exceder o limite, essas novas &lt;em&gt;threads&lt;/em&gt; deverão aguardar até que as outras &lt;em&gt;threads&lt;/em&gt; terminem para começar a executar. Com isso, nossa classe Servidor passa a ficar da seguinte forma:&lt;/p&gt;

&lt;p&gt;Servidor.java&lt;/p&gt;

&lt;pre&gt;import java.io.IOException;
import java.net.ServerSocket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class Servidor {

    public static void main(String[] args) throws IOException {
        /* cria um socket &#34;servidor&#34; associado a porta 8000
         já aguardando conexões
         */
        ServerSocket servidor = new ServerSocket(8000);
        //executor que limita a criação de threads a 20
        ExecutorService pool = Executors.newFixedThreadPool(20);
        
        while (true) {
            //cria uma nova thread para cada nova solicitacao de conexao
            pool.execute(new ThreadConexao(servidor.accept()));
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Veja que agora colocamos a criação de novas &lt;em&gt;threads&lt;/em&gt; while(true). Isso impede que nosso servidor pare de executar após a primeira requisição, permitindo que ele aceite múltiplas conexões. Você deve estar a se perguntar &amp;#8211; mas um &lt;em&gt;while true&lt;/em&gt; não gera um laço infinito? &amp;#8211; de certa forma sim, mas para a nossa situação esta é a ideia, já que não queremos que o servidor pare, e que o servidor só finalize quando o usuário enviar o comando CTRL+C no prompt/terminal. De qualquer forma, o método accept() é bloqueado até que receba uma nova conexão, e esse laço sé será executado quando houver uma solicitação, caso contrário, ficará parado num estado de bloqueio =D&lt;/p&gt;

&lt;p&gt;Pronto. Agora temos um servidor funcional que aceita conexões múltiplas e responde a muitas requisições.&lt;/p&gt;

&lt;h2 id=&#34;considerações-finais&#34;&gt;Considerações finais&lt;/h2&gt;

&lt;p&gt;Nosso servidor está longe de ser uma versão completa para competir com o Apache e outros servidores HTTP, até por que nosso servidor só envia documentos HTML. Vale lembrar que, quando o navegador recebe um HTML como resposta, ele tem que renderizá-lo, e ao fazer isto, ele encontra tags de arquivos de imagem, áudio, scripts ou estilos, o que gera outras requisições para o servidor, para que ele envie também esses arquivos. O código ainda pode ser melhorado, teríamos que fazer com que o servidor forneça o Content-Type correto para cada tipo de arquivo (o que não é difícil, fica como exercício). Também seria necessário implementar uma camada de segurança (o que hoje em dia é fundamental, pois sem ela nosso servidor está completamente vulnerável a ataques), e por aí vai.&lt;/p&gt;

&lt;p&gt;Além do mais, nosso servidor responde ao padrão HTTP/1.1, mas recentemente foi lançado o protocolo HTTP2, que veio para tornar o antigo padrão ainda mais rápido. Embora tenha sofrido alterações internas (o que significa que os servidores HTTP terão que se &amp;#8220;adaptar&amp;#8221; para seguirem esse novo padrão), o conceito continua o mesmo. Você pode ler um pouco mais sobre HTTP2 nesse post &lt;a href=&#34;http://tableless.com.br/http2-atualizacao-do-protocolo-base-da-internet/&#34;&gt;&amp;#8220;HTTP/2 – Atualização do protocolo base da internet&amp;#8221;&lt;/a&gt; e nesse &lt;a href=&#34;http://tableless.com.br/http2-para-desenvolvedores-de-web/&#34;&gt;&amp;#8220;HTTP2 para Desenvolvedores de Web&amp;#8221;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Espero ter despertado em vocês a vontade de conhecer mais a fundo como as coisas funcionam, para criarem suas próprias contribuições e compartilharem com a galera, afinal, esse é o espirito do Tableless.&lt;/p&gt;

&lt;p&gt;Por favor, deixem comentários, se gostaram ou não, erros, dúvidas. O feedback de vocês é importante.&lt;/p&gt;

&lt;p&gt;Até a próxima =D&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;referências&#34;&gt;Referências:&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Lições sobre socket (em inglês):&lt;/strong&gt; &lt;a title=&#34;http://www.oracle.com/technetwork/java/socket-140484.html&#34; href=&#34;http://www.oracle.com/technetwork/java/socket-140484.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.oracle.com/technetwork/java/socket-140484.html&#34;&gt;http://www.oracle.com/technetwork/java/socket-140484.html&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java Tutorial Tudo sobre sockets (em inglês):&lt;/strong&gt; &lt;a title=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/&#34; href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://docs.oracle.com/javase/tutorial/networking/sockets/&#34;&gt;http://docs.oracle.com/javase/tutorial/networking/sockets/&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RFC2616 (em inglês):&lt;/strong&gt; &lt;a title=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616.html&#34; href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616.html&#34;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616.html&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Código&lt;/strong&gt;&lt;strong&gt; Fonte Completo:&lt;/strong&gt; &lt;a title=&#34;Repo MeuServidorHTTP&#34; href=&#34;https://github.com/thiguetta/MeuServidorHTTP&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/thiguetta/MeuServidorHTTP&#34;&gt;https://github.com/thiguetta/MeuServidorHTTP&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Versão alternativa que fornece arquivos de imagem, javascript e css também:&lt;/strong&gt; &lt;a title=&#34;Repo SimpleHTTPServer&#34; href=&#34;https://github.com/thiguetta/SimpleHTTPServer&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/thiguetta/SimpleHTTPServer&#34;&gt;https://github.com/thiguetta/SimpleHTTPServer&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando seu próprio servidor HTTP do zero (ou quase) – Parte I</title>
      <link>https://tableless.github.io/hugo-public/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-i/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-i/</guid>
      <description>

&lt;p&gt;Sou apaixonado por tecnologias livres e como sou extremamente curioso, gosto de saber como as coisas funcionam. Como também sou cinestésico, não me contento em apenas em entender, tenho que criar, recriar, escrever, rescrever, inventar, reinventar, enfim sentir realmente como se faz. Nesse vai e vem de aprendizado, minha última curiosidade foi entender como os servidores HTTP funcionam e criar um do zero (ou pelo menos quase).&lt;/p&gt;

&lt;p&gt;É claro que para fazer isso eu não fui tão lá embaixo a ponto de utilizar C, utilizei da linguagem de programação da qual me sinto mais confortável e que já oferece algumas facilidades que em C teria que sangrar pra fazer o mesmo porém não impossível, mas enfim, optei por desenvolver em Java, os passos vou contar pra vocês aqui, mas utilizando os mesmo conceitos nada impede que utilize qualquer outra linguagem de programação.&lt;/p&gt;

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Vamos ao que interessa! A grosso modo, um servidor HTTP é uma aplicação (software) que fornece páginas web (geralmente escritas em HTML), ou seja, ao digitar o endereço da página (URL) e dar um ENTER no seu navegador, ele envia uma requisição no servidor destino, o servidor processa essa informação e retorna o documento HTML correspondente, por fim o navegador renderiza o documento e exibe aquela página bonita (nem sempre!).&lt;/p&gt;

&lt;div style=&#34;width: 510px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;http://www.tankonyvtar.hu/en/tartalom/tamop425/0027_ADW1/images/ADW100.png&#34;&gt;&lt;img src=&#34;http://www.tankonyvtar.hu/en/tartalom/tamop425/0027_ADW1/images/ADW100.png&#34; alt=&#34;Requisição HTTP&#34; width=&#34;500&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Requisição HTTP
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Para isso vamos entender como a comunicação entre seu navegador e o servidor funciona, o protocolo, depois vamos entender como é feita a conexão, tratar e enviar documentos e por fim vamos deixar nosso servidor pronto para receber múltiplas conexões.&lt;/p&gt;

&lt;h2 id=&#34;o-protocolo-http&#34;&gt;O Protocolo HTTP&lt;/h2&gt;

&lt;p&gt;É claro que nem so de Web a Internet é feita, existem uma serie de recursos que estão sobre a Internet, a web é uma delas, mas para que esses serviços sejam tratados como devem é necessário ter um linguagem comum que permita que o servidor entenda o que o navegador quer, e que o navegador saiba se a resposta do pedido está correta ou não, para isso estabelecem-se os protocolos, que são padrões estipulados por um órgão competente afim de uniformizar o “trafego” de informações de diferentes serviços na internet. Quem define esses padrões é a IETF (Internet Engineering Task Force, ou melhor, Força Tarefa de Engenharia da Internet). Para saber mais quem são eles, acesse &lt;a href=&#34;http://www.ietf.org&#34; target=&#34;_blank&#34;&gt;aqui&lt;/a&gt; (em Inglês)&lt;/p&gt;

&lt;p&gt;O protocolo HTTP, ou Hyper Text Transfer Protocol, ou melhor ainda, protocolo de transferencia de hiper texto, direto e reto é o cara que define a troca de paginas HTML, pronto falei!. A versão mais atual (que é a que vamos adotar nesse tutorial por assim dizer) é a 1.1 que na minha opinião é a mais difundida também (pode ser que encontre por ai alguns utilizando a versão 1.0 ou até mesmo a 0.9), enfim , essa versão e seus padrões foram propostos no documento &lt;a href=&#34;http://www.ietf.org/rfc/rfc2068.txt&#34; target=&#34;_blank&#34;&gt;RFC 2068&lt;/a&gt; e atualizado e alterado por diversos outros RFCs, que não convém a gente falar aqui, mas se tiver curiosidade procura lá no site da IEFT acima que tem todos.&lt;/p&gt;

&lt;p&gt;So para nos situar o HTTP está na camada mais alta do protocolo de comunicação de rede conhecido como TCP/IP (não vamos entrar em detalhes pois não é o foco), chamada camada de aplicação (Nada mais justo já que o servidor e o navegados são aplicações).&lt;/p&gt;

&lt;div style=&#34;width: 430px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;http://static.thegeekstuff.com/wp-content/uploads/2011/10/tcp-ip.png&#34;&gt;&lt;img src=&#34;http://static.thegeekstuff.com/wp-content/uploads/2011/10/tcp-ip.png&#34; alt=&#34;Camadas de Rede (TCP/IP)&#34; width=&#34;420&#34; height=&#34;470&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Camadas de Rede (TCP/IP)
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;No nosso escopo, o servidor é um software que fica aguardando solicitações, falando em nível de aplicação, o processo é simples, o navegador (vamos chamar de cliente) envia uma requisição (request), o servidor processa e devolve uma resposta(response).&lt;/p&gt;

&lt;h2 id=&#34;a-requisição&#34;&gt;A Requisição&lt;/h2&gt;

&lt;p&gt;A requisição é um “documento” em texto plano composto por um cabeçalho (que define  a comunicação, requerido) e os dados (opcional, depende da aplicação).&lt;/p&gt;

&lt;p&gt;O cabeçalho é bem simples, a primeira linha contém a informação principal da requisição, ou seja, qual a sua solicitação (método), o que está sendo solicitado (arquivo/página/recurso a ser acessado) e padrão de comunicação que no nosso caso é o HTTP/1.1, a segunda linha é o endereço de host do servidor que irá responder a sua solicitação, veja o exemplo:&lt;/p&gt;

&lt;pre&gt;GET /index.html HTTP/1.1
Host: &lt;a href=&#34;http://google.com&#34;&gt;google.com&lt;/a&gt;&lt;/pre&gt;

&lt;p&gt;As linhas seguintes são informações pertinentes a conexão e podem conter informações de quem está solicitando, o formato dessas informações é do tipo &lt;propriedade&gt; : &lt;valor&gt; o final de cada linha é encerrado por um &lt;CR&gt;&lt;LF&gt; (cuidado, pois muitos confundem este comando com o ENTER, embora para windows esse comando corresponde ao ENTER, não é verdade para Linux e afins), o final da requisição deve ser uma linha em branco (ou seja apenas um &lt;CR&gt;&lt;LF&gt;)veja o exemplo de uma requisição completa&lt;/p&gt;

&lt;pre&gt;GET /HTTP/1.1
Host: www.google.com.br
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:29.0) Gecko/20100101 Firefox/29.0
Accept: text/html,application/xhtml+xml,application/xml
Accept-Language: pt-BR,pt,en-US,en
Accept-Encoding: gzip, deflate
Connection: keep-alive&lt;/pre&gt;

&lt;p&gt;Traduzindo, queremos pegar (GET) a raiz ou página inicial ( / ) que está em “www.google.com.br”. Esta requisição está sendo enviada de um navegador (User-Agent) Firefox, que aceita (Accept) os seguintes formatos, html e xml de preferencia que estejam no idioma (Accept-Language) Português do Brasil (pt-BR) ou qualquer outro idioma a seguir (veja que é possível passar uma lista de idiomas na ordem em que gostaria que aparecessem, veja que caso o servidor não tenha nenhuma dessas páginas ou não trate essa propriedade, ele irá devolver a página no idioma padrão do html que ele encontrar correspondente a sua solicitação), o formato de compactação aceito pelo navegador  (Accept-Enconding) e por fim a persistência da conexão, ou seja se você quer que o servidor mantenha a conexão ativa, o que eu quero dizer é que para cada recurso dentro de uma pagina HTML, seja uma imagem, um estilo css, ou um javascript, que precisa ser carregado, o navegador faz uma nova requisição, não seria legal criar uma nova conexão para cada requisição ainda mais se elas acontecem em um curto espaço de tempo, então o keep-alive mantém a conexão “viva&amp;#8221; tempo pra que esses recursos sejam carregados. É claro que o protocolo define muito mais propriedades, como pode observar no documento RFC mencionado acima, porém cada servidor deve implementar essas funcionalidades, no nosso caso vamos implementar apenas as funcionalidades na requisição de exemplo e algumas mais que mencionaremos mais adiante.&lt;/p&gt;

&lt;h2 id=&#34;a-resposta&#34;&gt;A Resposta&lt;/h2&gt;

&lt;p&gt;A resposta segue um formato bem parecido da requisição, a primeira linha contem o protocolo, o código e mensagem de retorno como segue:&lt;/p&gt;

&lt;pre&gt;HTTP/1.1 200 OK&lt;/pre&gt;

&lt;p&gt;Esse código é esperado quando a pagina solicitada foi encontrada e seu conteúdo está enviada logo abaixo do cabeçalho (veremos a diante). Existem diversos códigos de retorno de sucesso, e de erro também, quem aqui nunca recebeu um 404 Not Found ao tentar acessar uma página que não existe?, esses e outros detalhes iremos tratar na parte de implementação. Por fim as linhas seguintes da resposta contem algumas informações pertinentes ao navegador e por fim a pagina html solicitada, veja que o conteúdo é concatenado com a resposta:&lt;/p&gt;

&lt;pre&gt;HTTP/1.1 200 OK
Date: Tue, 17 Jun 2014 01:20:13 GMT
Server: gws
Location: https://www.google.com.br/
Last-Modified: Tue, 17 Jun 2014 01:20:13 GMT
Content-Encoding: gzip
Content-Length: 234
Connection: closeContent-Type: text/html


&amp;lt;html&amp;gt;todo o html da página&amp;lt;/html&amp;gt; *&lt;/pre&gt;

&lt;p&gt;*este conteúdo pode estar compactado&lt;/p&gt;

&lt;p&gt;Nesta resposta o servidor retorna a data da resposta (Date), qual o nome/tipo/empresa que desenvolveu/sistema operacional do servidor que gerou a resposta, a localização atual (Location) importante caso seu site use caminho relativo em hiperlinks, imagens e outros (veremos com mais detalhes na implementação) ultima vez que o arquivo foi modificado (Last-Modified), importante caso o navegador permita cache de paginas, compactacao do conteúdo (Content-Enconding), para que o navegador saiba fazer a descompactacao se necessário, tamanho em bytes do  conteúdo,o estado da conexão, que neste caso o servidor informa que a conexão foi fechado, o tipo do conteúdo(Content-Type), que é um texto contendo html e por fim, é claro, o conteúdo da resposta, ou seja, aquilo que o navegador irá exibir pra gente.&lt;/p&gt;

&lt;p&gt;Quer testar? Então abra o navegador de sua preferência, melhor que seja o firefox =D, em seguida abra o modo de desenvolvedor (geralmente é so apertar F12), e por fim clique na aba Rede, pronto agora é so digitar um site na barra de endereço, e acompanhar as requisições pelo console, se quiser mais detalhes clique em uma requisição e peça para exibir detalhes, se estiver usando o firefox, ele aparece esses detalhes logo na lateral da lista de requisições. analise as propriedades enviadas na requisição e veja qual foi a resposta. você irá percebem que existem mais propriedades do que comentamos aqui, mas para nós neste tutorial não será necessário, se quiser pode pesquisar mais sobre eles ou ler o documento RFC que ja falamos sobre ele.&lt;/p&gt;

&lt;div id=&#34;attachment_17&#34; style=&#34;width: 310px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;http://euamoaweb.com.br.md-54.webhostbox.net/arquivolivre.com.br/wp-content/uploads/2014/06/Screen-Shot-2014-06-17-at-12.00.06-AM.png&#34;&gt;&lt;img class=&#34;wp-image-17 size-medium&#34; src=&#34;http://blog-tsg0.rhcloud.com/wp-content/uploads/2014/06/Screen-Shot-2014-06-17-at-12.00.06-AM-300x165.png&#34; alt=&#34;Requisicao&#34; width=&#34;300&#34; height=&#34;165&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Requisicao
  &lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;attachment_18&#34; style=&#34;width: 310px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;http://euamoaweb.com.br.md-54.webhostbox.net/arquivolivre.com.br/wp-content/uploads/2014/06/Screen-Shot-2014-06-17-at-12.00.34-AM.png&#34;&gt;&lt;img class=&#34;wp-image-18 size-medium&#34; src=&#34;http://blog-tsg0.rhcloud.com/wp-content/uploads/2014/06/Screen-Shot-2014-06-17-at-12.00.34-AM-300x166.png&#34; alt=&#34;Resposta&#34; width=&#34;300&#34; height=&#34;166&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Resposta
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Chegamos ao fim da primeira parte do nosso tutorial, sei que teoria é chato mas se faz necessário, mas prometo que na &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-ii/&#34; target=&#34;_blank&#34;&gt;Parte II&lt;/a&gt; colocaremos as mãos a obra.&lt;/p&gt;

&lt;p&gt;Então até a próxima.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP/2 – Atualização do protocolo base da internet</title>
      <link>https://tableless.github.io/hugo-public/http2-atualizacao-do-protocolo-base-da-internet/</link>
      <pubDate>Wed, 18 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/http2-atualizacao-do-protocolo-base-da-internet/</guid>
      <description>&lt;p&gt;HTTP é o protocolo de comunicação base usado para a internet funcionar. O nome é Hypertext Transfer Protocol. Olha só a palavra Hypertext aparecendo de novo. Onde mais você encontra ela? Isso! Exato! Na sigla HTML: HyperText Markup Language. O HTTP é o protocolo que troca ou faz a transferência de hipertextos.&lt;/p&gt;

&lt;p&gt;Eu não vou explicar aqui o que é um &lt;a href=&#34;http://pt.wikipedia.org/wiki/Hipertexto&#34;&gt;Hipertexto&lt;/a&gt; porque eu sei que você já sabe. Mas a grande novidade é que durante os últimos 16 anos nós usamos uma mesma versão desse protocolo e agora a galera do &lt;a href=&#34;https://httpwg.github.io/&#34;&gt;IETF HTTP Working Group&lt;/a&gt; soltou a atualização, chamada de HTTP/2!&lt;/p&gt;

&lt;p&gt;O HTTP/2 não é uma reescrita completa do protocolo, tanto que os métodos e códigos de status continuam os mesmos. O foco foi em performance. Especificamente para diminuir a latência percebida pelo usuário final, redes e a melhora do uso de recursos do servidor. Eles dizem que o objetivo principal é usar uma única conexão entre o browser e o website!&lt;/p&gt;

&lt;p&gt;O ponto principal do HTTP/1.1 era que ele permitia que o seu site fosse comprimido pelos servidores e depois descomprimidos pelos computadores. Isso resolve uma série de problemas de tamanho em uma época onde conexão era muito restrita. A versão 1.1 do protocolo permitiu que a internet continuasse crescendo, resolvendo o uso de dados em grandes quantidades pelos websites.&lt;/p&gt;

&lt;p&gt;A versão 2 tem quase o mesmo propósito. O principal problema resolvido agora é que o browser faz várias requisições de arquivos para o servidor montar seu websitio. Todo mundo aqui usa CSS, JS, imagens, vídeos, fonts e diversas outras coisinhas para fazer websites bonitos e agradáveis. Isso carrega demais as páginas e significa mais requisições entre browser e servidor.&lt;/p&gt;

&lt;p&gt;O ponto é que o browser só consegue fazer uma requisição por vez, por servidor. Essas requisições demoram para serem feitas, principalmente quando há CSS ou JS bloqueantes. Por isso que muita gente, principalmente grandes websites, baixam imagens, JS, CSS etc de diferentes servidores. E aqui se forma o problema. Conforme isso vai acontecendo, a carga na rede, como um todo, aumenta bastante e vários outros serviços começam a engasgar.&lt;/p&gt;

&lt;p&gt;O que muda então é o seguinte: enquanto hoje o browser faz uma requisição para ter uma resposta, ele vai fazer uma requisição e conseguirá ter várias respostas de uma vez. Isso quer dizer que ele pode falar com o servidor uma vez e pedir tudo o que tem direito. Isso é muito importante e um grande avanço.&lt;/p&gt;

&lt;p&gt;Isso não quer dizer que você vai desistir da performance do seu site, pelo contrário, você vai ter tempo para melhorar a performance de outros pontos, por exemplo, o processamento do computador ao montar sua página, uso de memória etc.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&#34;https://www.mnot.net/blog&#34;&gt;Mark Nottingham&lt;/a&gt;, chairman do IETF, &lt;a href=&#34;https://www.mnot.net/blog/2015/02/18/http2&#34;&gt;fez um post em seu blog no dia 18 de Fevereiro&lt;/a&gt; explicando o lançamento e dando mais detalhes.&lt;/p&gt;

&lt;p&gt;Uma curiosidade interessante é que eles usaram o &lt;a href=&#34;https://github.com/http2&#34;&gt;GitHub para definir as especificações, testes etc&lt;/a&gt;. &lt;a href=&#34;http://http2.github.io/&#34;&gt;Veja a especificação aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Se tiver perguntas, o pessoal do IETF &lt;a href=&#34;http://http2.github.io/faq/&#34;&gt;criou um FAQ bastante extenso&lt;/a&gt; explicando uma série de perguntar pertinentes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>O grande desencontro do HTTP com o HTML</title>
      <link>https://tableless.github.io/hugo-public/o-grande-desencontro-http-com-o-html/</link>
      <pubDate>Mon, 06 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/o-grande-desencontro-http-com-o-html/</guid>
      <description>

&lt;p&gt;O texto irá contar a evolução e desencontro de duas tecnologias. O importante aqui é apresentar a você uma série de conceitos e raciocínios ligados à linguagem de marcação e ao protocolo de marcação mais famosos dos nossos tempos. Vê se não banca o curioso, nada de descer até o fim do texto para conhecer o desfecho desta trama.&lt;/p&gt;

&lt;h2 id=&#34;prólogo&#34;&gt;Prólogo&lt;/h2&gt;

&lt;h3 id=&#34;hypertext-transfer-protocol-http&#34;&gt;Hypertext Transfer Protocol (HTTP)&lt;/h3&gt;

&lt;p&gt;O HTTP é um protocolo de comunicação para distribuição de objetos de hipermídia referenciados por uma URL. Este é o principal dos protocolos da Internet e com certeza, como desenvolvedores, é o que devemos melhor conhecer. A função do protocolo é bastante simples: realizar requisições e receber respostas entre um cliente e servidor.&lt;/p&gt;

&lt;p&gt;A transmissão de informações entre um emissor e um receptor caracteriza uma comunicação. E da mesma forma que uma comunicação interpessoal, a cordialidade é essencial. O protocolo HTTP estabelece um cabeçalho para suas requisições e respostas. O cabeçalho de uma mensagem são informações complementares que são de uso do cliente e servidor. Através das informações passadas pelo cabeçalho, que são de uso exclusivo do servidor e navegador, é possível informar em uma requisição a preferência de idiomas, as codificações e os formatos de conteúdo para uma resposta. O cabeçalho da resposta, por sua vez, contém o &lt;a href=&#34;http://httpstatus.es&#34;&gt;código de status&lt;/a&gt;, codificação, formato do conteúdo e tempo de expiração da página.&lt;/p&gt;

&lt;h4 id=&#34;métodos-de-requisição&#34;&gt;Métodos de requisição&lt;/h4&gt;

&lt;p&gt;O protocolo HTTP foi criado no projeto World Wide Web e designado para operar essencialmente com documentos de hipertexto. Nesta época, havia somente o método GET para requisitar as páginas, mas isto foi antes de qualquer especificação do protocolo.&lt;/p&gt;

&lt;p&gt;O HTTP 1.1, que constitui a especificação consolidada mais recente, possui alguns outros métodos que são informados no cabeçalho da requisição. Os principais métodos que você deve conhecer são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;: desde sempre, solicita um objeto para o servidor. Em tempo, objetos são qualquer entidade que o servidor conheça e que o cliente esteja interessando em manipular.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PUT&lt;/strong&gt;: escreve um objeto no servidor de maneira a respeitar a propriedade da &lt;a href=&#34;http://pt.wikipedia.org/wiki/Idempot%C3%AAncia&#34;&gt;idempotência&lt;/a&gt;. Em linhas gerais, este tipo de requisição pode ser chamada mais de uma vez e o resultado no servidor será o mesmo. Geralmente estas requisições carregam consigo um identificador único para o objeto e portanto são mais usadas para alterá-lo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;: escreve um objeto no servidor sem respeitar a propriedade da idempotência. Requisições deste tipo, quando repetidas, podem gerar resultados diferentes no servidor. O uso comum é para a criação de objetos no servidor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DELETE&lt;/strong&gt;: remove um objeto no servidor.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;representational-state-transfer-rest&#34;&gt;Representational State Transfer (REST)&lt;/h3&gt;

&lt;p&gt;Graças a ubiquidade alcançada pelos navegadores, aplicações apoiadas na internet são cada vez mais comuns. REST é um estilo de arquitetura que define como aplicações devem utilizar o protocolo HTTP e URLs para representar recursos.&lt;/p&gt;

&lt;p&gt;O estilo estabelece que o conceito de &lt;strong&gt;recurso&lt;/strong&gt; é tudo aquilo no servidor que pode ser nomeado, tal como documentos ou imagens. Cada recurso deve possuir um identificador único, ou seja, uma &lt;strong&gt;URL&lt;/strong&gt;. Por exemplo, uma aplicação para gerenciar produtos pode identificar um recurso de produto através da URL &lt;code&gt;products/59&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O cliente, através dos &lt;strong&gt;métodos de requisição do HTTP&lt;/strong&gt;, efetua ações em um recurso. Considerando a mesma aplicação, requisições com método &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; e &lt;code&gt;DELETE&lt;/code&gt; para a URL &lt;code&gt;products/59&lt;/code&gt; irão mostrar, alterar e excluir o produto, respectivamente. Note, uma única URL para três diferentes ações.&lt;/p&gt;

&lt;p&gt;O último conceito relacionado a REST é o de &lt;strong&gt;representação&lt;/strong&gt;. O cliente sempre irá transferir uma representação de um recurso. Informações passadas pelo cabeçalho da requisição ou acrescentadas ao fim da URL podem informar qual o formato da representação que se espera de um recurso. Desta forma, o mesmo recurso pode ser transferido na forma de HTML, JSON e até mesmo XML.&lt;/p&gt;

&lt;p&gt;O Ruby on Rails, &lt;em&gt;framework&lt;/em&gt; bastante usado para desenvolver aplicações &lt;em&gt;web&lt;/em&gt;, prove uma série de funcionalidades para auxiliar o uso de REST. Para compreender melhor o assunto, basta conferir &lt;a href=&#34;http://guides.rubyonrails.org/routing.html#crud-verbs-and-actions&#34;&gt;o guia de rotas&lt;/a&gt; do Ruby on Rails, que documenta como definir URLs e ações de &lt;em&gt;controller&lt;/em&gt; com base em recursos.&lt;/p&gt;

&lt;p&gt;A bibliografia a respeito de REST é vasta. A última dica sobre o assunto é conferir a tradução de um texto que é muito bom e engraçado: &lt;a href=&#34;http://distopico.wordpress.com/traducao-de-how-i-explained-rest-to-my-wife&#34;&gt;Como eu expliquei REST para a minha esposa&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;hypertext-markup-language-html&#34;&gt;Hypertext Markup Language (HTML)&lt;/h3&gt;

&lt;p&gt;O desenvolvimento do HTML foi concomitante ao do HTTP, sua função é marcar os documentos do projeto World Wide Web. Você já está careca de saber que o HTML é um conjunto de &lt;em&gt;tags&lt;/em&gt; que estruturam e garantem semântica ao documento.&lt;/p&gt;

&lt;h2 id=&#34;capítulo-1-a-evolução-das-especificações&#34;&gt;Capítulo 1: A evolução das especificações&lt;/h2&gt;

&lt;p&gt;No início, o navegador tinha como função ser a interface para uma grande biblioteca distribuída. O protocolo HTTP, antes mesmo da sua especificação, tinha apenas um método GET. Não havia a intenção de se alterar as informações armazenadas em um servidor. A primeira especificação do HTTP já era mais ambiciosa e definia uma série de &lt;a href=&#34;http://www.w3.org/Protocols/HTTP/Methods.html&#34;&gt;métodos de requisições&lt;/a&gt;. Com estes métodos, já era possível deixar explícito que uma alteração seria realizada no servidor.&lt;/p&gt;

&lt;p&gt;Criada logo após a especificação do HTTP, a &lt;a href=&#34;http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt&#34;&gt;primeira especificação do HTML&lt;/a&gt; era um pouco menos ambiciosa. Tente imaginar, a especificação não continha formulários. Mesmo assim, os métodos de requisição do HTTP não foram deixados de fora. As âncoras aceitavam um atributo &lt;code&gt;methods&lt;/code&gt; para indicar quais métodos poderiam ser usados ao requisitar determinado objeto. Poucos navegadores deram suporte ao atributo, o qual nunca chamou muita a atenção e na especificação atual já está obsoleto.&lt;/p&gt;

&lt;p&gt;Manter o HTML com o único propósito de marcar conteúdo já não era a estratégia quando definida a segunda especificação da linguagem. A especificação eleva o HTML 2.0 a um &lt;em&gt;Internet Media Type&lt;/em&gt;. Isto significa que os usuários podem não apenas navegar e interagir com documentos, mas também preencher e submeter formulários.&lt;/p&gt;

&lt;p&gt;Além de um atributo &lt;code&gt;action&lt;/code&gt; com a URL de destino, os formulários aceitam um atributo &lt;code&gt;method&lt;/code&gt; que suporta os valores &lt;code&gt;GET&lt;/code&gt; ou &lt;code&gt;POST&lt;/code&gt; como método da requisição de envio. O uso de &lt;code&gt;POST&lt;/code&gt;, segundo a especificação, é restrito a operações que modifiquem a base de dados ou assinem algum serviço.&lt;/p&gt;

&lt;h2 id=&#34;capítulo-2-o-desencontro&#34;&gt;Capítulo 2: O desencontro&lt;/h2&gt;

&lt;p&gt;No estado atual da especificação, o HTML suporta âncoras que realizam requisições com o método &lt;code&gt;GET&lt;/code&gt; e formulários que são enviados com método &lt;code&gt;GET&lt;/code&gt; ou &lt;code&gt;POST&lt;/code&gt;. Qualquer outro recurso, tais como imagens, folhas de estilo e &lt;em&gt;scripts&lt;/em&gt;, são requisitados com o método &lt;code&gt;GET&lt;/code&gt;. &lt;strong&gt;O HTML não possui nenhum recurso para o uso dos métodos &lt;code&gt;PUT&lt;/code&gt; e &lt;code&gt;DELETE&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O resultado é que não existe uma maneira de utilizar uma API REST unicamente através de HTML. Em outras palavras, uma página pode apenas acessar e criar novos recursos. Não é possível excluir ou alterar recursos utilizando REST e toda a sorte dos métodos de requisição do HTTP.&lt;/p&gt;

&lt;p&gt;As discussões a respeito desta falha de compatibilidade são antigas. Existem várias propostas de soluções. A mais notável, chamada &lt;a href=&#34;http://cameronjones.github.io/form-http-extensions/index.html#form-method-attribute&#34;&gt;HTML Form HTTP Extensions&lt;/a&gt;, acrescenta um atributo &lt;code&gt;method&lt;/code&gt; ao formulário que aceita a maioria dos métodos do HTTP 1.1. Desta maneira, é possível disparar uma requisição com método &lt;code&gt;DELETE&lt;/code&gt; através de um formulário. A proposta, que é um rascunho não oficial e não possui suporte em nenhum navegador, inclui também artifícios para adicionar informações ao cabeçalho da requisição.&lt;/p&gt;

&lt;h2 id=&#34;capítulo-3-alternativas&#34;&gt;Capítulo 3: Alternativas&lt;/h2&gt;

&lt;p&gt;Antes de falar das alternativas, é importante nos voltarmos para o JavaScript. A API &lt;code&gt;XMLHttpRequest&lt;/code&gt; permite o uso de todos os métodos além de manipular outros dados do cabeçalho da requisição:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = new XMLHttpRequest();
request.open(&#39;DELETE&#39;, &#39;products/59&#39;);

request.setRequestHeader(&#39;X-Requested-With&#39;, &#39;XMLHttpRequest&#39;);
request.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É importante destacar que poder disparar requisições com diferentes métodos apenas através de JavaScript não é o bastante. Em especial, requisições deste tipo são assíncronas, não sendo sempre o que precisamos.&lt;/p&gt;

&lt;h3 id=&#34;formulários&#34;&gt;Formulários&lt;/h3&gt;

&lt;p&gt;Apesar do Ruby on Rails se tratar de um framework para desenvolver aplicações web para navegadores, o estilo REST é suportado e evangelizado em toda a documentação do framework.&lt;/p&gt;

&lt;p&gt;Enquanto as especificações não evoluem, os formulários parecem ser a melhor alternativa para disparar diferentes métodos. O Ruby on Rails tem como dependência o &lt;a href=&#34;http://rack.github.io&#34;&gt;Rack&lt;/a&gt;, que é uma interface para desenvolver aplicações em Ruby. O Rack permite que o formulário com método &lt;code&gt;POST&lt;/code&gt; possa informar um novo método através de um campo &lt;code&gt;_method&lt;/code&gt;. Isto não afeta diretamente o método da requisição, apenas faz com que o Ruby on Rails interprete a requisição de maneira diferente. O formulário a seguir seria atendido por uma rota de &lt;code&gt;DELETE&lt;/code&gt; de &lt;code&gt;products/59&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;products/59&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;_method&amp;quot; value=&amp;quot;delete&amp;quot;&amp;gt;
    &amp;lt;button&amp;gt;Deletar produto&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caso esteja utilizando Ruby on Rails, não é recomendado possuir códigos como este nas suas &lt;code&gt;views&lt;/code&gt;. Ao invés disto, utilize &lt;a href=&#34;http://guides.rubyonrails.org/form_helpers.html&#34;&gt;Form Helpers&lt;/a&gt;, os quais já se encarregam de escrever este e outros campos necessários para o correto funcionamento do framework.&lt;/p&gt;

&lt;p&gt;Tratando-se de outras linguagens, diferentes frameworks &lt;em&gt;full-stack&lt;/em&gt; também endereçam esta solução. O Laravel, escrito em PHP, &lt;a href=&#34;http://laravel.com/docs/html#opening-a-form&#34;&gt;também suporta um campo &lt;code&gt;hidden&lt;/code&gt; de nome &lt;code&gt;_method&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A flexibilidade e vantagem desta solução é poder ter as mesmas rotas e ações para manipular um recurso através de formulários HTML e requisições JavaScript. Graças ao REST, as diferentes ações podem transferir uma representação do recurso em HTML ou JSON para requisições oriundas de formulários e &lt;code&gt;XMLHttpRequest&lt;/code&gt;, respectivamente.&lt;/p&gt;

&lt;h3 id=&#34;âncoras&#34;&gt;Âncoras&lt;/h3&gt;

&lt;p&gt;Segunda a especificação, os &lt;em&gt;links&lt;/em&gt; são conexões entre dois recursos. Em especial, as âncoras permitem que o usuário navegue através de um documento ou acesse outro recurso seguindo determinada URL. Os &lt;em&gt;links&lt;/em&gt;, que incluem &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;, sempre requisitam recursos através do método &lt;code&gt;GET&lt;/code&gt; e portanto &lt;strong&gt;não devem causar efeito colateral no servidor&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;removendo-registros&#34;&gt;Removendo registros&lt;/h4&gt;

&lt;p&gt;Em áreas administrativas, é bastante comum termos registros em tabelas com uma âncora de excluir. E está errado por vários motivos: não é por navegar para uma página que registros devem ser excluídos. Lembre-se que nos tempos em que conexão banda larga era rara, aceleradores praticavam acesso a todas as âncoras para agilizar a navegação. Assim, tudo seria excluído. O mínimo a se dizer é que cada um destes botões devem estar envoltos em um formulário &lt;code&gt;POST&lt;/code&gt;, até mesmo se sua aplicação não respeitar REST.&lt;/p&gt;

&lt;p&gt;Um argumento que pode surgir contra esta prática é a mudança dos elementos no HTML, por trocarmos um único &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; por um formulário que tem um &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; não tão fácil de estilizar. Se você estiver utilizando REST, existe uma alternativa que é apoiada em JavaScript: continuar usando &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; que quando clicado criará e enviará um formulário. O Ruby on Rails faz exatamente isto com o auxílio do &lt;code&gt;jquery_ujs&lt;/code&gt; incluso na gem &lt;a href=&#34;https://github.com/rails/jquery-rails&#34;&gt;jquery-rails&lt;/a&gt; quando encontra uma âncora com &lt;code&gt;data-method&lt;/code&gt; igual a esta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;products/59&amp;quot; data-method=&amp;quot;delete&amp;quot; rel=&amp;quot;nofollow&amp;quot;&amp;gt;Remover&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O atributo &lt;code&gt;rel&lt;/code&gt; com valor &lt;code&gt;nofollow&lt;/code&gt; serve para que esta âncora não seja deliberadamente seguida. Repetindo uma recomendação, caso esteja no Rails, utilize o &lt;em&gt;helper&lt;/em&gt; &lt;code&gt;link_to&lt;/code&gt; ao invés de escrever diretamente o código acima.&lt;/p&gt;

&lt;p&gt;Um detalhe importante é que através desta abordagem, caso o comportamento do JavaScript seja impedido, o usuário terá apenas acesso a uma representação do recurso. O mesmo acontece para o caso de o usuário copiar esta URL e acessar pela barra de navegação. Nestes casos, uma requisição &lt;code&gt;GET&lt;/code&gt; é disparada e não haverá exclusão do recurso. A questão aqui é que a representação do recurso, ou seja, a página que é exibida ao acessar &lt;code&gt;products/59&lt;/code&gt; através de &lt;code&gt;GET&lt;/code&gt;, deve conter um formulário que permita excluir o produto. Este artifício muitas vezes é deixado de lado e a exclusão dos registros fica condiciona a JavaScript.&lt;/p&gt;

&lt;h2 id=&#34;nota-do-autor&#34;&gt;Nota do autor&lt;/h2&gt;

&lt;p&gt;O conceito de REST é muito interessante e espero que logo possamos utilizar nativamente no HTML. Seria genial e com certeza é necessária uma evolução da especificação neste aspecto. Cá entre nós, evoluções deste tipo são muito mais úteis que mudar a semântica de &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; e afins.&lt;/p&gt;

&lt;p&gt;Antes de mais nada, não se esqueça que &lt;strong&gt;acessar um &lt;em&gt;link&lt;/em&gt; não pode causar nenhum efeito colateral na sua aplicação&lt;/strong&gt;. Use e abuse de formulários. Mais ainda, faça que o &lt;em&gt;back-end&lt;/em&gt; da sua aplicação utilize REST. Escolha um bom &lt;em&gt;framework&lt;/em&gt; e vá em frente.&lt;/p&gt;

&lt;p&gt;Desculpe pelo texto ter ficado extenso e talvez um tanto pesado. Espero que tenha gostado e que aproveite estas dicas para escrever aplicações melhores.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>