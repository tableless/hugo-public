<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Navegadores on Tableless</title>
    <link>http://tableless.com.br/tags/navegadores/index.xml</link>
    <description>Recent content in Navegadores on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="http://tableless.com.br/tags/navegadores/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Detectando navegadores com Bowser</title>
      <link>http://tableless.com.br/detectando-navegadores-com-bowser/</link>
      <pubDate>Tue, 24 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/detectando-navegadores-com-bowser/</guid>
      <description>

&lt;h2 id=&#34;uma-ajuda-para-detectar-e-dar-suporte-a-diferentes-navegadores&#34;&gt;Uma ajuda para detectar e dar suporte a diferentes navegadores&lt;/h2&gt;

&lt;h3 id=&#34;o-bowser&#34;&gt;O Bowser&lt;/h3&gt;

&lt;p&gt;Em muitos projetos, precisamos dar uma atenção especial para alguns navegadores (nosso querido IE, por exemplo). A proposta do &lt;strong&gt;Bowser&lt;/strong&gt; é facilitar a detecção de navegadores e suas versões, minimizando os erros de detecção, e facilitando sua vida.&lt;/p&gt;

&lt;h3 id=&#34;mãos-à-obra&#34;&gt;Mãos à obra&lt;/h3&gt;

&lt;p&gt;Para começar, você precisa fazer o download do arquivo JavaScript do &lt;strong&gt;Bowser&lt;/strong&gt; no &lt;a href=&#34;https://github.com/ded/bowser&#34; target=&#34;_blank&#34;&gt;GitHub oficial do projeto&lt;/a&gt;, e inclui-lo no seu HTML. Depois, basta fazer suas condicionais utilizando o objeto Javascript Bowser, que contém várias informações sobre seu navegador.&lt;/p&gt;

&lt;p&gt;Podemos facilmente detectar se o navegador é IE, na versão menor ou igual a 8, como a seguir:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript,&#34;&gt;if (bowser.msie &amp;&amp; bowser.version &amp;lt;= 8) {
  alert(&#39;Atualize seu browser!&#39;);
};
&lt;/pre&gt;

&lt;p&gt;Ou você pode detectar a &lt;em&gt;engine&lt;/em&gt; do navegador:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript,&#34;&gt;if (bowser.webkit) {
  alert(&#39;A engine do seu navegador é Webkit!&#39;);
};
&lt;/pre&gt;

&lt;p&gt;E também pode fazer um tratamento específico pra mobile:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript,&#34;&gt;if (bowser.mobile &amp;&amp; bowser.ios) {
  alert(&#39;Você está num dispositivo mobile da Apple!&#39;);
};
&lt;/pre&gt;

&lt;p&gt;Agora você não precisa mais gastar seu tempo escrevendo muitas linhas de JavaScript com &lt;em&gt;regex&lt;/em&gt; para todos os lados, tentando detectar navegadores, versões, se é mobile ou desktop&amp;#8230; O Bowser te entrega tudo isso.&lt;/p&gt;

&lt;p&gt;O projeto está disponível no &lt;a href=&#34;https://github.com/ded/bowser&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando seu próprio servidor HTTP do zero (ou quase) – Parte III</title>
      <link>http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-iii/</link>
      <pubDate>Mon, 05 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-iii/</guid>
      <description>

&lt;p&gt;Estamos entrando na terceira parte do tutorial, e quem está acompanhando até aqui já sabe então como funciona a comunicação entre cliente e servidor, envio de requisição pelo cliente e recebimento de resposta (na duvida só voltar e releia a &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-i/&#34; title=&#34;Criando seu próprio servidor HTTP do zero (ou quase) – Parte I&#34;&gt;Parte I&lt;/a&gt; e/ou &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-ii/&#34; title=&#34;Criando seu próprio servidor HTTP do zero (ou quase) – Parte II&#34;&gt;Parte II&lt;/a&gt;), porém o que a gente quer é criar o servidor, receber as requisições e enviar a resposta ao cliente.&lt;/p&gt;

&lt;h2 id=&#34;o-servidor&#34;&gt;O Servidor&lt;/h2&gt;

&lt;p&gt;A idéia do servidor é bem simples e estende a do cliente, como assim? Fácil, fácil. no post anterior vimos como criar um socket, no caso, nos criamos um socket já conectado ao site do google, mas o que internamente acontece é, criamos um socket, associamos esse socket a uma porta (lembrando que no caso do cliente a porta aberta é aleatória, so para que o servidor saiba onde deve retornar a resposta) e conectamos ao socket do servidor na porta especifica.&lt;/p&gt;

&lt;p style=&#34;text-align: justify&#34;&gt;
  Agora vamos pensar um pouco, no caso do servidor, temos que criar um socket, associar (bind) a uma porta especifica(para que todos os clientes saibam exatamente onde conectar) e ficamos aguardando alguém solicitar uma conexão (listen), se alguém solicitar conexão nós aceitamos (accept), resumindo o processo, temos como na imagem abaixo:
&lt;/p&gt;

&lt;div style=&#34;width: 369px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;a href=&#34;http://3.bp.blogspot.com/_Gt5b2CU22sM/S4iS4lbeU5I/AAAAAAAAAUU/DBmariOce1o/s400/rzab6503.gif&#34;&gt;&lt;img src=&#34;http://3.bp.blogspot.com/_Gt5b2CU22sM/S4iS4lbeU5I/AAAAAAAAAUU/DBmariOce1o/s400/rzab6503.gif&#34; alt=&#34;&#34; width=&#34;359&#34; height=&#34;324&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Diagrama Cliente/Servidor
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Em Java já temos uma classe pronta que faz isso, que é o ServerSocket, que já cria um socket que está aguardando conexões, o que torna nossa vida bem mais simples, então vamos parar de teoria e ir pro código, para isso criamos uma classe chamada Servidor e nela faremos o seguinte:&lt;/p&gt;

&lt;pre&gt;import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

public class Servidor {

    public static void main(String[] args) throws IOException {
        /* cria um socket &#34;servidor&#34; associado a porta 8000
          já aguardando conexões
        */
        ServerSocket servidor = new ServerSocket(8000);
        //aceita a primeita conexao que vier
        Socket socket = servidor.accept();
        //verifica se esta conectado  
        if (socket.isConnected()) {
            //imprime na tela o IP do cliente
            System.out.println(&#34;O computador &#34;+ socket.getInetAddress() + &#34; se conectou ao servidor.&#34;);
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Veja que estamos abrindo a porta 8000 e não a 80, isso por que embora essa seja a porta &amp;#8220;destinada/utilizada&amp;#8221; para servidores HTTP, ela é gerenciada pelo sistema operacional então não poderemos abri-la por enquanto (o SO não permitiria até por que em alguns sistemas linux já existe um servidor HTTP utilizando essa porta, em outros a porta está bloqueada pelo firewall, e teremos que abri-la manualmente mas veremos isso em breve), por isso vamos utilizar outra porta para testes, vamos compilar esse código e coloca-lo em execução, veja que ele permanecerá em execução até que ele receba pelo menos uma solicitação de conexão, que é o que vamos fazer, assim basta abrir o navegador e digitar o endereço &lt;a href=&#34;http://localhost:8000&#34;&gt;http://localhost:8000&lt;/a&gt; e ir para a página, veja que ao fazer isso sua linha de comando aparecerá a frase:&lt;/p&gt;

&lt;pre&gt;java Server
O computador /0:0:0:0:0:0:0:1 se conectou ao servidor.&lt;/pre&gt;

&lt;p&gt;Veja  que este é o endereço IP do seu computador já no formato IPv6.  Note  que logo em seguida o programa foi finalizado, isso porque nosso servidor não está configurado para múltiplas conexões/requisições, porém vamos fazer isso já já, agora vamos ver qual foi a requisição que nosso navegador fez ao servidor, e para ler a entrada o conceito é o mesmo de ontem, vamos usar o InputStream para ler os dados enviados pelo cliente, então vamos adicionar o seguinte código logo após imprimir o IP:&lt;/p&gt;

&lt;pre&gt;[...]
            //cria um BufferedReader a partir do InputStream do cliente
            BufferedReader buffer = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            System.out.println(&#34;Requisição: &#34;);
            //Lê a primeira linha
            String linha = buffer.readLine();
            //Enquanto a linha não for vazia
            while (!linha.isEmpty()) {
                //imprime a linha
                System.out.println(linha);
                //lê a proxima linha
                linha = buffer.readLine();
            }
[...]
&lt;/pre&gt;

&lt;p&gt;Veja que agora utilizamos um BufferedReader ao invés do Scanner, isto por que o Scanner mesmo após ter terminado de ler a requisição ele espera que a a conexão seja encerrada, a fim de aguardar novas entradas, mas como não é interessante para gente esperar,  vamos usar o Buffer pois podemos verificar se a linha for vazia, se for, simplesmente encerra o programa sem ter que aguardar que a conexão seja encerrada. (Caso seja necessário continuar lendo a entrada antes da conexão encerras é so pegar o InputReader novamente e continuar lendo. Agora ao executarmos nosso servidor,  e acessar a página localhost:8000 no navegador teremos a seguinte saída na linha de comando:&lt;/p&gt;

&lt;pre&gt;java Server
O computador /0:0:0:0:0:0:0:1 se conectou ao servidor.
Requisição: 
GET / HTTP/1.1
Host: localhost:8000
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:29.0) Gecko/20100101 Firefox/29.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: pt-BR,pt;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
DNT: 1
Connection: keep-alive&lt;/pre&gt;

&lt;p&gt;Veja que minha requisição foi originada de um navegador Firefox e que o formato da requisição é muito semelhante do que vimos na primeira parte do tutorial =D. Agora é so fazer o servidor tratar essas informações e devolver uma resposta ao cliente, nesse caso vamos devolver uma página HTML que é o que o navegador espera. Vamos criar duas páginas uma chamada índex.html e outra 404.html, e vamos armazena-las na mesma pasta que está colocando o código fonte do servidor com os seguintes códigos:&lt;/p&gt;

&lt;p&gt;Arquivo index.html&lt;/p&gt;

&lt;h1 id=&#34;funcionou&#34;&gt;Funcionou!!!!&lt;/h1&gt;

&lt;p&gt;Arquivo 404.html&lt;/p&gt;

&lt;pre&gt;Erro 404&lt;/pre&gt;

&lt;h1 id=&#34;a-página-que-você-procura-não-foi-encontrada&#34;&gt;A página que você procura não foi encontrada&lt;/h1&gt;

&lt;p&gt;Por convenção quando alguém solicita o arquivo &amp;#8220;/&amp;#8221; está solicitando a pagina inicial que geralmente é o índex.html, dependendo da configuração do servidor, no nosso caso queremos que nosso servidor retorne o índex.html, se o usuário pedir por qualquer coisa no formato &amp;#8220;/{nome da pagina}.html&amp;#8221; retornaremos esse arquivo, caso o arquivo não exista, retornaremos o erro 404 e a página de erro correspondente.&lt;/p&gt;

&lt;p&gt;Sabemos que a primeira linha da requisição contem o método, o arquivo solicitado e o protocolo separados por um espaço em branco, para o nosso servidor o método não importa, então assumiremos sempre o GET, e o protocolo será sempre o HTTP/1.1, então o que nos importa é o arquivo solicitado. Vamos alterar o nosso código que deve ficar assim:&lt;/p&gt;

&lt;pre&gt;[...]
            /* Lê a primeira linha
             contem as informaçoes da requisição
             */
            String linha = buffer.readLine();
            //quebra a string pelo espaço em branco
            String[] dadosReq = linha.split(&#34; &#34;);
            //pega o metodo
            String metodo = dadosReq[0];
            //paga o caminho do arquivo
            String caminhoArquivo = dadosReq[1];
            //pega o protocolo
            String protocolo = dadosReq[2];
            //Enquanto a linha não for vazia
            while (!linha.isEmpty()) {
                //imprime a linha
                System.out.println(linha);
                //lê a proxima linha
                linha = buffer.readLine();
            }
            //se o caminho foi igual a / entao deve pegar o /index.html
            if (caminhoArquivo.equals(&#34;/&#34;)) {
                caminhoArquivo = &#34;/index.html&#34;;
            }
            //abre o arquivo pelo caminho
            File arquivo = new File(caminhoArquivo);
            byte[] conteudo;
            //status de sucesso - HTTP/1.1 200 OK
            String status = protocolo + &#34; 200 OK\r\n&#34;;
            //se o arquivo não existe então abrimos o arquivo de erro, e mudamos o status para 404
            if (!arquivo.exists()) {
                status = protocolo + &#34; 404 Not Found\r\n&#34;;
                arquivo = new File(&#34;/404.html&#34;);
            }
            conteudo = Files.readAllBytes(arquivo.toPath());
[...]
&lt;/pre&gt;

&lt;p&gt;Veja que ainda não respondemos ao navegados com os dados, apenas montamos uma parte da resposta, para enviar a resposta precisaremos do OutputStream e montar uma string com a estrutura básica da resposta, dai vamos escrever esses dados no stream, semelhante ao que fizemos na parte II do nosso tutorial:&lt;/p&gt;

&lt;pre&gt;//cria um formato para o GMT espeficicado pelo HTTP
            SimpleDateFormat formatador = new SimpleDateFormat(&#34;E, dd MMM yyyy hh:mm:ss&#34;, Locale.ENGLISH);
            formatador.setTimeZone(TimeZone.getTimeZone(&#34;GMT&#34;));
            Date data = new Date();
            //Formata a dara para o padrao
            String dataFormatada = formatador.format(data) + &#34; GMT&#34;;
            //cabeçalho padrão da resposta HTTP
            String header = status
                    + &#34;Location: http://localhost:8000/\r\n&#34;
                    + &#34;Date: &#34; + dataFormatada + &#34;\r\n&#34;
                    + &#34;Server: MeuServidor/1.0\r\n&#34;
                    + &#34;Content-Type: text/html\r\n&#34;
                    + &#34;Content-Length: &#34; + conteudo.length + &#34;\r\n&#34;
                    + &#34;Connection: close\r\n&#34;
                    + &#34;\r\n&#34;;
            //cria o canal de resposta utilizando o outputStream
            OutputStream resposta = socket.getOutputStream();
            //escreve o headers em bytes
            resposta.write(header.getBytes());
            //escreve o conteudo em bytes
            resposta.write(conteudo);
            //encerra a resposta
            resposta.flush();
&lt;/pre&gt;

&lt;p&gt;Agora é só compilar, rodar e ver o resultado =D&lt;/p&gt;

&lt;p&gt;No caso de sucesso deve aparecer como na figura abaixo:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/09/sucesso.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-51391&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/09/sucesso.png&#34; alt=&#34;200 - Sucesso&#34; width=&#34;1279&#34; height=&#34;707&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Caso a página não existe, deve aparecer assim:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/09/erro404.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-51392&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/09/erro404.png&#34; alt=&#34;Erro 404&#34; width=&#34;1280&#34; height=&#34;709&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Temos um servidor funcional capaz de fornecer as páginas HTML para os clientes que solicitarem, mas perceba que nosso servidor atende a apenas uma requisição e se encerra logo em seguida, sem contar que nosso método main ficou gigante, mas fique tranquilo, isso será assunto para a próxima e ultima parte do tutorial, onde vamos organizar melhor nosso código, tratar alguns comandos do servidor importantes como manter a conexão viva e trabalhar com múltiplas requisições, conexões simultâneas e afins. Por hora fica o exercício, tente organizar o código a sua maneira, altere como desejar, crie mais páginas HTML e teste e veja se está sendo exibida corretamente, todo código feito até aqui está no final da página e está todo comentado para facilitar o entendimento.&lt;/p&gt;

&lt;p&gt;Espero que estejam gostando e por favor deixem comentários com seu feedback: o que achou, dúvidas, se funcionou ou não, se a abordagem não estiver adequada ou mesmo erros que posso ter cometido pelo caminho.&lt;/p&gt;

&lt;p&gt;Até o próximo post.&lt;/p&gt;

&lt;p&gt;Download do código fonte: &lt;a href=&#34;https://github.com/thiguetta/ServidorHTTP&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/thiguetta/ServidorHTTP&#34;&gt;https://github.com/thiguetta/ServidorHTTP&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando seu próprio servidor HTTP do zero (ou quase) – Parte II</title>
      <link>http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-ii/</link>
      <pubDate>Fri, 11 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-ii/</guid>
      <description>

&lt;p&gt;Se chegou até aqui é por que você terminou de ler a primeira parte do tutorial (Caso não, leia a &lt;a href=&#34;http://tableless.com.br/criando-seu-proprio-servidor-http-do-zero-ou-quase-parte-i/&#34; title=&#34;Criando seu próprio servidor HTTP do zero (ou quase) – Parte I&#34;&gt;Parte I&lt;/a&gt; ), mas não desista, a parte legal vai chegar, mas antes de começar, falta mais um item de teoria &amp;#8211;  sim eu sei que é chato, mas juro que é importante &amp;#8211; os Sockets.&lt;/p&gt;

&lt;h2 id=&#34;sockets-e-portas&#34;&gt;Sockets e portas&lt;/h2&gt;

&lt;p&gt;Falamos muito de requisições e respostas no último post mas ainda não falamos de conexão e troca de informações. Bom, vamos lá, ligeiramente comentamos um pouco sobre os protocolos de rede, também disse que o protocolo web, o HTTP, está na camada mais alta do TCP/IP, a camada de aplicação, mas para este tutorial pouco importa o que acontece nas camadas inferiores  (se tiver curiosidade procure mais sobre), o que realmente importa é saber que esse tal de TCP/IP é responsável pela conexão entre dois pontos (dois computadores, ou no nosso caso, cliente e servidor).&lt;/p&gt;

&lt;p&gt;Tanto o servidor quanto o cliente são computadores com seus respectivos sistemas operacionais (Linux, Windows, etc) e neles estão em execução diversas aplicações inclusive o navegador e o próprio servidor HTTP, mas nesse monte de aplicações em execução, como vamos saber que estamos enviando e recebendo dados da aplicação certa? precisamos de um algo que identifique cada aplicação (ou pelo menos que identifique uma aplicação que use a rede). Esses pontos de identificação, por assim dizer, são chamados de Socket (ou em português, soquete, tomada, encaixe, enfim algo que tenha uma “abertura/encaixe&amp;#8221; para conexão), resumindo é um ponto que permite conectar alguma coisa, no nosso caso, um outro computador através da rede. Para receber uma conexão, o Socket precisa de uma abertura, essa abertura é o que chamamos de porta, sei que para alguns o conceito parece ser trivial, mas para outros, inclusive profissionais de TI, esses conceitos podem embaralhar a cabeça.&lt;/p&gt;

&lt;p&gt;Resumindo, um Socket é o ponto final da conexão, onde uma porta é aberta para que a aplicação possa enviar ou receber dados, cada porta é identificada por um número que é única no computador, sendo que se tentar abrir uma porta que já estiver sendo usado por outra aplicação, o sistema operacional irá barrar e retornar um erro de acesso negado ou informa que a porta está em uso.&lt;/p&gt;

&lt;p&gt;Existe uma lista de portas conhecidas  que são utilizadas por algumas aplicações, as mais comuns são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;21 FTP &amp;#8211; Transferencia de arquivo&lt;/li&gt;
&lt;li&gt;22 SSH &amp;#8211;  Secure Shell&lt;/li&gt;
&lt;li&gt;25 SMTP &amp;#8211; Envio de Emails&lt;/li&gt;
&lt;li&gt;80 HTTP &amp;#8211; Web&lt;/li&gt;
&lt;li&gt;443 HTTPS &amp;#8211; Web “Segura&amp;#8221;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Uma porta ela é única por computador mas não é única na internet, quando você quer efetuar a conexão com uma determinada aplicação rodando em um computador remoto, a identificação do socket é composto pelo endereço de IP ou o nome canônico (domínio &amp;#8211; endereço do site) da máquina destino e a porta que essa aplicação usando, no seguinte formato {Endereço}:{Porta}.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;exemplo.com:80 ou
 192.168.1.224:1000     
&lt;/pre&gt;

&lt;p&gt;A maioria das aplicações que requerem conexão com algum serviço se conectam diretamente as portas especificas que cada uma delas usa, sendo necessário informar apenas o IP (ao menos que seja uma porta que a aplicação não conheça, o serviço está funcionando numa porta atípica ai será necessário informar, veremos mais na parte III). O que isso significa? isso significa que quando você digita o site &lt;a href=&#34;http://www.google.com.br&#34;&gt;http://www.google.com.br&lt;/a&gt; no seu navegador, ele sabe que os servidores HTTP estão executando na porta 80, então não é preciso identificar-la, pois o navegador irá &amp;#8220;converter&amp;#8221; para o formato correto, transparentemente, a mesma coisa acontece quando você acessa um site seguro utilizando &lt;a href=&#34;https://www.seubanco.com.br&#34;&gt;https://www.seubanco.com.br&lt;/a&gt; o navegador sabe que a porta de conexão segura no servidor é a 443, e tentará se conectar nela.&lt;/p&gt;

&lt;p&gt;O que acontece é seu navegador irá se conectar ao site, ele sabe que o servidor está respondendo na porta 80 no endereço tal, para isso é necessário que o navegador abre uma porta local aleatória, para que assim o servidor possa saber para quem responder:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.raywenderlich.com/wp-content/uploads/2011/06/sockets.jpg&#34;&gt;&lt;img src=&#34;http://www.raywenderlich.com/wp-content/uploads/2011/06/sockets.jpg&#34; alt=&#34;&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pronto agora que entendemos o conceito (ou pelo menos espero que tenham entendido =D) vamos colocar as mãos na massa.&lt;/p&gt;

&lt;p&gt;Vou partir do principio que já sabem criar uma classe e compilar um programa em Java (caso não lembre-se que o Google é nosso amigo =D). Se preferir, usando o mesmo conceito pode converter a ideia para a linguagem de sua preferência (só não esqueça de compartilhar com a galera =D).&lt;/p&gt;

&lt;p&gt;Vamos lá, vou criar uma classe em Java chamada Cliente, será uma classe simples que vai se conectar a um servidor (neste caso vamos conectar no &lt;a href=&#34;http://google.com.br&#34;&gt;google.com.br&lt;/a&gt;) e ver se ele está conectado, se sim ele imprimirá na tela o IP do servidor.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;import java.io.IOException;
import java.net.Socket;

public class Cliente {
    public static void main(String[] args) throws IOException {
        //cria um socket com o google na porta 80
        Socket socket = new Socket(&#34;google.com.br&#34;, 80);
        //verifica se esta conectado
        if (socket.isConnected()) { 
            //imprime o endereço de IP do servidor
            System.out.println(&#34;Conectado a &#34; + socket.getInetAddress());
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Ao instanciar um novo objeto da classe Socket com os parâmetros domínio e porta, internamente a máquina virtual Java já abre uma porta aleatória em seu computador e em seguida conecta ao servidor google.com.br na porta 80. Veja que até então não sabemos o endereço de IP do servidor mas ao efetuar a conexão o socket já se atualiza com essa informação. Vamos compilar nossa classe e verificar o resultado que  deve ser algo desse tipo:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ javac Cliente.java
$ java Cliente
Conectado a google.com.br/173.194.118.151&lt;/pre&gt;

&lt;p&gt;Mas isso não é o suficiente queremos trocar informações com o servidor conectado, para isso nosso socket fornece 2 recursos  um para leitura dos dados recebidos (InputStream) do servidor e outro para enviar os dados que queremos para o servidor (OutputStream), é claro que para enviarmos algum dado para o servidor temos que saber como se comunicar com o servidor, como a gente já sabe, o servidor do google é um servidor HTTP que nos fornece as páginas de serviço do Google, certo? então sabemos que o servidor entende o protocolo HTTP. vamos enviar uma requisição HTTP simples a esse servidor e ver o que ele responde.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;/* veja que a requisição termina com \r\n que equivale a &amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;
       para encerar a requisição tem uma linha em branco */
    String requisicao = &#34;&#34;
        + &#34;GET / HTTP/1.1\r\n&#34;
        + &#34;Host: www.google.com.br\r\n&#34;
        + &#34;\r\n&#34;;
    //OutputStream para enviar a requisição
    OutputStream envioServ = socket.getOutputStream();
    //temos que mandar a requisição no formato de vetor de bytes
    byte[] b = requisicao.getBytes();
    //escreve o vetor de bytes no &#34;recurso&#34; de envio 
    envioServ.write(b);
    //marca a finalização da escrita
    envioServ.flush();
&lt;/pre&gt;

&lt;p&gt;É claro que apenas isso não basta pois somente estamos enviando a requisição certo?, então precisaremos ler o InputStream logo após enviar os dados para ver o que o servidor responde, vamos facilitar as coisas afinal isto não é C, para ler o que o servidor responde vamos utilizar um Scanner, que ja faz a conversão o Input de bytes para String, assim a gente não tem que tratar esses trecos.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;//cria um scanner a partir do InputStream que vem do servidor
    Scanner sc = new Scanner(socket.getInputStream());
    //enquanto houver algo para ler
    while (sc.hasNext()) {
        //imprime uma linha da resposta
        System.out.println(sc.nextLine());
    }
&lt;/pre&gt;

&lt;p&gt;Agora se executarmos o programa podemos ler o que o servidor nos devolve e exibir na tela, logo teremos um resultado parecido com isso&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;$ javac Cliente.java 
$ java Cliente
Conectado a google.com.br/173.194.118.151 
HTTP/1.1 200 OK
Date: Tue, 17 Jun 2014 23:29:57 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
Set-Cookie: PREF=ID=fee5bb44e3822528:FF=0:TM=1403047797:LM=1403047797:S=BpVMDbzBHKUgdlRS; expires=Thu, 16-Jun-2016 23:29:57 GMT; path=/; domain=.google.com.br
Set-Cookie: NID=67=CT9hDvtQnKCvGeox_lmn7IjB_gbZ6Z9m7YT2rM1LAw2hVDVbvas16qfTsH1Jc1TRhrynqE-j0fb3EPl_JvjttiV-kqVpJlYjmg7Qd_e8oHcnJM1L2xlHWtlKw2EcomUM; expires=Wed, 17-Dec-2014 23:29:57 GMT; path=/; domain=.google.com.br; HttpOnly
P3P: CP=&#34;This is not a P3P policy! See http://www.google.com/support/accounts/bin/answer.py?hl=en&amp;answer=151657 for more info.&#34;
Server: gws
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN
Alternate-Protocol: 80:quic
Transfer-Encoding: chunked

8000
&amp;lt;!doctype html&amp;gt;&amp;lt;html[...]um monte de HTML[...]

0
&lt;/pre&gt;

&lt;p&gt;Veja que o resultado é semelhante ao que vimos anteriormente sobre na nossa teoria de requisição e resposta, também há algumas outras propriedade que não vimos mas não importa para nós ao menos que queira se aprofundar no assunto. Veja também que seu programa também continua em execução, isso acontece porque o servidor do google ainda não encerrou a conexão, isso acontece porque no HTTP/1.1 a propriedade &amp;#8220;Connection: keep-alive&amp;#8221; é padrão mesmo que não enviamos na requisição, quem define esse tempo é o próprio servidor, por experiência própria eu sei que a conexão com o google se mantém ativa por aproximadamente 3 minutos, isso para dar tempo suficiente para que você faça todas as pesquisas sem ter que criar uma nova conexão para cada pesquisa que você faz, isso é importante no caso do google já que ele recebe milhares de requisições por segundo, sendo que varias delas são feitas pela mesma pessoa, então não convém criar uma nova conexão para cada nova requisição.&lt;/p&gt;

&lt;p&gt;Você deve estar se perguntando, mas Thiago, isso não é o que o navegador faz?&lt;/p&gt;

&lt;p&gt;&amp;#8211; Sim, o que fizemos hoje foi implementar a parte mais básica de um navegados web.&lt;/p&gt;

&lt;p&gt;Mas a proposta é fazer um servidor e não um navegador, certo?&lt;/p&gt;

&lt;p&gt;&amp;#8211; Certo, mas antes de avançarmos é importante entender bem qual é o trabalho do navegador antes de criar o servidor que irá responder as requisições dele, mas isso será assunto para a parte III.&lt;/p&gt;

&lt;p&gt;Posso fazer em outra linguagem?&lt;/p&gt;

&lt;p&gt;&amp;#8211; Claro, socket é implementado em todas as linguagens, basta consultar a documentação da sua linguagem preferida para entender como replicar o conceito acima.&lt;/p&gt;

&lt;p&gt;Por hoje ficamos por aqui pessoal, espero que tenham aproveitado bem nossa parte prática, no próximo começaremos definitivamente a criar nosso servidor.&lt;/p&gt;

&lt;p&gt;Até Mais.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTTP2 para Desenvolvedores de Web</title>
      <link>http://tableless.com.br/http2-para-desenvolvedores-de-web/</link>
      <pubDate>Tue, 21 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/http2-para-desenvolvedores-de-web/</guid>
      <description>

&lt;p&gt;HTTP2 significa uma mudança na forma como construímos websites. As boas práticas de HTTP1 são prejudiciais no mundo do HTTP2.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HTTP1 é lento e ineficiente para a maioria dos casos de uso de hoje na web.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;HTTP1.x é a versão do HTTP que nós já conhecemos quando entramos o endereço de um site. É um protocolo antigo que foi concebido antes mesmo de sabermos o que essa imensa rede mundial de computadores se tornaria. Apesar desse protocolo continuar funcionando como esperado, simplesmente não é tão eficiente como no início, porque ultimamente estamos exigindo algo muito mais complexo do que este protocolo foi projetado originalmente.&lt;/p&gt;

&lt;h2 id=&#34;nós-estamos-hackeando-o-http1&#34;&gt;Nós estamos hackeando o HTTP1&lt;/h2&gt;

&lt;p&gt;Para que os sites carreguem em tempo aceitável usando HTTP1, desenvolvemos uma série de técnicas; hacks na verdade; para conseguirmos extrair um bom desempenho deste protocolo antigo. São eles:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Usando CSS Sprites&lt;/strong&gt;: Combine várias imagens em uma só imagem e utilizando CSS para mostrar apenas uma parte dessa imagem num devido lugar da página.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Concatenando o Código&lt;/strong&gt;: Tornando vários arquivos de CSS ou JS e consolidá-los em um único arquivo maior.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cookieless&lt;/strong&gt; &amp;#8211; Servindo arquivos de um domínio sem o uso de cookies, através de servidores estáticos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Usando Partições de Shard&lt;/strong&gt;: Criando registros de Alias no DNS de diferentes domínios ou sub-domínios para hospedagem dos arquivos de imagens.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As duas primeiras técnicas visam evitar várias solicitações HTTP. Em HTTP1 um pedido é uma coisa muito cara e leva muito tempo, cada pedido pode ser baixados com os cookies que devem ser enviados como parte do pedido, e nada disso é compactado. É mais rápido agrupar um monte de coisas e fazer tudo de uma só vez no lado do cliente do que continuar enviando pedidos para o servidor cada momento que o código precisa de um arquivo.&lt;/p&gt;

&lt;p&gt;A terceira técnica é usada para minimizar o tempo necessário para obter os arquivos; cookies, se estiver definido, deve ser enviado para o domínio solicitado junto com cada pedido &amp;#8211; que acrescenta-se a um monte de espaço &amp;#8216;desperdiçado&amp;#8217; na linha. Se os seus arquivos estão em um domínio diferente (exemplo: imagens.meusite.com) que não usa cookies, então o pedido desses arquivos não precisará enviar cookies com eles, o que será um pouco mais rápido.&lt;/p&gt;

&lt;p&gt;A última técnica, sharding, é porque os navegadores costumavam permitir apenas duas solicitações HTTP simultâneas fossem feitas por domínio. Se você criar um novo domínio para alguns de seus arquivos, então você dobra a quantidade de conexões simultâneas o navegador irá permitir a fim de obter seus arquivos. Assim, você pode baixar o conteúdo do site mais rapidamente. Na realidade, sharding não tem sido muito útil nos últimos anos, pois os fabricantes de navegadores decidiram eliminar essa restrição das duas conexões &amp;#8216;era tonto, e eles ignoraram.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;o-que-esperar-do-http2&#34;&gt;O que esperar do HTTP2?&lt;/h2&gt;

&lt;blockquote style=&#34;font-size: 200%&#34;&gt;
  &lt;p&gt;
    &lt;em&gt;Não use as boas práticas do HTTP1 como base para um site que está sendo hospedado em HTTP2.&lt;/em&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;O protocolo HTTP2 está quase aqui, ele é baseado no SPDY®, e isso torna tudo muito mais eficiente. Significa também que todas as técnicas de desempenho HTTP1 são prejudiciais. Eles irão fazer um site HTTP2 mais lento, e não mais rápido. Portanto, não use as boas práticas do HTTP1 como base para um site que está sendo hospedado em HTTP2.&lt;/p&gt;

&lt;p&gt;HTTP2 faz com que o custo de múltiplos pedidos diminua por causa de um número de técnicas já incluídas:&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
  &lt;li&gt;
    HTTP2 pode deixar a conexão em aberta para reutilização por um longo de tempo, para que não haja a necessidade daquela negociação cara que HTTP1 faz com o servidor em cada solicitação.
  &lt;/li&gt;
  &lt;li&gt;
    Ao contrário do HTTP1, o novo protocolo usa compactação de arquivos e assim o tamanho da solicitação é significativamente menor &amp;#8211; e, como resultado, mais rápida.
  &lt;/li&gt;
  &lt;li&gt;
    HTTP2 é multiplex, ou seja, pode enviar e receber várias coisas ao mesmo tempo através de uma única conexão.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O que tudo isso significa, é que não só as técnicas que usamos no HTTP1 estão obsoletas, mas como também, farão as coisas ficarem mais lentas. Você poderá estar baixando arquivos desnecessários para a página a ser servida (concatenação de código e CSS sprites são suscetíveis à isso), e a técnica de sharding invoca pesquisas de DNS que irão retardar as coisas, na verdade, no HTTP2 voce não precisar de usar shard de forma alguma.&lt;/p&gt;

&lt;p&gt;Resumindo, quando você desenvolver o front-end (html/css/js) para um site que será servido através do HTTP2, tenha a certeza de que você não está usando velhas técnicas de desempenho do HTTP1, o que irão prejudicar o seu HTTP2 site.&lt;/p&gt;

&lt;h3 id=&#34;aprendendo-mais-sobre-o-http2&#34;&gt;Aprendendo mais sobre o HTTP2&lt;/h3&gt;

&lt;p&gt;Aqui está &lt;a href=&#34;http://daniel.haxx.se/http2/&#34;&gt;um excelente artigo (em inglês)&lt;/a&gt;, escrito por Daniel Stenberg, no qual ele detalha mais profundamente esse assunto.&lt;/p&gt;

&lt;h3 id=&#34;tradução&#34;&gt;Tradução&lt;/h3&gt;

&lt;p&gt;A tradução deste artigo para o Português foi devidamente autorizada pelo autor, &lt;a href=&#34;https://mattwilcox.net/web-development/http2-for-front-end-web-developers&#34;&gt;Matt Wilcox&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Utilizando APPs em vez de browsers</title>
      <link>http://tableless.com.br/utilizando-apps-em-vez-de-browsers/</link>
      <pubDate>Fri, 06 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/utilizando-apps-em-vez-de-browsers/</guid>
      <description>&lt;p&gt;De acordo com a &lt;a href=&#34;http://www.comscore.com/Press_Events/Press_Releases/2011/12/comScore_Reports_November_2011_U.S._Mobile_Subscriber_Market_Share?utm_source=TablelessComBr&amp;amp;utm_medium=link&amp;amp;utm_campaign=Post&#34;&gt;comScore&lt;/a&gt; as pessoas estão usando mais mobile Apps para consumir conteúdo do que browsers.&lt;/p&gt;

&lt;p&gt;O tráfego medido pela comScore mostra o market share dos principais players do mercado de mobile em Novembro. O Android continua ganhando, logo atrás vem o iPhone que foi impulsionado pelas vendas do 4S. Todas as outras plataformas perderam campo. Outra coisa, o report da comScore não conta com iPads nem iPods.&lt;/p&gt;

&lt;p&gt;Os mobiles Android represetam algo em torno de 47% e o iPhone 30%.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2012/01/Screen-Shot-2012-01-05-at-10.24.17-AM.png&#34; alt=&#34;&#34; title=&#34;Screen Shot 2012-01-05 at 10.24.17 AM&#34; width=&#34;456&#34; height=&#34;271&#34; class=&#34;alignnone size-full wp-image-5123&#34; srcset=&#34;uploads/2012/01/Screen-Shot-2012-01-05-at-10.24.17-AM.png 456w, uploads/2012/01/Screen-Shot-2012-01-05-at-10.24.17-AM-300x178.png 300w&#34; sizes=&#34;(max-width: 456px) 100vw, 456px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2012/01/Screen-shot-2011-12-29-at-2.03.27-PM.png&#34; alt=&#34;&#34; title=&#34;Screen-shot-2011-12-29-at-2.03.27-PM&#34; width=&#34;514&#34; height=&#34;270&#34; class=&#34;size-full wp-image-5118&#34; srcset=&#34;uploads/2012/01/Screen-shot-2011-12-29-at-2.03.27-PM.png 514w, uploads/2012/01/Screen-shot-2011-12-29-at-2.03.27-PM-300x157.png 300w&#34; sizes=&#34;(max-width: 514px) 100vw, 514px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O mais importante são os números abaixo que mostram o uso de conteúdo por estes dispositivos pelos usuários:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2012/01/Screen-shot-2011-12-29-at-2.10.55-PM.png&#34; alt=&#34;&#34; title=&#34;Screen-shot-2011-12-29-at-2.10.55-PM&#34; width=&#34;490&#34; height=&#34;325&#34; class=&#34;size-full wp-image-5119&#34; srcset=&#34;uploads/2012/01/Screen-shot-2011-12-29-at-2.10.55-PM.png 490w, uploads/2012/01/Screen-shot-2011-12-29-at-2.10.55-PM-300x198.png 300w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Acho que pouquíssimas pessoas, mesmo nos seus computadores, entram no site do Twitter para escrever em vez de usar algum App, não é verdade? Mesmo assim acho que o futuro não estão nos Apps. Eles sempre ficarão lá, firmes e fortes, mas aos poucos muitas empresas irão reformular seus sistemas web para ficar o mais parecido possível com as apps. Esse é o mais inteligente já que você não precisa reprogramar tudo novamente como é feito hoje. A mudança do CSS será o trabalho mais importante nesse caso, já que a interface &amp;#8220;precisa&amp;#8221; ser diferente em cada um aparelhos.&lt;/p&gt;

&lt;p&gt;Na verdade não precisa&amp;#8230; Mas é bom manter a interface nativa de cada um dos aparelhos para que os usuários não estranhem a utilização. Não seria bom que a interface do twitter no Windows Phone fosse igual a do iPhone ou a do Android. Confunde bastante. Não, é?&lt;/p&gt;

&lt;p&gt;Só uma observação: estes números refletem a realidade lá dos states, ok? Provavelmente esse comportamento pode ser multiplicado em outros países, como aqui.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Command &amp; Conquer: Tiberium Alliances</title>
      <link>http://tableless.com.br/commander-conquer-tiberium-alliances/</link>
      <pubDate>Mon, 19 Dec 2011 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/commander-conquer-tiberium-alliances/</guid>
      <description>&lt;p&gt;Se você é fã de jogos de estratégia já deve conhecer o Command &amp;amp; Conquer. Para ser sincero eu não gostava muito dessa série e por isso joguei muito pouco. Achava tudo muito complicado. 😉&lt;/p&gt;

&lt;p&gt;Mas a notícia interessante é que a EA/Phenomic (os mesmos que desenvolvedoram de Lord of Ultima, BattleForge e Spellforce) vai lançar uma edição do jogo chamada &lt;a href=&#34;http://www.ea.com/tiberium-alliances&#34; title=&#34;Site oficial do Jogo&#34;&gt;Command &amp;amp; Conquer: Tiberium Alliances&lt;/a&gt; e vai ser baseado em HTML5.&lt;/p&gt;

&lt;p&gt;Você poderá se unir com outros jogadores para formar alianças, criando impérios maiores e etc. Sendo em HTML5, você poderá acessar de qualquer browser. QUALQUER browser (viu, flash?). A EA também vai preparar as versões do jogo para mobiles facilitando a jogabilidade em dispositivos móveis (viu, flash?). Isso elimina aquele trabalho de criar uma versão para cada dispositivo e para cada plataforma. O custo vai lá para baixo! É exatamente por isso que eu sou contra APPs instaláveis nos aparelhos, principalmente móveis.&lt;/p&gt;

&lt;p&gt;O custo de desenvolver um mesmo App para pelo menos a tríade dos sistemas móveis (Android, Windows Phone, iPhone) e depois para os sistemas para desktops (Apple, Windows e quem sabe Linux) é gigante. Não estamos falando só de sites, ok? Estamos falando de tudo, até jogos, como este da EA que está para sair. Se temos a possibilidade de fazer uma aplicação que pode ser usada em todas as plataformas com experiência relativamente igual, sem danificar gráficos, jogabilidade, velocidade e etc, porque perder tempo criando aplicações nativas diferentes?&lt;/p&gt;

&lt;p&gt;Abaixo veja o trailer de como o jogo está ficando. Sensacional. Quero só ver quando WebGL puder ser usado de verdade nos navegadores.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.arkade.com.br/noticias/command-conquer-tiberium-wars-pc/&#34;&gt;Mais sobre o jogo&lt;/a&gt;. Eu vi essa notícia via &lt;a href=&#34;http://twitter.com/reinaldoferraz&#34;&gt;@reinaldoferraz&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tenha o DOM</title>
      <link>http://tableless.com.br/tenha-o-dom/</link>
      <pubDate>Mon, 25 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/tenha-o-dom/</guid>
      <description>

&lt;p&gt;Muito ja foi falado sobre DOM e posso estar sendo repetitivo aqui, mas é importante falar deste assunto que em dias de manipulação pesada de seletores, percebo que pouca atenção é dada. Temos muita literatura boa sobre o assunto mas muitas vezes o foco acaba sendo o novo plugin que saiu e faz mais-do-mesmo-no-front-end-só-que-mais-fácil (E se você tiver sorte ele é free).&lt;/p&gt;

&lt;p&gt;Entender realmente como um navegador funciona é importante, e garante seu entendimento do &lt;strong&gt;real&lt;/strong&gt; dos problemas que está enfrentando no código que está implementando. Tem mais! Criar um código que manipula o layout (leia-se DOM) fica mais fácil, é uma relação &lt;em&gt;win-win&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Criado pelo W3C, &lt;strong&gt;O DOM é uma multi-plataforma que representa como as marcações em HTML, XHTML e XML são organizadas e lidas pelo navegador que você usa&lt;/strong&gt;. Uma vez indexadas, estas marcações se transformam em elementos de uma árvore que você pode manipular via API &amp;#8211; que é o que fazemos quando usamos programas ou scripts para alterar funcionalidades de uma página: conteudo, estrutura ou folha de estilo.&lt;/p&gt;

&lt;h2 id=&#34;um-pouco-de-história&#34;&gt;Um pouco de história&lt;/h2&gt;

&lt;p&gt;Não tem graça falar sobre o assunto sem mostrar como ele surgiu. Isso só reforça ainda mais a importância de conhecermos bem o assunto pois mostra sua relevância (e porque falar de _browser wars_ é bem legal, apesar de evidenciar os cabelos brancos).&lt;/p&gt;

&lt;p&gt;Netscape e Microsoft guerreavam com Netscape 2 e IE3.0 lá em 1996 e enquanto a Netscape lançava o &lt;strong&gt;Javascript&lt;/strong&gt; a Microsoft lançava o &lt;strong&gt;JScript&lt;/strong&gt;. A diferença entre um e outro não é nada mais além do nome &amp;#8211; acredite! Por razões comerciais devido as “&lt;span&gt;sangrentas” &lt;em&gt;browser wars&lt;/em&gt; as empresas decidiram adotar nomes diferentes para a mesma coisa &amp;#8211; que na verdade era (e continua sendo) o &lt;strong&gt;ECMAScript&lt;/strong&gt;, a linguagem que comecou a ser criada em 1994 quando o W3C colocou na mesma mesa as duas empresas e várias outras para desenvolver um padrão para linguagens de script para os navegadores. &lt;strong&gt;Javascript, JScript e ActionScript não são nada mais que &lt;/strong&gt;&lt;strong&gt;&lt;em&gt;dialetos&lt;/em&gt; de ECMAScript.&lt;/strong&gt;&lt;/p&gt;&lt;/p&gt;

&lt;h2&gt;
  O DOM em sua forma e como é reconhecido pelos navegadores
&lt;/h2&gt;

&lt;p&gt;
  &lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2011/07/dom_tree.gif&#34; alt=&#34;dom_tree&#34; width=&#34;700&#34; height=&#34;365&#34; class=&#34;alignnone size-full wp-image-43633&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;
  A figura acima mostra a estrutura de uma árvore DOM, a linearização  das marcações de modo que ela possa ser montada inicialmente por um navegador. Esta estrutura não será o que veremos no navegador &amp;#8211; o layout em si. O DOM é a base para uma outra árvore que é o que realmente um browser monta na tela, a &lt;strong&gt;Árvore de Renderização &lt;/strong&gt;&amp;#8211; &lt;em&gt;aka &lt;/em&gt;&lt;em&gt;Render Tree&lt;/em&gt;.
&lt;/p&gt;

&lt;p&gt;
  A base para todos os nós da árvore DOM é o base class chamado &lt;strong&gt;Node.h&lt;/strong&gt;. Ele possui várias categorias, e as relevantes para renderizarmos código no navegador são os nós de &lt;strong&gt;documentos, elementos &lt;/strong&gt;e&lt;strong&gt; texto&lt;/strong&gt;.
&lt;/p&gt;

&lt;ol start=&#34;1&#34;&gt;
  &lt;li&gt;
    &lt;strong&gt;Documentos &lt;/strong&gt;é o nó mais importante do DOM, com três classes diferentes: &lt;strong&gt;Document&lt;/strong&gt;, que é usado por todos os documentos XML e outros que não sejam SVG (que também é um XML, porém com marcação já padronizada), &lt;strong&gt;HTMLDocument &lt;/strong&gt;que como o nome diz, cuida de documentos HTML e SVGDocument, responsável pelos documentos SVG e tambem por outros documentos herdados da classe Document (Como o &lt;strong&gt;Document.h &lt;/strong&gt;e o &lt;strong&gt;HTMLDocument.h&lt;/strong&gt;).
  &lt;/li&gt;
  &lt;li&gt;
    &lt;strong&gt;Elementos&lt;/strong&gt; são todas as tags que estão em arquivos HTML ou XML se transformam em elementos da árvore DOM. Considerando a renderização do navegador, um elemento é um nó com uma tag que pode ser usada para fazer subclasses específicas que podem ser processadas de acordo com as necessidades da &lt;em&gt;&lt;span class=&#34;c4 c9&#34;&gt;Render Tree &lt;/em&gt;(&lt;strong&gt;Element.h&lt;/strong&gt;).&lt;/li&gt; 
    
    &lt;li&gt;
      &lt;strong&gt;Texto&lt;/strong&gt;: É o texto que vai entre os elementos. Todo o conteúdo das tags (&lt;p&gt;Isto é um text node&lt;/p&gt;). O nó de Texto guarda basicamente texto puro, que pode ser renderizado ou trabalhado via script.
    &lt;/li&gt;&lt;/ol&gt; 
    

&lt;pre&gt;&lt;code&gt;&amp;lt;h2&amp;gt;
  A Render Tree
&amp;lt;/h2&amp;gt;

&amp;lt;div id=&amp;quot;attachment_3942&amp;quot; style=&amp;quot;width: 413px&amp;quot; class=&amp;quot;wp-caption alignnone&amp;quot;&amp;gt;
  &amp;lt;a href=&amp;quot;http://tableless.com.br/wp-content/uploads/2011/07/render.png&amp;quot;&amp;gt;&amp;lt;img class=&amp;quot;size-full wp-image-3942  &amp;quot; src=&amp;quot;http://tableless.com.br/wp-content/uploads/2011/07/render.png&amp;quot; alt=&amp;quot;Como a render tree e montada&amp;quot; width=&amp;quot;403&amp;quot; height=&amp;quot;187&amp;quot; srcset=&amp;quot;uploads/2011/07/render.png 630w, uploads/2011/07/render-300x139.png 300w&amp;quot; sizes=&amp;quot;(max-width: 403px) 100vw, 403px&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;

  &amp;lt;p class=&amp;quot;wp-caption-text&amp;quot;&amp;gt;
    Como a render tree é montada
  &amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;p&amp;gt;
  A &amp;lt;em&amp;gt;Render Tree&amp;lt;/em&amp;gt; é a parte mais importante do processo de renderização. Bem parecida com a árvore DOM, cada objeto corresponde a nós de &amp;lt;strong&amp;gt;Documentos, Elementos ou&amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt; Texto&amp;lt;/strong&amp;gt;. A diferença é que q &amp;lt;em&amp;gt;Render Tree&amp;lt;/em&amp;gt; possui tambem objetos que não possuem nós na árvore DOM, como &amp;lt;strong&amp;gt;scripts e folhas de estilos&amp;lt;/strong&amp;gt;.
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  O processo de criação da&amp;lt;strong&amp;gt; Render Tree&amp;lt;/strong&amp;gt; passa pelos seguintes passos:
&amp;lt;/p&amp;gt;

&amp;lt;ol start=&amp;quot;1&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;
    &amp;lt;strong&amp;gt;Attachment&amp;lt;/strong&amp;gt;: Após finalizar o parse do DOM e a criação de seus nós, os navegadores chamam um método chamado &amp;lt;strong&amp;gt;attach &amp;lt;/strong&amp;gt;para começar a renderização. O attach adiciona primeiramente as folhas de estilo a árvore DOM e começa a estilização da página. Um bom exemplo é o uso das propriedades CSS display x visibility: Caso um elemento da árvore DOM tenha uma propriedade display:none, este elemento (e seus nós filhos) não será criado na&amp;lt;em&amp;gt; Render Tree&amp;lt;/em&amp;gt;. Ao contrário do uso de visibility:hidden, que vai renderizar o elemento na &amp;lt;span&amp;gt;árvore, porém  ele irá remover (ou adicionar quando visibility:visible) via&amp;lt;strong&amp;gt; Repaint &amp;lt;/strong&amp;gt;as cores (ou propriedades) que formam este elemento. Vale lembrar também que este processo de attach é &amp;lt;em&amp;gt;top down&amp;lt;/em&amp;gt;, criando sempre inicialmente os nós parent e depois seus descendentes (nós filhos). (&amp;lt;a href=&amp;quot;http://tableless.com.br/entendendo-os-reflows-2&amp;quot; title=&amp;quot;Entendendo os Reflows&amp;quot;&amp;gt;Para saber mais sobre Repaint e Reflows, veja este outro artigo&amp;lt;/a&amp;gt;)&amp;lt;/li&amp;gt; 

    &amp;lt;li&amp;gt;
      &amp;lt;strong&amp;gt;RenderStyle.h&amp;lt;/strong&amp;gt;: Durante o processo de attach um método é criado, o &amp;lt;strong&amp;gt;RenderStyle.h&amp;lt;/strong&amp;gt; que vai guardar objetos de referência com cada uma das propriedades CSS do documento. O nó criado no DOM é verificado no documento de CSS e caso existam propriedades que incidam naquele elemento, ela é aplicada. Esta propriedade fica salva dentro da &amp;lt;em&amp;gt;Render Tree &amp;lt;/em&amp;gt;até que ela seja destruída ou que este valor seja alterado por algum script.
    &amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;
      &amp;lt;strong&amp;gt;CSS Box Model: &amp;lt;/strong&amp;gt;Após o método &amp;lt;strong&amp;gt;RenderStyle&amp;lt;/strong&amp;gt; ser criado, ele é acessado via &amp;lt;strong&amp;gt;RenderObject&amp;lt;/strong&amp;gt;. O Box model é usado para posicionar um elemento dentro da página, oferecendo suporte para o conteúdo, padding, bordas e margens que envolvem este elemento
    &amp;lt;/li&amp;gt;&amp;lt;/ol&amp;gt; 

    &amp;lt;p&amp;gt;
      &amp;lt;img class=&amp;quot;alignnone&amp;quot; src=&amp;quot;http://www.w3.org/TR/CSS21/images/boxdim.png&amp;quot; alt=&amp;quot;Uma representação visual do CSS box model&amp;quot; width=&amp;quot;455&amp;quot; height=&amp;quot;340&amp;quot; /&amp;gt;
    &amp;lt;/p&amp;gt;

    &amp;lt;h2&amp;gt;
      Destruindo (ou atualizando) a Render Tree
    &amp;lt;/h2&amp;gt;

    &amp;lt;p&amp;gt;
      A &amp;lt;em&amp;gt;Render Tree&amp;lt;/em&amp;gt; é destruída quando nós da árvore DOM são removidos, causando a necessidade de um novo parse no DOM, ou quando uma tab do navegador com a árvore DOM usada é fechada. Após o refresh da árvore DOM, todo o processo acima é refeito, com attach chamando o RenderStyle, que montado chama o método &amp;lt;strong&amp;gt;style()&amp;lt;/strong&amp;gt; do RenderObject que acessa o CSS BOX model.
    &amp;lt;/p&amp;gt;

    &amp;lt;h2&amp;gt;
      Como os navegadores interpretam todos estes elementos criados por DOM e Render Tree antes de aplicar o estilo?
    &amp;lt;/h2&amp;gt;

    &amp;lt;p&amp;gt;
      Todo navegador tem uma lista de elementos HTML suportados. Quando o seu markup possui tags presentes na lista, a árvore DOM é montada e o processo de attachment começa logo na sequência e os estilos são aplicados, dando continuidade a criação da &amp;lt;span&amp;gt;&amp;lt;em&amp;gt;Render tree&amp;lt;/em&amp;gt;.&amp;lt;/p&amp;gt; 

      &amp;lt;p&amp;gt;
        O grande problema é que cada navegador tem a sua própria lista, que trata situações similares de maneiras diferentes. Obviamente já sabemos que o navegador que mais apresenta problemas para as situações acima é o Internet Explorer, mas acredite, &amp;lt;strong&amp;gt;todos &amp;lt;/strong&amp;gt;os navegadores apresentam problemas quando um elemento não está em sua lista de elementos permitidos, e precisa de um trabalho para fazer tudo acontecer na &amp;lt;span&amp;gt;Render Tree como deve ser feito.&amp;lt;/p&amp;gt; 

        &amp;lt;p&amp;gt;
          Elementos fora desta lista são tratados como Elementos desconhecidos. E eles são uma grande fonte de problemas:
        &amp;lt;/p&amp;gt;

        &amp;lt;ol start=&amp;quot;1&amp;quot;&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;strong&amp;gt;Como estilizar este elemento?&amp;lt;/strong&amp;gt;Por exemplo, a tag &amp;lt;p&amp;gt; tem por padrão espacamento no topo e bottom, &amp;lt;blockquote&amp;gt; possui uma indentação automática adicionando uma margem à esquerda ou &amp;lt;h1&amp;gt; tem uma fonte maior que o &amp;lt;p&amp;gt; por ser um cabeçalho. Tudo isso esta padronizado, mas como cuidar de algo que não existe?
          &amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;
            &amp;lt;strong&amp;gt;Como este elemento deve aparecer na árvore DOM?&amp;lt;/strong&amp;gt;Os navegadores também possuem uma lista que mostra quais elementos podem ser filhos de outros elementos. Por exemplo, se você adiciona por engano no seu markup &amp;lt;p&amp;gt;&amp;lt;p&amp;gt; o segundo paragrafo implicitamente fechará o primeiro &amp;lt;p&amp;gt;, fazendo que os dois elementos sejam irmãos (no mesmo nível na árvore DOM) e nao como nós filhos como de maneira linear pode parecer. Porém se vc adiciona um &amp;lt;p&amp;gt;&amp;lt;span&amp;gt;, este paragrafo inicial não será fechado, porque o navegador permite que &amp;lt;span&amp;gt; seja filho de elementos de paragrafo, fazendo assim o &amp;lt;span&amp;gt; ser nó filho de &amp;lt;p&amp;gt;
          &amp;lt;/li&amp;gt;
        &amp;lt;/ol&amp;gt;

        &amp;lt;p&amp;gt;
          Para elementos desconhecidos, a ideia é não estilizar. Caso queira algum estilo em elementos desconhecidos, você deve colocá-lo no nó acima (se necessário um &amp;lt;em&amp;gt;wrapper&amp;lt;/em&amp;gt;), para fazer com que ele herde o estilo.
        &amp;lt;/p&amp;gt;

        &amp;lt;p&amp;gt;
          Perceba a sutileza de como isso funciona. Os dois diagramas mostram uma árvore DOM, montada por um navegador suporte HTML5 nativo e o Internet Explorer 8 (navegadores que não suportam HTML5 tem funcionamento semelhante):
        &amp;lt;/p&amp;gt;

        &amp;lt;div id=&amp;quot;attachment_3988&amp;quot; style=&amp;quot;width: 570px&amp;quot; class=&amp;quot;wp-caption alignnone&amp;quot;&amp;gt;
          &amp;lt;a href=&amp;quot;http://tableless.com.br/wp-content/uploads/2011/07/renderizaao_HTML5-5.png&amp;quot;&amp;gt;&amp;lt;img class=&amp;quot;size-full wp-image-3988 &amp;quot; src=&amp;quot;http://tableless.com.br/wp-content/uploads/2011/07/renderizaao_HTML5-5.png&amp;quot; alt=&amp;quot;Arvore DOM com suporte HTML5&amp;quot; width=&amp;quot;560&amp;quot; height=&amp;quot;472&amp;quot; srcset=&amp;quot;uploads/2011/07/renderizaao_HTML5-5.png 800w, uploads/2011/07/renderizaao_HTML5-5-300x252.png 300w&amp;quot; sizes=&amp;quot;(max-width: 560px) 100vw, 560px&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;

          &amp;lt;p class=&amp;quot;wp-caption-text&amp;quot;&amp;gt;
            Arvore DOM com suporte HTML5
          &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div id=&amp;quot;attachment_3987&amp;quot; style=&amp;quot;width: 576px&amp;quot; class=&amp;quot;wp-caption alignnone&amp;quot;&amp;gt;
          &amp;lt;a href=&amp;quot;http://tableless.com.br/wp-content/uploads/2011/07/renderizacaoIE-5.png&amp;quot;&amp;gt;&amp;lt;img class=&amp;quot;size-full wp-image-3987  &amp;quot; src=&amp;quot;http://tableless.com.br/wp-content/uploads/2011/07/renderizacaoIE-5.png&amp;quot; alt=&amp;quot;Arvore DOM IE e outros navegadores sem suporte HTML5&amp;quot; width=&amp;quot;566&amp;quot; height=&amp;quot;458&amp;quot; srcset=&amp;quot;uploads/2011/07/renderizacaoIE-5.png 1178w, uploads/2011/07/renderizacaoIE-5-300x243.png 300w, uploads/2011/07/renderizacaoIE-5-1024x830.png 1024w&amp;quot; sizes=&amp;quot;(max-width: 566px) 100vw, 566px&amp;quot; /&amp;gt;&amp;lt;/a&amp;gt;

          &amp;lt;p class=&amp;quot;wp-caption-text&amp;quot;&amp;gt;
            Arvore DOM IE e outros navegadores sem suporte HTML5
          &amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;p&amp;gt;
          É por essas e outras que a gente usa o modernizr, o HTML5shiv ou um simples document.create(“SECTION”) / document.create(“ARTICLE”). E é isso que acontece quando navegadores interpretam elementos desconhecidos. Eles desconsideram o nó real aonde o elemento está, e o reconhece como filho de &amp;lt;BODY&amp;gt;. E por favor, sem trocadilhos com o &amp;lt;span&amp;gt;filho dos outros.&amp;lt;/p&amp;gt; 

          &amp;lt;p&amp;gt;
            Ver como uma árvore DOM é montada  e como a &amp;lt;em&amp;gt;Render tree &amp;lt;/em&amp;gt;é feita nos dá idéia do quão importante é ter um documento semântico. &amp;lt;strong&amp;gt;Realmente semântico&amp;lt;/strong&amp;gt;. Uma vez entendidos os conceitos, a manipulação e a programação dos elementos fica mais fácil.
          &amp;lt;/p&amp;gt;

          &amp;lt;p&amp;gt;
            E você começa a entender como os navegadores funcionam.
          &amp;lt;/p&amp;gt;

          &amp;lt;h2&amp;gt;
            Referências
          &amp;lt;/h2&amp;gt;

          &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://tableless.com.br/entendendo-os-reflows-2&amp;quot;&amp;gt;Entendendo os Reflows&amp;lt;/a&amp;gt; por Alysson Franklin
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://www.modernizr.com/&amp;quot;&amp;gt;Modernizr&amp;lt;/a&amp;gt; para suporte HTML5
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://code.google.com/p/html5shiv/&amp;quot;&amp;gt;HTML5shiv&amp;lt;/a&amp;gt; para suporte HTML5
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://en.wikipedia.org/wiki/Browser_wars&amp;quot;&amp;gt;Browser Wars&amp;lt;/a&amp;gt; pela Wikipedia
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://en.wikipedia.org/wiki/ECMAScript&amp;quot;&amp;gt;ECMAScript&amp;lt;/a&amp;gt; pela Wikipedia
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://en.wikipedia.org/wiki/JavaScript&amp;quot;&amp;gt;Javascript&amp;lt;/a&amp;gt; pela Wikipedia
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://en.wikipedia.org/wiki/JScript&amp;quot;&amp;gt;JScript&amp;lt;/a&amp;gt; pela Wikipedia
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
              &amp;lt;a href=&amp;quot;http://www.w3.org/TR/CSS21/box.html#box-dimensions&amp;quot;&amp;gt;CSS Box model&amp;lt;/a&amp;gt; pelo W3C
            &amp;lt;/li&amp;gt;
            &amp;lt;ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Entendendo os Reflows</title>
      <link>http://tableless.com.br/entendendo-os-reflows-2/</link>
      <pubDate>Mon, 18 Jul 2011 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/entendendo-os-reflows-2/</guid>
      <description>

&lt;p&gt;Reflow é um assunto extenso e necessário. Ele sempre vai existir nos navegadores, então temos que entendê-lo para saber como utilizá-lo de maneira racional. O mais legal é entender todo o contexto sobre o que são e como funcionam, para a partir daí repensar o código que renderizamos no navegador para obtermos maior performance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reflow é o resultado de um evento que desencadeia mudanças no jeito que a pagina deve ser renderizada, tomando tempo para cálculo e reposicionamento de elementos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Para explicar como isso acontece, o importante é entender como um navegador renderiza uma página web.&lt;/p&gt;

&lt;h2 id=&#34;dom&#34;&gt;DOM&lt;/h2&gt;

&lt;p&gt;Document Object Model (DOM) é uma interface independente de linguagem e plataforma para representar e interagir com objetos em HTML, XHTML e XML. Mas o DOM é mais que isso; toda linguagem estruturada tem uma arvore DOM.&lt;/p&gt;

&lt;div id=&#34;attachment_3941&#34; style=&#34;width: 490px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2011/07/DOMTree.gif&#34;&gt;&lt;img class=&#34;size-full wp-image-3941 &#34; src=&#34;http://tableless.com.br/wp-content/uploads/2011/07/DOMTree.gif&#34; alt=&#34;Exemplo de arvore DOM para documento HTML&#34; width=&#34;480&#34; height=&#34;212&#34; srcset=&#34;uploads/2011/07/DOMTree.gif 800w, uploads/2011/07/DOMTree-300x132.gif 300w&#34; sizes=&#34;(max-width: 480px) 100vw, 480px&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Exemplo de arvore DOM para documento HTML
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Mas sobre o DOM podemos dizer que programas ou scripts podem dinamicamente acessar elementos na árvore DOM e alterar seu conteúdo, estrutura e estilo. Adicional ao estado inicial da pagina, estas alterações são agregadas a árvore DOM. O resultado é a renderização &amp;#8211; o que nós vemos em um navegador. Mas a nossa &lt;em&gt;Render Tree&lt;/em&gt; tem mais que isso:&lt;/p&gt;

&lt;h2 id=&#34;render-tree-e-como-realmente-entender-display-x-visibility&#34;&gt;Render Tree e como realmente entender display X visibility&lt;/h2&gt;

&lt;div id=&#34;attachment_3942&#34; style=&#34;width: 514px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2011/07/render.png&#34;&gt;&lt;img class=&#34;size-full wp-image-3942 &#34; src=&#34;http://tableless.com.br/wp-content/uploads/2011/07/render.png&#34; alt=&#34;Como a render tree e montada&#34; width=&#34;504&#34; height=&#34;234&#34; srcset=&#34;uploads/2011/07/render.png 630w, uploads/2011/07/render-300x139.png 300w&#34; sizes=&#34;(max-width: 504px) 100vw, 504px&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Como a render tree é montada
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;O DOM é resultado do parse do markup HTML que você montou dentro de um navegador. Só que dentro de um HTML você não tem apenas a estrutura do documento, estilos em CSS e funcionalidades em javascript também estarão no seu markup. E a Render tree é a soma de DOM mais estilos, que depois podem ser manipulados (seus scripts).&lt;/p&gt;

&lt;p&gt;Pode parecer estranho, mas para mim a melhor maneira de entender as diferencas entre DOM e Render Tree é encarar esta última como um &lt;span class=&#34;c17&#34;&gt;individuo narcisista&lt;/span&gt;. Isso mesmo: A Render Tree gosta de aparecer, é o que vemos no browser. O DOM acontece por trás das cortinas. &lt;em&gt;À Render tree, o palco&lt;/em&gt;. (&lt;a href=&#34;http://tableless.com.br/tenha-o-dom&#34; title=&#34;Tenha o DOM&#34;&gt;Para saber mais sobre o DOM, veja este outro artigo&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Uma página que tem controles de show/hide mostra isso muito bem. Enquanto todo o conteúdo da página está presente na árvore DOM, apenas alguns itens estarão disponíveis na Render Tree &amp;#8211; os visíveis na página (display:block). Alterar os elementos display:none vão disparar mudanças na render tree, e não na árvore DOM.&lt;/p&gt;

&lt;p&gt;Já tentou entender as diferenças entre display:none e visibility:hidden? A maioria das explicações que vemos é que um “deixa de mostrar o elemento totalmente, incluindo seu espaço em tela” e o outro “deixa de mostrar o elemento visual, mas sua área de exibição continua sendo utilizada”. Esta explicação não está incorreta, mas seria melhor dizer que a propriedade display altera a estrutura da render tree, adicionando algo que antes não estava ali, enquanto visibility não faz alterações, apenas o câmbio de mostrar ou não um elemento que já esta na render tree.&lt;/p&gt;

&lt;h2 id=&#34;repaint&#34;&gt;Repaint&lt;/h2&gt;

&lt;p&gt;Entendido as diferenças entre display e visibility, além do contexto de área do elemento, conseguimos explicar o Repaint. Uma ação que faça alteração de propriedades de background &lt;strong&gt;sem alterar dimensões ou outras propriedades do elemento&lt;/strong&gt; não causam o reflow, apenas o repaint, que seria a atualização da propriedade de cor ou da imagem &amp;#8211; literalmente pintar novamente o elemento. Repaints gastam menos CPU que reflows.&lt;/p&gt;

&lt;h2 id=&#34;como-um-navegador-monta-seu-documento-html&#34;&gt;Como um navegador monta seu documento HTML&lt;/h2&gt;

&lt;p&gt;Esses vídeos são sensacionais. Eles explicam o que são os reflows e dai como minimizá-los durante a fase de desenvolvimento do documento (sempre usando &lt;span class=&#34;c9&#34;&gt;&lt;a class=&#34;c7&#34; href=&#34;http://tableless.com.br/bem-vindo-a-xangrila-parte-1&#34;&gt;Progressive Enhancement&lt;/a&gt;&lt;/span&gt; quando possível) é mais fácil..&lt;/p&gt;

&lt;p&gt;[youtube &lt;a href=&#34;http://www.youtube.com/watch?v=ZTnIxIA5KGw&#34;&gt;http://www.youtube.com/watch?v=ZTnIxIA5KGw&lt;/a&gt;]&lt;/p&gt;

&lt;p class=&#34;c6 anotacao&#34;&gt;
  Esta é uma representação de como a página da Mozilla é montada. Quer mais? Veja também como a &lt;span class=&#34;c9&#34;&gt;&lt;a class=&#34;c7&#34; href=&#34;http://video.google.com/videoplay?docid=-5863446593724321515&#34;&gt;Wikipedia&lt;/a&gt;&lt;/span&gt; e a página do &lt;span class=&#34;c9&#34;&gt;&lt;a class=&#34;c7&#34; href=&#34;http://video.google.com/videoplay?docid=-1471976166301235697&#34;&gt;Google&lt;/a&gt;&lt;/span&gt; no Japão são renderizadas.
&lt;/p&gt;

&lt;p&gt;Analisando o primeiro vídeo, perceba que ao finalizar a montagem do rodapé, “algo mais” acontece (a partir de 12seg). São os Reflows. A maioria dos elementos são recalculados e reposicionados. Se ponderarmos que o rodapé acaba de ser montado aos 14 segundos e a renderização termina aos 26 segundos da pagina, estamos falando quase de 50% do tempo de renderização sendo gasto com Reflows, o que é muito, dependendo do que a sua página deve fazer.&lt;/p&gt;

&lt;h3 id=&#34;o-que-causam-exatamente-os-reflows&#34;&gt;O que causam exatamente os reflows?&lt;/h3&gt;

&lt;h5 id=&#34;reflow-é-um-assunto-extenso-e-necessário-ele-sempre-vai-existir-nos-navegadores-então-temos-que-entendê-lo-para-saber-como-utilizá-lo-de-maneira-racional-o-mais-legal-é-entender-todo-o-contexto-sobre-o-que-são-e-como-funcionam-para-a-partir-daí-repensar-o-código-que-renderizamos-no-navegador-para-obtermos-maior-performance&#34;&gt;`Reflow é um assunto extenso e necessário. Ele sempre vai existir nos navegadores, então temos que entendê-lo para saber como utilizá-lo de maneira racional. O mais legal é entender todo o contexto sobre o que são e como funcionam, para a partir daí repensar o código que renderizamos no navegador para obtermos maior performance.&lt;/h5&gt;

&lt;p&gt;&lt;strong&gt;Reflow é o resultado de um evento que desencadeia mudanças no jeito que a pagina deve ser renderizada, tomando tempo para cálculo e reposicionamento de elementos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Para explicar como isso acontece, o importante é entender como um navegador renderiza uma página web.&lt;/p&gt;

&lt;h2 id=&#34;dom-1&#34;&gt;DOM&lt;/h2&gt;

&lt;p&gt;Document Object Model (DOM) é uma interface independente de linguagem e plataforma para representar e interagir com objetos em HTML, XHTML e XML. Mas o DOM é mais que isso; toda linguagem estruturada tem uma arvore DOM.&lt;/p&gt;

&lt;div id=&#34;attachment_3941&#34; style=&#34;width: 490px&#34; class=&#34;wp-caption alignleft&#34;&gt;
  &lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2011/07/DOMTree.gif&#34;&gt;&lt;img class=&#34;size-full wp-image-3941 &#34; src=&#34;http://tableless.com.br/wp-content/uploads/2011/07/DOMTree.gif&#34; alt=&#34;Exemplo de arvore DOM para documento HTML&#34; width=&#34;480&#34; height=&#34;212&#34; srcset=&#34;uploads/2011/07/DOMTree.gif 800w, uploads/2011/07/DOMTree-300x132.gif 300w&#34; sizes=&#34;(max-width: 480px) 100vw, 480px&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Exemplo de arvore DOM para documento HTML
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Mas sobre o DOM podemos dizer que programas ou scripts podem dinamicamente acessar elementos na árvore DOM e alterar seu conteúdo, estrutura e estilo. Adicional ao estado inicial da pagina, estas alterações são agregadas a árvore DOM. O resultado é a renderização &amp;#8211; o que nós vemos em um navegador. Mas a nossa &lt;em&gt;Render Tree&lt;/em&gt; tem mais que isso:&lt;/p&gt;

&lt;h2 id=&#34;render-tree-e-como-realmente-entender-display-x-visibility-1&#34;&gt;Render Tree e como realmente entender display X visibility&lt;/h2&gt;

&lt;div id=&#34;attachment_3942&#34; style=&#34;width: 514px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2011/07/render.png&#34;&gt;&lt;img class=&#34;size-full wp-image-3942 &#34; src=&#34;http://tableless.com.br/wp-content/uploads/2011/07/render.png&#34; alt=&#34;Como a render tree e montada&#34; width=&#34;504&#34; height=&#34;234&#34; srcset=&#34;uploads/2011/07/render.png 630w, uploads/2011/07/render-300x139.png 300w&#34; sizes=&#34;(max-width: 504px) 100vw, 504px&#34; /&gt;&lt;/a&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Como a render tree é montada
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;O DOM é resultado do parse do markup HTML que você montou dentro de um navegador. Só que dentro de um HTML você não tem apenas a estrutura do documento, estilos em CSS e funcionalidades em javascript também estarão no seu markup. E a Render tree é a soma de DOM mais estilos, que depois podem ser manipulados (seus scripts).&lt;/p&gt;

&lt;p&gt;Pode parecer estranho, mas para mim a melhor maneira de entender as diferencas entre DOM e Render Tree é encarar esta última como um &lt;span class=&#34;c17&#34;&gt;individuo narcisista&lt;/span&gt;. Isso mesmo: A Render Tree gosta de aparecer, é o que vemos no browser. O DOM acontece por trás das cortinas. &lt;em&gt;À Render tree, o palco&lt;/em&gt;. (&lt;a href=&#34;http://tableless.com.br/tenha-o-dom&#34; title=&#34;Tenha o DOM&#34;&gt;Para saber mais sobre o DOM, veja este outro artigo&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Uma página que tem controles de show/hide mostra isso muito bem. Enquanto todo o conteúdo da página está presente na árvore DOM, apenas alguns itens estarão disponíveis na Render Tree &amp;#8211; os visíveis na página (display:block). Alterar os elementos display:none vão disparar mudanças na render tree, e não na árvore DOM.&lt;/p&gt;

&lt;p&gt;Já tentou entender as diferenças entre display:none e visibility:hidden? A maioria das explicações que vemos é que um “deixa de mostrar o elemento totalmente, incluindo seu espaço em tela” e o outro “deixa de mostrar o elemento visual, mas sua área de exibição continua sendo utilizada”. Esta explicação não está incorreta, mas seria melhor dizer que a propriedade display altera a estrutura da render tree, adicionando algo que antes não estava ali, enquanto visibility não faz alterações, apenas o câmbio de mostrar ou não um elemento que já esta na render tree.&lt;/p&gt;

&lt;h2 id=&#34;repaint-1&#34;&gt;Repaint&lt;/h2&gt;

&lt;p&gt;Entendido as diferenças entre display e visibility, além do contexto de área do elemento, conseguimos explicar o Repaint. Uma ação que faça alteração de propriedades de background &lt;strong&gt;sem alterar dimensões ou outras propriedades do elemento&lt;/strong&gt; não causam o reflow, apenas o repaint, que seria a atualização da propriedade de cor ou da imagem &amp;#8211; literalmente pintar novamente o elemento. Repaints gastam menos CPU que reflows.&lt;/p&gt;

&lt;h2 id=&#34;como-um-navegador-monta-seu-documento-html-1&#34;&gt;Como um navegador monta seu documento HTML&lt;/h2&gt;

&lt;p&gt;Esses vídeos são sensacionais. Eles explicam o que são os reflows e dai como minimizá-los durante a fase de desenvolvimento do documento (sempre usando &lt;span class=&#34;c9&#34;&gt;&lt;a class=&#34;c7&#34; href=&#34;http://tableless.com.br/bem-vindo-a-xangrila-parte-1&#34;&gt;Progressive Enhancement&lt;/a&gt;&lt;/span&gt; quando possível) é mais fácil..&lt;/p&gt;

&lt;p&gt;[youtube &lt;a href=&#34;http://www.youtube.com/watch?v=ZTnIxIA5KGw&#34;&gt;http://www.youtube.com/watch?v=ZTnIxIA5KGw&lt;/a&gt;]&lt;/p&gt;

&lt;p class=&#34;c6 anotacao&#34;&gt;
  Esta é uma representação de como a página da Mozilla é montada. Quer mais? Veja também como a &lt;span class=&#34;c9&#34;&gt;&lt;a class=&#34;c7&#34; href=&#34;http://video.google.com/videoplay?docid=-5863446593724321515&#34;&gt;Wikipedia&lt;/a&gt;&lt;/span&gt; e a página do &lt;span class=&#34;c9&#34;&gt;&lt;a class=&#34;c7&#34; href=&#34;http://video.google.com/videoplay?docid=-1471976166301235697&#34;&gt;Google&lt;/a&gt;&lt;/span&gt; no Japão são renderizadas.
&lt;/p&gt;

&lt;p&gt;Analisando o primeiro vídeo, perceba que ao finalizar a montagem do rodapé, “algo mais” acontece (a partir de 12seg). São os Reflows. A maioria dos elementos são recalculados e reposicionados. Se ponderarmos que o rodapé acaba de ser montado aos 14 segundos e a renderização termina aos 26 segundos da pagina, estamos falando quase de 50% do tempo de renderização sendo gasto com Reflows, o que é muito, dependendo do que a sua página deve fazer.&lt;/p&gt;

&lt;h3 id=&#34;o-que-causam-exatamente-os-reflows-1&#34;&gt;O que causam exatamente os reflows?&lt;/h3&gt;

&lt;p&gt;#####`&lt;/p&gt;

&lt;p&gt;Reflows são excessivamente pesados e para reduzir efeitos uma das táticas que navegadores usam é processar nossos scripts em lote. Uma fila é criada para todos os comandos que causam reflow sejam processados de uma única vez. Porém o foco é entender o que causa um reflow e tentar minimizar o seu uso para ganhar performance na aplicação.&lt;/p&gt;

&lt;p&gt;Este assunto é novo, e com certeza, A lista que mostro abaixo deve crescer. É importante mantermos a atenção a este assunto porque pequenos cuidados podem significar muito. Em um site web visualizado em desktops a diferença é óbvia sobre o tempo de renderização. Mas isso implica em outras coisas, que podem fazer a diferença não apenas em montar uma página mais rápido, mas também para menor gasto de processamento, o que garante também mais tempo de bateria em mobiles e tablets por exemplo.&lt;/p&gt;

&lt;ol start=&#34;1&#34;&gt;
  &lt;li&gt;
    Adicionar, remover ou atualizar o DOM;
  &lt;/li&gt;
  &lt;li&gt;
    Esconder nós do DOM usando display:none;
  &lt;/li&gt;
  &lt;li&gt;
    Mover e animar o DOM na página;
  &lt;/li&gt;
  &lt;li&gt;
    Adicionar folhas de estilo on-the-fly que mudem o comportamento dos elementos;
  &lt;/li&gt;
  &lt;li&gt;
    Redimensionar janelas;
  &lt;/li&gt;
  &lt;li&gt;
    Alterar tamanho de fontes;
  &lt;/li&gt;
  &lt;li class=&#34;c6 c15&#34;&gt;
    Scroll de página;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Em um dos posts sobre o assunto, Tony G mapeou pesquisas prévias e montou a seguinte tabela, que também está sendo constantemente atualizada.&lt;/p&gt;

&lt;table class=&#34;c16&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;Element&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;Frame, Image&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;Range&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;SVGLocatable&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;SVGTextContent&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;SVGUse&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;h4&gt;
        &lt;strong&gt;window&lt;/strong&gt;
      &lt;/h4&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td&gt;
      &lt;span class=&#34;c0&#34;&gt;clientHeight,&lt;br /&gt; &lt;/span&gt;&lt;span class=&#34;c0&#34;&gt;clientLeft,&lt;br /&gt; &lt;/span&gt;&lt;span class=&#34;c0&#34;&gt;clientTop,&lt;br /&gt; &lt;/span&gt;&lt;span class=&#34;c0&#34;&gt;clientWidth,&lt;br /&gt; focus(), getBoundingClientRect(), getClientRects(), innerText,&lt;br /&gt; offsetHeight,&lt;br /&gt; offsetLeft,&lt;br /&gt; offsetParent,&lt;br /&gt; offsetTop,&lt;br /&gt; offsetWidth,&lt;br /&gt; outerText,&lt;br /&gt; scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft,&lt;br /&gt; scrollTop,&lt;br /&gt; &lt;/span&gt;scrollWidth
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span class=&#34;c0&#34;&gt;height, width&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span class=&#34;c0&#34;&gt;getBoundingClientRect(), getClientRects()&lt;/span&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;span class=&#34;c0&#34;&gt;computeCTM(), getBBox()&lt;/span&gt;&lt;/p&gt; 
      
      &lt;p class=&#34;c5&#34;&gt;
        &lt;/td&gt; 
        
        &lt;td&gt;
          &lt;span class=&#34;c0&#34;&gt;getCharNumAtPosition(), getComputedTextLength(), getEndPositionOfChar(), getExtentOfChar(), getNumberOfChars(), getRotationOfChar(), getStartPositionOfChar(), getSubStringLength(), selectSubString()&lt;/span&gt;
        &lt;/td&gt;
        
        &lt;td&gt;
          &lt;span class=&#34;c0&#34;&gt;instanceRoot&lt;/span&gt;
        &lt;/td&gt;
        
        &lt;td&gt;
          &lt;span class=&#34;c0&#34;&gt;getComputedStyle(),&lt;br /&gt; scrollBy(),&lt;br /&gt; scrollTo(),&lt;br /&gt; scrollX,&lt;br /&gt; scrollY, webkitConvertPointFromNodeToPage(), webkitConvertPointFromPageToNode()&lt;/span&gt;
        &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 
        

&lt;pre&gt;&lt;code&gt;    &amp;lt;h2&amp;gt;
      Como melhorar o meu código para minimizar os reflows?
    &amp;lt;/h2&amp;gt;

    &amp;lt;p&amp;gt;
      É simples. Basta minimizar o uso de requisições de estilo, que façam o navegador executar reflows ou repaints.
    &amp;lt;/p&amp;gt;

    &amp;lt;ol start=&amp;quot;1&amp;quot;&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c11&amp;quot;&amp;gt;Planejar a sua aplicação e entender como plugins e scripts criados vão se comportar em relação a reflow e repaints. Arquitetar o uso de plugins de acordo com a personalização que deve ser feita. Minimize o uso de alteração de estilos on-the-fly.&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c11&amp;quot;&amp;gt;Quando precisar alterar a propriedade de um estilo, troque o nome da classe, planeje a existência deste estado e adicione-o ao CSS previamente. Se o valor desta nova classe for dinâmica, use cssText. Evite alterar a propriedade diretamente para qualquer mudança.&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c0&amp;quot;&amp;gt;Pense como suas mudanças afetam a render tree e o quanto precisará ser revalidado depois desta mudanca. Se você usa position:absolute em um elemento, ele deixa de pertencer ao nó que está, e passa a ser filho do BODY. Alterá-lo então, não será tão custoso em termos de performance. Mesmo que alterações neste nó sobreponha outras areas, o reflow acontecerá apenas neste nó, e não em toda a render tree. &amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c11&amp;quot;&amp;gt;Limpe seu CSS. Classes não utilizadas devem ser removidas.&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c11&amp;quot;&amp;gt;Reduza o número de mudanças no DOM. Ele vai causar mudanças estruturais em todas as outras etapas. E mais tempo de reflow. &amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c11&amp;quot;&amp;gt;Animações na página, transições? Pondere sobre posicioná-la de maneira absoluta e trabalhar com ela a partir do BODY.&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;span class=&amp;quot;c11&amp;quot;&amp;gt;Vá com calma nos seletores CSS &amp;amp;#8211; os descendentes em particular &amp;amp;#8211; pois usam maior poder de CPU para executar a tarefa (CPU = Bateria).&amp;lt;/span&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ol&amp;gt;

    &amp;lt;h2&amp;gt;
      Referências
    &amp;lt;/h2&amp;gt;

    &amp;lt;ul&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://en.wikipedia.org/wiki/Document_Object_Model&amp;quot;&amp;gt;DOM&amp;lt;/a&amp;gt; pela wikipedia
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://video.google.com/videoplay?docid=-1471976166301235697#docid=1020647662203348823&amp;quot;&amp;gt;Gecko Reflow&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://paulirish.com/2011/dom-html5-css3-performance/&amp;quot;&amp;gt;DOM, HTML5, CSS3 e Performance&amp;lt;/a&amp;gt; &amp;amp;#8211; &amp;lt;a href=&amp;quot;http://dl.dropbox.com/u/39519/talks/gperf/index.html&amp;quot;&amp;gt;Slides&amp;lt;/a&amp;gt; por Paul Irish
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.mozilla.org/newlayout/doc/reflow.html&amp;quot;&amp;gt;Reflow&amp;lt;/a&amp;gt; pelo Mozilla Labs
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://ajaxian.com/archives/browser-reflows-how-do-they-affect-performance&amp;quot;&amp;gt;Reflow e Repaint&amp;lt;/a&amp;gt; na Ajaxian
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://code.google.com/speed/articles/reflow.html&amp;quot;&amp;gt;Reflow&amp;lt;/a&amp;gt; pelo Google Code
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.w3.org/DOM/&amp;quot;&amp;gt;W3C Overview do DOM&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.dayofjs.com/videos/22158462/web-browsers_alex-russel&amp;quot;&amp;gt;1 dia de javascript com Alex Russel: Como Navegadores Veem as suas Apps&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html&amp;quot;&amp;gt;Como (não) criar um layout no webkit por Tony G&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.webkit.org/blog/1091/more-web-inspector-updates/#timeline_panel&amp;quot;&amp;gt;Usando a timeline panel em navegadores webkit&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.bookofspeed.com/&amp;quot;&amp;gt;The book of Speed&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/&amp;quot;&amp;gt;Reflow/Repaint&amp;lt;/a&amp;gt; por Stoyan Stefanov
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://calendar.perfplanet.com/2009/the-new-game-show-will-it-reflow/&amp;quot;&amp;gt;Inconsistências dos navegadores em Reflows&amp;lt;/a&amp;gt; por Stoyan Stefanov
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.browserscope.org/?category=reflow&amp;quot;&amp;gt;BrowserScope tests para reflows&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.youtube.com/watch?v=a2_6bGNZ7bA&amp;quot;&amp;gt;Browsers para Web Developers&amp;lt;/a&amp;gt; David Baron da Mozilla labs
      &amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;
        &amp;lt;a href=&amp;quot;http://www.webkit.org/blog/114/webcore-rendering-i-the-basics/&amp;quot;&amp;gt;Renderização no webkit, o básico&amp;lt;/a&amp;gt;
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Novo parser HTML5 – FF4</title>
      <link>http://tableless.com.br/parser-html5-firefox4/</link>
      <pubDate>Mon, 28 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/parser-html5-firefox4/</guid>
      <description>

&lt;p&gt;O Firefox é o meu browser favorito embora não seja meu browser padrão atualmente. Durante muito tempo ele me segurava com suas extensions exclusivas. Os outros browsers demoraram para ter uma coleção aceitável de extensions que realmente competissem com as do Firefox.&lt;/p&gt;

&lt;p&gt;Foi lançado na semana passada o &lt;a href=&#34;http://getfirefox.com/&#34; title=&#34;baixe agora&#34; rel=&#34;external&#34;&gt;Firefox 4.0&lt;/a&gt; que trouxe uma série de mudanças interessantes. Uma das atualizações mais importantes foi o &amp;#8220;redesign&amp;#8221; do parser de HTML5.&lt;/p&gt;

&lt;h3 id=&#34;html5-parser&#34;&gt;HTML5 parser&lt;/h3&gt;

&lt;p&gt;O parser do &lt;a href=&#34;http://getfirefox.com&#34;&gt;Firefox 4&lt;/a&gt; foi todo reescrito para melhorar a performance e eficiência da renderização de código client-side. O motor antigo &amp;#8211; de 1998 &amp;#8211; foi descontinuado e agora com esse novo parser temos a possibilidade de utilizar SVG e MathML diretamente nas páginas HTML5 sem a utilização de namespace de XML. Entre outros diversos &lt;a href=&#34;https://bugzilla.mozilla.org/buglist.cgi?status_whiteboard_type=substring&amp;amp;status_whiteboard=[fixed%20by%20the%20HTML5%20parser]&amp;amp;resolution=FIXED&#34;&gt;bugs que foram arrumados&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A esse novo parser foi escrito baseando-se na especificação do HTML5, que foi a primeira especificação que explica exatamente como os fabricantes de browsers devem ler e renderização o HTML. Estes detalhes técnicos não eram ditos nas versões anteriores das especificações do HTML. Basicamente o antigo HTML era ainda definido nos termos do antigo SGML. Isso implica na relação do código HTML e DOM. Isso quer dizer que o parseador consegue ler melhor a estrutura do nosso HTML e suas hierarquias. Claro, toda a performance do paseador é somente utilizada se o código for bem escrito e não tiver erros de sintaxe. A grande maioria dos sites na web ainda utilizam códigos mal escritos em HTML4. Leia mais sobre o &lt;a href=&#34;http://tableless.com.br/html5/?chapter=16&#34;&gt;DOM&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para os casos onde o HTML for mal escrito, como em sites antigos que foram criados para suprir necessidades de browsers como Netscape e IE, o parser faz uma mudança de interpretação fazendo com que o Firefox entenda esse código antigo e não quebre o site. Logo, não precisamos manter um legado com códigos antigos e abre portas para a criação de código novo, mesmo estando em ambientes onde ainda é necessário conviver com código antigo.&lt;/p&gt;

&lt;h3 id=&#34;mathml-e-svg&#34;&gt;MathML e SVG&lt;/h3&gt;

&lt;p&gt;Uma das vantagens desse novo parser é que ele permite que você sirva MathML e SVG diretamente na sua página sem ter que declarar a página inteira como XML/XHTML. Isso quer dizer que o código abaixo pode ser inserido normalmente em uma página HTML, sem qualquer namespace declarado.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de MathML:&lt;/p&gt;

&lt;pre lang=&#34;html&#34; line=&#34;1&#34;&gt;&amp;lt;math&gt;
  &amp;lt;mi&gt;x&amp;lt;/mi&gt;
 
  &amp;lt;mo&gt;=&amp;lt;/mo&gt;
  &amp;lt;mfrac&gt;
    &amp;lt;mrow&gt;
      &amp;lt;mo&gt;&amp;minus;&amp;lt;/mo&gt;
      &amp;lt;mi&gt;b&amp;lt;/mi&gt;
      &amp;lt;mo&gt;&amp;PlusMinus;&amp;lt;/mo&gt;
      &amp;lt;msqrt&gt;
        &amp;lt;msup&gt;
 
          &amp;lt;mi&gt;b&amp;lt;/mi&gt;
          &amp;lt;mn&gt;2&amp;lt;/mn&gt;
        &amp;lt;/msup&gt;
        &amp;lt;mo&gt;&amp;minus;&amp;lt;/mo&gt;
        &amp;lt;mn&gt;4&amp;lt;/mn&gt;
        &amp;lt;mo&gt;&amp;InvisibleTimes;&amp;lt;/mo&gt;
        &amp;lt;mi&gt;a&amp;lt;/mi&gt;
 
        &amp;lt;mo&gt;&amp;InvisibleTimes;&amp;lt;/mo&gt;
        &amp;lt;mi&gt;c&amp;lt;/mi&gt;
      &amp;lt;/msqrt&gt;
    &amp;lt;/mrow&gt;
    &amp;lt;mrow&gt;
      &amp;lt;mn&gt;2&amp;lt;/mn&gt;
      &amp;lt;mo&gt;&amp;InvisibleTimes;&amp;lt;/mo&gt;
      &amp;lt;mi&gt;a&amp;lt;/mi&gt;
 
    &amp;lt;/mrow&gt;
  &amp;lt;/mfrac&gt;
&amp;lt;/math&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.github.com/tableless/mathml.html&#34; rel=&#34;external&#34;&gt;Veja o exemplo online&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja o &lt;a href=&#34;https://github.com/tableless/exemplos/blob/gh-pages/mathml.html&#34; rel=&#34;external&#34;&gt;código no Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Com o SVG é a mesma coisa, veja o código abaixo:&lt;/p&gt;

&lt;pre lang=&#34;html&#34; line=&#34;1&#34;&gt;




&lt;a href=&#34;http://tableless.com.br/&#34;&gt;
    &amp;lt;svg style=&#34;width:113px; height:113px; margin-left:30px&#34;&gt;
&amp;lt;polygon fill=&#34;#EA2125&#34; points=&#34;113,91 113,0 0,0 0,113 91,113&#34;/&gt;
&amp;lt;polygon opacity=&#34;0.5&#34; fill=&#34;#010101&#34; points=&#34;113,91 91,91 91,113&#34;/&gt;
&amp;lt;path fill=&#34;#FFFFFF&#34; d=&#34;M62.364,34.905v14.147l12.991-4.482l3.963,10.369l-13.003,5.447l8.165,11.593l-8.783,6.502L56.82,66.799
l-8.693,11.683l-9.225-6.502l8.261-12.036l-13.096-5.004l3.779-10.369l13.438,4.482V34.905H62.364z&#34;/&gt;
    &amp;lt;/svg&gt;
&lt;/a&gt;


&lt;/pre&gt;

&lt;p&gt;Veja o código &lt;a href=&#34;http://tableless.github.com/exemplos/logo-tableless-svg.html&#34; rel=&#34;external&#34;&gt;acima em ação&lt;/a&gt; no &lt;a href=&#34;https://github.com/tableless/exemplos/&#34; rel=&#34;external&#34;&gt;nosso GITHUB&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Perceba que os códigos acima se parecem muito mais com um HTML do que com um XML. Perceba que não há nenhum namespace declarado. Isso é uma maravilha porque dá flexibilidade.&lt;/p&gt;

&lt;p&gt;Pela explicação do &lt;a href=&#34;http://hacks.mozilla.org/2010/05/firefox-4-the-html5-parser-inline-svg-speed-and-more/&#34;&gt;Mozilla Hacks&lt;/a&gt;, o algoritmo é dividido em duas partes principais: &lt;strong&gt;tokenization&lt;/strong&gt; e &lt;strong&gt;tree building&lt;/strong&gt; (mantive o termo original porque a tradução literal seria muito estranha). A tokenization (algo como &lt;strong&gt;tokenização&lt;/strong&gt;. Viu, falei que seria estranho) seria o processo de ler o fluxo do código de tags, comentários e atributos de tags. A &lt;strong&gt;tree building&lt;/strong&gt; seria o processo de pegar essas informações encontradas pela tokenização e construir a árvore de tags, o árvore do DOM. O fluxo de tags que você construiu.&lt;/p&gt;

&lt;h4 id=&#34;outras-atualizações&#34;&gt;Outras atualizações&lt;/h4&gt;

&lt;p&gt;O Firefox 4 trouxe outras atualizações que podemos falar mais pra frente aqui no Tableless. São atualizações que navegadores Webkit já tem suporte e também o Opera, como: &lt;a href=&#34;http://tableless.com.br/introducao-ao-css-animation&#34;&gt;CSS Transitions&lt;/a&gt;, &lt;a href=&#34;http://tableless.com.br/html5/?chapter=8&#34;&gt;Formulários em HTML5&lt;/a&gt;, &lt;a href=&#34;http://tableless.com.br/html5/?chapter=11&#34;&gt;Audio Data API&lt;/a&gt;, &lt;a href=&#34;http://tableless.com.br/html5/?chapter=21&#34;&gt;History API&lt;/a&gt;, HTML5 Video buffered property, e o tão aguardado JägerMonkey o novo engine de Javascript da Mozilla.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6 dicas para evitar problemas de incompatibilidade entre browsers.</title>
      <link>http://tableless.com.br/evite-incompatibilidade-browsers/</link>
      <pubDate>Tue, 28 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/evite-incompatibilidade-browsers/</guid>
      <description>

&lt;p&gt;Nas últimas semanas muito falou-se das novas versões de &lt;em&gt;browsers&lt;/em&gt; que serão colocadas à disposição dos usuários nos próximos meses. Alguns esperam para ver se a gigante Microsoft recuperará o mercado e outros acompanham as novidades de Mozilla e Google com suas versões beta do Firefox 4 e do Chrome 6. É inevitável perceber a preocupação de todos em adaptar-se às necessidades dos usuários, padrões de desenvolvimento web e compatibilidade com o novo protagonista da web &amp;#8211; o HTML5 &amp;#8211; porém em meio à esses lançamentos, fica a pergunta: enquanto isso, como agir com os atuais &lt;em&gt;browsers&lt;/em&gt;? Como criar estruturas de &lt;em&gt;front-end&lt;/em&gt; para que os parâmetros do CSS 2 sejam igualmente aplicados à todos?&lt;/p&gt;

&lt;p&gt;Essas perguntas já travaram várias batalhas entre desenvolvedores e navegadores, tendo como principal vilão o Internet Explorer em suas versões 6, 7 e 8 que além de não ser compatível com os demais browsers também não é compatível entre suas próprias versões, dificultando a criação de padrões e a exclusão de &lt;em&gt;hacks&lt;/em&gt;. De qualquer forma, nosso trabalho é visualizar igualmente as interfaces em todos os navegadores &amp;#8211; o chamado &lt;em&gt;crossbrowser&lt;/em&gt; &amp;#8211; e para isso, apresento algumas possibilidades e propriedades que podem ser inseridas aos seus arquivos css para evitar esses problemas sem utilizar &lt;em&gt;hacks&lt;/em&gt;, “gambiarras” ou arquivos diferentes para cada &lt;em&gt;browser.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;dica-nº-1-organização-x-manutenção&#34;&gt;Dica nº 1: Organização x manutenção.&lt;/h3&gt;

&lt;p&gt;Em seu artigo, a &lt;a href=&#34;http://tableless.com.br/6-estrategias-para-melhorar-a-organizacao-do-seu-css-2#author-image&#34;&gt;Talita Pagani&lt;/a&gt; apresenta &lt;a href=&#34;http://tableless.com.br/6-estrategias-para-melhorar-a-organizacao-do-seu-css-2&#34;&gt;estratégias para melhorar a organização dos arquivos CSS&lt;/a&gt; e aproveito o gancho para aconselhar: é indiscutível que, em se tratando de manutenção ou a criação de arquivos CSS, a organização seja fundamental para encontrarmos os problemas quando as incompatibilidades surgirem. Então, uma estrutura de classes, ID&amp;#8217;s e identação de elementos, parâmetros e valores é ponto crucial para manutenção e desenvolvimento de estruturas &lt;em&gt;html&amp;amp;css&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;dica-nº-2-elementos-com-propriedades-pré-definidas&#34;&gt;Dica nº 2: Elementos com propriedades pré-definidas.&lt;/h3&gt;

&lt;p&gt;Muitos desenvolvedores não sabem, mas alguns elementos do HTML tem propriedades pré-definidas que, quando começamos a trabalhar com a diagramação podem por exemplo, nos trazer dificuldades de encontrar aquele “espaço a mais” que incomoda tanto. Então, inicialmente, vamos eliminar todas estas formatações criando uma declaração que elimina os principais parâmetros pré-definidos que “bagunçam” a interface de &lt;em&gt;browser&lt;/em&gt; para &lt;em&gt;browser:&lt;/em&gt; &lt;em&gt;margin’s&lt;/em&gt; e &lt;em&gt;padding’s.&lt;/em&gt; Para tanto, utilizaremos o selector universal (*) no ínicio da folha de estilo eliminando os espaçamentos internos ou externos dos elementos:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;css&amp;#8221;]*{&lt;/p&gt;

&lt;p&gt;padding: 0;&lt;/p&gt;

&lt;p&gt;margin:0;&lt;/p&gt;

&lt;p&gt;}[/cc]&lt;/p&gt;

&lt;p&gt;Caso em sua estrutura tenha várias folhas de estilo, separadas por página (home.css), aconselho que seja criado um arquivo específico para a declaração desta propriedade e valores zerados, com o nome de &amp;#8220;geral.css&amp;#8221; ou &amp;#8220;reset.css&amp;#8221;. Assim, posteriormente ele poderá ser linkado à página ou inserido, via parâmetro &lt;strong&gt;@import&lt;/strong&gt;,  às outras folhas de estilo incorporando às demais declarações.&lt;/p&gt;

&lt;p&gt;Se necessário utilizar &lt;em&gt;margin’s&lt;/em&gt; ou &lt;em&gt;padding’s&lt;/em&gt; para alguns elementos, meu conselho é que você crie classes específicas para cada um deles, pois isso vai lhe garantir um controle maior de qual elemento tem uma propriedade que pode causar alguma diferença em larguras ou alturas nos blocos do HTML.&lt;/p&gt;

&lt;p&gt;Há um artigo aqui no Tableless que explica esse conceito chamado &lt;a href=&#34;http://tableless.com.br/css-reset&#34; title=&#34;Como fazer um reset nas propriedades do CSS&#34;&gt;CSS Reset&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;dica-nº-3-largura-e-altura-x-propriedade-padding&#34;&gt;Dica nº 3: largura e altura x propriedade &lt;em&gt;padding&lt;/em&gt;.&lt;/h3&gt;

&lt;p&gt;Alguns desenvolvedores também não sabem, mas quando inserimos a propriedade &lt;em&gt;width&lt;/em&gt; ou &lt;em&gt;height&lt;/em&gt; à um elemento e adicionamos a propriedade &lt;em&gt;padding&lt;/em&gt; à esse mesmo elemento, os valores estabelecidos serão somados. Por exemplo, se tenho um elemento com &lt;em&gt;width: 640px&lt;/em&gt; e estabeleço o parâmetro &lt;em&gt;padding-left: 20px&lt;/em&gt;, meu elemento terá ao todo &lt;em&gt;660px&lt;/em&gt; de largura. Portanto, quando utilizar a propriedade &lt;em&gt;padding&lt;/em&gt;, tanto os valores de largura quanto os de altura, devem ser reduzidos proporcionalmente para que seu bloco continue com o mesmo tamanho e com um espaçamento interno necessário.&lt;/p&gt;

&lt;p&gt;No nosso exemplo, o correto então seria: &lt;em&gt;width: 620px&lt;/em&gt; e &lt;em&gt;padding-left: 20px&lt;/em&gt;. Ficando o elemento todo com uma largura total de &lt;em&gt;640px&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;css&amp;#8221;].blocoNoticias{&lt;/p&gt;

&lt;p&gt;width: 620px;&lt;/p&gt;

&lt;p&gt;padding-left: 20px;&lt;/p&gt;

&lt;p&gt;}[/cc]&lt;/p&gt;

&lt;h3 id=&#34;dica-nº-4-colunas-x-propriedade-float&#34;&gt;Dica nº 4: colunas x propriedade float.&lt;/h3&gt;

&lt;p&gt;Toda vez que utilizamos a propriedade &lt;em&gt;float&lt;/em&gt; para formatação de colunas em nossa página, temos que nos lembrar de regras básicas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;#8211; Se as colunas estão inseridas dentro de algum outro elemento, você terá que obrigatoriamente usar, neste elemento “externo”, a propriedade &lt;em&gt;display:table&lt;/em&gt; e a propriedade &lt;em&gt;height:auto&lt;/em&gt;. Caso contrário, no Firefox, seu background pode não aparecer ou tão pouco obedecer a altura da colunas.&lt;/li&gt;
&lt;li&gt;&amp;#8211; Se após as colunas, existir um outro elemento com propriedade horizontal, formando uma linha, ele obrigatoriamente deve receber a propriedade &lt;em&gt;clear:both&lt;/em&gt;, para que ele não incorpore a propriedade &lt;em&gt;float&lt;/em&gt; inserida nas colunas e fique logo abaixo delas.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dica-nº-5-propriedade-border-para-visualizar-os-problemas&#34;&gt;Dica nº 5: Propriedade border para visualizar os problemas.&lt;/h3&gt;

&lt;p&gt;Para quem já está com toda a página pronta e não consegue encontrar e resolver alguns problemas como uma coluna embaixo da outra ou um texto ultrapassando o limite de seu bloco, insira a propriedade &lt;em&gt;border:solid 1px red&lt;/em&gt; ao elemento e visualize na tela a altura e largura deste bloco. Com isso você vai conseguir perceber qual elemento está extrapolando o limite ou qual espaçamento está “empurrando” os demais blocos.&lt;/p&gt;

&lt;p&gt;Visualizar o problema na tela, facilita a resolução.&lt;/p&gt;

&lt;h3 id=&#34;dica-nº-6-verifique-sua-página-desde-o-início-em-todos-os-browsers&#34;&gt;Dica nº 6: verifique sua página, desde o início, em todos os &lt;em&gt;browsers.&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;É muito mais fácil começar uma estrutura &lt;em&gt;html&amp;amp;css&lt;/em&gt; já verificando a inserção de cada elemento em todos os &lt;em&gt;browsers&lt;/em&gt; ao mesmo tempo, do que desenvolver tudo visualizando apenas em um dos navegadores e após finalizar o projeto, visualizar nos demais. Com toda certeza, se este cuidado não for tomado, você vai se deparar com uma interface com cara de “jogos de &lt;em&gt;puzzle&lt;/em&gt; embaralhados” em algum momento e vai ser ainda mais difícil resolver os problemas.&lt;/p&gt;

&lt;p&gt;Essas são apenas algumas das tantas possibilidades que temos para evitar o uso de hacks ou “jeitinhos” na construção de nossos arquivos html&amp;amp;css no trabalho de &lt;em&gt;crossbroswers&lt;/em&gt;. De qualquer forma, me mantenho na torcida de que com a nova geração, tenhamos muito mais chances de desenvolver um código html melhor estruturado e um css com propriedades visuais que hoje ainda não podemos utilizar, do que ficar estudando os erros dos navegadores para encontrarmos os acertos dos desenvolvedores &amp;#8211; quase como tiros no escuro.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Processos e Adoção de Padrões</title>
      <link>http://tableless.com.br/processos-adocao-padroes/</link>
      <pubDate>Wed, 03 Mar 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/processos-adocao-padroes/</guid>
      <description>

&lt;p&gt;HTML 5 ou CSS 3 já podem ser usados? Quando o HTML 5 será lançado?&lt;/p&gt;

&lt;p&gt;Estou ouvindo demais essas perguntas. A resposta que darei, vai servir para as duas perguntas e para perguntas futuras sobre outras recomendações do W3C.&lt;/p&gt;

&lt;p&gt;Para termos uma visão melhor, você precisa entender como o W3C funciona.&lt;/p&gt;

&lt;h3 id=&#34;padrões-e-recomendações&#34;&gt;Padrões e Recomendações&lt;/h3&gt;

&lt;p&gt;O W3C é um órgão que regulamenta, cria e desenvolve linguagens para publicação de conteúdo na internet. Há uma diferença muito grande entre padrão e recomendação. O W3C não faz padrões, ele recomenda métodos e linguagens. Uma recomendação se torna padrão porque há a aderência da comunidade. Normalmente uma recomendação do W3C vira padrão, porque o W3C está lá para isso, eles trabalham para que seja assim. Entretanto, você pode criar uma linguagem como o HTML, e submeter para a aprovação do W3C ou fazer o &amp;#8220;marketing&amp;#8221; dela sozinho e torcer para que a comunidade de desenvolvedores e fabricantes de browsers o apóiem. Isso é difícil de fazer, mas não impossível. Aconteceu com o pessoal do WHATWG com o HTML 5. Um grupo de desenvolvedores estavam descontentes com o caminho que o W3C estava tomando em relação ao XHTML 2 e ao HTML. Então resolveram criar um grupo para escrever um novo padrão da linguagem HTML. O W3C se convenceu e adotou o padrão do HTML 5 que eles estavam escrevendo.&lt;/p&gt;

&lt;p&gt;Claro que esse grupo foi inspirado por desenvolvedores da Apple, Mozilla e Opera, mas isso foi só um detalhe. 😉&lt;/p&gt;

&lt;h3 id=&#34;processo-de-adoção&#34;&gt;Processo de adoção&lt;/h3&gt;

&lt;p&gt;O W3C recomenda métodos e linguagens, o mercado acata e vira um padrão. Uma idéia do W3C, assim que nasce, não é já indicada para uso. Para que isso aconteça há um processo de aprovação e testes. Esse processo é dividido por passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Working Draft&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Last Call&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Candidate Recommendation (CR)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Proposed Recommendation (PR)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;W3C Recommendation (REC)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;No Working Draft o W3C publica um documento para a comunidade e grupos de membros do W3C. Trate isso como uma ideia rascunhada no papel, onde eles estão perguntando para todos os interessados se é interessante e vale a pena continuar.&lt;/p&gt;

&lt;p&gt;No Last Call, o W3C publica os deadlines do projeto, e pede para que todos os grupos de trabalho que de alguma forma estão envolvidos naquele projeto, enviem seus reviews. Há uma fase dentro do Last Call onde o W3C pede para o público, que somos nós, enviar reviews e idéias sobre o assunto.&lt;/p&gt;

&lt;p&gt;No Cadidate Recommendation, o W3C já acredita na tecnologia proposta. Ela foi largamente revista por técnicos de dentro e fora do W3C e por todos os grupos de trabalho envolvidos no processo. Nesse ponto, há o começo da experiência de implementação dessa nova tecnologia. Normalmente alguns browsers já implementam essa ideia para que possa ser utilizada por desenvolvedores mundo afora.&lt;/p&gt;

&lt;p&gt;Depois dessa fase, entramos na Proposed Recommendation. Nessa fase a recomendação é enviada para o W3C Advisory Committee para que eles aprovem a adoção final que será um novo padrão no mercado. Entenda que nesse meio tempo, há um processo de testes, implementação e desenvolvimento muito criterioso. É o mundo inteiro testando e sugerindo revisões para que a tecnologia seja realmente interessante e inteligente o suficiente para suprir as expectativas.&lt;/p&gt;

&lt;p&gt;Quando essa especificação é aprovada, chegamos ao último estágio, onde a idéia inicial vira uma Recomendação. Aí sim os fabricantes de browsers e desenvolvedores poderão utilizar em seus projetos.&lt;/p&gt;

&lt;p&gt;Para ficar mais fácil imaginar, tente pensar em um calhamaço de papel. Nesse calhamaço contém um manual de instruções de uso, implementação e detalhes técnicos de como os browsers devem renderizar as instruções, instruções de como os desenvolvedores devem aplicar e escrever o código.&lt;/p&gt;

&lt;p&gt;Engraçado que tudo isso gira em torno de ideias escritas, revisadas e reescritas. Claro que eles fazem testes reais em browsers reais durante todo o processo. Por isso há integrantes de todos os browsers nas equipes para representar cada um dos browsers do mercado. É um trabalho conjunto.&lt;/p&gt;

&lt;h3 id=&#34;mas-e-aí-podemos-ou-não-usar&#34;&gt;Mas e aí, podemos ou não usar?&lt;/h3&gt;

&lt;p&gt;Durante muito tempo o CSS foi lançado em versões. Hoje temos 2 versões completas (CSS 1 e 2) e uma revisão (CSS 2.1). O time de desenvolvimento do W3C lançavam atualizações fechadas, ou seja, para haver um lançamento oficial, a especificação do CSS teria de ser totalmente desenvolvida, testada e aprovada. O CSS e o HTML passavam inteiros por todos os processos acima. Por isso, os lançamentos de atualizações no HTML e no CSS eram tão demorados.&lt;/p&gt;

&lt;p&gt;Hoje, a aprovação do CSS3 está sendo feito por módulos, assim como o HTML5. Há uma equipe para cada uma das principais propriedades do CSS. Por exemplo, há uma equipe que trabalha exclusivamente para o desenvolvimento do background no CSS3. Quando essa equipe acha que já fez um bom avanço, a propriedade de background, separada do resto da linguagem, passa por todo aquele processo que conhecemos no começo do artigo. Isso facilita a adoção dos browsers e dos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Por isso que hoje, mais do que nunca, é necessário que os desenvolvedores pratiquem o Graceful Degradation e do Progressive Enhancement. Pode ser que um browser não suporte uma determinada propriedade porque deu foco para outra propriedade. Isso faz com que a taxa de incompatibilidade de browsers aumente. Se levarmos em conta que os browsers estão mais espertos e suas atualizações estão sendo mais breves, isso não será grande problema. Nosso problema atual é exatamente browsers antigos que não recebem mais atualização. O IE6 está deixando de ser esse caso. A taxa de utilização do IE6 já está bem abaixo do IE7. Claro que em alguns casos isso não é motivador porque trata-se de público específico ou cliente interno. Mas a grande maioria do mercado já está sem essa sombra.&lt;/p&gt;

&lt;p&gt;Querendo ou não, essa nova forma de o W3C lançar atualizações em módulos, mexe com a dinâmica do mercado. Não apenas os browsers precisam de atualizações rápidas, mas o desenvolvedor também. Cada uma das atualizações lançadas, minimizam o tempo de trabalho, melhoram o processo de desenvolvimento e priorizam a qualidade de código. Outro passo importante para o desenvolvedor é entender que o site que ele escreve, é portável para qualquer tipo de dispositivo. O desenvolvedor é uma espécie de mensageiro. O conteúdo precisa entregue em diversos meios, e é o desenvolvedor que possibilita isso.&lt;/p&gt;

&lt;p&gt;Alguns links para que você conheça mais sobre o processo estão abaixo. Isso tudo pode ser encontrado no site do W3C. Basta ler.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/Consortium/&#34; title=&#34;Sobre o W3C&#34;&gt;About W3C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/2005/10/Process-20051014/tr#maturity-levels&#34; title=&#34;Níveis de aprovação&#34;&gt;Níveis de aprovação&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.w3.org/Style/CSS/current-work#test&#34; title=&#34;Projeto actual do CSS&#34;&gt;Current Work do CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Porque é a web que comanda</title>
      <link>http://tableless.com.br/porque-e-a-web-que-comanda/</link>
      <pubDate>Wed, 27 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/porque-e-a-web-que-comanda/</guid>
      <description>&lt;p&gt;A AppStore fez sucesso. Bastante. Por vários motivos: um deles foi por conta da remuneração do desenvolvedor. Teve gente que ganhou milhares de dólares sozinho vendendo aplicações por 99 centavos. Obviamente isso chamou a atenção de muita gente, que começou a fazer aplicações enlouquecidamente para ganhar alguns trocados. Consequentemente um grande números de aplicações que não precisam ser instaláveis no aparelho, apareceram. Vários desenvolvedores não perceberam que dependendo do seu sistema, ele não precisa ser desenvolvido exclusivamente para ser instalado na plataforma do iPhone.&lt;/p&gt;

&lt;p&gt;Hoje, aparelhos como o iPhone, que tem um browser com um bom suporte a HTML 5 e CSS 3, possibilitam criar sistemas e aplicativos baseados em web, com características, designs e comportamentos idênticos aos de aplicações instaláveis nos aparelhos. E o melhor, podem ser utilizados de qualquer lugar, pela web. Outro ponto negativo é que desenvolver para iPhone/iPod Touch é um bocado burocrático. Você precisa ter o SDK que só funciona no OS X, e você precisa aprender Objective C para programar os Apps para Apple. Em contrapartida, para fazer um App baseado em Web, onde seus clientes acessarão o sistema diretamente pelo browser do aparelho, é preciso saber Javascript, HTML 5 e CSS 3. Se você já é desenvolvedor Web, você já sabe desenvolver para iPhone, iPod Touch, Android e qualquer outro dispositivo similar.&lt;/p&gt;

&lt;p&gt;Se você gosta dos efeitos de transição dos aparelhos, você pode fazê-los sem problemas utilizando JQuery ou CSS 3. Há até um &lt;a href=&#34;http://www.jqtouch.com/&#34;&gt;plugin de JQuery chamado JQTouch&lt;/a&gt;, que permite fazer efeitos idênticos ao do iPhone. Esse plugin foi pensado exatamente para funcionar em Mobile Safari e outros aparelhos com browsers avançados, como no Android.&lt;/p&gt;

&lt;p&gt;Um caso sobre o que estamos falando é a aplicação do Itaú. Se você tem um iPhone, baixe o aplicativo pela AppStore. Ao abrir o aplicativo, perceba que o sistema não faz nada além de mostrar o site do Itaú. É muito mais interessante e barato ensinar o usuário a visitar o site em vez de procurar um aplicativo e instalar. Não é necessário nem divulgar um endereço mobile do site &amp;#8211; esse aliás é outra discussão.&lt;/p&gt;

&lt;p&gt;Obviamente, há exceções. A maioria dos jogos, se não todos, e alguns sistemas disponíveis funcionam melhor (ainda) se forem instalados no aparelho. Mas a grande maioria dos sistemas, principalmente aqueles que o usuário simplesmente insere ou verifca informações e dados, podem ser servidos diretamente pela web.&lt;/p&gt;

&lt;p&gt;No caso do iPhone, os sistemas que utilizam recursos do aparelho, como por exemplo fazer o aparelho vibrar, bluetooth, bateria, GPS e etc, precisam ser instalados. Isso não se aplica a alguns mobiles da Nokia que são baseados na plataforma WRT.&lt;/p&gt;

&lt;p&gt;A plataforma WRT permite que você desenvolva aplicativos utilizando Javascript, HTML e CSS. E por meio de Javascript, você pode ativar os recursos que ter utilizar no aparelho. Nesse caso, há uma vantagem em cima do iPhone: você não precisa aprender Objective C. Basta saber Javascript, CSS e HTML.&lt;/p&gt;

&lt;p&gt;O cenário de hoje é interessante. Tudo o que o desenvolvedor sempre sonhou em utilizar de HTML 5 e CSS 3 pode ser aplicado no desenvolvimento para web mobile. Os browsers estão mais espertos e a cada dia trazem novidades interessantes para melhorar o desenvolvimento dos padrões e da web. Realmente, daqui pra frente, é um novo mundo que se forma. Um mundo tão ou mais complexo que o desenvolvimento web para desktops como conhecemos hoje. Pra mim, é mais apaixonante.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.apple.com/iphone/library/documentation/UserExperience/Conceptual/MobileHIG/Introduction/Introduction.html&#34;&gt;Guidelines de User Experience&lt;/a&gt; da Apple.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.forum.nokia.com/Technology_Topics/Web_Technologies/Web_Runtime/&#34;&gt;Forum Nokia &amp;#8211; Web Runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Simuladores de Browsers Mobiles</title>
      <link>http://tableless.com.br/simuladores-de-browsers-mobiles/</link>
      <pubDate>Wed, 20 Jan 2010 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/simuladores-de-browsers-mobiles/</guid>
      <description>&lt;p&gt;Antigamente não existiam simuladores dos pequenos celulares. Na verdade, não precisava. Você provavelmente usava WAP. Quando começamos a utilizar CSS e XHTML para fazer sites mais decentes para os mobiles, tudo ficou mais complicado, você precisava ter um aparelho para fazer testes. Em muitos casos era simples resolver utilizando o Opera no desktop mesmo, mas em forma de visualização mobile/handheld. Contudo, você estava desenvolvendo para apenas aparelhos com Opera. Não havia, por exemplo, um simulador de IE Mobile. Nem precisa, é horrível, e atualmente, a maioria utiliza Opera.&lt;/p&gt;

&lt;p&gt;Para fazer sites para os iPhones e Androids da vida, não há segredo, já que eles aceitam tudo e mais um pouco de CSS e HTML. Você consegue ter homogeneidade ao desenvolver. Mesmo assim, para ter certeza, seria interessante você testar o site em um aparelho. Por isso, há simuladores que emulam o ambiente dos aparelhos. É o caso do iPhone e do Android.&lt;/p&gt;

&lt;p&gt;Para aprender mais sobre o simulador do Android, visite a &lt;a href=&#34;http://developer.android.com/guide/developing/tools/emulator.html&#34;&gt;página oficial sobre o emulador&lt;/a&gt; deles. Assim você aprende como ele funciona, as funções, instalação e etc. O &lt;a href=&#34;http://developer.android.com/sdk/index.html&#34;&gt;simulador pode ser instalado em Windows, Mac ou Linux&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O simulador para iPhone é só para quem tem Mac. Infelizmente a Apple ainda não liberou o SDK para outros sistemas. Uma pena, porque não só de mac vive o homem, e a maioria dos devs utilizam Windows ou Linux. Mesmo assim, você &lt;a href=&#34;http://developer.apple.com/iphone/program/sdk/&#34;&gt;pode baixá-lo&lt;/a&gt; e utilizá-lo para testar qualquer site ou arquivos locais.&lt;/p&gt;

&lt;p&gt;O pessoal da Nokia também disponibiliza vários emuladores. Contudo, aconselho que você utilize apenas o browser de S60, que é o melhor deles hoje em dia. Os browsers dos S60 suportam Webkit, mesmo não sendo a versão mais atualizada, é possível fazer muita coisa interessante, entretanto, há haver alguns erros de compatibilidade por conta do engine desatualizado.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.android.com/sdk/index.html&#34;&gt;Simulador de Android&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://developer.apple.com/iphone/program/sdk/&#34;&gt;Simulador de iPhone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.forum.nokia.com/info/sw.nokia.com/id/db2c69a2-4066-46ff-81c4-caac8872a7c5/NMB40_install.zip.html&#34;&gt;Simulador para Nokia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Aonde nos leva a morte do Internet Explorer 6?</title>
      <link>http://tableless.com.br/aonde-nos-leva-a-morte-do-internet-explorer-6/</link>
      <pubDate>Fri, 17 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/aonde-nos-leva-a-morte-do-internet-explorer-6/</guid>
      <description>&lt;p&gt;Semana passada foi o Digg, essa semana o YouTube. E a comunidade de desenvolvedores os segue fazendo barulho, anunciando que vai fazer o mesmo. Nós estamos fazendo nossa parte na Visie, eliminando a preocupação com o IE6 de nossos sites e convencendo nossos clientes a fazê-lo também. Já vai tarde.&lt;/p&gt;

&lt;p&gt;Mas não é tempo de comemorar, ainda há muito trabalho a fazer. Há oito anos o Zeldman publicou seu célebre artigo &lt;a href=&#34;http://www.alistapart.com/articles/tohell/&#34;&gt;To Hell With Bad Browsers&lt;/a&gt;, em que nos explicava porque devíamos abandonar o suporte aos navegadores 4.0. O ponto básico era não ter que fazer várias versões do mesmo site. Uma versão apenas, com bom layout CSS, podia funcionar para todo mundo, com todas as vantagens dos padrões web, mas não nos navegadores 4.0.&lt;/p&gt;

&lt;p&gt;Bom, fazem oito anos. OITO LONGOS ANOS! Há oito anos que podemos escrever uma versão só de cada site, desde que saibamos escrever hacks de CSS e ajustes de float para o Internet Explorer 6. Há oito anos que estamos repetindo o fato de que o Internet Explorer 6 é a pedra que restou em nosso sapato. Há oito anos que sonhamos em não ter que escrever hacks.&lt;/p&gt;

&lt;p&gt;A morte do Internet Explorer 6 significa apenas isso: poder usar PNG transparente e não ter que escrever hacks (ou não ter que escrever &lt;strong&gt;tantos&lt;/strong&gt; hacks.)&lt;/p&gt;

&lt;p&gt;A Microsoft passou oito anos sem atualizar seu navegador para nos dar exatamente o que? PNG transparente? Nesse período, Firefox, Opera, Safari e Konqueror estão trabalhando em coisas como controle de opacidade, &lt;a href=&#34;http://tableless.com.br/introducao-ao-css-animation&#34;&gt;CSS transform&lt;/a&gt;, bordas com imagem, sombras, &lt;a href=&#34;http://tableless.com.br/introducao-sobre-media-queries&#34;&gt;media queries&lt;/a&gt;, &lt;a href=&#34;http://tableless.com.br/css3-columns&#34;&gt;colunas&lt;/a&gt; e os maravilhosos novos &lt;a href=&#34;http://tableless.com.br/nth-child&#34;&gt;seletores do CSS3&lt;/a&gt;. Coisas maravilhosas que você já pode usar, mas a maioria de seus usuários não vai ver porque usa Internet Explorer.&lt;/p&gt;

&lt;p&gt;A morte do Internet Explorer 6 nos leva apenas ao lugar onde deveríamos ter chegado há oito anos: sites sem hacks. A Microsoft ainda está algumas gerações atrasadas e, se queremos usar CSS 3 e HTML 5 um dia, é bom parar de comemorar e voltar ao trabalho. Há um mundo para mudar.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flock 1.0 – agora dá para usar</title>
      <link>http://tableless.com.br/flock-10-agora-da-para-usar/</link>
      <pubDate>Sun, 02 Dec 2007 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/flock-10-agora-da-para-usar/</guid>
      <description>

&lt;p&gt;O &lt;a href=&#34;http://getfirefox.com/&#34;&gt;Firefox&lt;/a&gt; é o browser do meu coracão. Não vivo mais sem suas extensões. Se você é desenvolvedor e usa Firefox, sabe do que estou falando.&lt;/p&gt;

&lt;p&gt;Só que eu não sou apenas desenvolvedor. Nas horas vagas, sou gente normal. Gosto de passar uma parte do meu tempo navegando pelos meus sites prediletos. Por isso, eu gastava algumas horas procurando por extensões que me deixassem mais ligado em sites como &lt;a href=&#34;http://flickr.com/photos/diegoeis&#34;&gt;Flickr&lt;/a&gt;, &lt;a href=&#34;http://twitter.com/diegoeis/&#34;&gt;Twitter&lt;/a&gt; e &lt;a href=&#34;http://del.icio.us/tableless&#34;&gt;Del.icio.us&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&#34;http://flock.com/&#34;&gt;Flock&lt;/a&gt;, durante algum tempo, tinha a promessa de ser um browser que facilitasse nossa relação com os serviços online. Até então, pelo menos para mim, ele não tinha alcançado este objetivo. Parece que tudo mudou de figura. Foi lançado a &lt;a href=&#34;http://flock.com/get-ready-to-flock&#34;&gt;versão 1.0 do Flock para Windows, Mac e Linux&lt;/a&gt; e pelo menos até agora, estou gostando bastante.&lt;/p&gt;

&lt;!--More--&gt;

&lt;p&gt;Depois da instalação, ele me perguntou se eu gostaria de importar meus favoritos e outras configurações do &lt;a href=&#34;http://getfirefox.com/&#34;&gt;Firefox&lt;/a&gt; ou &lt;a href=&#34;http://apple.com/safari&#34;&gt;Safari&lt;/a&gt;. Disse para pegar tudo do &lt;a href=&#34;http://getfirefox.com/&#34;&gt;Firefox&lt;/a&gt;. Isso foi feito sem o menor problema.&lt;/p&gt;

&lt;h3 id=&#34;extensões-do-firefox&#34;&gt;Extensões do Firefox&lt;/h3&gt;

&lt;p&gt;Mesmo o Flock sendo baseado no Firefox, minha primeira preocupação foi testar as extensões que eu mais uso no Firefox. Nas versões anteriores do Flock, muitas delas davam defeitos e eu acabava não migrando de browser por conta disso. Mas agora, depois dos testes, parece que a versão 1.0 está totalmente estável para o uso de &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/search&#34;&gt;extensões do Firefox&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Instalei aqui: &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/271&#34;&gt;ColorZilla&lt;/a&gt;, &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/539&#34;&gt;Measureit&lt;/a&gt;, &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/60&#34;&gt;Web Developer&lt;/a&gt;, &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/1320&#34;&gt;Gmail Manager&lt;/a&gt;, &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/39&#34;&gt;Mouse Gestures&lt;/a&gt; e &lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/2410&#34;&gt;FoxMarks&lt;/a&gt;. Todas elas funcionaram sem problemas.&lt;/p&gt;

&lt;h3 id=&#34;cadastro-e-uso-dos-serviços-online&#34;&gt;Cadastro e uso dos Serviços Online&lt;/h3&gt;

&lt;p&gt;Achei um pouco complicado de cadastrar meus serviços online. Demorei para notar que eu tinha que entrar no site do serviço, me deslogar e logar novamente para ele detectar o login e assim cadastrar no Flock. Entretanto, depois disso, tudo foi bem transparente. A interface é bem acabada, mesmo assim achei tudo bem apertado no painel lateral. Talvez exista a possibilidade de customizar essa opção.&lt;/p&gt;

&lt;p&gt;Contudo, há muito o que melhorar com a interface para facilitar o uso de alguns serviços. Não descobri uma maneira fácil de dar Reply em mensagens do &lt;a href=&#34;http://twitter.com/diegoeis/&#34;&gt;Twitter&lt;/a&gt;, a não ser digitando na unha. Ele também não dá nenhuma pista de qual seja o apelido dos usuários. O que dificulta se você quer responder a mensagem do seu amigo.&lt;/p&gt;

&lt;p&gt;Já o uso do Flickr é sensacional desde as versões anteriores do Flock. Mesma coisa para o &lt;a href=&#34;http://del.icio.us/tableless&#34;&gt;Del.icio.us&lt;/a&gt; e outros serviços. Foi implementado também serviços como YouTube.&lt;/p&gt;

&lt;h3 id=&#34;outros-pontos&#34;&gt;Outros pontos&lt;/h3&gt;

&lt;p&gt;O visual geral do Flock, na minha opinião, é melhor que a do Firefox. E há suporte para a instalação de outros temas.&lt;/p&gt;

&lt;p&gt;Há uma parte que gostei muito chamada My World. Seria uma espécie de página onde você fica por dentro do seu &amp;#8220;profile&amp;#8221; do Flock. Confere suas contas de serviços, vê suas visitas e movimentações nos serviços cadastrados e etc&amp;#8230;&lt;/p&gt;

&lt;p&gt;Gostei bastante também da interface de blogging. Integrei o Flock com o WordPress do Tableless. Ficou mais fácil blogar.&lt;/p&gt;

&lt;p&gt;Se você quiser testar o &lt;a href=&#34;http://flock.com/&#34;&gt;Flock&lt;/a&gt;, indico, pelo menos por agora. Vou dar mais pitaco sobre ele conforme vou usando pelo &lt;a href=&#34;http://twitter.com/diegoeis/&#34;&gt;meu Twitter&lt;/a&gt;.&lt;!-- technorati tags begin --&gt;&lt;/p&gt;

&lt;p style=&#34;font-size:10px;text-align:right;&#34;&gt;
  Tags: &lt;a rel=&#34;tag&#34; href=&#34;http://technorati.com/tag/flock&#34;&gt;flock&lt;/a&gt;, &lt;a rel=&#34;tag&#34; href=&#34;http://technorati.com/tag/browser&#34;&gt;browser&lt;/a&gt;, &lt;a rel=&#34;tag&#34; href=&#34;http://technorati.com/tag/%20web&#34;&gt; web&lt;/a&gt;, &lt;a rel=&#34;tag&#34; href=&#34;http://technorati.com/tag/%20desenvolvimeto%20web&#34;&gt; desenvolvimeto web&lt;/a&gt;, &lt;a rel=&#34;tag&#34; href=&#34;http://technorati.com/tag/%20navegadores&#34;&gt; navegadores&lt;/a&gt;, &lt;a rel=&#34;tag&#34; href=&#34;http://technorati.com/tag/%20internet&#34;&gt; internet&lt;/a&gt;
&lt;/p&gt;

&lt;!-- technorati tags end --&gt;
</description>
    </item>
    
  </channel>
</rss>