<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Less on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/less/index.xml</link>
    <description>Recent content in Less on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/less/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sass vs. LESS vs. Stylus: Batalha dos Pré-processadores</title>
      <link>https://tableless.github.io/hugo-public/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</link>
      <pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar:&lt;/p&gt;

&lt;h2 id=&#34;sintaxe&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Essa sintaxe não é por causa de ser mais antiga e sim pois no início o &lt;strong&gt;Sass&lt;/strong&gt; era parte de um outro pré-processador chamado &lt;strong&gt;Haml&lt;/strong&gt; criado por desenvolvedores &lt;strong&gt;Ruby&lt;/strong&gt;, e por causa disso as folhas de estilo escritas com &lt;strong&gt;Sass&lt;/strong&gt; utilizavam uma sintaxe como a do &lt;strong&gt;Ruby&lt;/strong&gt;, sem chaves, ponto e vírgula e controlado por identação.&lt;/p&gt;

&lt;h3 id=&#34;stylus&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-1&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-1&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-1&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-1&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-2&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-2&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-2&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Como mencionado nos comentários, o LESS tem suporte a herança e pode ser feita com a seguinte sintaxe:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p {
        &amp;:extend(.block);
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;h2 id=&#34;importação&#34;&gt;Importação&lt;/h2&gt;

&lt;p&gt;Na comunidade CSs, importar CSS é visto com maus olhos por utilizar diversas chamadas HTTP. Importar com um pré-processador funciona de forma diferente no entanto. Se você importar um arquivo com qualquer um dos três pré-processadores, ele irá literalmente pegar todo o conteúdo do arquivo durante a importação e gerar apenas um arquivo. Lembre-se que arquivos .css comuns importados compilam com o código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;file.css&#34;;
&lt;/pre&gt;

&lt;p&gt;Lembre-se também que mixins e variáveis podem ser importadas e usadas em sua folha de estilo principal. Importação faz com que possamos criar arquivos separados para uma melhor organização.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-1&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* arquivo.{extensao} */
body {
    background: #eee;
}
&lt;/pre&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
@import &#34;arquivo.{extensao}&#34;;
 
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-3&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;h2 id=&#34;introdução-1&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;-&amp;gt;Pré-processadores produzem CSS que funciona em todos os browsers&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Eles fazem isso compilando o código que escrevemos em CSS puro que pode ser usado em qualquer browser de agora até a era das pedras. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar&lt;/p&gt;

&lt;h2 id=&#34;sintaxe-1&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador CSS é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less-1&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-3&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis-1&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass-2&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-3&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-4&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-4&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento-1&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-2&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-5&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins-1&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-3&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-4&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-5&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-6&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança-1&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus-1&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus-1&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-5&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less-1&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
body {
    background: #eee;
}
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h2 id=&#34;funções-de-cores&#34;&gt;Funções de Cores&lt;/h2&gt;

&lt;p&gt;Funções de cores são funções nativas que transformam uma cor por compilação. Podem ser extremamente úteis para criar gradientes, escurecer cores no &amp;#8220;hover&amp;#8221; de elementos e muito mais.&lt;/p&gt;

&lt;h3 id=&#34;sass-4&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten($color, 10%); /* retorna uma cor 10% mais clara que $color */
darken($color, 10%);  /* retorna uma cor 10% mais escura $color */
 
saturate($color, 10%);   /* retorna uma cor 10% mais saturada que $color */
desaturate($color, 10%); /* retorna uma cor 10% menos saturada que $color */
 
grayscale($color);  /* retorna $color na escala de cinza */
complement($color); /* retorna cor complementar de $color */
invert($color);     /* retorna cor inversa de $color */
 
mix($color1, $color2, 50%); /* mistura $color1 com $color2 com um peso de 50% */
&lt;/pre&gt;

&lt;p&gt;Essas é apenas uma pequena lista de funções de cores disponíveis no Sass. A lista completa das funções de cores disponíveis no Sass pode ser encontrada na &lt;a href=&#34;http://sass-lang.com/documentation/Sass/Script/Functions.html&#34; target=&#34;_blank&#34;&gt;documentação do Sass&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Funções de cores podem ser usadas em qualquer lugar que uma cor é válida no CSS. Veja um exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$color: #0982C1;
 
h1 {
    background: $color;
    border: 3px solid darken($color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-6&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(@color, 10%); /* retorna uma cor 10% mais clara que @color */
darken(@color, 10%);  /* retorna uma cor 10% mais escura @color */
 
saturate(@color, 10%);   /* retorna uma cor 10% mais saturada que @color */
desaturate(@color, 10%); /* retorna uma cor 10% menos saturada que @color */
 
spin(@color, 10); /* retorna uma cor 10 graus acima na matiz/tonalidade que @color */
spin(@color, -10); /* retorna uma cor 10 graus abaixo na matiz/tonalidade que @color */
 
mix(@color1, @color2); /* mistura @color1 com @color2 */
&lt;/pre&gt;

&lt;p&gt;A lista de todas as funções disponíveis no LESS pode encontrada na &lt;a href=&#34;http://lesscss.org/#-color-functions&#34; target=&#34;_blank&#34;&gt;documentação LESS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no LESS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@color: #0982C1;
 
h1 {
    background: @color;
    border: 3px solid darken(@color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-6&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(color, 10%); /* retorna uma cor 10% mais clara que &#39;color&#39; */
darken(color, 10%);  /* retorna uma cor 10% mais escura &#39;color&#39; */
 
saturate(color, 10%);   /* retorna uma cor 10% mais saturada que &#39;color&#39; */
desaturate(color, 10%); /* retorna uma cor 10% menos saturada que &#39;color&#39; */
&lt;/pre&gt;

&lt;p&gt;A lista completa de todas funções de cores disponíveis no Stylus pode ser encontrada na &lt;a href=&#34;http://stylus-lang.com/docs/bifs.html&#34; target=&#34;_blank&#34;&gt;documentação Stylus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no Stylus:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;color = #0982C1
 
h1
    background color
    border 3px solid darken(color, 50%)
&lt;/pre&gt;

&lt;h2 id=&#34;operações&#34;&gt;Operações&lt;/h2&gt;

&lt;p&gt;Fazer cálculos no CSS é bastante útil e agora totalmente possível. É bem simples e é dessa maneira que fazemos:&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-3&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: (14px/2);
    top: 50px + 100px;
    right: 100px - 50px;
    left: 10 * 10;
}
&lt;/pre&gt;

&lt;h2 id=&#34;aplicações-práticas&#34;&gt;Aplicações Práticas&lt;/h2&gt;

&lt;p&gt;Nós falamos de diversas funcionalidades e novas coisas que pré-processadores podem fazer, mas não mostramos nada na prática ainda. Veja uma pequena lista de aplicações no mundo real em que um pré-processador é um salva-vidas.&lt;/p&gt;

&lt;h3 id=&#34;vendor-prefixes&#34;&gt;Vendor Prefixes&lt;/h3&gt;

&lt;p&gt;Essa é uma das principais razões para se usar um pré-processador e por um motivo bom &amp;#8211; economia gigante de tempo e lágrimas. Criar um mixin para cuidar dos vendor prefixes é fácil e nos salva de uma codificação repetitiva e dolorosa. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-5&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin border-radius($values) {
    -webkit-border-radius: $values;
        -moz-border-radius: $values;
            border-radius: $values;
}
 
div {
    @include border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-7&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.border-radius(@values) {
    -webkit-border-radius: @values;
        -moz-border-radius: @values;
            border-radius: @values;
}
 
div {
    .border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-7&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;border-radius(values) {
    -webkit-border-radius: values;
        -moz-border-radius: values;
            border-radius: values;
}
 
div {
    border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-7&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;div {
    -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
            border-radius: 10px;
}
&lt;/pre&gt;

&lt;h3 id=&#34;texto-3d&#34;&gt;Texto 3D&lt;/h3&gt;

&lt;p&gt;Simular um texto 3D utilizando diversos text-shadows é uma grande ideia. O único problema é que mudar a cor depois de criar é difícil e incômodo. Usando mixins e funções de cores, podemos criar um texto 3D e mudar sua cor sem nenhuma dificuldade.&lt;/p&gt;

&lt;h4 id=&#34;sass-6&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin text3d($color) {
    color: $color;
    text-shadow: 1px 1px 0px darken($color, 5%),
            2px 2px 0px darken($color, 10%),
            3px 3px 0px darken($color, 15%),
            4px 4px 0px darken($color, 20%),
            4px 4px 2px #000;
}
 
h1 {
    font-size: 32pt;
    @include text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-8&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.text3d(@color) {
    color: @color;
    text-shadow: 1px 1px 0px darken(@color, 5%),
            2px 2px 0px darken(@color, 10%),
            3px 3px 0px darken(@color, 15%),
            4px 4px 0px darken(@color, 20%),
            4px 4px 2px #000;
}
 
span {
    font-size: 32pt;
    .text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-8&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;text3d(color)
    color: color
    text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000
span
    font-size: 32pt
    text3d(#0982c1)
&lt;/pre&gt;

&lt;p&gt;Escolhi escrever os &amp;#8220;text-shadows&amp;#8221; do Stylus em apenas uma linha pois omiti as chaves.&lt;/p&gt;

&lt;h4 id=&#34;css-compilado-8&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;span {
    font-size: 32pt;
    color: #0982c1;
    text-shadow: 1px 1px 0px #097bb7, 
            2px 2px 0px #0875ae, 
            3px 3px 0px #086fa4, 
            4px 4px 0px #07689a, 
            4px 4px 2px #000;
}
&lt;/pre&gt;

&lt;h4 id=&#34;resultado-final&#34;&gt;Resultado Final&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.tutsplus.com/net/uploads/legacy/1144_preprocshootout/text3d.png&#34; alt=&#34;Texto 3D&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;colunas&#34;&gt;Colunas&lt;/h3&gt;

&lt;p&gt;Usar operações numéricas e variáveis para colunas é uma ideia que tive da primeira vez que estava brincando com pré-processadores CSS. Declarando a largura desejada em uma variável, podemos facilmente alterá-la sem precisar de nenhum cálculo mental. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-7&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$siteWidth: 1024px;
$gutterWidth: 20px;
$sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: $siteWidth;
}
.content {
    float: left;
    width: $siteWidth - ($sidebarWidth+$gutterWidth);
}
.sidebar {
    float: left;
    margin-left: $gutterWidth;
    width: $sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-9&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@siteWidth: 1024px;
@gutterWidth: 20px;
@sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: @siteWidth;
}
.content {
    float: left;
    width: @siteWidth - (@sidebarWidth+@gutterWidth);
}
.sidebar {
    float: left;
    margin-left: @gutterWidth;
    width: @sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-9&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;siteWidth = 1024px;
gutterWidth = 20px;
sidebarWidth = 300px;
 
body {
    margin: 0 auto;
    width: siteWidth;
}
.content {
    float: left;
    width: siteWidth - (sidebarWidth+gutterWidth);
}
.sidebar {
    float: left;
    margin-left: gutterWidth;
    width: sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-9&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: 0 auto;
    width: 1024px;
}
.content {
    float: left;
    width: 704px;
}
.sidebar {
    float: left;
    margin-left: 20px;
    width: 300px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;peculiaridades-notáveis&#34;&gt;Peculiaridades Notáveis&lt;/h2&gt;

&lt;p&gt;Existem algumas peculiaridades ao usar um pré-processador CSS. Irei falar de algumas engraçadas, mas se você está realmente interessado em encontrar todas elas eu recomendo você vasculhar toda a documentação, ou melhor, começar a usar um pré-processador na sua codificação diária.&lt;/p&gt;

&lt;h3 id=&#34;relatório-de-erros&#34;&gt;Relatório de Erros&lt;/h3&gt;

&lt;p&gt;Se você já escreveu CSS por uma boa quantia de tempo, tenho certeza que você já chegou a um ponto onde você tinha um erro em algum lugar e simplesmente não conseguia o encontrar. Se você é como eu, provavelmente passou a tarde toda arrancando os cabelos fora e comentando diversas coisas para caçar o erro.&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS relatam os erros. Simples assim. Se tem alguma coisa errada em seu códigom ele te fala onde e, se você estiver com sorte até mesmo o porquê. Você pode dar uma olhada &lt;a href=&#34;http://tjholowaychuk.com/post/5002088731/stylus-vs-sass-vs-less-error-reporting&#34; target=&#34;_blank&#34;&gt;nesse post&lt;/a&gt; caso esteja interessado em ver como os erros são relatados em diferentes pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;comentários&#34;&gt;Comentários&lt;/h3&gt;

&lt;p&gt;Quando um pré-processador CSS está compilando, qualquer comentário escrito com barras duplas &amp;#8220;//&amp;#8221; é excluído e qualquer comentários escrito com barra e asterisco &amp;#8220;/* */&amp;#8221; não é alterado. Dito isso, use comentários com barras duplas para comentários que você queira na versão não compilada e comentários com barra e asterisco para comentários que serão visíveis após a compilação.&lt;/p&gt;

&lt;p&gt;Observação: Se você compilar os arquivos, minificando-os, todos comentários são excluídos.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Cada um dos pré-processadores que falamos (Sass, LESS e Stylus) possui um modo único de realizar a mesma tarefa &amp;#8211; dando a nós desenvolvedor a habilidade de usar funcionalidades úteis mantendo a compatibilidade entre browsers e um código limpo.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mesmo não sendo uma exigência para o desenvolvimento, pré-processadores podem economizar muito tempo e tem funcionalidades bastante úteis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu aconselho todos vocês a utilizar e testar a maior quantidade de pré-processadores possível, pois assim você poderá escolher efetivamente um favorito e saber o porquê ele é seu favorito dentre tantos outros. Se você ainda não testou usar nenhum pré-processador para escrever seu CSS, eu recomendo grandemente a você testar.&lt;/p&gt;

&lt;p&gt;Você tem alguma funcionalidade de seu pré-processador favorito que não foi mencionada? Há algo que algum pré-processador possa fazer e outros não? Conte-nos nos comentários abaixo!&lt;/p&gt;

&lt;p&gt;Traduzido e adaptado de: &lt;a href=&#34;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320&#34;&gt;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout&amp;#8211;net-24320&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Workflow Front-end</title>
      <link>https://tableless.github.io/hugo-public/workflow-front-end/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/workflow-front-end/</guid>
      <description>

&lt;p&gt;O desenvolvimento em html, javascript e CSS é uma forma mágica de se construir um mundo novo a cada linha de código. Os mágicos do front-end precisam de cartolas para que retirem seus coelhos. Essas cartolas e varinhas mágicas devem ser escolhidas a dedo, para que a mágica aconteça de forma suave e agradável à plateia.&lt;/p&gt;

&lt;p&gt;Cada mágico tem sua técnica, portanto o objetivo não é estabelecer um padrão imutável, mas estabelecer diretrizes que possam servir de auxílio a qualquer ilusionista. Vamos entender magia.&lt;/p&gt;

&lt;h2 id=&#34;baralho&#34;&gt;Baralho&lt;/h2&gt;

&lt;p&gt;Todo mágico possui um baralho. Com ele é possível fazer um número imenso de ilusões. Tão versátil quanto um baralho, deve ser o editor de texto a ser usado pelo desenvolvedor.&lt;/p&gt;

&lt;p&gt;Vamos falar de dois editores: Edge Code e Sublime Text.&lt;/p&gt;

&lt;p&gt;O Edge Code tem como objetivo permitir o foco no trabalho, para isso ele tem uma interface propositalmente simples. Uma mágica que adoro nele é poder editar conteúdo de um arquivo por meio de outro com base em uma relação específica – ou seja, tenho no arquivo html uma marcação que faz referência a uma classe CSS, clicando com o botão direito nessa classe e selecionando quick edit podemos editar o CSS do arquivo externo com base no arquivo html. Esse baralho tem muito mais mágicas.&lt;/p&gt;

&lt;p&gt;O Sublime Text tem tantos recursos que possibilitam uma produtividade imensa. Quando você acessa &lt;a href=&#34;http://www.sublimetext.com/&#34;&gt;http://www.sublimetext.com/&lt;/a&gt;, nota-se o foco em mostrar o quão produtivo o Sublime Text é. Uma mágica de produtividade é a possibilidade de selecionar um texto que se repete em um arquivo html por meio da tecla de atalho Ctrl+d e alterar todos ao mesmo tempo. Adoro isso.&lt;/p&gt;

&lt;h2 id=&#34;cartola&#34;&gt;Cartola&lt;/h2&gt;

&lt;p&gt;O NodeJS permite que mágicas que eram feitas somente no palco – navegador –, possam ser feitas atrás das cortinas – servidor. No entanto essas mágicas são cada vez mais complexas, gerando uma dependência de recursos que necessitariam de outra ferramenta mágica para gerenciá-las.&lt;/p&gt;

&lt;p&gt;Essa outra ferramenta mágica é nossa cartola. Dela tiramos tudo que é necessário para fazermos o show. Duas cartolas não podem deixar de serem conhecidas: NPM e Bower.&lt;/p&gt;

&lt;p&gt;O NPM é o que todo gerenciador de dependências precisa ser: instalador de pacotes, gerenciador de versão e gerenciador de dependências.&lt;/p&gt;

&lt;p&gt;O Bower é o que o NPM é, mas para componentes front-end.&lt;/p&gt;

&lt;p&gt;Se este é o cenário, então é bom termos duas cartolas, cada uma fazendo seu tipo de mágica: NPM no desenvolvimento com Grunt, Gulp, JSHint, etc; e Bower para componentes front-end.&lt;/p&gt;

&lt;h2 id=&#34;assistentes&#34;&gt;Assistentes&lt;/h2&gt;

&lt;p&gt;Assistentes de palco são vitais no contexto de muitas mágicas. Além de distrair quem vê o espetáculo, elas embelezam o ambiente. Elas são o CSS da ilusão.&lt;/p&gt;

&lt;p&gt;Frameworks de estilo podem agilizar muito um trabalho, porque muitas das preocupações iniciais do projeto, podem ser deixadas de lado pela adoção de um padrão, que já respondeu a todas elas. Nossas assistentes de palco são: Bootstrap e Pure.&lt;/p&gt;

&lt;p&gt;Bootstrap é de longe a ferramenta mais popular para atribuição de estilo aos projetos. Pontos positivos: variedade de componentes, utilizado por grandes empresas que contribuem com o projeto e boa documentação. Ele é a assistente que sabe como as mágicas são feitas.&lt;/p&gt;

&lt;p&gt;Pure tem como objetivo fornecer estilo totalmente independente de qualquer javascript e de uma maneira muito leve. É uma assistente magrinha que faz seu trabalho bem feito.&lt;/p&gt;

&lt;p&gt;É inquestionável que a aparência faz muita diferença.&lt;/p&gt;

&lt;h2 id=&#34;caixas-e-lâminas&#34;&gt;Caixas e lâminas&lt;/h2&gt;

&lt;p&gt;Na mágica da mulher cortada ao meio, uma mulher entra numa caixa e o mágico enfia uma lâmina no meio da caixa, e ela é separada em duas partes. As mãos, a cabeça e os pés continuam se mexendo. Quando uso pré-processadores CSS me sinto separado um corpo ao meio, mas ao mesmo tempo confiando que ele irá unir as partes e no final teremos um corpo inteiro.&lt;/p&gt;

&lt;p&gt;É claro que escrever CSS puro gerará menos código que o uso errôneo de mixins em SASS. Mas devemos medir a relação de custo e benefício em relação a produtividade (após a curva de aprendizagem ser superada) e qualidade do nosso código, para podermos escolher aquilo que é melhor para o projeto &amp;#8211; espetáculo. Nossas caixas e lâminas para separarem corpos podem ser: LESS e SASS.&lt;/p&gt;

&lt;p&gt;As características da LESS que devem ser sempre destacadas são, em sua maioria, comuns aos pré-processadores. Mas devem ser ditas aqui:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Variáveis: valores que são usados em vários lugares podem ser reutilizados por todo o estilo do projeto, e quando uma alteração for necessária, poderá ser feita com muita facilidade.&lt;/li&gt;
&lt;li&gt;Mixins: servem ao mesmo propósito das variáveis – a reutilização –, mas sendo usadas para classes completas. Podendo incluir uma classe dentro de outra classe, como se fosse uma propriedade.&lt;/li&gt;
&lt;li&gt;Aninhamento: a possibilidade de aninhar seletores dentro de outros seletores é um truque que me encanta muito. Porque ele criará os seletores longos por conta própria e você ficará com o trabalho de apenas construir a hierarquia a seletores por meio de aninhamento.&lt;/li&gt;
&lt;li&gt;Operações: executar operações com propriedades e cores por meio do CSS é tão fora de cogitação que se torna muito surpreendente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SASS faz tudo isso descrito acima, e faz antes de o LESS ter feito. Mas a consideração que deve ser feita é: LESS tem uma sintaxe mais simples, que leva a uma curva de aprendizagem menor, e quando essa curva atinge uma boa inclinação, ela é mais produtiva.&lt;/p&gt;

&lt;h2 id=&#34;automatização&#34;&gt;Automatização&lt;/h2&gt;

&lt;p&gt;Muitas coisas precisam ser feitas, que não necessariamente são observadas, mas tem valor. Isso se aplica a tudo na vida. Montar o palco para o espetáculo, preparar e limpar as ferramentas, checar se tudo está apto para funcionamento, etc. Concatenar arquivos, minificar código, realizar o deploy, etc.&lt;/p&gt;

&lt;p&gt;Estas tarefas podem continuar a serem feitas, mas sem o trabalho que normalmente se tem para as suas execuções. A ferramenta a ser usada neste caso é o Grunt.&lt;/p&gt;

&lt;p&gt;Com o Grunt você pode automatizar tarefas para serem executadas via linha de comando. Basta ter o NodeJS e configurar as tarefas a serem automatizadas.&lt;/p&gt;

&lt;h2 id=&#34;qualidade&#34;&gt;Qualidade&lt;/h2&gt;

&lt;p&gt;Uma mágica bem feita pode ser repetida diversas vezes, e ainda causará boas impressões. Isso se deve a qualidade com que a mágica foi feita. Existe a melhor maneira de executá-la, e quando isso é feito, tudo flui muito bem. Escrever códigos javascript e css com qualidade &amp;#8211; o que inclui boas práticas de sintaxe e construção – é um desafio, porque escrever sem boas práticas também funciona.&lt;/p&gt;

&lt;p&gt;Para verificar a qualidade do nosso código temos: JSLint, JSHint e CSSLint.&lt;/p&gt;

&lt;p&gt;JSLint realiza uma busca com foco em erros de sintaxe e erros estruturais.&lt;/p&gt;

&lt;p&gt;JSHint é um fork do JSLint com uma melhoria que permite customizações, ele permite flexibilidade.&lt;/p&gt;

&lt;p&gt;CSSLint tem o objetivo de verificar além da sintaxe a performance do CSS.&lt;/p&gt;

&lt;h2 id=&#34;enfim&#34;&gt;Enfim&lt;/h2&gt;

&lt;p&gt;Cada mágico tem um conjunto de mágicas que são apresentadas. Mas todos tem o mesmo objetivo: encantar. Todo desenvolvedor precisa encantar a todos para ter seu trabalho reconhecido. Essas ferramentas, e muitas outras, podem fazer a diferença. Então faça a diferença.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grids semânticos com LESS</title>
      <link>https://tableless.github.io/hugo-public/grids-semanticos-com-less/</link>
      <pubDate>Fri, 08 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/grids-semanticos-com-less/</guid>
      <description>

&lt;h1 id=&#34;grids-semânticos-com-less&#34;&gt;Grids semânticos com LESS&lt;/h1&gt;

&lt;p&gt;Já reparou como os blocos da sidebar aqui do Tableless possuem todos a mesma largura? Ou como a largura do bloco de artigo somada a largura da sidebar é equivalente ao wrap do menu e do rodapé? Mesmo que você não tenha percebido isto antes de maneira consciente, a informação parece mais organizada desta forma&amp;#8230;É por que o design do Tableless, como boa parte do conteúdo da internet, foi alinhado com o auxilio de um grid.&lt;/p&gt;

&lt;h2 id=&#34;o-que-é-um-grid&#34;&gt;O que é um grid?&lt;/h2&gt;

&lt;p&gt;Um grid é basicamente um conjunto de linhas guias, horizontais e/ou verticais, que servem de base para um design. No caso de design digital, o grid funciona como um esqueleto onde o layout será apoiado. Grids estão em todos os lugares, mesmo que você não os enxergue. Basta olhar a sua volta. A organização da informação é uma das principais vantagens na utilização de um grid, mas eu poderia citar diversas outras como precisão, consistência, hierarquia visual, ritmo&amp;#8230; Só isto já daria um artigo inteiro. Grids são mesmo maravilhosos e a maior parte dos designers que conheço são apaixonados pro eles. Mas muitas vezes reproduzir a precisão de um grid em um código HTML/CSS é uma tarefa muito desgastante. Alguns desenvolvedores &amp;#8211; as vezes por desconhecimento, as vezes por preguiça, as vezes por falta de tempo hábil &amp;#8211; acabam alterando os valores. Arredondam uma porcentagem aqui, inventam uma margem ali, completamente desconsideram o valor de espaçamento entre linha&amp;#8230; Resultado: o layout final parece bem diferente do original já que o grid foi praticamente descartado. Designers choram. Desenvolvedores se descabelam. Caos. Okay, talvez não de maneira tão dramática. Mas recriar a precisão do grid no CSS pode ser um problema. Ainda mais quando se trata de um projeto que inclui design responsivo&amp;#8230;&lt;/p&gt;

&lt;h2 id=&#34;sistemas-convencionais-de-grids-e-seus-problemas&#34;&gt;Sistemas convencionais de grids (e seus problemas)&lt;/h2&gt;

&lt;p&gt;Existem algumas alternativas que prometem ajudar nesta tarefa. Sistemas como o &lt;a href=&#34;http://cssgrid.net/&#34; title=&#34;1140 Grid System&#34;&gt;1140 Grid System&lt;/a&gt; e o clássico &lt;a href=&#34;http://960.gs/&#34; title=&#34;960gs&#34;&gt;960gs&lt;/a&gt; quebram um galho e são faceis de utilizar, mas diversos aspectos me incomodavam nestes sistemas: classes não semânticas que sujavam o código (.onecol, .twocol&amp;#8230; argh!), a necessidade de utilizar excessivamente truques como clearfix para &amp;#8220;abrir&amp;#8221; as fileiras e o aspecto engessado já que em nenhum destes sistemas existia a opção de customizar a largura das margens e colunas de acordo com o projeto. O jeito então era escrever manualmente um grid para cada job. Falo por mim mesma quando digo que matemática nunca foi o meu forte e aqueles pequenos segundos quebrando a cabeça na calculadora acabavam deixando todo processo mais lento quando somados no fim do dia. Mas tudo isto mudou com o adventos dos pré-processadores de CSS.&lt;/p&gt;

&lt;h2 id=&#34;para-que-servem-pré-processadores&#34;&gt;Para que servem pré-processadores?&lt;/h2&gt;

&lt;p&gt;Basicamente eles pegam o texto escrito em uma linguagem e convertem ele para outra. Ou seja, literalmente pré-processam o código. No que isto é útil? Bem, é possível adicionar funcionalidades novas em linguagens pré existentes. Sistemas como &lt;a href=&#34;http://lesscss.org/&#34; title=&#34;LESS &#34;&gt;LESS&lt;/a&gt;, &lt;a href=&#34;http://sass-lang.com/&#34; title=&#34;SASS&#34;&gt;SASS&lt;/a&gt; e &lt;a href=&#34;http://learnboost.github.com/stylus/&#34; title=&#34;Stylus&#34;&gt;Stylus&lt;/a&gt; tornam possível trabalhar com velhos conhecidos dos programadores como variáveis, mixins, funções e operações matemáticas dentro do próprio CSS. É algo como uma folha de estilos com esteróides. E são estas funcionalidades extras que permitem a criação de um grid semântico.&lt;/p&gt;

&lt;h2 id=&#34;um-aviso-aos-navegantes&#34;&gt;Um aviso aos navegantes&lt;/h2&gt;

&lt;p&gt;Vamos utilizar o sistema &lt;a href=&#34;http://semantic.gs/&#34; title=&#34;Semantic.gs&#34;&gt;Semantic.gs&lt;/a&gt;. Existem muitos outros do tipo, mas a vantagem dele é que não se trata de um framework cheio de classes inúteis ou de um plugin de js que pesará no final. Este grid é todo escrito usando apenas CSS compatível com as linguagens do LESS, SASS e Stylus. Para este artigo eu escolhi utilizar LESS por ser a linguagem mais popular. Mas é facinho de adaptar para as outras, só vai mudar a sintaxe. Ainda não sabe utilizar o LESS? Sugiro que você leia o artigo aqui do Tableless &amp;#8220;&lt;a href=&#34;http://tableless.com.br/css-dinamico-com-less/&#34; title=&#34;CSS dinâmico com LESS&#34;&gt;CSS Dinâmico com Less&lt;/a&gt;&amp;#8220;. Entendeu tudo direitinho? Então você esta pronto para começar.&lt;/p&gt;

&lt;h2 id=&#34;o-design&#34;&gt;O design&lt;/h2&gt;

&lt;p&gt;O primeiro passo, obviamente, é criar o grid no seu editor de imagens favoritos. No caso do Photoshop você pode quebrar a cabeça puxando linhas guias, utilizar algum plugin como o &lt;a href=&#34;http://guideguide.me/&#34; title=&#34;GuideGuide&#34;&gt;GuideGuide&lt;/a&gt; ou ainda utilizar usar um gerador online. Eu recomendo o &lt;a href=&#34;http://gridcalculator.dk/&#34; title=&#34;Grid Calculator&#34;&gt;Grid Calculator&lt;/a&gt;. Você insere o tamanho das colunas, das margens e a largura total do arquivo e magicamente ele gera um script de Photoshop ou Ilustrator ou ainda um arquivo em png com o grid prontinho. Mais fácil que tirar sarro do Internet Explorer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Um grid é basicamente um conjunto de linhas guias, horizontais e/ou verticais, que servem de base para um design.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Então vamos considerar uma estrutura basica bem simples. Header, um bloco de conteúdo, sidebar e footer em um wrap de 960 pixes de largura.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-13192&#34; alt=&#34;grid-exemplo-layout&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/03/layout.jpg&#34; width=&#34;580&#34; height=&#34;407&#34; srcset=&#34;uploads/2013/03/layout.jpg 580w, uploads/2013/03/layout-239x168.jpg 239w, uploads/2013/03/layout-441x310.jpg 441w&#34; sizes=&#34;(max-width: 580px) 100vw, 580px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para criar este layout eu utilizei um grid de 12 colunas com 60 pixels de largura. Okay. Layout feito. Hora de desenvolver.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-13191&#34; alt=&#34;grid-exemplo-colunas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/03/grid.jpg&#34; width=&#34;580&#34; height=&#34;407&#34; srcset=&#34;uploads/2013/03/grid.jpg 580w, uploads/2013/03/grid-239x168.jpg 239w, uploads/2013/03/grid-441x310.jpg 441w&#34; sizes=&#34;(max-width: 580px) 100vw, 580px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;construindo-o-grid&#34;&gt;Construindo o Grid&lt;/h2&gt;

&lt;p&gt;Baixe a &lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2013/03/grid.zip&#34;&gt;Demo&lt;/a&gt; ou crie um novo arquivo HTML com a seguinte estrutura.&lt;/p&gt;

&lt;pre&gt;&amp;lt;body&amp;gt;

&amp;lt;div class=&#34;wrap&#34;&amp;gt;
&amp;lt;header class=&#34;cabecalho&#34;&amp;gt;
&amp;lt;h1&amp;gt;Header&amp;lt;/h1&amp;gt;
&amp;lt;/header&amp;gt;

&amp;lt;section class=&#34;conteudo&#34;&amp;gt;
&amp;lt;h1&amp;gt;Conteúdo&amp;lt;/h1&amp;gt;
&amp;lt;/section&amp;gt;

&amp;lt;aside class=&#34;sidebar&#34;&amp;gt;
&amp;lt;h1&amp;gt;Sidebar&amp;lt;/h1&amp;gt;
&amp;lt;/aside&amp;gt;

&amp;lt;footer class=&#34;footer&#34;&amp;gt;
&amp;lt;h1&amp;gt;Footer&amp;lt;/h1&amp;gt;
&amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt; &amp;lt;!-- /wrap--&amp;gt;

&amp;lt;/body&amp;gt;&lt;/pre&gt;

&lt;p&gt;Crie também um arquivo de CSS na linguagem LESS (style.less, por exemplo) e coloque o link entre as tags head do seu layout.&lt;/p&gt;

&lt;pre&gt;&amp;lt;link rel=&#34;stylesheet/less&#34; href=&#34;css/style.less&#34; /&amp;gt;&lt;/pre&gt;

&lt;p&gt;Não se esqueça de fazer o download da &lt;a href=&#34;https://raw.github.com/cloudhead/less.js/master/dist/less-1.3.3.min.js&#34; title=&#34;LESS&#34;&gt;última versão do LESS&lt;/a&gt; e referencia-la também head do seu HTML. Lembrando sempre que este script deve aparecer depois da folha de estilos.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&amp;quot;js/less-1.3.3.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hora de setar o nosso grid. Inclua o seguinte código na sua folha de estilos LESS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* ==|=======================================================================
   Grid //  http://semantic.gs/ 
========================================================================== */

/*Altere estes valores de acordo com a largura das colunas, largura das margens e o número de colunas do seu grid.*/
@column-width: 60;
@gutter-width: 20;
@columns: 12;

@gridsystem-width: (@column-width*@columns) + (@gutter-width*@columns) * 1px;

/*Delete a linha abaixo se desejar trabalhar com valores em pixel.*/
@total-width: 100%;

.clearfix() {
    *zoom:1;

    &amp;:before,
    &amp;:after {
        content:&#34;&#34;;
        display:table;
    }
    &amp;:after {
        clear:both;
    }
}

body {
    width: 100%;
    .clearfix;
}

.row(@columns:@columns) {
    display: block;
    width: @total-width*((@gutter-width + @gridsystem-width)/@gridsystem-width);
    margin: 0 @total-width*(((@gutter-width*.5)/@gridsystem-width)*-1);
    .clearfix;
}
.column(@x,@columns:@columns) {
    display: inline;
    float: left;
    width: @total-width*((((@gutter-width+@column-width)*@x)-@gutter-width) / @gridsystem-width);
    margin: 0 @total-width*((@gutter-width*.5)/@gridsystem-width);
    }

.push(@offset:1) {
    margin-left: @total-width*(((@gutter-width+@column-width)*@offset) / @gridsystem-width) + @total-width*((@gutter-width*.5)/@gridsystem-width);
}
.pull(@offset:1) {
    margin-right: @total-width*(((@gutter-width+@column-width)*@offset) / @gridsystem-width) + @total-width*((@gutter-width*.5)/@gridsystem-width);
}

/*Determine a largura do seu container.*/
.wrap {
    max-width: 960px;
    margin: 0 auto;
}&lt;/pre&gt;

&lt;p&gt;Para customizar de acordo com o seu grid é bem fácil. Basta alterar os valores deste trecho:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@column-width: 60;
@gutter-width: 20;
@columns: 12;&lt;/pre&gt;

&lt;p&gt;Na opção @column-width você escreve a largura em pixels da coluna, em @gutter-width você escolhe a largura das margens e em @columns o número de colunas. E pronto! A matemática é toda feita pra você e o semantic.gs converte todas as medidas de pixel para porcentagem.&lt;/p&gt;

&lt;h2 id=&#34;como-aplicar-o-grid&#34;&gt;Como aplicar o grid&lt;/h2&gt;

&lt;p&gt;Segundo o nosso (belíssimo) layout o header deve ocupar a largura total do wrap, ou seja, o espaço equivalente a 12 colunas. Para isto basta acrescentar a classe .column(12) na folha de estilos.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.cabecalho {
      .column(12);
}&lt;/pre&gt;

&lt;p&gt;E isto no CSS final é compilado para os valores em porcentagens com uma margem de 10px:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.cabecalho  {
   display: inline;
   float: left;
   width: 97.61904761904762%;
   margin: 0 1.1904761904761905%;
}&lt;/pre&gt;

&lt;p&gt;Legal, né? Da mesma forma podemos determinar o espaço destinado ao conteúdo e a sidebar.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.conteudo {
        .column(9);
}
.sidebar {
        .column(3);
}&lt;/pre&gt;

&lt;p&gt;E isto será compilado para:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.conteudo {
  display: inline;
  float: left;
  width: 64.58333333333334%;
  margin: 0 1.0416666666666665%;
}
.sidebar {
  display: inline;
  float: left;
  width: 31.25%;
  margin: 0 1.0416666666666665%;
}&lt;/pre&gt;

&lt;h2 id=&#34;dominando-o-mundo-com-media-queries&#34;&gt;Dominando o mundo com media queries&lt;/h2&gt;

&lt;p&gt;Agora para fazer o conteúdo se adaptar a dispositivos mobile é moleza. É só utilizar os bons e velhos media-queries. Vamos supor que para smartphones tanto a section conteúdo quanto a sidebar devem ocupar a largura total do wrap.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@media screen and (max-width: 480px) {
   .conteudo, .sidebar {
      .column(12);
   }
 }&lt;/pre&gt;

&lt;p&gt;E pronto! Desenvolvimento responsivo de maneira prática e semântica, sem se preocupar com a matemática.&lt;/p&gt;

&lt;h2 id=&#34;como-a-magia-acontece&#34;&gt;Como a magia acontece&lt;/h2&gt;

&lt;p&gt;É tudo através desta função. Basicamente ele considera a largura total do sistema de grid como a largura das colunas multiplicado pelo número de colunas somado com a largura das margens multiplicado pelo número de colunas vezes um pixel.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@gridsystem-width: (@column-width*@columns) + (@gutter-width*@columns) * 1px;&lt;/pre&gt;

&lt;p&gt;Não quer trabalhar com porcentagens? Sem problema. Delete esta linha que os valores ficam em pixel.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@total-width: 100%;&lt;/pre&gt;

&lt;h2 id=&#34;saiba-mais&#34;&gt;Saiba mais&lt;/h2&gt;

&lt;p&gt;Existem algumas outras funções interessantes como a possibilidade de puxar e empurrar as divs e trabalhar com colunas aninhadas. Vale a pena ler a &lt;a href=&#34;http://semantic.gs/&#34; title=&#34;Semantic.gs&#34;&gt;documentação do semantic.gs&lt;/a&gt; e seguir o projeto no &lt;a href=&#34;https://github.com/twigkit/semantic.gs/&#34; title=&#34;Semantic.gs no GitHub&#34;&gt;GitHub&lt;/a&gt; para conferir futuras atualizações. O sistema é compatível com Firefox 3.5+, Safari 4+, Chrome, Opera 9+ e IE6.&lt;/p&gt;

&lt;p&gt;E vocês? Utilizam algum sistema de grid? Quais são as vantagens e desvantagens? Deixem as sugestões nos comentários.&lt;/p&gt;

&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2013/03/grid.zip&#34;&gt;Demo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Drops 9 – Préprocessadores, frameworks e bibliotecas</title>
      <link>https://tableless.github.io/hugo-public/drops-9-preprocessadores-frameworks-e-bibliotecas/</link>
      <pubDate>Fri, 11 May 2012 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/drops-9-preprocessadores-frameworks-e-bibliotecas/</guid>
      <description>&lt;p&gt;Uma continuação do post que escrevi sobre o assunto e a primeira parte de uma série de artigos com dicas sobre como estruturar uma área client-side.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/podcast/drops9-frameworks-bibliotecas-preprocessadores.mp3&#34;&gt;Arquivo Mp3&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS dinâmico com LESS</title>
      <link>https://tableless.github.io/hugo-public/css-dinamico-com-less/</link>
      <pubDate>Wed, 16 Nov 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/css-dinamico-com-less/</guid>
      <description>

&lt;p&gt;O desenvolvimento front-end nunca esteve tão dinâmico. Ferramentas como HAML, SASS e ZenCoding vêm revolucionando a maneira como trabalhamos. Em projetos onde qualquer coisa pode mudar a qualquer hora, flexibilidade é um ponto importantíssimo.&lt;/p&gt;

&lt;p&gt;O [LESS][1] chega nesse barco, adicionando um alto nível de personalização e permitindo recursos de programação em folhas de estilo estáticas. Com a biblioteca, é possível utilizar recursos como variáveis, funções, operações e escopo dentro de simples regras CSS.&lt;/p&gt;

&lt;h2 id=&#34;variáveis&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Uma das principais funcionalidades do LESS é a criação de variáveis.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@azul: #4ca5fe;
@cor_link: #df0d32;
@fonte_titulo: bold 25px/25px &#34;Georgia&#34;, &#34;Times New Roman&#34;, serif; 
&lt;/pre&gt;

&lt;p&gt;Variáveis servem para definir valores padrões para seus projetos e facilitar a manutenção e alteração dos mesmos. As variáveis acima poderiam ser utilizadas em diferentes estilos, por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.titulo {
    color: @azul;
    font: @fonte_titulo;
}

.li {
    color: @azul;
}

.li a {
    color: @cor_link;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixin é um conceito de programação orientada a objetos e basicamente representa a utilização de classes dentro de classes. Essas classes não são instanciadas e servem apenas para reaproveitamento de código.&lt;/p&gt;

&lt;p&gt;No LESS, mixins são classes/declarações que serão utilizadas dentro de outras classes de estilo.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.fonte-titulo{
    font-size: 36px;
    font-family: Helvetica, Arial, sans-serif;
    color: #666;
    letter-spacing: -2px;
    font-weight: 700;
}

h1 {
    text-transform: uppercase;
    .fonte-titulo;
}

h2 {
    .fonte-titulo;
    color: #000;
}
&lt;/pre&gt;

&lt;p&gt;Variáveis e mixins são as principais ferramentas para evitar uma terrível prática: repetição de código (no nosso caso, repetição de estilos).&lt;/p&gt;

&lt;h2 id=&#34;funções&#34;&gt;Funções&lt;/h2&gt;

&lt;p&gt;Estendendo o conceito acima, funções são mixins que recebem parâmetros. Os parâmetros podem ter um valor padrão, como o exemplo _borda&lt;em&gt;arredondada&lt;/em&gt; abaixo (6px), que será utilizado caso nenhum parâmetro seja passado.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.titulo(@azul){
    color: @azul;
    border: 1px dotted @azul;
}

.borda_arredondada(@radius: 6px){
    border-radius: @radius;
    -moz-border-radius: @radius;
    -webkit-border-radius: @radius;
}

.thumbnail{
    background: #ccc;
    .borda_arredondada(10px);
}

.foto_materia{
    background: #000;
    padding: 4px;
    .borda_arredondada;
}
&lt;/pre&gt;

&lt;h2 id=&#34;regra-dentro-de-regra-dentro-de-regra-8230&#34;&gt;Regra dentro de regra dentro de regra&amp;#8230;&lt;/h2&gt;

&lt;p&gt;Alguns desenvolvedores já aplicam essa técnica visualmente. No entanto, com LESS, as regras aninhadas também herdam os valores de seus &amp;#8220;pais&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;#menu {
    letter-spacing: -2px;
    color: @azul;

    .item {
        padding: 2px;
        margin: 2px;
    
        &amp;.inactive {
            color: #666;
        }

        &amp;:hover {
            color: red;
        }
    
    }

}
&lt;/pre&gt;

&lt;p&gt;Note o símbolo &amp;#8220;&amp;amp;&amp;#8221; que representa a concatenação. O elemento não herda simplesmente os atributos de seu antecessor, ele também sobrescreve o novo valor. Essa regra é importantíssima para pseudo-elementos como :hover, :focus etc.&lt;/p&gt;

&lt;h2 id=&#34;operações&#34;&gt;Operações&lt;/h2&gt;

&lt;p&gt;O LESS também permite operações com valores e cores. Por exemplo, é possível multiplicar uma cor hexa-decimal ou dividir uma certa quantidade em pixels.&lt;/p&gt;

&lt;p&gt;As funções de cores englobam efeitos como dessaturação e fade.&lt;/p&gt;

&lt;p&gt;Para valores compostos, como o border do div#conteudo abaixo, é obrigatório o uso de parênteses.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@borda_padrao: 6px;
@cor_padrao: #111;

div#conteudo {
    color: @cor_padrao * 2;
    border: (@borda_padrao / 3) solid #ccc;
}

div#menu { 
    color: darken(@cor_padrao, 10%);
}
&lt;/pre&gt;

&lt;p&gt;Na [documentação oficial do LESS][1] você encontra uma lista completa das funções para cores.&lt;/p&gt;

&lt;h2 id=&#34;escopo-namespace&#34;&gt;Escopo &amp;amp; Namespace&lt;/h2&gt;

&lt;p&gt;Para quem já programa, os conceitos explicados até agora são familiares. O LESS nada mais é do que um framework que transforma o CSS em uma pseudo linguagem de programação.&lt;/p&gt;

&lt;p&gt;Escopo é outro conceito importante em programação que também está presente no LESS.&lt;/p&gt;

&lt;p&gt;Uma variável possui um escopo global e outro local, dentro de sua função/mixin. O LESS vai sempre procurar primeiro por varáveis no escopo local e depois em seus antecessores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@variavel: 1px;

div#conteudo {
    @variavel: 2px;
    div#titulo {
        border-size: @variavel;
    }
}

div#menu {
    border-size: @variavel;
}
&lt;/pre&gt;

&lt;p&gt;Você também pode reutilizar apenas uma parte de um mixin aplicando um namespace para encapsular seu código.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;#titulo {
    .principal {
        font-size: 36px;
        letter-spacing: -2px;
    }
    .secundario {
        font-size: 24px;
        letter-spacing: -1.4px;
    }
}

#header h1 {
    color: #df0d32;
    #titulo &amp;gt; .principal;
}
&lt;/pre&gt;

&lt;p&gt;O h1 do elemento #header herda apenas o .principal do #titulo.&lt;/p&gt;

&lt;h2 id=&#34;implementações&#34;&gt;Implementações&lt;/h2&gt;

&lt;p&gt;A implementação do LESS pode ser feita &lt;em&gt;on the fly&lt;/em&gt;, com JavaScript. Esse método é recomendado para sites pequenos, com pouca audiência. Para sites mais visitados, pré-processe seus arquivos LESS, transformando-os em folhas de estilo estáticas.&lt;/p&gt;

&lt;p&gt;Por exemplo, para aplicativos Ruby/Rails existe uma [gem][2] que converte arquivos LESS para CSS. Já o o módulo &lt;em&gt;compressor&lt;/em&gt; do Django oferece suporte nativo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tableless.com.br/wp-content/uploads/2011/09/less.jpg&#34; alt=&#34;Screenshot do aplicativo LESS para Mac OS&#34; width=&#34;620&#34; height=&#34;354&#34; class=&#34;aligncenter size-full wp-image-4535&#34; srcset=&#34;uploads/2011/09/less.jpg 620w, uploads/2011/09/less-300x171.jpg 300w&#34; sizes=&#34;(max-width: 620px) 100vw, 620px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Outra solução bacana é o [aplicativo LESS para Mac][3].&lt;/p&gt;

&lt;p&gt;E se você procura elementos básicos já prontos, a dica é visitar o site [Less Elements][4]. Nele você encontra soluções para bordas, degradês e sombras.&lt;/p&gt;

&lt;p&gt;[1]: &lt;a href=&#34;http://lesscss.org/#-color-functions&#34;&gt;http://lesscss.org/#-color-functions&lt;/a&gt; &amp;ldquo;&amp;rdquo;
 [2]: &lt;a href=&#34;http://rubygems.org/gems/less&#34;&gt;http://rubygems.org/gems/less&lt;/a&gt; &amp;ldquo;&amp;rdquo;
 [3]: &lt;a href=&#34;http://incident57.com/less/&#34;&gt;http://incident57.com/less/&lt;/a&gt; &amp;ldquo;&amp;rdquo;
 [4]: &lt;a href=&#34;http://lesselements.com/&#34;&gt;http://lesselements.com/&lt;/a&gt; &amp;ldquo;&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>