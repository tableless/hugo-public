<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Otimização on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/otimiza%C3%A7%C3%A3o/index.xml</link>
    <description>Recent content in Otimização on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/otimiza%C3%A7%C3%A3o/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Otimize a performance do seu site com o Kraken</title>
      <link>https://tableless.github.io/hugo-public/otimize-performance-seu-site-com-o-kraken/</link>
      <pubDate>Tue, 14 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/otimize-performance-seu-site-com-o-kraken/</guid>
      <description>

&lt;p&gt;Quando o assunto é performance, você ainda pode ter muita dor de cabeça. É comum muitos sites e aplicações web terem a sua experiência deformada por problemas na performance. Há tempos procuramos métodos para otimizar nossos sites, tais como concatenação de arquivos para diminuir as requisições HTTP, minificar CSS, JavaScript e até mesmo HTML. Entre várias outras técnicas. Porém, cada vez mais essas técnicas não conseguem acompanhar os novos recursos que sempre estão surgindo para deixar nossos sites cada vez mais impressionantes. E pesados.&lt;/p&gt;

&lt;p&gt;Quando o assunto é front-end, um dos grandes vilões para uma boa performance ainda são as imagens, já que a maior parte do tráfego de seu site vem delas. Não é difícil ver uma única imagem com o tamanho superior à todo código que é carregado em uma determinada página. Tentamos contornar esse dilema usando SVG nas iconografias, fazer gradientes e elementos de interface complexos usando apenas CSS. Mas isso ainda não nos deixam isentos do uso de imagens em jpeg, gif e png, e do peso delas.&lt;/p&gt;

&lt;h3 id=&#34;conheça-o-kraken&#34;&gt;Conheça o Kraken&lt;/h3&gt;

&lt;p&gt;Como é impossível ter um site sem imagens, o que podemos fazer é amenizar o impacto delas na performance. Então aí que eu lhes apresento o Kraken.&lt;/p&gt;

&lt;p&gt;O Kraken é uma ferramenta poderosa que conta com um motor de compressão de imagens super eficiente. Eu por exemplo já tive imagens com 99% do seu tamanho reduzido. E o melhor de tudo, sem nenhum impacto na qualidade visual.&lt;/p&gt;

&lt;p&gt;E é exatamente isso que o Kraken promete, e onde ele se destaca. Não uma mera diminuição no tamanho do arquivo, mas sim que isso aconteça garantindo que não haverá perdas na qualidade visual da imagem. Como no exemplo abaixo:&lt;/p&gt;

&lt;div style=&#34;width: 766px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img class=&#34;&#34; src=&#34;http://s29.postimg.org/kh32i0mg7/kraken_before_and_after.jpg&#34; alt=&#34;Kraken&#34; width=&#34;756&#34; height=&#34;205&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Kraken antes e depois
  &lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&#34;minha-experiência-com-o-kraken&#34;&gt;Minha experiência com o Kraken&lt;/h3&gt;

&lt;p&gt;Sempre usei o plugin imagemin do grunt. Mas nunca tive resultados expressivos. Até que, por recomendação de um amigo, eu conheci o Kraken e realmente fiquei impressionado com os seus resultados. Mas além de contar histórias, vou demonstrar o uso prático da aplicação.&lt;/p&gt;

&lt;p&gt;No meu site pessoal, na página portfolio, há uma listagem dos meus projetos e suas respectivas capas. 90% dessa página é composta por imagens e notei que estava levando muito tempo para carregar por conta dessas imagens. Então eu testei otimizar cada uma delas para ver o resultado. Antes vale lembrar que eu fiz essas imagens pelo Photoshop, e elas foram salvas no formato png no modo smallest/slow, que garante uma compressão maior. Mas será que é o suficiente? Vamos ver logo abaixo:&lt;/p&gt;

&lt;div style=&#34;width: 760px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img class=&#34;&#34; src=&#34;http://s12.postimg.org/j3s0bu43h/compress_o.png&#34; alt=&#34;compressão&#34; width=&#34;750&#34; height=&#34;305&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    compressão
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Nessa brincadeira, eu poupei 1.84MB de carregamento em minha página, isso remete a 85.39% a menos do tamanho total de todas as imagens juntas. É um ganho e tanto, não?&lt;/p&gt;

&lt;p&gt;Agora vamos ver o impacto disso na página em questão:&lt;/p&gt;

&lt;p&gt;Antes:&lt;/p&gt;

&lt;div style=&#34;width: 557px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img class=&#34;&#34; src=&#34;http://s30.postimg.org/6l234x6cx/kraken_antes.jpg&#34; alt=&#34;Antes&#34; width=&#34;547&#34; height=&#34;52&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Antes
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Depois&lt;/p&gt;

&lt;div style=&#34;width: 562px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img class=&#34;&#34; src=&#34;http://s30.postimg.org/wun5npsa9/kraken_depois.jpg&#34; alt=&#34;depois&#34; width=&#34;552&#34; height=&#34;51&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    depois
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Lembrando que em ambos os carregamentos o cache foi limpo.&lt;/p&gt;

&lt;p&gt;E sobre a qualidade. Gostaria que você mesmo fizesse esse teste com a imagem de sua preferência.&lt;/p&gt;

&lt;h3 id=&#34;ok-quero-usar&#34;&gt;Ok, quero usar!&lt;/h3&gt;

&lt;p&gt;Infelizmente nada que funciona tão bem é de graça. O Kraken possui vários tipos de planos, com pagamento mensal ou anual.&lt;/p&gt;

&lt;p&gt;Mas também há também o modo gratuito, com algumas limitações, é claro. No modo gratuito você não terá acesso a recursos como a API deles, Plugin para WordPress entre outros. Mas talvez o que vá mais lhe incomodar é o limite de 1MB por imagem.&lt;/p&gt;

&lt;p&gt;Eu pessoalmente, uso apenas o modo gratuito e não tenho muitos problemas. Geralmente quando eu lido com imagens acima de 1MB, eu recorro a uma outra alternativa que citarei logo abaixo.&lt;/p&gt;

&lt;h3 id=&#34;uma-alternativa-interessante&#34;&gt;Uma alternativa interessante&lt;/h3&gt;

&lt;p&gt;Também há uma ferramenta chamada Compressor.io, ela tem a mesma finalidade do Kraken mas é 100% gratuito. Ela se demonstra tão eficiente quanto, e eu já até tive imagens que a compressão foi maior no Compressor.io do que no Kraken, como podem ver abaixo:&lt;/p&gt;

&lt;p&gt;No Kraken:&lt;/p&gt;

&lt;div style=&#34;width: 898px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img class=&#34;&#34; src=&#34;http://s10.postimg.org/okddqy9gp/compressao_no_kraken.png&#34; alt=&#34;Kraken&#34; width=&#34;888&#34; height=&#34;93&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Kraken
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;No Compressor:&lt;/p&gt;

&lt;div style=&#34;width: 838px&#34; class=&#34;wp-caption alignnone&#34;&gt;
  &lt;img class=&#34;&#34; src=&#34;http://s10.postimg.org/h346bqjxl/compressao_no_compressor.png&#34; alt=&#34;Compressor&#34; width=&#34;828&#34; height=&#34;57&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Compressor
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Tudo bem que nesse exemplo não se tratou de uma imagem grande. Nesse caso eu usei a imagem que se tornou a capa desse artigo. Mas demonstra que mesmo tratando-se de uma aplicação gratuita, se mostra tão competente quanto. (Não me perguntem o por que em cada ferramenta a imagem foi identificada com o tamanho original diferente. Mas é a mesma imagem, eu juro! )&lt;/p&gt;

&lt;p&gt;O único problema é que o Compressor.io só permite você otimizar uma imagem por vez, e isso pode tornar as coisas meio trabalhosas dependendo da quantidade de imagens que você precisa tratar. Também não há tantos recursos quanto o Kraken tem caso você esteja disposto a pagar pelo serviço.&lt;/p&gt;

&lt;p&gt;Caso você tenha várias imagens com menos de 1MB e algumas imagens com mais, você poderá usar o melhor de cada ferramenta para conseguir atingir a otimização de performance que você deseja para seu site, gratuitamente!&lt;/p&gt;

&lt;p&gt;&lt;a title=&#34;Kraken&#34; href=&#34;http://kraken.io&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://kraken.io&#34;&gt;http://kraken.io&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a title=&#34;Compressor&#34; href=&#34;http://compressor.io&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://compressor.io&#34;&gt;http://compressor.io&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Agora é com vocês!&lt;/p&gt;

&lt;p&gt;Não esqueça de deixar seu comentário abaixo! Já conhecia o Kraken? Começou a usar depois desse artigo? Conhece outras alternativas? Compartilhe conosco!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>jQuery: dicas de otimização e performance</title>
      <link>https://tableless.github.io/hugo-public/jquery-dicas-de-otimizacao-e-performance/</link>
      <pubDate>Tue, 10 Jan 2012 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/jquery-dicas-de-otimizacao-e-performance/</guid>
      <description>

&lt;p&gt;A grande maioria dos desenvolvedores jQuery não se preocupa muito com performance e otimização. Afinal, o mantra do framework, &amp;#8220;write less, do more&amp;#8221;, envolve esconder a parte feia do Javascript e, muitas vezes, acrescentar camadas desnecessárias.&lt;/p&gt;

&lt;p&gt;Neste artigo apresento algumas dicas de como melhorar a performance de sua aplicação jQuery. No entanto, vale lembrar que não é necessário otimizar nenhum código escrito previamente, já que a otimização dificilmente compensará o trabalho.&lt;/p&gt;

&lt;h2 id=&#34;1-mantenha-se-atualizado&#34;&gt;#1: Mantenha-se atualizado&lt;/h2&gt;

&lt;p&gt;Procure utilizar sempre a última versão estável do jQuery. A cada nova versão lançada são introduzidas inúmeras melhorias de performance nos métodos do framework.&lt;/p&gt;

&lt;p&gt;Da versão 1.3 para a 1.4, por exemplo, houve um ganho de 50% na performance da execução dos testes padrão do jQuery.&lt;/p&gt;

&lt;p&gt;Fique ligado nas mudanças. O lançamento de uma nova versão vem sempre acompanhando de notas sobre as novas funcionalidades, um changelog, como [este aqui][1].&lt;/p&gt;

&lt;h2 id=&#34;2-não-utilize-jquery&#34;&gt;#2: Não utilize jQuery!&lt;/h2&gt;

&lt;p&gt;Em alguns momentos não é necessário utilizar jQuery. Apesar de ser fácil de utilizar e muito mais bonito de ler, o framework é apenas mais uma camada no desenvolvimento, uma &amp;#8220;maquiagem&amp;#8221; para o Javascript.&lt;/p&gt;

&lt;p&gt;Em projetos pequenos você pode, se quiser, abolir totalmente o jQuery: é realmente necessário incluir os ~30kb do framework? Não dá pra resolver com Javascript puro?&lt;/p&gt;

&lt;p&gt;Já em projetos maiores, mesmo incluindo o jQuery, em alguns casos é melhor não utilizá-lo. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;size: function() {
    return this.length;
},
&lt;/pre&gt;

&lt;p&gt;Acima está o código-fonte do método size, do jQuery. O que ele faz? Nada além de retornar o tamanho do objeto utilizando o método nativo length. Logo, é mais rápido utilizar diretamente o length!&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;$(&#39;.menu&#39;).size()
$(&#39;.menu&#39;).length
&lt;/pre&gt;

&lt;p&gt;O mesmo vale para retornar o ID de um elemento:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;$(this).attr(&#39;id&#39;)
this.id
&lt;/pre&gt;

&lt;p&gt;O seletor $(this), aliás, somente deve ser utilizado quando for necessário um método que só existe no jQuery. Nos outros casos, sempre dê preferência ao this nativo do Javascript.&lt;/p&gt;

&lt;p&gt;Também é comum utilizar jQuery para alterar o CSS de um elemento, por exemplo:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;$(&#39;#menu&#39;).css(&#39;display&#39;, &#39;block&#39;);
&lt;/pre&gt;

&lt;p&gt;Olhando o &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/css.js#L121&#34;&gt;código-fonte&lt;/a&gt; do jQuery, o método .css() possui aproximadamente 20 linhas (sem contar outros métodos chamados). A atribuição acima poderia ser executada da seguinte forma, com uma única linha:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;document.getElementById(&#39;menu&#39;).style.display = &#39;block&#39;;
&lt;/pre&gt;

&lt;p&gt;Os próprios métodos jQuery possuem camadas dentro do framework. Ao invés de utilizar o método $.getJSON, por exemplo, você pode chamar diretamente o método $.ajax com os parâmetros type: &amp;#8216;GET&amp;#8217; e dataType: &amp;#8216;json&amp;#8217;.&lt;/p&gt;

&lt;p&gt;Vale a pena dar uma olhada no [código-fonte][3] do jQuery para entender o que o framework faz por baixo dos panos e até que ponto é válido utilizá-lo.&lt;/p&gt;

&lt;h2 id=&#34;3-seletores&#34;&gt;#3: Seletores&lt;/h2&gt;

&lt;p&gt;Procure sempre ser o mais específico possível em um seletor. Quanto mais específico, mais rápido. Opte sempre por utilizar o ID do elemento. Mesmo quando for preciso utilizar uma classe no seletor, utilize o ID do elemento pai.&lt;/p&gt;

&lt;p&gt;Os seletores que utilizam o ID ou a tag de um elemento são mais rápidos por um simples motivo: ambos utilizam métodos nativos do Javascript document.getElementbyId() e document.getElementsByTagname().&lt;/p&gt;

&lt;p&gt;Evite utilizar seletores com atributos e/ou pseudo-seletores, a menos que seja extremamente necessário.&lt;/p&gt;

&lt;p&gt;Outra dica importante: dê preferência ao método .find() quando precisar achar elementos filhos de um elemento com ID. Por exemplo, ao invés de $(&amp;#8216;#container p&amp;#8217;) utilize $(&amp;#8216;#container&amp;#8217;).find(&amp;#8216;p&amp;#8217;), dessa forma o escopo da busca fica limitado ao primeiro objeto. O mesmo vale para seletores de classes e pseudo-seletores.&lt;/p&gt;

&lt;h2 id=&#34;4-cache-de-elementos&#34;&gt;#4: Cache de elementos&lt;/h2&gt;

&lt;p&gt;Esta é uma dica simples, mas que pode adicionar ganhos de performance consideráveis. Procure sempre armazenar em uma variável o objeto jQuery retornado por um seletor, principalmente quando o seletor está dentro de um loop.&lt;/p&gt;

&lt;p&gt;Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;var menu = $(&#39;#menu&#39;);
var itens = [&#39;Home&#39;, &#39;Contato&#39;, &#39;Sobre&#39;];
for(x in itens)
    menu.append(&#39;

&lt;li&gt;
  &#39;+itens[x]+&#39;
&lt;/li&gt;&#39;);
&lt;/pre&gt;

&lt;p&gt;Ao invés de:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;var itens = [&#39;Home&#39;, &#39;Contato&#39;, &#39;Sobre&#39;];
for(x in itens)
    $(&#39;#menu&#39;).append(&#39;

&lt;li&gt;
  &#39;+itens[x]+&#39;
&lt;/li&gt;&#39;);
&lt;/pre&gt;

&lt;p&gt;No exemplo acima, o seletor $(&amp;#8216;#menu&amp;#8217;) seria executado 3 vezes, ou seja, o elemento seria buscado no DOM três vezes seguidas, sem nenhuma alteração.&lt;/p&gt;

&lt;p&gt;Conforme citei na abertura do artigo, cachear seletores é uma prática que vai contra o &amp;#8220;write less, do more&amp;#8221; do jQuery. Seu código pode ficar um pouco mais &amp;#8220;sujo&amp;#8221;, mas, em contrapartida, fica também mais rápido.&lt;/p&gt;

&lt;h2 id=&#34;5-encadeamento-de-métodos&#34;&gt;#5: Encadeamento de métodos&lt;/h2&gt;

&lt;p&gt;Encadear métodos sempre foi uma das funcionalidades mais legais do jQuery e, se você ainda não faz uso dessa técnica, é por aqui que você deve começar.&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;$(&#39;#container&#39;).addClass(&#39;corpo&#39;);
$(&#39;#container&#39;).width(940);
$(&#39;#container&#39;).height(300);
&lt;/pre&gt;

&lt;p&gt;Vira:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;$(&#39;#container&#39;).addClass(&#39;corpo&#39;)
               .width(940)
               .height(300);
&lt;/pre&gt;

&lt;p&gt;Quase todos os métodos e plugins retornam (ou deveriam retornar) um objeto jQuery. Além de melhorar a leitura, essa prática também afeta diretamente a performance do seu código já que o seletor só é executado uma única vez.&lt;/p&gt;

&lt;h2 id=&#34;6-dom&#34;&gt;#6: DOM&lt;/h2&gt;

&lt;p&gt;Qualquer tipo de manipulação no DOM envolve um processo bem lento. No geral, você deve fugir desse tipo de implementação, principalmente se ela não possuir nenhum tipo de cache.&lt;/p&gt;

&lt;p&gt;O ideal é manipular já com os dados finais e completos. Não manipule o DOM em um loop, por exemplo.&lt;/p&gt;

&lt;p&gt;Utilizando o exemplo da dica de caching, poderíamos alterar para ficar ainda mais otimizado:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;var menu = $(&#39;#menu&#39;);
var itens = [&#39;Home&#39;, &#39;Contato&#39;, &#39;Sobre&#39;];
var html = &#39;&#39;;
for(x in itens){
    html += &#39;

&lt;li&gt;
  &#39;+itens[x]+&#39;
&lt;/li&gt;&#39;;
}
menu.append(html);
menu.show();
&lt;/pre&gt;

&lt;p&gt;Repare que o método .append() foi chamado apenas uma vez, já recebendo o HTML completo concatenado.&lt;/p&gt;

&lt;h2 id=&#34;7-dry-don-8217-t-repeat-yourself&#34;&gt;#7: DRY (Don&amp;#8217;t Repeat Yourself)&lt;/h2&gt;

&lt;p&gt;O jQuery disponibiliza um alto nível de personalização, permitindo que você [escreva seus seletores][4] e [seus plugins][5].&lt;/p&gt;

&lt;p&gt;Evite repetir blocos de código. Evite repetir seletores. Evite repetir manipulações no DOM (faça tudo o que precisa fazer uma única vez!). Esta é uma dica muito importante para performance, já que qualquer código repetido significa alguns bytes ou kbytes a mais na sua aplicação.&lt;/p&gt;

&lt;p&gt;Mathias Bynens disponibilizou um &lt;a href=&#34;http://speakerdeck.com/u/mathiasbynens/p/faster-javascript-execution-for-the-lazy-developer&#34;&gt;uma apresentação genial&lt;/a&gt; sobre DRY e Javascript, vale a pena conferir.&lt;/p&gt;

&lt;h2 id=&#34;como-medir-a-performance-da-sua-aplicação&#34;&gt;Como medir a performance da sua aplicação?&lt;/h2&gt;

&lt;p&gt;O site &lt;a href=&#34;http://jsperf.com/&#34;&gt;jsPerf&lt;/a&gt; permite a criação de testes de performance para códigos javascript, utilizando jQuery ou não. É um bom lugar para você começar a comparar diferentes tipos de implementação. &lt;a href=&#34;http://www.slideshare.net/mathiasbynens/using-jsperf-correctly&#34;&gt;Esta apresentação&lt;/a&gt; dá dicas e ensina a utilizar a ferramenta.&lt;/p&gt;

&lt;p&gt;Você também pode (e deve) utilizar a aba profile do Firebug e/ou do Chrome Developer Tools. &lt;a href=&#34;http://michaelsync.net/2007/09/10/firebug-tutorial-logging-profiling-and-commandline-part-ii&#34;&gt;Aqui&lt;/a&gt; tem um tutorial antigo, mas bacana, sobre o Firebug e &lt;a href=&#34;http://www.youtube.com/watch?v=OxW1dCjOstE&#34;&gt;aqui&lt;/a&gt; você encontra um tutorial sobre o Chrome Developer Tools.&lt;/p&gt;

&lt;p&gt;[1]: &lt;a href=&#34;http://blog.jquery.com/2011/11/21/jquery-1-7-1-released/&#34;&gt;http://blog.jquery.com/2011/11/21/jquery-1-7-1-released/&lt;/a&gt; &amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;[3]: &lt;a href=&#34;https://github.com/jquery/jquery&#34;&gt;https://github.com/jquery/jquery&lt;/a&gt; &amp;ldquo;&amp;rdquo;
 [4]: &lt;a href=&#34;http://tableless.com.br/jquery-seletores-personalizados/&#34;&gt;http://tableless.com.br/jquery-seletores-personalizados/&lt;/a&gt; &amp;ldquo;&amp;rdquo;
 [5]: &lt;a href=&#34;http://tableless.com.br/anatomia-de-um-plugin-jquery/&#34;&gt;http://tableless.com.br/anatomia-de-um-plugin-jquery/&lt;/a&gt; &amp;ldquo;&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Performance do seu CSS</title>
      <link>https://tableless.github.io/hugo-public/melhorando-performance-css/</link>
      <pubDate>Tue, 29 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/melhorando-performance-css/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/modulando-o-css&#34;&gt;Modular seu código CSS&lt;/a&gt; é uma boa prática para que o website carregue apenas o código necessário para montar a pagina que o visitante está. Por isso não precisamos carregar o código CSS que monta a página de contato uma vez que o usuário está na home, possibilitando um ganho de performance.&lt;/p&gt;

&lt;p&gt;Podemos ainda melhorar um pouco mais nossa performance tendo atenção com a forma que escrevemos os seletores do CSS. Há algumas dicas que podemos seguir para que isso seja possível.&lt;/p&gt;

&lt;p&gt;O seletor é a alma do CSS. É com ele que o browser procura e captura o elemento que você deseja formatar. Existem diversos seletores que possibilitam a captura de elementos em diversos cenários e necessidades. Com a atualizações dos browsers em relação a padronização do CSS 2.1 e do CSS 3, os desenvolvedores ganharam novos ferramentas e formas de capturar elementos.&lt;/p&gt;

&lt;p&gt;Quero que você entenda que essas dicas são sugestões. Não seja um purista cabeça dura. Seja flexível e tolerante com alguns cenários que podem surgir durante o projeto. É bom sempre procurar o meio termo entre performance e velocidade de produção.&lt;/p&gt;

&lt;p&gt;Outro ponto para pensar é que a má performance do CSS pode significar muito pouco perto de outros fatores como servidor, performance server-side, peso de imagens e outros fatores. Por isso é importante que você tenha em mente que fazendo as sugestões abaixo não é garantia de que seu site ficará super ultra rápido. =^)&lt;/p&gt;

&lt;h3 id=&#34;processo-de-leitura&#34;&gt;Processo de leitura&lt;/h3&gt;

&lt;p&gt;O browser segue um processo de leitura muito fácil de ser entendido.&lt;/p&gt;

&lt;p&gt;Todo o seletorer (se voce não sabe o que é um seletor de CSS, recomendo que leia &lt;a href=&#34;http://tableless.com.br/seletores-complexos-do-css?utm_source=Artigo%2BSeletores%2BPerformance&amp;amp;utm_medium=Artigo%2Btableless&amp;amp;utm_campaign=seletores%2Bperformance&#34;&gt;isto&lt;/a&gt; e &lt;a href=&#34;http://tableless.com.br/seletores-agrupados-e-encadeados?utm_source=Artigo%2BSeletores%2BPerformance&amp;amp;utm_medium=Artigo%2Btableless&amp;amp;utm_campaign=seletores%2Bperformance&#34;&gt;isto&lt;/a&gt; antes de continuar).&lt;/p&gt;

&lt;p&gt;O sistema de leitura consiste em encontrar o elemento da extrema direita do seletor. Logo a leitura do seletor começa da direita para a esquerda. A medida que o browser lê o seletor, ele vai encontrando os elementos e só pára quando há um erro no seletor ou não encontra o elemento.&lt;/p&gt;

&lt;p&gt;Tenha como exemplo este seletor:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;ul li a {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;Nesse primeiro momento, ao ler o elemento da direita, o browser seleciona TODOS os elementos &lt;strong&gt;A&lt;/strong&gt; da página, independente se ele está ou não dentro de um &lt;strong&gt;LI&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;“The style system matches a rule by starting with the rightmost selector and moving to the left through the rule’s selectors. As long as your little subtree continues to check out, the style system will continue moving to the left until it either matches the rule or bails out because of a mismatch.” – David Hyatt&lt;/p&gt;

&lt;h3 id=&#34;não-use-ids-ou-classes-ligados-a-tags&#34;&gt;Não use IDs ou Classes ligados a tags&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;EVITE&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;div.content {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;div#geral {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RECOMENDADO&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;.content {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;#geral {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;h3 id=&#34;tente-especificar-os-elementos&#34;&gt;Tente especificar os elementos&lt;/h3&gt;

&lt;p&gt;Sempre que puder tente especificar os elementos com IDs ou Classes em vez de escrever seletores longos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EVITE&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;nav#menu ul li a {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RECOMENDADO&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;.menuitem {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;Eu não gosto muito desta sugestão porque teríamos de colocar uma classe &amp;#8220;menuitem&amp;#8221; em cada um dos ítens do menu. O HTML ficaria horrível. Prefiro fazer como abaixo. Não é a melhor forma (como eu cito no próximo tópico), mas é um meio termo entre performance, flexibilidade e produção de código:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;#menu a {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;h3 id=&#34;não-misture-ids-com-nomes-de-tags-e-classes&#34;&gt;Não misture IDs com nomes de tags e classes&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;EVITE&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;button#botaoverde {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;.menu#menuPrincipal {…}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RECOMENDADO&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;#botaoverde {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;#menuPrincipal {…}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;h3 id=&#34;não-coloque-nomes-de-tags-nos-nomes-de-classes&#34;&gt;Não coloque nomes de tags nos nomes de classes&lt;/h3&gt;

&lt;p&gt;Muita gente relaciona o nome da tag ao nome da class ou id do CSS. Essa prática pode confundir posteriormente tanto na manutenção quanto no processo de produção por pelo menos dois motivos: &lt;strong&gt;1.&lt;/strong&gt; Você pode atribuir essa classe a elementos diferentes e não somente aquele que você relacionou no nome. &lt;strong&gt;2.&lt;/strong&gt; A classe pode fazer muito mais do que estava descrito inicialmente.&lt;/p&gt;

&lt;p&gt;Por isso é interessante que cada nome de Classe seja ÚNICA e não seja relacionada a nenhum elemento em específico.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EVITE&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;li.selected {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Bom, mas não muito&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;.liselected {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RECOMENDADO&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;.selected {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;h3 id=&#34;evite-seletores-filhos&#34;&gt;Evite seletores filhos&lt;/h3&gt;

&lt;p&gt;Sempre tente evitar declarar hierarquia nos seletores. Sempre que puder, coloque o nome do elemento diretamente por meio de class ou id. Mesmo assim tenha em mente a limpeza do seu HTML. Se você já aplicou boa parte dessas sugestões no resto do site, você pode abrir mão em alguns lugares que poderão ser úteis como na criação de um menu.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EVITE&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;section form#cadastro fieldset label input.Text {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RECOMENDADO&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;input[type=&amp;#8221;text&amp;#8221;] {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;h3 id=&#34;evite-seletores-descendentes&#34;&gt;Evite seletores descendentes&lt;/h3&gt;

&lt;p&gt;Os seletores descendentes são os seletores tem menos performance no CSS.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EVITE&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;section article h1 {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;É bom, mas nem tanto&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;section &amp;gt; article &amp;gt; h1 {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RECOMENDADO&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;[cc lang=&amp;#8221;CSS&amp;#8221;]&lt;/p&gt;

&lt;p&gt;.tituloh1 {&amp;#8230;}&lt;/p&gt;

&lt;p&gt;[/cc]&lt;/p&gt;

&lt;p&gt;Claro que é muito complexo colocar uma classe nos títulos do site, ainda mais se os títulos são gerados por outras pessoas. Por isso prefiro, dependendo do site, dependendo do cliente, dependendo de como eu acordar de manhã, utilizar a primeira sugestão, que está marcada para EVITAR. Lembre-se ache o meio termo.&lt;/p&gt;

&lt;h4 id=&#34;referências&#34;&gt;Referências:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.archive.jpsykes.com/152/testing-css-performance-pt-2/&#34; rel=&#34;external&#34;&gt;Testing CSS Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.stevesouders.com/blog/2009/06/18/simplifying-css-selectors/&#34; rel=&#34;external&#34;&gt;Simplifying CSS Selectors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://css-tricks.com/more-on-css-selector-performance/&#34; rel=&#34;external&#34;&gt;More on CSS Selector Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/en/Writing_Efficient_CSS&#34; rel=&#34;external&#34;&gt;Wrinting Efficient CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>