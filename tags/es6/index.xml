<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es6 on Tableless</title>
    <link>http://tableless.com.br/tags/es6/index.xml</link>
    <description>Recent content in Es6 on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="http://tableless.com.br/tags/es6/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Criando a sua primeira aplicação web com React</title>
      <link>http://tableless.com.br/criando-sua-primeira-aplicacao-web-com-react/</link>
      <pubDate>Fri, 17 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/criando-sua-primeira-aplicacao-web-com-react/</guid>
      <description>

&lt;p&gt;Você já deve ter ouvido falar do React, a biblioteca JS mais popular da atualidade, usado por várias empresas grandes como Facebook, Airbnb e Twitter. A ideia desse artigo é demonstrar a criação de uma aplicação simples, que use as principais partes do React. Neste tutorial nós iremos ver:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Componentes&lt;/li&gt;
&lt;li&gt;Componentes puros/funcionais&lt;/li&gt;
&lt;li&gt;O uso do &lt;em&gt;state&lt;/em&gt; vs &lt;em&gt;props&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Todos os exemplos deste tutorial serão escritos em ES6. Se você não sabe ES6 &lt;a href=&#34;https://github.com/ldaltro/guia-basico-ES6&#34;&gt;leia esse artigo antes&lt;/a&gt;. Se você é impaciente demais para isso considere que:&lt;/p&gt;

&lt;p&gt;ES6:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;const foo = 42; // const declara uma constante
let bar = 5; // let declara uma variável
&lt;/pre&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;const soma = (a, b) =&amp;gt; a + b;
ou 
const soma = (a, b) =&amp;gt; { return a + b; };
&lt;/pre&gt;

&lt;p&gt;ES5:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var soma = function (a, b) {
  return a + b;
};
&lt;/pre&gt;

&lt;p&gt;ES6:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;import React from &#39;react&#39;;
&lt;/pre&gt;

&lt;p&gt;ES5:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var React = require(&#39;react&#39;);
&lt;/pre&gt;

&lt;p&gt;ES6:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;class MeuComponente extends React.Component {
  render() {
    return ();
  }
} 
&lt;/pre&gt;

&lt;p&gt;ES5:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var MeuComponente = React.createClass({
  render: function(){
    return ();
  }
});&lt;/pre&gt;

&lt;p&gt;Outro pré-requisito para o tutorial é ter o &lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt; instalado na sua máquina. Se você ainda não fez isso, clique &lt;a href=&#34;https://nodejs.org/en/download/&#34;&gt;aqui&lt;/a&gt; e siga as instruções, dependendo do seu sistema operacional.&lt;/p&gt;

&lt;h2 id=&#34;afinal-o-que-é-react&#34;&gt;Afinal, o que é React?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;React&lt;/strong&gt; é uma biblioteca criada pelo Facebook em 2013 com o objetivo de tornar o desenvolvimento de &lt;em&gt;Single Page Applications&lt;/em&gt; (SPAs) mais fácil. A biblioteca se baseia em alguns conceitos como:&lt;/p&gt;

&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;

&lt;p&gt;Uma aplicação React é dividida em componentes, ou seja, pequenos pedaços de código responsáveis por alguma parte da UI. Um componente ideal é independente e reutilizável, capaz de retornar a resposta esperada usando apenas dados genéricos enviados por outras partes da aplicação.&lt;/p&gt;

&lt;p&gt;Um exemplo de componente React interessante pode ser visto &lt;a href=&#34;https://github.com/tomchentw/react-google-maps&#34;&gt;nessa biblioteca de mapas&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&amp;lt;&lt;span class=&#34;pl-ent&#34;&gt;&lt;span class=&#34;pl-c1&#34;&gt;GoogleMap&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&#34;pl-e&#34;&gt;ref&lt;/span&gt;&lt;span class=&#34;pl-k&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;pl-s1&#34;&gt;&lt;span class=&#34;pl-smi&#34;&gt;props&lt;/span&gt;&lt;span class=&#34;pl-k&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;pl-smi&#34;&gt;onMapLoad&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;pl-e&#34;&gt;defaultZoom&lt;/span&gt;&lt;span class=&#34;pl-k&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;pl-s1&#34;&gt;&lt;span class=&#34;pl-c1&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;pl-e&#34;&gt;defaultCenter&lt;/span&gt;&lt;span class=&#34;pl-k&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;pl-s1&#34;&gt;{&lt;span class=&#34;pl-c1&#34;&gt; &lt;span class=&#34;pl-s&#34;&gt;lat&lt;/span&gt;:&lt;/span&gt; &lt;span class=&#34;pl-c1&#34;&gt;-25.363882&lt;/span&gt;,&lt;span class=&#34;pl-c1&#34;&gt; &lt;span class=&#34;pl-s&#34;&gt;lng&lt;/span&gt;:&lt;/span&gt; &lt;span class=&#34;pl-c1&#34;&gt;131.044922&lt;/span&gt; }&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;pl-e&#34;&gt;onClick&lt;/span&gt;&lt;span class=&#34;pl-k&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;pl-s1&#34;&gt;&lt;span class=&#34;pl-smi&#34;&gt;props&lt;/span&gt;&lt;span class=&#34;pl-k&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;pl-smi&#34;&gt;onMapClick&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;pl-pse&#34;&gt;}&lt;/span&gt;
  &amp;gt;
&amp;lt;/&lt;span class=&#34;pl-ent&#34;&gt;&lt;span class=&#34;pl-c1&#34;&gt;GoogleMap&lt;/span&gt;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Graças ao componentes do React, podemos importar um mapa do Google Maps e usá-lo como se fosse uma tag nativa de HTML, passando apenas as propriedades que nós queremos no componente, como &lt;em&gt;defaultZoom&lt;/em&gt; e &lt;em&gt;defaultCenter&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;jsx&#34;&gt;JSX&lt;/h3&gt;

&lt;p&gt;Em React nós não usamos HTML, toda a marcação é feita no JavaScript, com uma sintaxe baseada em XML chamada JSX. A ideia pode parecer bem maluca no começo mas vai fazer sentido assim que você começar a escrever os seus próprios componentes. JSX parece bastante com HTML mas existem algumas diferenças como:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Todas as tags devem ser fechadas&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Podemos colocar expressões JavaScript dentro do JSX usando {}. Ex.: &lt;pre class=&#34;lang-javascript&#34;&gt;function ola() {
return &amp;ldquo;ola&amp;rdquo;;
}
&amp;lt;p&amp;gt;{2 + 2}&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;{ola()}&amp;lt;/p&amp;gt;&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Como o JSX fica dentro de arquivos &amp;#8216;.js&amp;#8217; a palavra &lt;em&gt;class&lt;/em&gt; não pode ser usada. Em seu lugar, devemos usar &lt;em&gt;className&lt;/em&gt;. Ex.: &lt;pre class=&#34;lang-javascript&#34;&gt;&amp;lt;h1 className=&amp;ldquo;titulo&amp;rdquo;&amp;gt;Olá!&amp;lt;/h1&amp;gt;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por debaixo dos panos, usamos o &lt;strong&gt;Babel&lt;/strong&gt; para converter o JSX em funções comuns de JavaScript, logo, esse código:&lt;/p&gt;

&lt;pre&gt;&amp;lt;div&amp;gt;Olá mundo&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Fica assim:&lt;/p&gt;

&lt;pre&gt;&lt;span class=&#34;nx&#34;&gt;React&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;createElement&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&#39;div&#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &#34;Olá mundo&#34;&lt;span class=&#34;p&#34;&gt;);
&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Leia mais sobre JSX &lt;a href=&#34;https://facebook.github.io/react/docs/introducing-jsx.html&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;virtual-dom&#34;&gt;Virtual DOM&lt;/h3&gt;

&lt;p&gt;Para evitar updates custosos e desnecessários, o React não escreve as alterações diretamente na DOM. Ao invés disso, a biblioteca cria uma cópia da árvore de componentes em memória e esta cópia (Virtual DOM) é quem recebe os updates primeiro. Depois que a Virtual DOM é atualizada o React calcula a maneira mais eficiente de atualizar a árvore DOM real usando um algoritmo de &lt;em&gt;diffing.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;pondo-a-mão-na-massa&#34;&gt;Pondo a mão na massa&lt;/h2&gt;

&lt;p&gt;Ok, chega de tanta teoria, vamos por a mão na massa! Abra o seu terminal e vamos instalar um pacote que vai nos ajudar a criar nossas aplicações o &lt;strong&gt;&lt;a href=&#34;https://github.com/facebookincubator/create-react-app&#34;&gt;create-react-app&lt;/a&gt;:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;npm install create-react-app&lt;/pre&gt;

&lt;p&gt;Montar um ambiente de desenvolvimento capaz de suportar React costumava ser uma tarefa complicada (&lt;a href=&#34;https://tableless.com.br/hello-world-com-react-do-rascunho-ate-o-primeiro-componente/&#34;&gt;esse tutorial do Diego Eis explica muito bem a criação de um ambiente &amp;#8220;na mão&amp;#8221;&lt;/a&gt;). Por causa disso, o Facebook inventou um pacote chamado &lt;em&gt;create-react-app&lt;/em&gt;, que cria um ambiente com tudo o que nós precisamos para começar o nosso projeto (React, ES6 e webpack).&lt;/p&gt;

&lt;p&gt;Depois de instalar o pacote, vamos criar um novo projeto. No terminal digite:&lt;/p&gt;

&lt;pre class=&#34;p1&#34;&gt;&lt;span class=&#34;s1&#34;&gt;create-react-app vamos-aprender-react&lt;/span&gt;&lt;/pre&gt;

&lt;p&gt;Depois de alguns minutos todas as dependências estão instaladas e &lt;em&gt;voilà!&lt;/em&gt; Temos um projeto pronto para ser criado.&lt;/p&gt;

&lt;p&gt;Com o terminal do diretório do seu projeto digite:&lt;/p&gt;

&lt;pre&gt;npm start&lt;/pre&gt;

&lt;p&gt;Se tudo deu certo, o seu browser em &lt;em&gt;&lt;a href=&#34;http://localhost:3000/&#34;&gt;http://localhost:3000/&lt;/a&gt;&lt;/em&gt; deve estar assim:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-57013 size-full&#34; src=&#34;uploads/2017/01/Captura-de-Tela-2017-01-22-às-19.29.35.png&#34; alt=&#34;Imagem ilustrativa do create-react-app&#34; width=&#34;1438&#34; height=&#34;748&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Parabéns! Você acabou de criar a sua primeira aplicação com React! Vamos dar uma olhada no que foi gerado:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-57015 size-full&#34; src=&#34;uploads/2017/01/Captura-de-Tela-2017-01-22-às-19.34.30.png&#34; alt=&#34;Estrutura de pastas do create-react-app&#34; width=&#34;232&#34; height=&#34;415&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Como podemos ver, a pastar &lt;em&gt;src&lt;/em&gt; contém todos os nosso componentes React. Dentro de &lt;em&gt;src&lt;/em&gt; abra o arquivo &lt;em&gt;index.js&lt;/em&gt;, ele deve conter algo desse tipo:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./App&#39;;
import &#39;./index.css&#39;;

ReactDOM.render(
 &amp;lt;App /&amp;gt;,
 document.getElementById(&#39;root&#39;)
);
&lt;/pre&gt;

&lt;p&gt;O index.js é o arquivo principal da nossa aplicação, ele é responsável por colocar o nosso componente principal (App) no elemento &lt;em&gt;root&lt;/em&gt; da nossa página. &lt;em&gt;Root&lt;/em&gt; é uma div que está dentro do único arquivo .html do projeto (public/index.html). Toda a nossa aplicação vai ser escrita dentro dessa div root.&lt;/p&gt;

&lt;h3 id=&#34;criando-nosso-primeiro-componente&#34;&gt;Criando nosso primeiro componente&lt;/h3&gt;

&lt;p&gt;Abra o arquivo &lt;em&gt;App.js&lt;/em&gt;, ele é o primeiro componente da nossa árvore. Dentro dele podemos ver o JSX usado para renderizar a tela de boas vindas do &lt;em&gt;create-react-app&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&amp;lt;div className=&#34;App&#34;&amp;gt;
 &amp;lt;div className=&#34;App-header&#34;&amp;gt;
 &amp;lt;img src={logo} className=&#34;App-logo&#34; alt=&#34;logo&#34; /&amp;gt;
 &amp;lt;h2&amp;gt;Welcome to React&amp;lt;/h2&amp;gt;
 &amp;lt;/div&amp;gt;
 &amp;lt;p className=&#34;App-intro&#34;&amp;gt;
 To get started, edit &amp;lt;code&amp;gt;src/App.js&amp;lt;/code&amp;gt; and save to reload.
 &amp;lt;/p&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Note que todo esse código está dentro de um método chamado &lt;em&gt;render&lt;/em&gt; na classe &lt;em&gt;App&lt;/em&gt; que é filha da classe de &lt;em&gt;React.Component&lt;/em&gt;. &lt;em&gt;Render&lt;/em&gt; é responsável por dizer ao React o que deve ser renderizado, todo componente precisa de um método &lt;em&gt;render&lt;/em&gt; para exibir alguma coisa.&lt;/p&gt;

&lt;p&gt;Substitua o método &lt;em&gt;render&lt;/em&gt; por:&lt;/p&gt;

&lt;pre&gt;render() {
 return &amp;lt;HelloWorld/&amp;gt;;
 }&lt;/pre&gt;

&lt;p&gt;Se tentarmos rodar o projeto, veremos o seguinte erro:&lt;/p&gt;

&lt;pre&gt;7:13 error &#39;HelloWorld&#39; is not defined react/jsx-no-undef 
&lt;/pre&gt;

&lt;p&gt;Isso acontece porque estamos tentando usar um component (HelloWorld) que ainda não foi definido. Vamos resolver isso criando um arquivo chamado HelloWorld.js dentro da pastar &lt;em&gt;src&lt;/em&gt;. Dentro de HelloWorld coloque:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;

export default class HelloWorld extends React.Component {
 render() {
 return &amp;lt;p&amp;gt;Olá mundo!&amp;lt;/p&amp;gt;;
 }
}&lt;/pre&gt;

&lt;p&gt;Esse código cria um componente React chamado HelloWorld e implementa o método &lt;em&gt;render&lt;/em&gt; que retorna um parágrafo com &lt;strong&gt;olá mundo&lt;/strong&gt;. Depois disso vamos importar nosso novo componente em App.js:&lt;/p&gt;

&lt;pre&gt;import React, { Component } from &#39;react&#39;;
import logo from &#39;./logo.svg&#39;;
import &#39;./App.css&#39;;

import HelloWorld from &#39;./HelloWorld&#39;;// nosso primeiro componente React!

class App extends Component {
 render() {
 return &amp;lt;HelloWorld/&amp;gt;;
 }
}

export default App;&lt;/pre&gt;

&lt;p&gt;Agora abrindo o browser em &lt;em&gt;&lt;a href=&#34;http://localhost:3000/&#34;&gt;http://localhost:3000/&lt;/a&gt;&lt;/em&gt; vemos:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-57018 size-full&#34; src=&#34;uploads/2017/01/Captura-de-Tela-2017-01-22-às-20.00.26.png&#34; alt=&#34;Exemplo de Hello World&#34; width=&#34;1439&#34; height=&#34;723&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ótimo! Nós acabamos de criar nosso primeiro React Component \o/. Mas ele não faz lá muita coisa não é mesmo? Vamos tentar fazer esse componente ser mais customizável.&lt;/p&gt;

&lt;h2 id=&#34;criando-componentes-genéricos-com-props&#34;&gt;Criando componentes genéricos com Props&lt;/h2&gt;

&lt;p&gt;E se nós quiséssemos exibir o nome de uma pessoa na mensagem do nosso HelloWorld? Obviamente poderíamos fazer algo do tipo:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;

export default class HelloWorld extends React.Component {
 render() {
 return &amp;lt;p&amp;gt;Olá Lucas!&amp;lt;/p&amp;gt;;
 }
}&lt;/pre&gt;

&lt;p&gt;Mas e se for necessário escrever novos nomes? Criar um componente novo para cada pessoa não parece uma ideia muito inteligente&amp;#8230; lembra do exemplo do Google Maps mostrado na introdução? No exemplo, nós passávamos dados para um componente como se fosse uma tag HTML. Vamos fazer a mesma coisa para o nosso HelloWorld! Mude App.js para:&lt;/p&gt;

&lt;pre&gt;import React, { Component } from &#39;react&#39;;
import logo from &#39;./logo.svg&#39;;
import &#39;./App.css&#39;;

import HelloWorld from &#39;./HelloWorld&#39;;// nosso primeiro componente React!

class App extends Component {
 render() {
 return &amp;lt;div&amp;gt;
 &amp;lt;HelloWorld nome=&#34;Lucas&#34;/&amp;gt;
 &amp;lt;HelloWorld nome=&#34;Tableless&#34;/&amp;gt;
 &amp;lt;HelloWorld nome=&#34;Leitor&#34;/&amp;gt;
 &amp;lt;/div&amp;gt;;
 }
}

export default App;&lt;/pre&gt;

&lt;p&gt;Veja que dessa vez nós tivemos que colocar o HelloWorld dentro de uma div, isso acontece porque o método &lt;em&gt;render&lt;/em&gt; deve sempre retornar apenas um elemento, &lt;strong&gt;sempre que tiver que renderizar mais de um elemento no seu componente, coloque tudo dentro de uma div&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Agora nós temos que fazer com que o componente HelloWorld leia o valor dado em nome. Isso pode ser feito facilmente usando o objeto &lt;strong&gt;props&lt;/strong&gt; presente em todo componente React. Veja como HelloWorld.js vai ficar agora:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;

export default class HelloWorld extends React.Component {
 render() {
 return &amp;lt;p&amp;gt;Olá {this.props.nome}!&amp;lt;/p&amp;gt;;
 }
}

HelloWorld.propTypes = {
 nome: React.PropTypes.string.isRequired
}&lt;/pre&gt;

&lt;p&gt;Tudo que for passado de um componente para outro é adicionado ao objeto &lt;em&gt;props&lt;/em&gt;, podendo ser acessado dentro do componente. Nós também usamos a propriedade &lt;em&gt;propTypes&lt;/em&gt; para informar ao React que a _prop_ &amp;#8216;nome&amp;#8217; é uma &lt;em&gt;string&lt;/em&gt; e que essa &lt;em&gt;string&lt;/em&gt; é obrigatória para o funcionamento do componente (&lt;em&gt;isRequired&lt;/em&gt;). Você não é obrigado a usar &lt;em&gt;propTypes&lt;/em&gt; nos seus componentes, mas é interessante fazer isso, já que elas facilitam a documentação do seu código e podem reduzir erros.&lt;/p&gt;

&lt;p&gt;Agora nós temos um componente muito mais genérico:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone wp-image-57023 size-full&#34; src=&#34;uploads/2017/01/Captura-de-Tela-2017-01-22-às-20.18.28.png&#34; alt=&#34;Exemplo de Componente React&#34; width=&#34;181&#34; height=&#34;193&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Props&lt;/em&gt; são algo crucial para os componentes React, já que com elas nós podemos fazer com que o nosso componente seja reutilizado até mesmo em outra aplicação. Mas devemos sempre ter em mente que _props_ são imutáveis, uma vez definida a _prop_ &amp;#8216;nome&amp;#8217;, uma instância de HelloWorld não pode mais ser alterada. Ex.:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;

export default class HelloWorld extends React.Component {
 render() {
 this.props.nome = &#34;Fulano&#34;; // ERRO Cannot assign to read only property &#39;nome&#39; of object &#39;#&amp;lt;Object&amp;gt;&#39;
 return &amp;lt;p&amp;gt;Olá {this.props.nome}!&amp;lt;/p&amp;gt;;
 }
}

HelloWorld.propTypes = {
 nome: React.PropTypes.string.isRequired
}&lt;/pre&gt;

&lt;h3 id=&#34;componente-8220-puro-8221-ou-stateless&#34;&gt;Componente &amp;#8220;puro&amp;#8221; ou &lt;em&gt;stateless&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Nosso componente HelloWorld é bastante simples e utiliza apenas &lt;em&gt;props&lt;/em&gt;, por causa disso ele pode ser escrito de uma forma melhor, utilizando uma &lt;a href=&#34;https://en.wikipedia.org/wiki/Pure_function&#34;&gt;função pura&lt;/a&gt;. Veja como fica o nosso componente em forma de função:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;; const HelloWorld = (props) =&amp;gt; &amp;lt;p&amp;gt;Olá {props.nome}!&amp;lt;/p&amp;gt;;&lt;/pre&gt;

&lt;pre&gt;HelloWorld.propTypes = { nome: React.PropTypes.string.isRequired } export default HelloWorld;&lt;/pre&gt;

&lt;p&gt;Veja que dessa vez o componente é basicamente escrito em apenas uma linha (&lt;strong&gt;const HelloWorld = (props) =&amp;gt; &lt;p&gt;Olá {props.nome}!&lt;/p&gt;;&lt;/strong&gt;). Esse é o React Component ideal! Simples, reutilizável e escrito em apenas uma função! Tente criar seus componentes dessa maneira, ao invés de ter um componente complexo e grande, crie vários componentes menores e simples, isso vai melhorar bastante a qualidade do seu projeto.&lt;/p&gt;

&lt;p&gt;Para comprovar que o nosso componente é realmente reutilizável vamos usá-lo em uma lista de nomes. Volte para App.js e digite:&lt;/p&gt;

&lt;pre&gt;import React, { Component } from &#39;react&#39;;
import logo from &#39;./logo.svg&#39;;
import &#39;./App.css&#39;;

import HelloWorld from &#39;./HelloWorld&#39;;// nosso primeiro componente React!

class App extends Component {
 render() {
 const nomes = [&#34;Lucas&#34;, &#34;Tableless&#34;, &#34;Leitor&#34;, &#34;Maria&#34;, &#34;João&#34;, &#34;Ana&#34;];
 return &amp;lt;div&amp;gt;
 {nomes.map((n, i) =&amp;gt; &amp;lt;HelloWorld nome={n} key={i}/&amp;gt;)}
 &amp;lt;/div&amp;gt;;
 }
}

export default App;
&lt;/pre&gt;

&lt;p&gt;Perceba que nós temos uma mudança aqui, para exibir nomes do nosso &lt;em&gt;array&lt;/em&gt; nós usamos a &lt;a href=&#34;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map&#34;&gt;função map&lt;/a&gt;, já que ela retorna uma expressão JavaScript (além de ter uma sintaxe mais legal que a do o laço for :P) e passamos uma nova &lt;em&gt;prop&lt;/em&gt; chamada &lt;em&gt;&lt;strong&gt;key&lt;/strong&gt;&lt;/em&gt; para o nosso componente. &lt;em&gt;Keys&lt;/em&gt; ajudam o React a identificar qual elemento foi adicionado/removido de uma lista/array (&lt;a href=&#34;https://facebook.github.io/react/docs/lists-and-keys.html&#34;&gt;mais informações sobre o assunto aqui&lt;/a&gt;). Uma &lt;em&gt;Key&lt;/em&gt; deve sempre ser um valor &lt;strong&gt;único&lt;/strong&gt; ou poderemos ter problemas de performance. Evite usar o índice do seu &lt;em&gt;loop&lt;/em&gt; como &lt;em&gt;key&lt;/em&gt; em aplicações reais (como fizemos no exemplo acima), tente usar números realmente únicos como um ID vindo de um backend. Leia mais sobre isso &lt;a href=&#34;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318#.4nmajnqsa&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;componentes-interativos-com-state&#34;&gt;Componentes interativos com state&lt;/h2&gt;

&lt;p&gt;Como visto anteriormente &lt;em&gt;props&lt;/em&gt; são imutáveis, componentes feitos apenas com &lt;em&gt;props&lt;/em&gt; não podem por exemplo, ser atualizados baseados em uma ordem do usuário. Para representar o estado mutável do seu componente usamos a propriedade &lt;strong&gt;&lt;em&gt;state&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Para ilustrar o uso de &lt;em&gt;state&lt;/em&gt; no nosso elemento vamos fazer um novo componente e chamá-lo de &lt;strong&gt;ContaClick.js&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;

export default class ContaClick extends React.Component {
 constructor() {
 super();
 this.state = {
 clicks: 0
 }
 }

 render() {
 return &amp;lt;div&amp;gt;&amp;lt;p&amp;gt;{this.state.clicks}&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;
 }
}

&lt;/pre&gt;

&lt;p&gt;No construtor da classe ContaClick nós definimos o estado inicial do nosso componente: um contador de clicks que começa em 0. Vamos adicionar um botão para atualizar o contador:&lt;/p&gt;

&lt;pre&gt;import React from &#39;react&#39;;

export default class ContaClick extends React.Component {
 constructor() {
 super();
 this.state = {
 clicks: 0
 }
 }

 clicou = () =&amp;gt; this.setState({clicks: this.state.clicks + 1});
 
 render() {
 return &amp;lt;div&amp;gt;
 &amp;lt;p&amp;gt;{this.state.clicks}&amp;lt;/p&amp;gt;
 &amp;lt;button onClick={this.clicou}&amp;gt;Clica aqui!&amp;lt;/button&amp;gt;
 &amp;lt;/div&amp;gt;
 }
}
&lt;/pre&gt;

&lt;p&gt;No código acima nós criamos um botão embaixo do exibidor de cliques que chama o método &lt;em&gt;&lt;strong&gt;clicou&lt;/strong&gt;&lt;/em&gt; sempre que o evento onClick é disparado. O método &lt;em&gt;&lt;strong&gt;clicou&lt;/strong&gt;&lt;/em&gt; substitui o objeto &lt;em&gt;state&lt;/em&gt; do componente ContaClick por um objeto novo com clicks incrementados em uma unidade. Veja que nós atualizamos o &lt;em&gt;state&lt;/em&gt; usando a função &lt;em&gt;setState&lt;/em&gt;. &lt;strong&gt;NUNCA atualize o objeto _state_ manualmente&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Agora vamos colocar o nosso componente &lt;em&gt;ContaClick&lt;/em&gt; em &lt;em&gt;app&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;import React, { Component } from &#39;react&#39;;
import logo from &#39;./logo.svg&#39;;
import &#39;./App.css&#39;;

import HelloWorld from &#39;./HelloWorld&#39;;// nosso primeiro componente React!
import ContaClick from &#39;./ContaClick&#39;;

class App extends Component {
 render() {
 const nomes = [&#34;Lucas&#34;, &#34;Tableless&#34;, &#34;Leitor&#34;, &#34;Maria&#34;, &#34;João&#34;, &#34;Ana&#34;];
 return &amp;lt;div&amp;gt;
 {nomes.map((n, i) =&amp;gt; &amp;lt;HelloWorld nome={n} key={i}/&amp;gt;)}
 &amp;lt;ContaClick /&amp;gt;
 &amp;lt;/div&amp;gt;;
 }
}

export default App;
&lt;/pre&gt;

&lt;p&gt;Pronto! Rodando a aplicação podemos usar o contador e ver que ele é atualizado a cada clique!&lt;/p&gt;

&lt;p&gt;Até a próxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Trabalhando com serviços no Javascript</title>
      <link>http://tableless.com.br/trabalhando-com-servicos-no-javascript/</link>
      <pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/trabalhando-com-servicos-no-javascript/</guid>
      <description>

&lt;p&gt;JavaScript é uma &lt;em&gt;linguagem multiparadigma&lt;/em&gt;. Pode-se “_emular_” várias técnicas de programação com ele, e isso é &lt;strong&gt;incrível&lt;/strong&gt; pois podemos decidir qual o melhor paradigma para a resolução dos problemas dos nossos projetos. Porém se por um lado isso pode parecer poderoso para a linguagem, também pode deixar os iniciantes bem confusos, é muito comum escolher a abordagem errada para o problema. Por esse motivo que o JavaScript em sido polêmico nos últimos anos.&lt;/p&gt;

&lt;p&gt;Pensando nisso muitos desenvolvedores criam suas próprias soluções, uns pensando em ajudar e outros em forçar padrões.&lt;/p&gt;

&lt;p&gt;Eu prefiro ensinar a pescar, pois JavaScript não tem que ser complexo. A &lt;strong&gt;versão 6 do JavaScript (ES6/ES2015)&lt;/strong&gt; tornou a linguagem muito mais expressiva, facilitando muito o entendimento.&lt;/p&gt;

&lt;h3 id=&#34;encapsulando-lógicas&#34;&gt;Encapsulando lógicas&lt;/h3&gt;

&lt;p&gt;Tudo em JavaScript são objetos (exceto &lt;em&gt;undefined&lt;/em&gt;), então &lt;strong&gt;serviços também são objetos&lt;/strong&gt;, dominando como criamos e trabalhamos com objetos todas as coisas ficam bem mais tranquilas.&lt;/p&gt;

&lt;p&gt;O Jean Carlo Emer fez um artigo muito, &lt;a href=&#34;http://tableless.com.br/modularizacao-em-javascript/&#34;&gt;mas muito bom sobre Modularização no JavaScript&lt;/a&gt;. Sugiro que você leia, mas vou explicar um pouco sobre o assunto logo abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;size-medium aligncenter&#34; src=&#34;https://cdn-images-1.medium.com/max/800/1*hsXIPyBqqI7ZTh2QyLfizw.gif&#34; alt=&#34;i know JavaScript basics &#34; width=&#34;320&#34; height=&#34;237&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;scope-e-closures&#34;&gt;Scope e Closures&lt;/h4&gt;

&lt;p&gt;JavaScript possui escopo léxico. Entre outras coisas isso permite que você crie &lt;em&gt;closures&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;De maneira resumida você cria um “ambiente controlado” onde há funções/variáveis que só podem ser acessadas naquele escopo, criando um enclausuramento (&lt;em&gt;closure&lt;/em&gt;).&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;const initPage = (root) =&amp;gt; {
  const $root = $(root);
  const $menu = $root.find(&#39;.menu&#39;);
  const $profile = $menu.find(&#39;.profile&#39;);

  const initProfile = () =&amp;gt; {
    $.get(&#39;/me&#39;)
      .then(response =&amp;gt; $profile.text(response.username));
    // ...
  };

  const showProfileModal = e =&amp;gt; {
   // ...
  };

  $profile.on(&#39;click&#39;, e =&amp;gt; showProfileModal(e));

  initProfile();
};

initPage(&#39;body&#39;);
&lt;/pre&gt;

&lt;p&gt;Este é um exemplo bem bobo, mas que ilustra bem como criamos &lt;em&gt;closures&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;As variáveis declaradas dentro de &lt;em&gt;initPage&lt;/em&gt; só existem naquele escopo.&lt;/p&gt;

&lt;p&gt;No mesmo exemplo podemos refatorar esse código em uma &lt;strong&gt;IIFE (Immediately-Invoked Function Expression)&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;((root) =&amp;gt; {
  const $root = $(root);
  const $menu = $root.find(&#39;.menu&#39;);
  const $profile = $menu.find(&#39;.profile&#39;);

  const initProfile = () =&amp;gt; {
    $.get(&#39;/me&#39;)
     .then(response =&amp;gt; $profile.text(response.username));
    //  ...
  };

  const showProfileModal = e =&amp;gt; {
    // ...
  };

  $profile.on(&#39;click&#39;, e =&amp;gt; showProfileModal(e));

  initProfile();
})(&#39;body&#39;);
&lt;/pre&gt;

&lt;p&gt;Nesse código declaramos uma função e a executamos imediatamente, passando um argumento. Isso é extremamente útil quando queremos fazer um processamento de uma informação que vai servir apenas para criar uma variável.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;const timezones = (() =&amp;gt; {
  const zones = [];
  const min = -12;
  const max = 13;
  let simbol;

  for (let i = min; i &amp;lt;= max; i++) {
    simbol = (i &amp;lt; 0) ? &#39;&#39; : &#39;+&#39;;
    zones.push(`GMT${simbol}${i}`);
  }

  return zones;
})();
&lt;/pre&gt;

&lt;p&gt;Como você já pode perceber, é possível expor dados de uma &lt;em&gt;closure&lt;/em&gt; como no exemplo anterior. A variável zones é retornada, assim a variável &lt;em&gt;timezones&lt;/em&gt; agora possui como valor o resultado da &lt;em&gt;closure&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nesse exemplo a &lt;em&gt;closure&lt;/em&gt; não usa dados externos a ela (&lt;em&gt;parent scope&lt;/em&gt;/escopo pai) porém dada a natureza do JavaScript isso é perfeitamente possível.&lt;/p&gt;

&lt;p&gt;Isso é útil para não poluir o escopo principal com informações irrelevantes.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;const makeCounter = (start = 0) =&amp;gt; {
  let current = start;

  const add = (value = 1) =&amp;gt; current += value;
  const remove = (value = 1) =&amp;gt; add(value * -1);
  const get = () =&amp;gt; current;

  return { add, remove, get };
};

const counter = makeCounter(10);

counter.add() // 11
counter.add() // 12
counter.add(8) // 20
counter.remove(10) // 10
&lt;/pre&gt;

&lt;p&gt;Este é um exemplo bem interessante. Estamos combinando &lt;em&gt;closures&lt;/em&gt; com &lt;em&gt;factory&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com isso podemos criar vários contadores, e trabalhar como melhor convir com estes contadores.&lt;/p&gt;

&lt;div id=&#34;attachment_56186&#34; style=&#34;width: 510px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;wp-image-56186 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2016/10/wtf.gif&#34; alt=&#34;Só isso! Simples, né?&#34; width=&#34;500&#34; height=&#34;284&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Só isso! Simples, né?
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Se você entendeu como o exemplo do contador funciona, parabéns você já sabe criar serviços com javascript.&lt;/p&gt;

&lt;p&gt;Isso mesmo, este contator é um serviço. Na verdade ele é um &lt;em&gt;factory&lt;/em&gt;, mas com pequenos ajustes ele vira um serviço de fácil reuso.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// makeCounter.js -&amp;gt; factory
const makeCounter = (start = 0) =&amp;gt; {
  let current = start;

  const add = (value = 1) =&amp;gt; current += value;
  const remove = (value = 1) =&amp;gt; add(value * -1);
  const get = () =&amp;gt; current;

  return { add, remove, get };
};

export default makeCounter
&lt;/pre&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// counter.js -&amp;gt; service
import makeCounter from &#39;./makeCounter.js&#39;;

export default makeCounter(0);
&lt;/pre&gt;

&lt;p&gt;Agora temos dois arquivos, um contendo o &lt;em&gt;factory&lt;/em&gt; do contador, e outro contendo o serviço de contagem.&lt;/p&gt;

&lt;h2 id=&#34;módulos-javascript&#34;&gt;Módulos JavaScript&lt;/h2&gt;

&lt;p&gt;&lt;img class=&#34;size-full wp-image-56185 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2016/10/module.gif&#34; alt=&#34;module&#34; width=&#34;400&#34; height=&#34;250&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Como visto anteriormente, é bem simples criar serviços com JavaScript, basta antes entender alguns conceitos.&lt;/p&gt;

&lt;p&gt;Porém isso não é tudo, se você esta criando um serviço é porque tem a intenção de reusar esta lógica em mais de um local da aplicação. Isto não é uma regra, talvez você queira apenas centralizar a lógica da operação.&lt;/p&gt;

&lt;p&gt;Não importa o objetivo inicial, você vai acabar criando um módulo JavaScript para aquela sua operação/serviço. No exemplo do contador foram criados dois arquivos, o &lt;em&gt;contador&lt;/em&gt; e o &lt;em&gt;factory do contador&lt;/em&gt;. Nesse momento você precisa entender minimamente o que são módulos JavaScript.&lt;/p&gt;

&lt;p&gt;Em resumo: um arquivo JavaScript é um módulo e um módulo JavaScript é um arquivo.&lt;/p&gt;

&lt;p&gt;Você pode criar um módulo a partir de outros módulos, como é o exemplo do contador, ele é composto a partir do módulo &lt;em&gt;makeCouter&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Em geral a lógica dos módulo é encapsulada em &lt;em&gt;closures&lt;/em&gt; e o retorno delas é &lt;em&gt;cacheado&lt;/em&gt;, sendo assim, uma vez que você importa um módulo, ele será &lt;strong&gt;o mesmo sempre, compartilhando seu estado&lt;/strong&gt;. Saiba mais &lt;a href=&#34;http://www.vuejs-brasil.com.br/utilizando-vuex-na-forma-modular-2/#vamosentenderoqueaconteceu&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;usando-serviços&#34;&gt;Usando serviços&lt;/h3&gt;

&lt;p&gt;Agora que você possui essas informações acredito que criar seus próprios serviços não será nenhum &lt;em&gt;bicho de sete cabeças&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Vale a pena dizer que tudo pode ser considerado um serviço, inclusive &lt;em&gt;factories&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para reforçar vou deixar mais um exemplo de uso de serviços.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;import Http from &#39;./http.js&#39;;
import UsersService from &#39;./modules/users/service.js&#39;;

Http.setToken(&#39;XPTO&#39;); // Define o token de autentificação

// Cattega a primeira página de usuários
// Exibe um alerta com o nome do primeiro usuário retornado pelo serviço

UsersService
  .getAll({ page: 1 })
  .then(result =&amp;gt; result.data)
  .then(data =&amp;gt; data[0])
  .then(first =&amp;gt; {
    alert(first.name);
  });
&lt;/pre&gt;

&lt;p&gt;Para efeito de aprendizado uma sintaxe alternativa, com &lt;a href=&#34;https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Statements/import&#34;&gt;&lt;em&gt;import binding&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;import { setToken } from &#39;./http.js&#39;;
import { getAll as getAllUsers } from &#39;./modules/users/service.js&#39;;

setToken(&#39;XPTO&#39;); // Define o token de autentificação

// Carrega a primeira página de usuários
// Exibe um alerta com o nome do primeiro usuário retornado pelo serviço

getAllUsers({ page: 1 })
  .then(result =&amp;gt; result.data)
  .then(data =&amp;gt; data[0])
  .then(first =&amp;gt; {
    alert(first.name);
  });
&lt;/pre&gt;

&lt;p&gt;Este pode não parecer para alguns mas é um exemplo bem prático do uso de serviços.&lt;/p&gt;

&lt;p&gt;O serviço de &lt;em&gt;Http&lt;/em&gt; também é usado pelo &lt;em&gt;serviço de usuários&lt;/em&gt;, por isso é possível definir o &lt;strong&gt;&lt;em&gt;token&lt;/em&gt;&lt;/strong&gt; de autentificação antes de efetivamente usar os serviços, pois eles vão compartilhar o mesmo estado/serviço.&lt;/p&gt;

&lt;p&gt;Outra característica interessante é que esses serviços não estão ligados diretamente a nenhum contexto. Isso significa que não importa que ambiente você esteja ou que &lt;em&gt;framework&lt;/em&gt; você esta usando, os serviços são agnósticos. Eles podem ser usados no &lt;strong&gt;NodeJS, VueJS, ReactJS&lt;/strong&gt;, etc.&lt;/p&gt;

&lt;p&gt;Este é um dos princípios do polimorfismos do JavaScript porém este é outro assunto.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Se quiser saber mais sobre meu trabalho visite meu blog&lt;a href=&#34;https://medium.com/@luizvinicius73&#34;&gt; https://medium.com/@luizvinicius73&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Este artigo foi originalmente postado no meu &lt;a href=&#34;https://medium.com/by-vinicius-reis/trabalhando-com-servicos-no-javascript-864310cf386c&#34;&gt;blog no medium&lt;/a&gt; em 31 de Julho de 2016&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Entendendo o async e o await em JavaScript</title>
      <link>http://tableless.com.br/entendendo-o-async-e-o-await-em-javascript/</link>
      <pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/entendendo-o-async-e-o-await-em-javascript/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;As funcionalidades &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; não conseguiram chegar para o ES6, mas isso não significa que elas não irão chegar ao JavaScript. Enquanto escrevo esse post, ela é uma proposta na &lt;a href=&#34;https://github.com/tc39/ecma262/tree/82bebe057c9fca355cfbfeb36be8e42f18c61e94&#34; target=&#34;_blank&#34;&gt;fase 3&lt;/a&gt; e está sendo trabalhada ativamente. As funcionalidades já estão no &lt;a href=&#34;https://blogs.windows.com/msedgedev/2015/09/30/asynchronous-code-gets-easier-with-es2016-async-function-support-in-chakra-and-microsoft-edge/&#34; target=&#34;_blank&#34;&gt;Edge&lt;/a&gt; e devem chegar a outros browsers assim que chegar na &lt;a href=&#34;https://twitter.com/bterlson/status/692464374842290176&#34; target=&#34;_blank&#34;&gt;fase 4&lt;/a&gt; &amp;#8211; pavimentando seu caminho para inclusão na próxima edição da linguagem (veja também: &lt;a href=&#34;https://tc39.github.io/process-document/&#34; target=&#34;_blank&#34;&gt;Processo TC39&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;utilizando-promises&#34;&gt;Utilizando Promises&lt;/h2&gt;

&lt;p&gt;Vamos supor que tenhamos o código abaixo. Aqui eu estou encapsulando uma chamada &lt;code&gt;HTTP&lt;/code&gt; em uma &lt;code&gt;Promise&lt;/code&gt;. A promise executa o &lt;code&gt;body&lt;/code&gt; caso haja sucesso e é rejeitada com um &lt;code&gt;err&lt;/code&gt; caso contrário. Ela puxa o HTML de um artigo aleatório &lt;a href=&#34;https://ponyfoo.com/&#34; target=&#34;_blank&#34;&gt;desse blog&lt;/a&gt; toda vez que é executada.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var request = require(&#39;request&#39;);

function getRandomPonyFooArticle () {
  return new Promise((resolve, reject) =&amp;gt; {
    request(&#39;https://ponyfoo.com/articles/random&#39;, (err, res, body) =&amp;gt; {
      if (err) {
        reject(err); return;
      }
      resolve(body);
    });
  });
}
&lt;/pre&gt;

&lt;p&gt;Uma utilização típica da promise mostrada anteriormente está no código abaixo. Nele nós construímos um encadeamento de promises transformando o HTML da página em Markdown de um subconjunto de seu DOM e então imprimimos de forma amigável no terminal utilizando um &lt;code&gt;console.log&lt;/code&gt;. Sempre lembre de adicionar um &lt;code&gt;.catch&lt;/code&gt; para suas promises.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var hget = require(&#39;hget&#39;);
var marked = require(&#39;marked&#39;);
var Term = require(&#39;marked-terminal&#39;);

printRandomArticle();

function printRandomArticle () {
  getRandomPonyFooArticle()
    .then(html =&amp;gt; hget(html, {
      markdown: true,
      root: &#39;main&#39;,
      ignore: &#39;.at-subscribe,.mm-comments,.de-sidebar&#39;
    }))
    .then(md =&amp;gt; marked(md, {
      renderer: new Term()
    }))
    .then(txt =&amp;gt; console.log(txt))
    .catch(reason =&amp;gt; console.error(reason));
}
&lt;/pre&gt;

&lt;p&gt;Esse código foi “melhor que utilizar callbacks” quando se trata da sensação de como foi ler o código sequencialmente.&lt;/p&gt;

&lt;h2 id=&#34;usando-generators&#34;&gt;Usando generators&lt;/h2&gt;

&lt;p&gt;Nós já exploramos os generators como uma forma de deixar o html disponível de uma maneira sintética e síncrona &lt;a href=&#34;https://ponyfoo.com/articles/es6-generators-in-depth&#34; target=&#34;_blank&#34;&gt;no passado&lt;/a&gt;. Mesmo que o código agora seja um pouco síncrono, existe um pouco de encapsulamento envolvido, e generators podem não ser a melhor maneira de chegar aos resultados que queremos, então vamos continuar utilizando Promises.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function getRandomPonyFooArticle (gen) {
  var g = gen();
  request(&#39;https://ponyfoo.com/articles/random&#39;, (err, res, body) =&amp;gt; {
    if (err) {
      g.throw(err); return;
    }
    g.next(body);
  });
}

getRandomPonyFooArticle(function* printRandomArticle () {
  var html = yield;
  var md = hget(html, {
    markdown: true,
    root: &#39;main&#39;,
    ignore: &#39;.at-subscribe,.mm-comments,.de-sidebar&#39;
  });
  var txt = marked(md, {
    renderer: new Term()
  });
  console.log(txt);
});
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Lembre-se que você deve encapsular a chamada ao yield em um bloco try / catch para preservar o tratamento de erros que adicionamos quando usamos promises.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nem precisamos falar que usar generators dessa maneira não permite que escalemos bem nossas aplicações. Além de envolver uma sintaxe não intuitiva nessa mistura, seu código iterador será altamente acoplado ao generator que está sendo consumido. Isso faz com que você terá de modificar ele toda vez que uma nova expressão de &lt;code&gt;await&lt;/code&gt; for inserida no generator. A melhor alternativa é utilizar uma nova funcionalidade que está chegando: &lt;strong&gt;Funções Assíncronas&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;utilizando-async-await&#34;&gt;Utilizando &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Quando as &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; finalmente chegarem, seremos capazes de pegar nossa implementação baseada em promises e tirar a vantagem do estilo de &lt;strong&gt;“aparência síncrona”&lt;/strong&gt; dos generators. Outro benefício dessa abordagem é que não teremos que alterar o &lt;code&gt;getRandomPonyFooArticle&lt;/code&gt;, enquanto ele retornar uma promise ele poderá ser aguardado.&lt;/p&gt;

&lt;p&gt;Perceba que o &lt;code&gt;await&lt;/code&gt; só poderá ser utilizado em funções marcadas com a palavra chave &lt;code&gt;async&lt;/code&gt;. Ele funciona similarmente aos generators, suspendendo a execução em seu contexto até que a promise seja entregue. Se a expressão esperada não for uma promise, ela é transformada em uma promise.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;read();

async function read () {
  var html = await getRandomPonyFooArticle();
  var md = hget(html, {
    markdown: true,
    root: &#39;main&#39;,
    ignore: &#39;.at-subscribe,.mm-comments,.de-sidebar&#39;
  });
  var txt = marked(md, {
    renderer: new Term()
  });
  console.log(txt);
}
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Novamente &amp;#8211; assim como os generators &amp;#8211; lembre-se que você deverá encapsular o await em um bloco try / catch para que possamos capturar e tratar erros esperados das promises das funções assíncronas.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Além disso, uma &lt;strong&gt;Função Assíncrona&lt;/strong&gt; sempre irá retornar uma &lt;code&gt;Promise&lt;/code&gt;. Essa promise é rejeitada em caso de exceções não tratadas ou é resolvida e enviada como retorno da função assíncrona caso contrário. Isso nos permite invocar uma Função assíncrona e misturar isso com uma continuação baseada em promises normalmente. O exemplo a seguir mostra como as duas maneiras podem ser combinadas.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function asyncFun () {
  var value = await Promise
    .resolve(1)
    .then(x =&amp;gt; x * 3)
    .then(x =&amp;gt; x + 5)
    .then(x =&amp;gt; x / 2);
  return value;
}
asyncFun().then(x =&amp;gt; console.log(`x: ${x}`));
// &amp;lt;- &amp;#039;x: 4&amp;#039;
&lt;/pre&gt;

&lt;p&gt;Voltando ao nosso exemplo anterior, ele mostra que podemos usar o &lt;code&gt;return txt&lt;/code&gt; da nossa função &lt;code&gt;async read&lt;/code&gt; e permitir que os “consumidores” possam dar continuidade utilizando promises ou até mesmo uma outra &lt;strong&gt;Função Assíncrona&lt;/strong&gt;. Dessa maneira, nossa função read deve se preocupar apenas com imprimir um markdown de forma legível no terminal de um artigo aleatório do Pony Foo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function read () {
  var html = await getRandomPonyFooArticle();
  var md = hget(html, {
    markdown: true,
    root: &#39;main&#39;,
    ignore: &#39;.at-subscribe,.mm-comments,.de-sidebar&#39;
  });
  var txt = marked(md, {
    renderer: new Term()
  });
  return txt;
}
&lt;/pre&gt;

&lt;p&gt;Então você poderá adicionar mais tarde um &lt;code&gt;await read()&lt;/code&gt; em outra &lt;strong&gt;Função Assíncrona&lt;/strong&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function write () {
  var txt = await read();
  console.log(txt);
}
&lt;/pre&gt;

&lt;p&gt;Ou poderá simplesmente utilizar promises para dar continuação.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;read().then(txt =&amp;gt; console.log(txt));
&lt;/pre&gt;

&lt;h2 id=&#34;bifurcação-no-caminho&#34;&gt;Bifurcação no caminho&lt;/h2&gt;

&lt;p&gt;No fluxo assíncrono de código é comum executar duas ou mais tarefas concorrentemente. Enquanto as &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; facilitam a escrita de código assíncrono, elas também transformam elas mesmas em um código que é serial, ou seja, código que executa uma operação por vez. Uma função com múltiplos &lt;code&gt;await&lt;/code&gt; irá ser suspensa uma vez em cada &lt;code&gt;await&lt;/code&gt; até que a &lt;code&gt;Promise&lt;/code&gt; chegue (antes de retomar a execução e mover para o próximo &lt;code&gt;await&lt;/code&gt;, não diferente de como podemos ver com os generators e o &lt;code&gt;yield&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Para contornar isso você pode usar o &lt;code&gt;Promise.all&lt;/code&gt; para criar uma única promise que você irá dar o &lt;code&gt;await&lt;/code&gt; nela. O único problema é pegar o hábito de utilizar o &lt;code&gt;Promise.all&lt;/code&gt; ao invés de deixar tudo ocorrer em série, como também pode diminuir a performance do seu código.&lt;/p&gt;

&lt;p&gt;O exemplo a seguir mostra como você pode utilizar o &lt;code&gt;await&lt;/code&gt; em três diferentes promises que poderiam ser executadas concorrentemente. Dado que o &lt;code&gt;await&lt;/code&gt; suspende a sua &lt;strong&gt;Função Assíncrona&lt;/strong&gt; e que o &lt;code&gt;await Promise.all&lt;/code&gt; resulta em um &lt;strong&gt;array de results&lt;/strong&gt;, nós podemos desestruturar para puxar resultados individualmente do array.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function concurrent () {
  var [r1, r2, r3] = await Promise.all([p1, p2, p3]);
}
&lt;/pre&gt;

&lt;p&gt;Até um tempo atrás havia uma alternativa para o código acima: &lt;code&gt;await*&lt;/code&gt;, onde você não precisava encapsular as promises com o &lt;code&gt;Promise.all&lt;/code&gt;. O &lt;strong&gt;Babel 5&lt;/strong&gt; ainda suporta essa sintaxe, mas ela foi tirada da documentação e também do &lt;strong&gt;Babel 6&lt;/strong&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function concurrent () {
  var [r1, r2, r3] = await* [p1, p2, p3];
}
&lt;/pre&gt;

&lt;p&gt;Você ainda pode utilizar algo como &lt;code&gt;all = Promise.all.bind(Promise)&lt;/code&gt; para obter uma alternativa ao &lt;code&gt;Promise.all&lt;/code&gt;. Partindo desse ponto, você pode fazer o mesmo para o &lt;code&gt;Promise.race&lt;/code&gt;, que não tinha um equivalente para &lt;code&gt;await*&lt;/code&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;const all = Promise.all.bind(Promise);
async function concurrent () {
  var [r1, r2, r3] = await all([p1, p2, p3]);
}
&lt;/pre&gt;

&lt;h2 id=&#34;tratamento-de-erros&#34;&gt;Tratamento de Erros&lt;/h2&gt;

&lt;p&gt;Note que &lt;strong&gt;erros são engolidos “silenciosamente” nas Funções Assíncronas&lt;/strong&gt; &amp;#8211; assim como em &lt;code&gt;Promises&lt;/code&gt; normais. A menos que você adicione blocos &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; ao redor de chamadas &lt;code&gt;await&lt;/code&gt;, exceções não capturadas &amp;#8211; independentemente se ocorreram no corpo da sua &lt;strong&gt;Função Assíncrona&lt;/strong&gt; ou enquanto estava suspensa durante o &lt;code&gt;await&lt;/code&gt; &amp;#8211; irão rejeitar a &lt;code&gt;Promise&lt;/code&gt; retornada pela &lt;strong&gt;Função Assíncrona&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Naturalmente isso pode ser visto como um ponto forte: você tem a capacidade de tirar proveito das convenções do uso do &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt;, algo que você era incapaz de realizar com o uso de &lt;code&gt;callbacks&lt;/code&gt; &amp;#8211; e de alguma forma utilizar com &lt;code&gt;Promises&lt;/code&gt;. Nesse sentido, &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; são semelhantes aos generators, onde você também tinha a capacidade de tirar proveito do uso do &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; graças à suspensão da execução da função tornando um fluxo assíncrono em um código síncrono.&lt;/p&gt;

&lt;p&gt;Além disso, você também é capaz de capturar exceções de fora da &lt;strong&gt;Função Assíncrona&lt;/strong&gt;, simplesmente adicionando uma cláusula &lt;code&gt;.catch&lt;/code&gt; à &lt;code&gt;Promise&lt;/code&gt; que eles retornam. Enquanto isso é uma forma flexível de combinar o tratamento de erros utilizando &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; com cláusulas &lt;code&gt;.catch&lt;/code&gt; nas &lt;code&gt;Promises&lt;/code&gt;, também pode levar a uma grande confusão e deixar com que erros fiquem sem tratamento.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;read()
  .then(txt =&amp;gt; console.log(txt))
  .catch(reason =&amp;gt; console.error(reason));
&lt;/pre&gt;

&lt;p&gt;Nós devemos ter cuidado e educarmos a nós mesmos sobre as diferentes formas em que podemos encontrar, tratar, registrar e prevenir as exceções.&lt;/p&gt;

&lt;h2 id=&#34;utilizando-async-await-hoje&#34;&gt;Utilizando &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; hoje&lt;/h2&gt;

&lt;p&gt;Uma das formas de se utilizar &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; em seu código hoje é através do &lt;strong&gt;Babel&lt;/strong&gt;. Isso envolve uma série de módulos, mas você pode sempre criar um módulo que encapsula todos esses outros em um se você preferir. Eu incluí um &lt;code&gt;npm-run&lt;/code&gt; como uma maneira útil de se manter tudo em pacotes instalados localmente.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;npm i -g npm-run
npm i -D \
  browserify \
  babelify \
  babel-preset-es2015 \
  babel-preset-stage-3 \
  babel-runtime \
  babel-plugin-transform-runtime

echo &#39;{
  &#34;presets&#34;: [&#34;es2015&#34;, &#34;stage-3&#34;],
  &#34;plugins&#34;: [&#34;transform-runtime&#34;]
}&#39; &amp;gt; .babelrc
&lt;/pre&gt;

&lt;p&gt;O exemplo a seguir irá compilar o arquivo &lt;code&gt;example.js&lt;/code&gt; utilizando o &lt;strong&gt;browserify&lt;/strong&gt; enquanto utiliza o &lt;strong&gt;babelify&lt;/strong&gt; para habilitar o suporte às &lt;strong&gt;Funções Assíncronas&lt;/strong&gt;. Você pode então enviar o script para o &lt;strong&gt;node&lt;/strong&gt; ou &lt;strong&gt;salvar em disco&lt;/strong&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;npm-run browserify -t babelify example.js | node
&lt;/pre&gt;

&lt;h2 id=&#34;leitura-adicional&#34;&gt;Leitura adicional&lt;/h2&gt;

&lt;p&gt;O rascunho das &lt;a href=&#34;https://tc39.github.io/ecmascript-asyncawait/&#34; target=&#34;_blank&#34;&gt;especificações para Funções Assíncronas&lt;/a&gt; é bem curto e deve ser uma leitura interessante se você quer aprender mais sobre essa funcionalidade que está por vir.&lt;/p&gt;

&lt;p&gt;Eu colei um pedaço de código abaixo com a finalidade de ajudar você a entender como &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; funcionam internamente. Mesmo que não possamos criar novas palavras chave, é importante em termos de compreensão saber o que está acontecendo atrás dar curtinas do &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;É útil saber que &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; internamente se aproveitam dos &lt;strong&gt;generators&lt;/strong&gt; e das &lt;strong&gt;promises&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;O código a seguir mostra como uma declaração de uma &lt;strong&gt;Função Assíncrona&lt;/strong&gt; pode ser transformada em uma função comum que retorna o resultado alimentando a &lt;code&gt;spawn&lt;/code&gt; com um generator &amp;#8211; onde nós iremos considerar o &lt;code&gt;await&lt;/code&gt; como o equivalente sintático para &lt;code&gt;yield&lt;/code&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function example (a, b, c) {
  example function body
}

function example (a, b, c) {
  return spawn(function* () {
    example function body
  }, this);
}
&lt;/pre&gt;

&lt;p&gt;Na &lt;code&gt;spawn&lt;/code&gt;, uma promise é encapsulada em volta do código que irá percorrer o generator &amp;#8211; composta do código do usuário &amp;#8211; em série, repassando valores para o “generator” (corpo da &lt;strong&gt;Função Assíncrona&lt;/strong&gt;). Com isso podemos observar que &lt;strong&gt;Funções Assíncronas&lt;/strong&gt; são um &lt;code&gt;syntactic sugar&lt;/code&gt; que utiliza generators e promises, isso faz com que seja importante você entender como cada uma dessas partes trabalham para que você possa ter um melhor entendimento em como você pode misturar, comparar e combinar diferentes tipos de fluxo de código assíncrono juntos.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function spawn (genF, self) {
  return new Promise(function (resolve, reject) {
    var gen = genF.call(self);
    step(() =&amp;gt; gen.next(undefined));
    function step (nextF) {
      var next;
      try {
        next = nextF();
      } catch(e) {
        // finished with failure, reject the promise
        reject(e);
        return;
      }
      if (next.done) {
        // finished with success, resolve the promise
        resolve(next.value);
        return;
      }
      // not finished, chain off the yielded promise and `step` again
      Promise.resolve(next.value).then(
        v =&amp;gt; step(() =&amp;gt; gen.next(v)),
        e =&amp;gt; step(() =&amp;gt; gen.throw(e))
      );
    }
  });
}
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Os pedaços de códigos mostrados devem ajudá-lo a compreender como o algoritmo do &lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; itera sobre uma sequência de generators (expressões &lt;code&gt;await&lt;/code&gt;), encapsulando cada item na sequência em uma promise e então encadeando com a próxima sequência. Quando a sequência terminar ou uma das promises são rejeitadas ou a promise é retornada para a função que chamou o generator.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Artigo traduzido e adaptado de: &lt;a href=&#34;https://ponyfoo.com/articles/understanding-javascript-async-await&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://ponyfoo.com/articles/understanding-javascript-async-await&#34;&gt;https://ponyfoo.com/articles/understanding-javascript-async-await&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Collections ES6 – parte 1</title>
      <link>http://tableless.com.br/collections-es6-parte-1/</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/collections-es6-parte-1/</guid>
      <description>

&lt;p&gt;Fala Amigos!&lt;/p&gt;

&lt;p&gt;Dando continuidade a nossa série sobre as novidades do Javascript, vamos falar hoje sobre collections.&lt;/p&gt;

&lt;h4 id=&#34;sets-e-maps&#34;&gt;Sets e Maps&lt;/h4&gt;

&lt;p&gt;Historicamente a única collection que vinha por padrão no Javascript era o &lt;em&gt;Array&lt;/em&gt;. Mas a partir do ES6 temos novos tipos como: &lt;em&gt;Set&lt;/em&gt;, &lt;em&gt;WeakSet&lt;/em&gt;, &lt;em&gt;Map&lt;/em&gt; e &lt;em&gt;WeakMap&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;set&#34;&gt;Set&lt;/h4&gt;

&lt;p&gt;Para quem tem conhecimento em linguagens de programação como C#, Java, Ruby e Python esta collection não é uma novidade, mas para quem tem conhecimento somente em Javascript, sim. Sendo assim, segue a definição:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Set&lt;/em&gt; é um tipo de collection que permite a inserção de qualquer tipo de valor (Ex: objeto, function, número, string, etc) e não permite valores duplicados. Outra particularidade é que utilizando &lt;em&gt;Set&lt;/em&gt; não é possível acessar um valor diretamente como é feito com &lt;em&gt;Array&lt;/em&gt;, normalmente você valida para ver se o valor está presente ou itera sobre os valores.&lt;/p&gt;

&lt;p&gt;Um exemplo de uso para &lt;em&gt;Sets&lt;/em&gt; é uma lista de pedidos onde cada pedido do usuário deve ser único e ocasionalmente é necessário verificar se aquele pedido já esta incluso.&lt;/p&gt;

&lt;p&gt;Simples!? Vamos ver na prática a utilização do &lt;em&gt;Set&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        //inicialização de um Set
        var set = new Set(); //cria um novo Set vazio
        var set2 = new Set([1, 2, 3]); //cria um novo Set a partir de um Array

        set.add(1); //adiciona um valor

        //número de valores no set
        set.size; // 1
        set2.size; // 3

        //verifica se o valor existe dentro do Set
        set.has(1); // true

        set.add(1); //adiciona um valor duplicado e nada acontece

        set.size; // 1

        set.delete(1); //remove um determinado valor do Set

        set.has(1); // false
        set.size; // 0

        //itera sobre os valores do Set
        for (let valor of set2) {
          console.log(valor);
        }

        //itera sobre os valores do Set
        set2.forEach(function(valor) {
          console.log(valor); 
        });

        //output das iterações: 
        // 1
        // 2
        // 3

        set2.clear(); //remove todos os valores do Set
        set2.size; // 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;weakset&#34;&gt;WeakSet&lt;/h4&gt;

&lt;p&gt;É um _Set_ de objetos que não previne que seus elementos/valores sejam coletados pelo garbage collector do Javascript. Além disso a sua api também é reduzida. Deste modo, não é permitido iterar sobre os valores do &lt;em&gt;Set&lt;/em&gt; e/ou limpar os mesmos usando o método &lt;em&gt;clear&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Na prática, ao utilizar um objeto como valor do seu &lt;em&gt;WeakSet&lt;/em&gt; e o mesmo não estiver sendo usado em mais nenhum lugar na sua aplicação, o garbage collector poderá limpar a sua referência e com isso magicamente o valor deixaria de existir.&lt;/p&gt;

&lt;p&gt;A api do &lt;em&gt;WeakSet&lt;/em&gt; é composta de apenas 3 métodos quais funcionam da mesma forma que o &lt;em&gt;Set&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;add(valor)&lt;/li&gt;
&lt;li&gt;has(valor)&lt;/li&gt;
&lt;li&gt;delete(valor)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No próximo post falaremos de &lt;em&gt;Map&lt;/em&gt; e &lt;em&gt;WeakMap.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Até a próxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Funções do JavaScript na versão ES 6 – Parte 1</title>
      <link>http://tableless.com.br/funcoes-javascript-na-versao-es-6-parte-1/</link>
      <pubDate>Wed, 25 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/funcoes-javascript-na-versao-es-6-parte-1/</guid>
      <description>

&lt;p&gt;Ao longo dos anos as funções em JavaScript não tem mudado muito, mas agora com a nova especificação de ECMAScript 6 teremos algum avanço. Confira abaixo o que tem mudado na nova versão do JavaScript.&lt;/p&gt;

&lt;h2 id=&#34;parâmetros-default&#34;&gt;Parâmetros Default:&lt;/h2&gt;

&lt;p&gt;Algo muito comum ao desenvolvermos é verificar a presença de uma váriavel e caso ela não exista, inicializamos com um valor, assim como no código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function hello(nome,cidade){

  nome = nome || &#34;Caio&#34;;
  cidade = cidade || &#34;São Paulo&#34;;

  console.log(&#34;Sou &#34;+nome+ &#34; e moro em &#34;+cidade);

}

hello(); // Sou Caio e moro em São Paulo
&lt;/pre&gt;

&lt;p&gt;Agora, com a novidade de &lt;strong&gt;default parameters&lt;/strong&gt;, nós podemos declarar valores padrões de uma forma bem mais elegante:&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function hello(nome=&#34;Caio&#34;, cidade=&#34;São Paulo&#34;){

  console.log(&#34;Sou &#34;+nome+ &#34; e moro em &#34;+cidade);

}

hello(); // Sou Caio e moro em São Paulo

hello(&#34;Pedro&#34;,&#34;Belo Horizonte&#34;) // Sou Pedro e moro em Belo Horizonte

&lt;/pre&gt;

&lt;p&gt;Veja que reduzimos muito nosso código, além de ficar mais fácil para um novo desenvolvedor compreender o que está ocorrendo.&lt;/p&gt;

&lt;h2 id=&#34;rest-parameters&#34;&gt;Rest Parameters:&lt;/h2&gt;

&lt;p&gt;Em JavaScript sempre pudemos passar quantos parâmetros quiséssemos para uma função por meio de argumentos:&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function somaContaDoCliente(cliente, moeda, valores){
  var i = 2;
  var tamanho = arguments.length;
  var resultado = 0;

  while (i &amp;lt; tamanho) {
   resultado += arguments[i];
   i++;
  }

console.log(&#34;A conta do cliente &#34;+cliente+ &#34; totalizou &#34;+moeda+ resultado);

}

somaContaDoCliente(&#34;Caio&#34;,&#34;R$&#34;,1,2,3,4,5); // A conta do cliente Caio totalizou R$15
&lt;/pre&gt;

&lt;p&gt;Repare que no código acima precisamos lembrar da posição que começa nosso valores, mas e se adicionarmos mais um parâmetro no futuro? Precisaríamos lembrar de alterar o índice que usamos, mas será que só pelo nome da variável, lembraríamos que ali pode estar uma quantidade indefinida de valores?&lt;/p&gt;

&lt;p&gt;Pensando nisto, foi criado o &lt;strong&gt;Rest Parameters&lt;/strong&gt;, onde nós podemos realizar isso de um modo mais interessante, pois não precisamos mais acessar o array arguments e verificar as posições dele, o parâmetro que pode receber vários valores é precedido por três pontos(&amp;#8230;) e precisa ser sempre o último parâmetro da função:&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function somaContaDoCliente(cliente, moeda, ...valores){

  var resultado = 0;
  var i = 0;

  while (i &amp;lt; valores.length) {

    resultado += valores[i];

    i++;

  }

console.log(&#34;A conta do cliente &#34;+cliente+ &#34; totalizou &#34;+moeda+ resultado);

}

somaContaDoCliente(&#34;Caio&#34;,&#34;R$&#34;,1,2,3,4,5); //A conta do cliente Caio totalizou R$15
&lt;/pre&gt;

&lt;p&gt;Repare que ficou mais simples, não nos preocupamos com o índice e ainda está bem claro que o valores é um parâmetro especial que recebe um ou mais números.&lt;/p&gt;

&lt;h2 id=&#34;destructured-parameters&#34;&gt;Destructured Parameters:&lt;/h2&gt;

&lt;p&gt;É muito comum em bibliotecas e afins, precisarmos extrair os paramêtros passados como opção, por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function auth(name, password, options) {

  options = options || {};

  var https = options.https,
  provider = options.provider,
  callback = options.callback;


//Autentica baseado no provider, verifica se usa https e executa um callback caso necessário.

}

auth(&#34;caio&#34;, &#34;minhasenha&#34;, {

  https: true,

  provider: &#34;git&#34;

});
&lt;/pre&gt;

&lt;p&gt;Com destructured parameters nós podemos simplesmente passar o array de elementos, sem precisar extrair cada um manualmente, deixando nossa função mais enxuta.&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function auth(name, password, {https,provider,callback}) {

  //Autentica baseado no provider, verifica se usa https e executa um callback caso necessário.

}

auth(&#34;caio&#34;, &#34;minhasenha&#34;, {

  https: true,

  provider: &#34;git&#34;

});

&lt;/pre&gt;

&lt;p&gt;Interessante não? O problema nesta abordagem é que caso o último parâmetro não seja passado, receberemos um erro, mas temos um meio de lidar com isso, usando os default parameters abordados no começo do texto, deixando nossa função da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function auth(name, password, {https,provider,callback} = {}) {

  //Autentica baseado no provider, verifica se usa https e executa um callback caso necessário.
}
&lt;/pre&gt;

&lt;p&gt;Ainda existem outras mudanças e incrementações nas funções em ECMAScript 6, essas irão ficar para o segundo post da série, espero que tenham gostado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iterators ES6</title>
      <link>http://tableless.com.br/iterators-es6/</link>
      <pubDate>Fri, 20 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/iterators-es6/</guid>
      <description>

&lt;p&gt;A partir de hoje iniciaremos uma série de posts falando sobre as novidades da nova versão do Javascript, conhecida como ES6 (EcmaScript 6). Que esta recheada de novidades e contemplando features muito legais como você verá na série.&lt;/p&gt;

&lt;p&gt;Como post de abertura vou falar hoje sobre iterators.&lt;/p&gt;

&lt;h3 id=&#34;o-que-são&#34;&gt;O que são?&lt;/h3&gt;

&lt;p&gt;Iterator é um objeto com uma determinada interface. E essa interface consiste de um método chamado &lt;em&gt;next()&lt;/em&gt; que retorna um objeto como resultado.&lt;/p&gt;

&lt;p&gt;Esse objeto de resultado, tem duas propriedades &lt;em&gt;value&lt;/em&gt; referente ao valor corrente e &lt;em&gt;done&lt;/em&gt; que é um valor booleano qual é setado para &lt;em&gt;true&lt;/em&gt; quando não existem mais valores para serem retornados.&lt;/p&gt;

&lt;p&gt;O iterator mantém uma referência à posição correta do próximo valor dentro da coleção de valores. Deste modo, toda vez que o método &lt;em&gt;next()&lt;/em&gt; é chamado ele retorna o valor correto. Caso o método &lt;em&gt;next()&lt;/em&gt; for chamado após o último valor ser retornado o iterator irá retornar o objeto de resultado com os seguintes valores: &lt;em&gt;done&lt;/em&gt; = &lt;em&gt;true&lt;/em&gt; e &lt;em&gt;value&lt;/em&gt; = &lt;em&gt;undefined&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;show-me-the-code&#34;&gt;Show me the code!&lt;/h4&gt;

&lt;p&gt;Com esse entendimento vamos ver na prática a implementação de um iterator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    var criarIterator = function(items){
        var i = 0;

        return {
            next: function(){

                var done = (i&amp;gt;= items.length);
                var value = !done ? items[i++] : undefined;

                return {
                    done: done,
                    value: value
                };
            }
        }
    };

    var iterator = criarIterator([1, 2, 3]);

    console.log(iterator.next());  // &amp;quot;{ value: 1, done: false}&amp;quot;
    console.log(iterator.next());  // &amp;quot;{ value: 2, done: false}&amp;quot;
    console.log(iterator.next());  // &amp;quot;{ value: 3, done: false}&amp;quot;
    console.log(iterator.next());  // &amp;quot;{ value: undefined, done: true}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simples, neh!?&lt;/p&gt;

&lt;p&gt;Imagino que se você tenha conhecimentos em Java ou C# já tenha se perguntado, será? E a resposta é sim! Iterator em Javascript funciona de uma maneira bem semelhante ao iterator dessas linguagens.&lt;/p&gt;

&lt;h4 id=&#34;legal-mas-e-onde-eu-uso-isso&#34;&gt;Legal! Mas e onde eu uso isso?&lt;/h4&gt;

&lt;p&gt;Iterator é uma peça fundamental na nova forma de manipular coleções de dados no ES6. Sendo assim, todos os tipos de coleções (&lt;em&gt;Arrays&lt;/em&gt;, &lt;em&gt;Sets&lt;/em&gt;, &lt;em&gt;Maps&lt;/em&gt; e até mesmo &lt;em&gt;Strings&lt;/em&gt;) já vem com essa interface implementada. Liberando novas formas de interação com esses objetos.&lt;/p&gt;

&lt;p&gt;Além disso um bom entendimento sobre iterators irá te dar uma base sólida e te ajudar muito no entendimento de outras features do ES6. Assim como &lt;em&gt;collections&lt;/em&gt;, &lt;em&gt;for of&lt;/em&gt; e &lt;em&gt;generators&lt;/em&gt; que serão assuntos dos próximos posts da série.&lt;/p&gt;

&lt;p&gt;Até a próxima!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>