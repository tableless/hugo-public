<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gulp on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/gulp/index.xml</link>
    <description>Recent content in Gulp on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/gulp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introdução ao Electron</title>
      <link>https://tableless.github.io/hugo-public/introducao-ao-electron/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-ao-electron/</guid>
      <description>

&lt;h2 id=&#34;o-que-é-o-electron&#34;&gt;O que é o Electron&lt;/h2&gt;

&lt;p&gt;O Electron foi desenvolvido para permitir que o desenvolvimento de aplicações &lt;em&gt;desktop&lt;/em&gt; usando JavaScript, HTML e CSS fosse muito mais fácil. Criado pela equipe do &lt;a href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;, ficou conhecido no começo como Atom Shell. O Electron foi criado usando tecnologias como o &lt;a href=&#34;https://nodejs.org&#34; target=&#34;_blank&#34;&gt;Node.js&lt;/a&gt; e o Chromium, e atualmente roda em ambiente de produção de vários projetos, como o próprio &lt;a href=&#34;https://code.visualstudio.com/&#34; target=&#34;_blank&#34;&gt;Atom editor&lt;/a&gt; e outros, como o &lt;a href=&#34;https://slack.com/&#34; target=&#34;_blank&#34;&gt;Slack&lt;/a&gt; e o &lt;a href=&#34;https://code.visualstudio.com/&#34; target=&#34;_blank&#34;&gt;Visual Studio Code&lt;/a&gt;. Ele é um &lt;em&gt;framework&lt;/em&gt; bem simples de trabalhar e de rápida configuração, para construção de pequenas e grandes aplicações &lt;em&gt;desktop&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Para todos que queiram se aventurar mais, ou já conhecem o Electron, a documentação completa é traduzida para vários idiomas, inclusive o português. Para acessá-la é só &lt;a href=&#34;https://github.com/atom/electron/tree/master/docs-translations/pt-BR&#34; target=&#34;_blank&#34;&gt;clicar aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mãos-à-obra&#34;&gt;Mãos à obra&lt;/h2&gt;

&lt;p&gt;Nesta Introdução iremos abordar os primeiros passos para começar a trabalhar com o Electron e desenvolver aplicações &lt;em&gt;desktop&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Além do &lt;a href=&#34;https://nodejs.org&#34; target=&#34;_blank&#34;&gt;Node.js&lt;/a&gt; presente em sua máquina, é necessário que você também instale globalmente o pacote &lt;code&gt;electron-prebuilt&lt;/code&gt;. Para isto, basta digitar o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;language-bash&#34;&gt;npm install -g electron-prebuilt&lt;/pre&gt;

&lt;h3 id=&#34;entendendo-a-estrutura&#34;&gt;Entendendo a estrutura&lt;/h3&gt;

&lt;p&gt;A estrutura básica de arquivos que usaremos aqui é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;language-text&#34;&gt;electron-app/
├── app 
    ├── assets
        └── css
            └── main.css
    ├── main.js
    ├── index.html
    └── package.json
├── Gulpfile.js
└── package.json
&lt;/pre&gt;

&lt;p&gt;Vamos falar um pouco de cada arquivo e pasta inseridos no exemplo acima:&lt;/p&gt;

&lt;h4 id=&#34;app&#34;&gt;app&lt;/h4&gt;

&lt;p&gt;É  a pasta onde todos os arquivos referentes à aplicação são inseridos.&lt;/p&gt;

&lt;h4 id=&#34;main-js&#34;&gt;main.js&lt;/h4&gt;

&lt;p&gt;É o arquivo de inicialização da aplicação. Nele vão as configurações do tipo: tamanho da tela, posicionamento, manipular eventos do sistema, etc&amp;#8230;&lt;/p&gt;

&lt;h4 id=&#34;index-html&#34;&gt;index.html&lt;/h4&gt;

&lt;p&gt;É a pagina HTML que será nossa &lt;em&gt;view&lt;/em&gt; inicial para essa introdução.&lt;/p&gt;

&lt;h4 id=&#34;app-package-json&#34;&gt;app/package.json&lt;/h4&gt;

&lt;p&gt;O arquivo &lt;code&gt;package.json&lt;/code&gt; que vai dentro da pasta &lt;em&gt;app&lt;/em&gt; é o arquivo que leva todos as dependências que sua aplicação precisará para rodar. Sendo assim, qualquer pacote _npm_ a ser usado diretamente por sua aplicação deverá ser instalado nesse &lt;em&gt;package&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;gulpfile-js&#34;&gt;Gulpfile.js&lt;/h4&gt;

&lt;p&gt;Optei usar &lt;a href=&#34;http://gulpjs.com/&#34; target=&#34;_blank&#34;&gt;Gulp&lt;/a&gt; por escolha própria mesmo, mas fiquem livres para escolher seu &lt;em&gt;&amp;#8220;task runner&amp;#8221;&lt;/em&gt; favorito.&lt;/p&gt;

&lt;h4 id=&#34;package-json&#34;&gt;package.json&lt;/h4&gt;

&lt;p&gt;O &lt;code&gt;package.json&lt;/code&gt; que fica na raiz do seu projeto é responsável pelas configurações, dependências para seu ambiente de desenvolvimento. Tudo que for incluso neste arquivo não estará presente na &lt;em&gt;build&lt;/em&gt; de produção da sua &lt;em&gt;app&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;declarando-as-dependências&#34;&gt;Declarando as dependências&lt;/h3&gt;

&lt;p&gt;Após criar a estrutura de pastas que foi citada no tópico anterior. Iremos atribuir os mesmos valores para os atributos de ambos &lt;code&gt;package.json&lt;/code&gt; presentes no projeto. Levando em consideração que &lt;code&gt;&amp;quot;your-app&amp;quot;&lt;/code&gt; será o nome da sua aplicação.&lt;/p&gt;

&lt;pre class=&#34;language-json&#34;&gt;{
  &#34;name&#34;    : &#34;olamundo&#34;,
  &#34;version&#34; : &#34;0.1.0&#34;,
  &#34;main&#34;    : &#34;main.js&#34;
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: Caso o campo main não tenha sido preenchido, o Electron automaticamente procurará pelo arquivo &lt;code&gt;index.js&lt;/code&gt;. É importante que preencha este campo com o arquivo que usará na inicialização da aplicação.&lt;/p&gt;

&lt;p&gt;Após feito isso, instale as dependências que utilizaremos nesta introdução, no arquivo &lt;code&gt;package.json&lt;/code&gt; que se encontra diretamente na raiz do seu projeto.&lt;/p&gt;

&lt;pre class=&#34; language-bash&#34;&gt;npm install --save-dev electron-prebuilt fs-jetpack asar rcedit Q
&lt;/pre&gt;

&lt;h3 id=&#34;criando-seu-arquivo-de-inicialização&#34;&gt;Criando seu arquivo de inicialização&lt;/h3&gt;

&lt;p&gt;Depois de configurar as pastas e instalar as dependências da nossa aplicação, vamos abrir o nosso arquivo &lt;code&gt;main.js&lt;/code&gt; . Nele vamos incluir todo o código de configuração:&lt;/p&gt;

&lt;pre class=&#34;language-javascript&#34;&gt;var app = require(&#39;app&#39;);
var BrowserWindow = require(&#39;browser-window&#39;);

require(&#39;crash-reporter&#39;).start();

var mainWindow = null;

app.on(&#39;window-all-closed&#39;, function() {
  
  if (process.platform != &#39;darwin&#39;) {
    app.quit();
  }

});

app.on(&#39;ready&#39;, function() {
  
  mainWindow = new BrowserWindow({width: 800, height: 600});
  
  mainWindow.loadUrl(&#39;file://&#39; + __dirname + &#39;/index.html&#39;);
  
  mainWindow.openDevTools();
  
  mainWindow.on(&#39;closed&#39;, function() {
    
    mainWindow = null;
  });
}); 
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Nota&lt;/strong&gt;: a Função &lt;em&gt;mainWindow.openDevTools&lt;/em&gt; é chamada apenas para iniciar o &lt;em&gt;Inspetor de Elementos&lt;/em&gt; junto com a aplicação. Caso não precisem, fiquem à vontade para removê-la do seu projeto.&lt;/p&gt;

&lt;h3 id=&#34;primeira-view&#34;&gt;Primeira &lt;em&gt;view&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;Finalmente a parte mais fácil. Note que em nosso arquivo &lt;code&gt;main.js&lt;/code&gt; existe a seguinte função:&lt;/p&gt;

&lt;pre class=&#34;language-javascript&#34;&gt;mainWindow.loadUrl(&#39;file://&#39; + __dirname + &#39;/index.html&#39;); 
&lt;/pre&gt;

&lt;p&gt;Ela será responsável por carregar o arquivo &lt;code&gt;index.html&lt;/code&gt;. No exemplo a seguir, criei um exemplo bem simples de um arquivo HTML. Esta página que foi criada, tem os mesmos aspectos de uma janela aberta de um navegador. Ou seja, podemos carregar todos os arquivos CSS e JavaScript que utilizaremos normalmente. Veja:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;
  &lt;pre class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
      &amp;lt;meta charset=&#34;utf-8&#34; /&amp;gt;
      &amp;lt;title&amp;gt;Olá Mundo&amp;lt;/title&amp;gt;
      &amp;lt;link href=&#34;assets/css/main.css&#34; rel=&#34;stylesheet&#34; type=&#34;text/css&#34; /&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
      &amp;lt;h1&amp;gt;Olá Mundo&amp;lt;/h1&amp;gt;
      
      &amp;lt;p&amp;gt;Bem vindos à nossa introdução ao Electron&amp;lt;/p&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;
  
  &lt;h2 id=&#34;run-your-app&#34;&gt;
    Rodando sua aplicação
  &lt;/h2&gt;
  
  &lt;h3&gt;
    electron-prebuilt
  &lt;/h3&gt;
  
  &lt;p&gt;
    Se você instalou o &lt;code&gt;electron-prebuilt&lt;/code&gt; global, Acesse a pasta &lt;strong&gt;app&lt;/strong&gt; e rode o seguinte comando:
  &lt;/p&gt;
  
  &lt;pre class=&#34;language-bash&#34;&gt;electron app&lt;/pre&gt;
  
  &lt;p&gt;
    Caso tenha instalado apenas localmente, então, na pasta &lt;strong&gt;app&lt;/strong&gt; de seu projeto, digite o seguinte comando:
  &lt;/p&gt;
  
  &lt;pre class=&#34;language-bash&#34;&gt;&#34;../node_modules/.bin/electron&#34; &#34;./app&#34;&lt;/pre&gt;
  
  &lt;h3&gt;
    Automatizando
  &lt;/h3&gt;
  
  &lt;p&gt;
    Como citei anteriormente, usaremos o &lt;em&gt;Gulp&lt;/em&gt; para automatizar o &lt;em&gt;run&lt;/em&gt; da nossa aplicação, facilitando assim a criação de testes e o próprio desenvolvimento da aplicação. Para isso, deixaremos nosso &lt;code&gt;Gulpfile.js&lt;/code&gt; da seguinte maneira:
  &lt;/p&gt;
  
  &lt;pre class=&#34;language-javascript&#34;&gt;var gulp = require(&#39;gulp&#39;),
  childProcess = require(&#39;child_process&#39;),
  electron = require(&#39;electron-prebuilt&#39;);
  
gulp.task(&#39;run&#39;, function () {
  childProcess.spawn(electron, [&#39;./app&#39;], { stdio: &#39;inherit&#39; });
});
&lt;/pre&gt;
  
  &lt;p&gt;
    Feito isso basta rodar o seguinte comando em seu terminal:
  &lt;/p&gt;
  
  &lt;pre class=&#34;language-bash&#34;&gt;gulp run&lt;/pre&gt;
  
  &lt;h2&gt;
    Criando uma distribuição
  &lt;/h2&gt;
  
  &lt;p&gt;
    Depois de terminado todo o processo de desenvolvimento, você pode criar uma distribuição do seu &lt;em&gt;app&lt;/em&gt; seguindo as instruções do &lt;a href=&#34;http://electron.atom.io/docs/v0.33.0/tutorial/application-distribution&#34; target=&#34;_blank&#34;&gt;Application Distribution guide&lt;/a&gt;.
  &lt;/p&gt;
  
  &lt;p&gt;
    Pronto! Você está pronto(a) para desenvolver aplicações Desktop com o Electron.
  &lt;/p&gt;
  
  &lt;p&gt;
    E caso queiram, o projeto está disponível no &lt;a href=&#34;https://github.com/henriquesosa/electron-intro&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.
  &lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Harvest: Boilerplate de Gulp para seus projetos</title>
      <link>https://tableless.github.io/hugo-public/harvest-boilerplate-de-gulp-para-seus-projetos/</link>
      <pubDate>Wed, 07 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/harvest-boilerplate-de-gulp-para-seus-projetos/</guid>
      <description>&lt;p&gt;Não importa qual o Task Runner você usa. Muitos gostam de Grunt, outros de Gulp, outros usam Rake e todos tem o seu encanto e seus truques. Já usei muito Grunt, mas ultimamente tenho experimentado o Gulp. Cara&amp;#8230; como é rápido. Por isso, tive a grande ideia de criar um boilerplate para os meus projetos, onde eu consigo rapidamente concatenar os assets, otimizar imagens, criar source maps dos arquivos SASS, subir um servidor e várias outras coisas.&lt;/p&gt;

&lt;p&gt;Mas antes de iniciar a criação desse boilerplate, obviamente, procurei se alguém não já teve essa ideia e feito esse trabalho para mim. Foi aí que eu achei o &lt;a href=&#34;http://www.ryanbensonmedia.com/harvest&#34;&gt;Harvest&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;O Harvest é um boilerplate Gulp que te ajuda a fazer uma série tarefas rotineiras como:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Levantar um servidor na porta 3000&lt;/li&gt;
&lt;li&gt;Live Reload usando o BrowserSync&lt;/li&gt;
&lt;li&gt;Build do projeto&lt;/li&gt;
&lt;li&gt;Conversão do SCSS com Source Maps&lt;/li&gt;
&lt;li&gt;Concatenação e minificação do CSS e JS&lt;/li&gt;
&lt;li&gt;Compressão e Otimização de imagem&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A instalação é fácil:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Faça o download ou o clone do projeto&lt;/li&gt;
&lt;li&gt;Rode &lt;code&gt;npm install&lt;/code&gt; para instalar as dependencias.&lt;/li&gt;
&lt;li&gt;Rode &lt;code&gt;gulp&lt;/code&gt; para iniciar o servidor, o live reload e o watch dos assets.&lt;/li&gt;
&lt;li&gt;Abra o browser em &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt; para ver seu servidor local e o live reload do projeto&lt;/li&gt;
&lt;li&gt;Rode &lt;code&gt;gulp deploy&lt;/code&gt; para fazer o build seu projeto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alguns dos módulos usados para fazer esse boilerplate são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-autoprefixer&#34; target=&#34;_blank&#34;&gt;Gulp Auto Prefixer&lt;/a&gt; insere os prefixos dos browsers no seu CSS automaticamente&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-concat&#34; target=&#34;_blank&#34;&gt;Gulp Concat&lt;/a&gt; Concatena o JS e o CSS em um arquivo.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-connect&#34; target=&#34;_blank&#34;&gt;Gulp Connect&lt;/a&gt; Cria um servidor local para o desenvolvimento faz o reload quando você muda e salva um arquivo.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-imagemin&#34; target=&#34;_blank&#34;&gt;Gulp ImageMin&lt;/a&gt; Minifica as imagens.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-sass&#34; target=&#34;_blank&#34;&gt;Gulp SASS&lt;/a&gt; Biblioteca do SASS sem a dependência do Ruby.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-sourcemaps&#34; target=&#34;_blank&#34;&gt;Gulp SourceMaps&lt;/a&gt; Adiciona os arquivos de source maps para facilitar o debug do SASS&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-uglify&#34; target=&#34;_blank&#34;&gt;Gulp Uglify&lt;/a&gt; Uglify de JS.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-shell&#34; target=&#34;_blank&#34;&gt;Gulp Shell&lt;/a&gt; Ajuda na criação e limpeza de diretório de build&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-sequence&#34; target=&#34;_blank&#34;&gt;Gulp Sequence&lt;/a&gt; Organiza e roda as tarefas de build em uma sequência definida.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/browser-sync&#34; target=&#34;_blank&#34;&gt;BrowserSync&lt;/a&gt; Sincroniza vários browsers e executa o live reload da página.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/gulp-minify-css&#34; target=&#34;_blank&#34;&gt;Gulp Minify CSS&lt;/a&gt; Minifica o CSS.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;a href=&#34;http://www.ryanbensonmedia.com/harvest/documentation&#34;&gt;documentação&lt;/a&gt; ainda está sendo escrita, mas acho que você vai conseguir se virar bem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Teste automatizado de API com frisby e jasmine</title>
      <link>https://tableless.github.io/hugo-public/teste-automatizado-de-api-com-frisby-e-jasmine/</link>
      <pubDate>Thu, 27 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/teste-automatizado-de-api-com-frisby-e-jasmine/</guid>
      <description>

&lt;p&gt;O &lt;a href=&#34;http://frisbyjs.com/&#34;&gt;Frisby&lt;/a&gt; é um framework para teste de API REST que roda em cima do nodejs. Seu principal apelo é a facilidade em se fazer testes automatizados de API com o apoio do framework de teste BDD jasmine.&lt;/p&gt;

&lt;h3 id=&#34;instalação&#34;&gt;Instalação:&lt;/h3&gt;

&lt;p&gt;Pré requisitos: nodejs, npm.&lt;/p&gt;

&lt;p&gt;1) jasmine-node. Instalação global.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;sudo npm install -g jasmine-node&lt;/pre&gt;

&lt;p&gt;2) frisby. Instalação local no projeto.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;sudo nam install --save-dev frisby&lt;/pre&gt;

&lt;h3 id=&#34;hello-world&#34;&gt;Hello, World!&lt;/h3&gt;

&lt;p&gt;Para o uso devemos instanciar seu módulo:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;var frisby = require (&#39;frisby&#39;);&lt;/pre&gt;

&lt;p&gt;No seu uso mais básico, passamos como parâmetro a url a ser chamada e a resposta esperada.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;frisby.create(&#39;Teste BDD&#39;).get(&#39;http://www.teste.com/pessoa/1&#39;).expectStatus(200).toss();&lt;/pre&gt;

&lt;p&gt;Com o comando acima, estamos testando a API sendo que seu sucesso depende do código de retorno HTTP 200.&lt;/p&gt;

&lt;p&gt;Por convenção devemos salvar este arquivo de teste com o sufixo &amp;#8216;-spec.js&amp;#8217;. Ex: &amp;#8216;pessoa-spec.js&amp;#8217;&lt;/p&gt;

&lt;p&gt;Para execução do teste e para que o mesmo gere relatório no formato &amp;#8216;junitreport&amp;#8217; devemos executar o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;jasmine-node pessoa-spec.js --junitreport --output specTestReportJasmine&lt;/pre&gt;

&lt;p&gt;Na prática apontamos para um pasta de teste para que todos sejam executados. Ex:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;jasmine-node spec/ --junitreport --output specTestReportJasmine&lt;/pre&gt;

&lt;p&gt;Já temos o essencial para integração do teste de api com alguma ferramenta de CI como o Jenkins(&lt;a href=&#34;https://jenkins-ci.org/&#34;&gt;https://jenkins-ci.org/&lt;/a&gt;) com relatório padronizado.&lt;/p&gt;

&lt;h3 id=&#34;hello-universe&#34;&gt;Hello, Universe!&lt;/h3&gt;

&lt;p&gt;O framework oferece alguns recursos interessantes e de fácil implementação para testar a resposta da API REST.&lt;/p&gt;

&lt;p&gt;1) Testar se a resposta HTTP contém um cabeçalho específico.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;frisby.create(&#39;Teste BDD&#39;).get(&#39;http://www.teste.com/pessoa/1&#39;)
   .expectStatus(200)
   .expectHeaderContains(&#39;Content-Type&#39;, &#39;json&#39;)
   .toss();

&lt;/pre&gt;

&lt;p&gt;2) Testar se a resposta HTTP contém um objeto com um conteúdo específico.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;frisby.create(&#39;Teste BDD&#39;).get(&#39;http://www.teste.com/pessoa/1&#39;)
   .expectStatus(200)
   .expectHeaderContains(&#39;Content-Type&#39;, &#39;json&#39;)
   .expectJSON({codigo:1,nome:&#34;fulano&#34;})
   .toss();&lt;/pre&gt;

&lt;p&gt;3) Testar se a resposta HTTP contém um objeto com um tipo específico.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;frisby.create(&#39;Teste BDD&#39;).get(&#39;http://www.teste.com/pessoa/1&#39;)
   .expectStatus(200)
   .expectHeaderContains(&#39;Content-Type&#39;, &#39;json&#39;)
   .expectJSONTypes({codigo: Number})
   .toss();&lt;/pre&gt;

&lt;p&gt;4) Realizar um teste que depende da conclusão de um teste anterior.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;frisby.create(&#39;Teste BDD&#39;).get(&#39;http://www.teste.com/pessoa/1&#39;)
   .expectStatus(200)
   .expectHeaderContains(&#39;Content-Type&#39;, &#39;json&#39;)
   .expectJSONTypes({codigo: Number})
   .after(function(){
      frisby.create(&#39;Teste BDD&#39;).delete(&#39;http://www.teste.com/pessoa/1&#39;).expectStatus(200).toss();
   })
   .toss();&lt;/pre&gt;

&lt;p&gt;No teste acima, caso tenha sucesso ao obter informações de uma pessoa será feito um teste da exclusão da mesma.&lt;/p&gt;

&lt;h4 id=&#34;integração-com-gulp-projetos-em-nodejs&#34;&gt;Integração com GULP(Projetos em nodejs)&lt;/h4&gt;

&lt;p&gt;Quando a aplicação backend é feita em nodejs é interessante configurar o gulpjs(&lt;a href=&#34;http://gulpjs.com/&#34;&gt;http://gulpjs.com/&lt;/a&gt;) para o gerenciamento dos testes. No exemplo abaixo o gulp é configurado para iniciar a aplicação backend, disparar os testes e finalizar a aplicação:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp.task(&#39;spec&#39;, function() {
   var jasmine = spawn(&#39;jasmine-node&#39;, [&#39;spec/&#39;,&#39;--junitreport&#39;,&#39;--output&#39;,&#39;specTestReportJasmine&#39;]);
   var serverApp = require(&#39;./server&#39;);
   var resumeText = &#34;&#34;;
 
   serverApp.init(8082);
 
   jasmine.stdout.on(&#39;data&#39;, function (data) {
      var texto = data.toString().trim();
      resumeText += texto;
   });
   jasmine.stderr.on(&#39;data&#39;, function (data) {
      console.log(&#39;erro: &#39; + data);
   });
   jasmine.on(&#39;close&#39;, function (code) {
      console.log(&#39;*********************\n&#39; + resumeText);
      serverApp.close();
      process.exit();
   });
});&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Em um relacionamento sério com generators front-end – Parte 3</title>
      <link>https://tableless.github.io/hugo-public/em-um-relacionamento-serio-com-generators-front-end-parte-3/</link>
      <pubDate>Fri, 06 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/em-um-relacionamento-serio-com-generators-front-end-parte-3/</guid>
      <description>

&lt;h2 style=&#34;text-align: center&#34;&gt;
  &lt;img class=&#34;aligncenter size-full wp-image-46781&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/pngbase643ef91c517603490c.png&#34; alt=&#34;png;base643ef91c517603490c&#34; width=&#34;281&#34; height=&#34;408&#34; srcset=&#34;uploads/2015/02/pngbase643ef91c517603490c.png 281w, uploads/2015/02/pngbase643ef91c517603490c-96x139.png 96w&#34; sizes=&#34;(max-width: 281px) 100vw, 281px&#34; /&gt;
&lt;/h2&gt;

&lt;h2 id=&#34;tl-dr&#34;&gt;TL;DR&lt;/h2&gt;

&lt;p&gt;Antes de iniciarmos o post, vale lembrar que em momento nenhum eu e o &lt;a href=&#34;https://twitter.com/PedroPolisenso&#34; target=&#34;_blank&#34;&gt;Pedro Polisenso&lt;/a&gt; estamos elegendo o melhor ou pior generator, visto que o output desse tipo de ferramenta é geralmente o mesmo dependendo da comparação, sendo assim, cabe a você analisar prós e contras de cada um e realizar uma escolha satisfatória pra sua necessidade.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mas vamos parar de mimimi e vamos ao que importa.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;slush-um-gerador-baseado-em-streamings-e-no-gulp&#34;&gt;Slush, um gerador baseado em streamings (e no gulp).&lt;/h2&gt;

&lt;p&gt;Nossa! Entramos no assunto principal e de cara deixando explícito que o &lt;a href=&#34;http://slushjs.github.io/&#34; target=&#34;_blank&#34;&gt;Slush&lt;/a&gt; utiliza Streamings e o Gulp, e se usa eles, já que todo mundo fala de Streamings e Gulp, é porque é bom, não é? Mas o que são Streamings e porque isso pode fazer a diferença na escolha do Slush como gerador? E que raios é esse tal de Gulp?&lt;/p&gt;

&lt;h3 id=&#34;stream&#34;&gt;Stream&lt;/h3&gt;

&lt;p&gt;Sendo bem objetivo, &lt;a href=&#34;http://pt.wikipedia.org/wiki/Stream&#34; target=&#34;_blank&#34;&gt;Stream&lt;/a&gt; é um processo computacional para lidar com informações. Ok, mas o que isso quer dizer para nós? Quer dizer que&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Streams está para o Slush, Como a cereja está para o bolo.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Isso mesmo! E quando digo isso, é porque, ao utilizar Streamings ganhamos agilidade para trabalhar com dados provenientes de arquivos ou seja lá qual for a origem, pois esta forma de processo, armazena toda a informação em memória, o que não nos obriga por exemplo, abrir(&lt;em&gt;ler&lt;/em&gt;) e fechar(&lt;em&gt;escrever&lt;/em&gt;) arquivos e/ou conexões o todo tempo para manipular essa informação, além de outros benefícios, que não vou abordar neste post, visto que o foco dele é o Slush, certo? 😀&lt;/p&gt;

&lt;h3 id=&#34;gulp&#34;&gt;Gulp&lt;/h3&gt;

&lt;p&gt;O &lt;a href=&#34;http://gulpjs.com/&#34; target=&#34;_blank&#34;&gt;Gulp&lt;/a&gt; é um Task Runner baseado em Streamings, e ao ler isso, normalmente a pessoa faz uma cara de espertinho, sabendo de cara que esse é o motivo do Slush ser um Scaffolding Generator baseado em Streamings (&lt;em&gt;dã&lt;/em&gt;). Ok! Mas ao chegar nessa conclusão, o que digo a vocês é que estão &lt;strong&gt;CERTÍSSIMOS&lt;/strong&gt; 😉&lt;/p&gt;

&lt;p&gt;Mas não é só isso, Gulp é de fácil uso, alta eficiência e qualidade de código, e além de tudo, fácil de aprender e isso o Slush herda por default ao utilizar ele.&lt;/p&gt;

&lt;p&gt;Tá! Mas não da pra falar do Gulp sem falar do Grunt (&lt;em&gt;mimimi4ever&lt;/em&gt;), porém, não quero gerar nenhum flame, o principal tópico que tenho a dizer sobre isso, é que no final, ambos tem a mesma finalidade, mas a forma de execução e as vezes de processamento, é que pode variar… oO&amp;#8230;mas vamos deixar esses breves conceitos embutidos pra lá e voltar ao assunto principal&amp;#8230;&lt;/p&gt;

&lt;h2 id=&#34;tudo-bem-mas-8230-é-só-isso-que-o-slush-tem-de-bom&#34;&gt;Tudo bem, mas&amp;#8230; é só isso que o Slush tem de bom?&lt;/h2&gt;

&lt;p&gt;Se fosse só o uso do Gulp e Streamings já seria bastante coisa, mas a boa notícia é que o Slush tem muito mais a oferecer, e para ilustrar, fiz uma pequena lista de benefícios trazidos por ele:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://slushjs.github.io/generators/#/&#34; target=&#34;_blank&#34;&gt;Repositório de Generators oficial&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;É extremamente flexível para criação e distribuição de Generators;&lt;/li&gt;
&lt;li&gt;Faz tudo que o Grunt faz, e muita das vezes de forma bem mais simples;&lt;/li&gt;
&lt;li&gt;Utiliza o Gulp em sua base e que por sua vez aplica outros inúmeros benefícios e comodidades;&lt;/li&gt;
&lt;li&gt;É totalmente testavél.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;entendi-e-gostei-como-faço-para-começar-a-utilizar&#34;&gt;Entendi e gostei, como faço para começar a utilizar?&lt;/h2&gt;

&lt;h4 id=&#34;instalação&#34;&gt;Instalação&lt;/h4&gt;

&lt;p&gt;Para instalar o Slush, basta você ter o &lt;a href=&#34;http://nodejs.org/&#34; target=&#34;_blank&#34;&gt;NodeJS&lt;/a&gt; no seu computador e executar o seguinte comando no terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ npm install -g slush
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para testar a instalação, basta executar o comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ slush -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se ele retonar a versão do mesmo, é porque ocorreu tudo supimpa (&lt;em&gt;rs&amp;#8230;&lt;/em&gt;).&lt;/p&gt;

&lt;h4 id=&#34;utilizando-generators-de-terceiros&#34;&gt;Utilizando Generators de terceiros&lt;/h4&gt;

&lt;p&gt;Para utilizar Generators de terceiros ou até mesmo distribuir e utilizar os que você criar em qualquer lugar daqui pra frente, vamos recorrer ao repositório disponibilizado pelo &lt;a href=&#34;http://joakim.beng.se/&#34; target=&#34;_blank&#34;&gt;criador do Slush&lt;/a&gt;, que você pode conferir &lt;a href=&#34;http://slushjs.github.io/generators/#/&#34; target=&#34;_blank&#34;&gt;aqui&lt;/a&gt;. Nele existem centenas de Generators dos mais variados tipos e finalidades, e para exemplificar o uso de Generators de terceiros, irei utilizar um que eu mesmo criei: O &lt;a href=&#34;https://github.com/webcomponents/slush-element/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;slush-element&lt;/strong&gt;&lt;/a&gt;, que basicamente serve pra criar Web Components, utilizando-se do padrão do Polymer, X-Tags ou Nativo (VannilaJS).&lt;/p&gt;

&lt;p&gt;Para iniciarmos o uso do generator &lt;strong&gt;element&lt;/strong&gt;, precisamos instalar o mesmo e para isso, basta executar o seguinte comando no terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ npm install -g &amp;lt;strong&amp;gt;slush-element&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Após concluir a instalação, você poderá executar esse generator em sua forma &lt;em&gt;default&lt;/em&gt; ou através de tarefas disponibilizadas, e a forma de se fazer isso, eu exemplifico logo abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Executando tarefa &amp;lt;em&amp;gt;&#39;default&#39;&amp;lt;/em&amp;gt; do generator &amp;lt;strong&amp;gt;element&amp;lt;/strong&amp;gt;
 $ slush element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ou então, se desejar e caso exista alguma tarefa específica, faça o seguinte:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Executando tarefa &amp;lt;em&amp;gt;&#39;repo&#39;&amp;lt;/em&amp;gt; do generator &amp;lt;strong&amp;gt;element&amp;lt;/strong&amp;gt;
 $ slush element:&amp;lt;strong&amp;gt;repo&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas claro, existem múltiplas opções de saída dentro deste exemplo, porém, vai lá, instala o generator, teste-o e divirta-se, e principalmente se você curtir o assunto Web Components como eu, este gerador será uma super mão na roda pra você. Mas para saber mais sobre ele, acesse este &lt;a href=&#34;https://github.com/webcomponents/slush-element&#34;&gt;link&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;bacana-mas-e-seu-eu-quiser-fazer-um-comofaz&#34;&gt;Bacana, mas e seu eu quiser fazer um? #comofaz&lt;/h2&gt;

&lt;p&gt;Bom, não irei aprofundar muito nos detalhes de criação, pois dá pra fazer uma série só sobre esses detalhes, mas irei demonstrar os arquivos necessários para desenvolvermos um Generator para o Slush e também colocarei o conteúdo que cada um deles necessita com comentários explicativos, mas qualquer dúvida a mais que você tiver, é só deixar nos comentários! Vou ter um prazer enorme em responder. E lá vamos nós 😀&lt;/p&gt;

&lt;pre&gt;slush-boilerplate/
   node_modules/         # Diretório de instalação local das dependências obrigatórias do Slush e do seu generator, se ele tiver alguma.
   templates/            # Local que armazenamos os templates do generator.
   templates/index.html  # Arquivo* de template [&lt;em&gt;*poderia ser qualquer arquivo&lt;/em&gt;].
   package.json          # Arquivo de configuração do NodeJS e onde ficam declaradas as dependências do Slush   Generator.
   slushfile.js          # Arquivo de configuração que o Slush busca para execução do generator.&lt;/pre&gt;

&lt;h3 id=&#34;arquivo-package-json&#34;&gt;Arquivo package.json&lt;/h3&gt;

&lt;p&gt;Em primeiro lugar, vou falar do &lt;em&gt;package.json,&lt;/em&gt; que além de declarar as dependências necessárias para que o Slush e o Generator possa trabalhar, possui uma keyword chamada &lt;strong&gt;slushgenerator&lt;/strong&gt;, que é obrigatória para indexação no repositório oficial de Generators do Slush, mas não se preocupe em colocar outras além dessa, pois isso também ajudará na hora de buscar pelo seu Generator. Segue o modelo do package.json do nosso Generator abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;slush-boilerplate&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;A slush generator boilerplate&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;homepage&amp;quot;: &amp;quot;https://github.com/obetomuniz/slush-boilerplate&amp;quot;,
  &amp;quot;author&amp;quot;: {
    &amp;quot;name&amp;quot;: &amp;quot;Beto Muniz&amp;quot;,
    &amp;quot;email&amp;quot;: &amp;quot;contato@betomuniz.com&amp;quot;
  },
  &amp;quot;repository&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;git://github.com/obetomuniz/slush-boilerplate.git&amp;quot;
  },
  &amp;quot;bugs&amp;quot;: {
    &amp;quot;url&amp;quot;: &amp;quot;https://github.com/obetomuniz/slush-boilerplate/issues&amp;quot;
  },
  &amp;quot;licenses&amp;quot;: [{
    &amp;quot;type&amp;quot;: &amp;quot;MIT&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;https://github.com/obetomuniz/slush-boilerplate/blob/master/LICENSE&amp;quot;
  }],
  &amp;quot;main&amp;quot;: &amp;quot;slushfile.js&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
&amp;lt;strong&amp;gt;    &amp;quot;gulp&amp;quot;: &amp;quot;^3.8.7&amp;quot;,
    &amp;quot;gulp-conflict&amp;quot;: &amp;quot;^0.3.0&amp;quot;,
    &amp;quot;gulp-install&amp;quot;: &amp;quot;^0.2.0&amp;quot;,
    &amp;quot;gulp-template&amp;quot;: &amp;quot;^2.0.0&amp;quot;,
    &amp;quot;inquirer&amp;quot;: &amp;quot;^0.8.0&amp;quot;&amp;lt;/strong&amp;gt;
  },
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;&amp;lt;strong&amp;gt;slushgenerator&amp;lt;/strong&amp;gt;&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;arquivo-slushfile-js&#34;&gt;Arquivo slushfile.js&lt;/h4&gt;

&lt;p&gt;Em segundo lugar e não menos importante, iremos criar o &lt;em&gt;slushfile.js&lt;/em&gt;, mas para entender melhor como funciona cada parte, leia os comentários no conteúdo logo abaixo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;use strict&#39;;

// Requisição das dependências do Slush
var gulp = require(&#39;gulp&#39;),
    install = require(&#39;gulp-install&#39;),
    conflict = require(&#39;gulp-conflict&#39;),
    template = require(&#39;gulp-template&#39;),
    inquirer = require(&#39;inquirer&#39;);

// Aqui está nossa tarefa default, ou seja, ao executarmos o comando `&amp;lt;em&amp;gt;slush boilerplate&amp;lt;/em&amp;gt;`, esta tarefa é a que será chamada.
gulp.task(&#39;default&#39;, function(done) {

  // Está é a lista de perguntas. Podemos aplicar uma ou mais perguntas, e de diferentes tipos como: lista, checklist, boleano, texto, etc.
  var prompts = [{
    name: &#39;seuNome&#39;,
    message: &amp;quot;Qual seu nome?&amp;quot;,
    default: &amp;quot;Fulano de Tal&amp;quot;
  }];

  inquirer.prompt(prompts, function(answers) {

    // Aqui os templates são declarados para serem encontrados no diretório `&amp;lt;em&amp;gt;templates&amp;lt;/em&amp;gt;`
    var files = [];
    files.push(__dirname + &#39;/templates/**&#39;);

    // Executando e processando nossos arquivos a serem gerados.
    gulp.src(files)
      .pipe(template(answers))
      .pipe(conflict(&#39;./&#39;))
      .pipe(gulp.dest(&#39;./&#39;))
      .pipe(install())
      .on(&#39;end&#39;, function() {
        done();
      });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;diretório-templates&#34;&gt;Diretório `&lt;em&gt;templates&lt;/em&gt;`&lt;/h4&gt;

&lt;p&gt;Neste diretório serão armazenado os arquivos que serão entregues ao se utilizar o Generator. No nosso caso, iremos entregar dentro do diretório apenas um arquivo &lt;em&gt;index.html&lt;/em&gt;, mas nada impede você de colocar imagens, vídeos, sub-diretórios, arquivos de JavaScript, folhas de estilo, Markdown, ou seja, qualquer tipo de arquivo pode ser um “template” aqui dentro.&lt;/p&gt;

&lt;h4 id=&#34;arquivo-index-html-dentro-do-diretório-templates&#34;&gt;Arquivo `&lt;em&gt;index.html&lt;/em&gt;` dentro do diretório `&lt;em&gt;templates&lt;/em&gt;`&lt;/h4&gt;

&lt;pre class=&#34;prettyprint lang-html&#34;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&#34;UTF-8&#34;&amp;gt;
  &amp;lt;title&amp;gt;Slush - Simple Bootstrap&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;h1&amp;gt;Olá, &amp;lt;%= seuNome %&amp;gt;.&amp;lt;/h1&amp;gt; &amp;lt;!-- Repare que coloco a mesma declaração de variável que eu crio na resposta da pergunta do slushfile.js. --&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E basicamente serão estes 3 arquivos + um sub-diretório que iremos precisar.&lt;/p&gt;

&lt;p&gt;Para testar localmente, além de ter o Slush instalado e ter rodado o comando &lt;code&gt;npm install&lt;/code&gt; no diretório do nosso Generator, será preciso executar no seu terminal o comando &lt;code&gt;npm link .&lt;/code&gt; dentro do diretório do nosso Generator, e assim, o mesmo será adicionado a lista de módulos do NPM do seu computador para uso normal.&lt;/p&gt;

&lt;p&gt;Em no nosso caso após executar o comando &lt;code&gt;npm link .&lt;/code&gt; iremos executar o comando abaixo dentro de uma pasta qualquer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $ slush boilerplate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ao fazer isso, será perguntado a você o seu nome, e em seguida, um arquivo &lt;em&gt;index.html&lt;/em&gt; será criado  neste diretório. Sim, é só isso mesmo 🙂&lt;/p&gt;

&lt;p&gt;E por fim, para distribuir seu generator, será necessário uma conta no &lt;a href=&#34;https://www.npmjs.com/&#34; target=&#34;_blank&#34;&gt;NPMJS.ORG&lt;/a&gt; e a execução do comando &lt;code&gt;npm publish&lt;/code&gt; dentro do diretório do seu Generator. Caso você não esteja logado localmente no NPM, ao executar o comando, será solicitado seu &lt;strong&gt;username, senha e email&lt;/strong&gt; cadastrados no &lt;em&gt;NPMJS.ORG&lt;/em&gt;, para prosseguir, basta oferecer tais dados e executar novamente o comando &lt;code&gt;npm publish&lt;/code&gt;. E por fim, pra conferir a publicação, basta acessar sua conta no &lt;em&gt;NPMJS.ORG&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OBS:&lt;/strong&gt; Se seu Generator tiver a keyword &lt;strong&gt;slushgenerator&lt;/strong&gt;, em pouco tempo ele será adicionado automaticamente no Repositório oficial de Generators do Slush.&lt;/p&gt;

&lt;h2 id=&#34;e-isso-é-tudo-pessoal-8230-o&#34;&gt;E isso é tudo pessoal&amp;#8230; o/&lt;/h2&gt;

&lt;p&gt;Mas antes de fechar o post, primeiramente espero que tenham gostado do tema e agradeço imensamente a leitura, mas deixo a dica para que não se prendam apenas nesse post, sempre busquem outras fontes de conhecimento, pois só assim, o seu senso crítico irá evoluir. Ah! E não deixem pra lá outros tópicos abordados aqui, como Streamings, Gulp, Grunt e bolos (sim, bolos).&lt;/p&gt;

&lt;p&gt;Mas é isso&amp;#8230;Um abração!!! E até o próximo post.&lt;/p&gt;

&lt;h2 id=&#34;referências&#34;&gt;Referências&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/slushjs/mock-gulp-dest&#34; target=&#34;_blank&#34;&gt;Ferramenta de Testes para Slush&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Stream_%28computing%29&#34; target=&#34;_blank&#34;&gt;Stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gulpjs.com/&#34; target=&#34;_blank&#34;&gt;GulpJS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://slushjs.github.io/#/&#34; target=&#34;_blank&#34;&gt;Slush&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://slushjs.github.io/generators/#/&#34; target=&#34;_blank&#34;&gt;Slush Generators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://nodejs.org/&#34; target=&#34;_blank&#34;&gt;NodeJS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/&#34; target=&#34;_blank&#34;&gt;NPMJS.ORG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/obetomuniz/slush-boilerplate&#34; target=&#34;_blank&#34;&gt;Slush Generator Boilerplate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webcomponents/slush-element&#34; target=&#34;_blank&#34;&gt;Slush Element&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignleft size-medium wp-image-46783&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/02/elvis-thanks.gif&#34; alt=&#34;elvis-thanks&#34; width=&#34;247&#34; height=&#34;139&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gulp: O novo automatizador</title>
      <link>https://tableless.github.io/hugo-public/gulp-o-novo-automatizador/</link>
      <pubDate>Mon, 20 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/gulp-o-novo-automatizador/</guid>
      <description>

&lt;p&gt;Se você não esteve morando em baixo de uma rocha pelos últimos meses, provavelmente conhece o automatizador de tarefas &lt;a href=&#34;http://tableless.com.br/grunt-voce-deveria-estar-usando/&#34;&gt;Grunt&lt;/a&gt;, que já dominava a área há algum tempo. Mas agora, chegou um novo automatizador chamado &lt;a href=&#34;http://gulpjs.com&#34;&gt;Gulp&lt;/a&gt; que promete realizar suas tarefas de forma mais rápida e simples do que seu concorrente.&lt;/p&gt;

&lt;p&gt;Caso você não saiba, automatizadores de tarefa são ferramentas que ajudam programadores &lt;del&gt;preguiçosos&lt;/del&gt; a realizarem tarefas repetitivas mas essenciais para o desenvolvimento como: concatenação de arquivos, minificação, testes e muitas outras coisas necessárias para a criação de um código rápido e eficiente.&lt;/p&gt;

&lt;h3 id=&#34;por-que-gulp&#34;&gt;Por que Gulp?&lt;/h3&gt;

&lt;p&gt;Se você já utiliza o Grunt em seus projetos, deve estar se perguntando por que mudar de automatizador. A resposta é simples: O Gulp é muito mais rápido que o Grunt, já que faz uso das streams do nodejs para escrever arquivos diretamente para o disco, dispensando intermediários. Sem falar na simplicidade do Gulpfile(equivalente ao Gruntfile), que utiliza uma sintaxe de código semelhante ao código comum do nodejs.&lt;/p&gt;

&lt;p&gt;Espero que até o final do texto você fique impressionado com a simplicidade do Gulp, e pense duas vezes antes de escolher o automatizador de tarefas para o seu próximo projeto.&lt;/p&gt;

&lt;h3 id=&#34;instalação&#34;&gt;Instalação&lt;/h3&gt;

&lt;p&gt;Lembrando que o Gulp roda no &lt;a href=&#34;http://nodejs.org/&#34;&gt;nodejs&lt;/a&gt; então é preciso que você o tenha instalado no seu computador, caso esteja tudo ok, basta rodar o comando abaixo na sua linha de comando para instalar o CLI:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;npm install -g gulp
&lt;/pre&gt;

&lt;p&gt;Caso você esteja em um sistema baseado em Unix, talvez seja preciso rodar `sudo` antes do comando acima. Agora você vai poder rodar o Gulp na sua linha de comando. Para ver a versão instalada, execute:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp -v
&lt;/pre&gt;

&lt;p&gt;Se o comando acima retornar a versão do Gulp instalada, a instalação foi um sucesso.&lt;/p&gt;

&lt;h3 id=&#34;iniciando-com-o-gulp&#34;&gt;Iniciando com o Gulp&lt;/h3&gt;

&lt;p&gt;Agora vamos ao que interessa, a automatização! O Gulp faz uso do Gulpfile para configuração das tarefas que ele vai rodar, que é o único arquivo necessário.&lt;/p&gt;

&lt;p&gt;Para nossos testes, criei uma estrutura desta forma:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;|projeto/
|--dist/
|--src/
|----source.js
|--Gulpfile.js
&lt;/pre&gt;

&lt;p&gt;Vou rodar três testes diferentes: Concatenação, minificação e teste de código com o jshint. O Gulp faz uso de &lt;a href=&#34;http://gratimax.github.io/search-gulp-plugins/&#34;&gt;plugins&lt;/a&gt; para facilitar a criação de tarefas, então vou instalar alguns para nós rodarmos nossos testes.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;npm install gulp gulp-jshint gulp-uglify gulp-concat gulp-rename --save-dev
&lt;/pre&gt;

&lt;p&gt;Note que eu instalei o próprio Gulp DE NOVO e alguns plugins. Isto é porque o Gulp instalado anteriormente foi o CLI, responsável por rodar o comando `gulp` na linha de comando e o instalado desta vez é o local que é usado para rodar os testes no projeto. Agora podemos criar nosso Gulpfile:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// Aqui nós carregamos o gulp e os plugins através da função `require` do nodejs
var gulp = require(&#39;gulp&#39;);
var jshint = require(&#39;gulp-jshint&#39;);
var uglify = require(&#39;gulp-uglify&#39;);
var concat = require(&#39;gulp-concat&#39;);
var rename = require(&#39;gulp-rename&#39;);

// Definimos o diretorio dos arquivos para evitar repetição futuramente
var files = &#34;./src/*.js&#34;;

//Aqui criamos uma nova tarefa através do ´gulp.task´ e damos a ela o nome &#39;lint&#39;
gulp.task(&#39;lint&#39;, function() {

// Aqui carregamos os arquivos que a gente quer rodar as tarefas com o `gulp.src`
// E logo depois usamos o `pipe` para rodar a tarefa `jshint`
gulp.src(files)
.pipe(jshint())
.pipe(jshint.reporter(&#39;default&#39;));
});

//Criamos outra tarefa com o nome &#39;dist&#39;
gulp.task(&#39;dist&#39;, function() {

// Carregamos os arquivos novamente
// E rodamos uma tarefa para concatenação
// Renomeamos o arquivo que sera minificado e logo depois o minificamos com o `uglify`
// E pra terminar usamos o `gulp.dest` para colocar os arquivos concatenados e minificados na pasta build/
gulp.src(files)
.pipe(concat(&#39;./dist&#39;))
.pipe(rename(&#39;dist.min.js&#39;))
.pipe(uglify())
.pipe(gulp.dest(&#39;./dist&#39;));
});

//Criamos uma tarefa &#39;default&#39; que vai rodar quando rodamos `gulp` no projeto
gulp.task(&#39;default&#39;, function() {

// Usamos o `gulp.run` para rodar as tarefas
// E usamos o `gulp.watch` para o Gulp esperar mudanças nos arquivos para rodar novamente
gulp.run(&#39;lint&#39;, &#39;dist&#39;);
gulp.watch(files, function(evt) {
gulp.run(&#39;lint&#39;, &#39;dist&#39;);
});
});
&lt;/pre&gt;

&lt;p&gt;O código acima está muito bem comentado e dispensa mais explicações. Caso você tenha usado o Grunt anteriormente, percebeu como a criação de tarefas com o Gulpfile é muito mais simples. Para rodar as tarefas, rode o comando:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp
&lt;/pre&gt;

&lt;p&gt;Perceba que ele executa a rotina de tarefas que você definiu e fica esperando mudanças no seu código para rodar novamente(lembra do watch?), mas se você quiser rodar apenas um tarefa específica, basta adicionar o nome da tarefa após o comando:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp lint
&lt;/pre&gt;

&lt;p&gt;No exemplo acima rodamos o teste de código usando o nome da task que definimos anteriormente.&lt;/p&gt;

&lt;h3 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h3&gt;

&lt;p&gt;Enfim, neste texto vimos como usar o Gulp para automatizar as tarefas do seu próximo projeto de forma simples e eficiente. O Gulp é um projeto novo e que ainda deve amadurecer muito nas próximas semanas. Caso você queira contribuir de alguma maneira, acesse o projeto no &lt;a href=&#34;https://github.com/gulpjs/gulp&#34;&gt;github&lt;/a&gt; e veja como ajudar.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>