<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pre Processador on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/pre-processador/index.xml</link>
    <description>Recent content in Pre Processador on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/pre-processador/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Instalando SASS na máquina – video</title>
      <link>https://tableless.github.io/hugo-public/instalando-sass-na-maquina-video/</link>
      <pubDate>Mon, 18 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/instalando-sass-na-maquina-video/</guid>
      <description>

&lt;p&gt;Se você quiser usar um pré-processador em seus projetos, aqui vão instruções simples para você começar agora. Darei mais atenção para quem usa Mac porque é o sistema que eu uso. Mas no Windows as instruções são quase as mesmas, principalmente se você for usar algum sistema que gerencia os assets. Também estou abordando aqui apenas o SASS, nada de LESS, Style ou qualquer outro pré-processador. Depois desse disclaimer, vamos ao que interessa.&lt;/p&gt;

&lt;h2 id=&#34;iniciando&#34;&gt;Iniciando&lt;/h2&gt;

&lt;p&gt;Um pré-processador precisa ser pré-processado (!) antes do código resultante seja renderizado pelo browser. Isso quer dizer que o browser nunca (nunca diga nunca) vai ler direto seu código SASS e renderizar seu código. Por isso, você precisa de um parser, que vai ler seu SASS, salvar em um arquivo CSS para seu browser renderizar o CSS.&lt;/p&gt;

&lt;p&gt;O SASS é uma GEM do Ruby, logo, invariavelmente você vai precisar do Ruby. Por isso, existem duas maneiras de você usar um Pré-processador sem se preocupar em preparar seu ambiente e rodar SASS com tranquilidade. A primeira forma é usando alguma aplicação que vai ler e parsar seus arquivos SASS, sem a necessidade do Ruby no ambiente. Claro, você vai precisar esperar alguns segundos para dar um refresh na página. Isso acontece por que o aplicativo está parseando seu código.&lt;/p&gt;

&lt;p&gt;A outra maneira é a melhor, você não tem esse delay de segundos, mas é mais complicada para quem não está acostumado com Terminal. Mesmo assim, é tão fácil, tão fácil, que eu sugiro que você tente primeiro fazer funcionar o SASS pelo terminal, se conseguir, tente usar a aplicação.&lt;/p&gt;

&lt;h2 id=&#34;scout&#34;&gt;Scout&lt;/h2&gt;

&lt;p&gt;Existem várias aplicações que compilam SASS e outras linguagens como CoffeeScript, TypeScript, LESS, Stylus e etc. A maioria deles é pago, mas muito bons. Se você preferir pagar, sugiro que use o mais famoso que é o &lt;a href=&#34;http://incident57.com/codekit/&#34;&gt;CodeKit&lt;/a&gt;. Mas se você não quer pagar nada, sugiro o Scout.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&#34;http://mhs.github.io/scout-app/&#34;&gt;Scout&lt;/a&gt; (tem para Windows e Mac) é um compilador para exclusivo SASS/Compass e ele tem um único objetivo, ler seus arquivos SASS, parsear, compilar e por fim salvar em uma pasta no formato CSS.&lt;/p&gt;

&lt;p&gt;Fiz um vídeo mudo (sou tímido) que mostra como adicionar um projeto no Scout. Basicamente você escolhe a pasta do projeto e indica quais as pastas onde ele vai encontrar os arquivos SASS e onde ele vai salvar os arquivos .CSS. Normalmente eu escolho sempre a mesma pasta, mas você pode escolher uma outra pasta que vai salvar os arquivos CSS finais. Veja abaixo o vídeo:&lt;/p&gt;

&lt;p&gt;Se você quiser testar outra aplicação em vez do Scout, experimente o &lt;a href=&#34;http://koala-app.com&#34;&gt;Koala&lt;/a&gt;. Ele também é free e compila outros pré-processadores como o LESS e CoffeeScript.&lt;/p&gt;

&lt;h2 id=&#34;usando-o-terminal&#34;&gt;Usando o terminal&lt;/h2&gt;

&lt;p&gt;Para usar no terminal, você precisa ter na máquina Ruby e a gem do Sass instalada. Feito isso, você vigia a pasta com os arquivos SASS com o comando abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;sass --watch [diretório dos arquivos SASS]
&lt;/pre&gt;

&lt;p&gt;Simples assim.&lt;/p&gt;

&lt;p&gt;Se você quiser avançar e já leu sobre Compass e sua facilidade de usar CSS3, você usá-lo para vigiar sua pasta. Para iniciar o projeto:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;compass create [nome do projeto]
&lt;/pre&gt;

&lt;p&gt;Se você já tiver a pasta do projeto, basta fazer o mesmo comando. Ele vai criar dentro da pasta uma pasta chamada &lt;strong&gt;sass&lt;/strong&gt;, com os arquivos SASS, uma pasta &lt;strong&gt;stylesheet&lt;/strong&gt;, que é onde vai ficar o código CSS resultante do SASS. Ele vai criar também um arquivo &lt;strong&gt;config.rb&lt;/strong&gt;, que é onde fica as configurações do seu projeto.&lt;/p&gt;

&lt;p&gt;Quando tiver feito esse comando acima, e claro, ter linkado o CSS no seu arquivo HTML, você pode começar digitar o comando &lt;strong&gt;compass watch&lt;/strong&gt;, que vai vigiar a pasta stylesheets procurando por arquivos SASS e transformando-os em CSS.&lt;/p&gt;

&lt;p&gt;Abaixo, veja outro vídeo mudo, onde eu crio o projeto e modifico o &lt;strong&gt;config.rb&lt;/strong&gt; do Compass para que a estrutura de pastas fique do jeito que eu gosto, geralmente para mudar a estrutura de pastas, inserindo as pastas de stylesheets, imagens e javascripts para dentro da pasta &lt;strong&gt;assets&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Eu vou tentar melhorar ainda mais esse passo a passo com o tempo. Não encontrei nenhum lugar onde ensinasse exatamente como fazer para rodar SASS na máquina sem estar em um projeto Ruby. Isso era uma dificuldade para devs novatos que querem experimentar as maravilhosas peripécias do SASS.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Utilizando Map Structure do Sass</title>
      <link>https://tableless.github.io/hugo-public/utilizando-maps-sass/</link>
      <pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/utilizando-maps-sass/</guid>
      <description>

&lt;p&gt;O Sass é um pré-processador usado para melhorar sua produtividade ao codificar CSS. Dentre as várias funcionalidades, existe uma chamada &lt;code&gt;maps&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;maps&lt;/code&gt; é como um array de variáveis. Ela guarda uma série de chaves com valores. A sintaxe é bastante comum, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$map: (
  key1: value1, 
  key2: value2, 
  key3: value3
);
&lt;/pre&gt;

&lt;p&gt;A primeira vista se parece com Json, né?&lt;/p&gt;

&lt;p&gt;A ideia é que você consiga pegar o valor de qualquer chave que está dentro do seu mapa e usar em momentos onde você irá repetir bastante código.&lt;/p&gt;

&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;

&lt;p&gt;No exemplo abaixo, vou mostrar uma situação muito comum ao desenvolvermos um site com variação de temas de cores. Na maneira normal, você faria um código basicamente assim:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.tema-azul body {
  background-color: #0176bb;
}

.tema-vermelho body {
  background-color: #e3413e;
}

.tema-amarelo body {
  background-color: #f8e042;
}
&lt;/pre&gt;

&lt;p&gt;Usando o mapa do SASS, a primeira coisa que faríamos seria separar as cores em variáveis, assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$cores: (
  azul: #0176bb, 
  vermelho: #e3413e, 
  amarelo: #f8e042
);
&lt;/pre&gt;

&lt;p&gt;E faríamos uma função dessa forma:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@each $tema, $cor in $cores {
  .tema-#{tema} body {
     background-color: $cor;
  }
}
&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;$tema&lt;/code&gt; seria cada uma das chaves, no nosso caso &lt;code&gt;azul&lt;/code&gt;, &lt;code&gt;vermelho&lt;/code&gt; e &lt;code&gt;amarelo&lt;/code&gt;. O &lt;code&gt;$cor&lt;/code&gt; seria cada um dos valores dos temas, ou seja, os valores hexadecimais. A função &lt;code&gt;@each&lt;/code&gt; está dizendo assim: a cada valor dos temas (azul, vermelho, amarelo) que encontrar no mapa &lt;code&gt;$cores&lt;/code&gt;, repita o bloco de código.&lt;/p&gt;

&lt;p&gt;Isso resultaria no seguinte código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.tema-azul body {
  background-color: #0176bb;
}

.tema-vermelho body {
  background-color: #e3413e;
}

.tema-amarelo body {
  background-color: #f8e042;
}
&lt;/pre&gt;

&lt;p&gt;Isso salva vidas. Agora vamos complicar mais. Normalmente um tema é composto de mais cores. Para isso o mapa vai ficar parecido isso:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$cores: (
  azul: (
    color1: #0176bb, 
    color2: #23aad0,
    color3: #edf7fd
  ),
  vermelho: (
    color1: #e3413e, 
    color2: #1f518c,
    color3: #f8e042
  ),
  amarelo: (
    color1: #4a5269, 
    color2: #fc7d74,
    color3: #4a5269
  )
);
&lt;/pre&gt;

&lt;p&gt;O código do &lt;code&gt;@each&lt;/code&gt; não mudará muito, mas precisaremos guardar cada uma dessas cores dentro de uma variável que será usada no código final. Ficará assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@each $tema, $cor in $cores {
  $color1: map-get($cor, color1);
  $color2: map-get($cor, color2);
  $color3: map-get($cor, color3);
}
&lt;/pre&gt;

&lt;p&gt;Explicando: a cada &lt;code&gt;$tema&lt;/code&gt; (azul, vermelho e amarelo) que há no mapa &lt;code&gt;$cores&lt;/code&gt;, ele vai gravar as variáveis &lt;code&gt;$color1&lt;/code&gt;, &lt;code&gt;$color2&lt;/code&gt; e &lt;code&gt;$color3&lt;/code&gt;. A função &lt;code&gt;map-get&lt;/code&gt; vai pegar o valor específico de cada variável &lt;code&gt;color1&lt;/code&gt;, &lt;code&gt;color2&lt;/code&gt; e &lt;code&gt;color3&lt;/code&gt; de cada tema e irá guardar. O código CSS fica assim:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@each $tema, $cor in $cores {
  $color1: map-get($cor, color1);
  $color2: map-get($cor, color2);
  $color3: map-get($cor, color3);

  .color-#{$tema} {
    body {
      background-color: $color1;
    }

    .header {
      background-color: $color2;
    }

    .menu a {
      background-color: $color3;
    }

  }
}
&lt;/pre&gt;

&lt;p&gt;Ele vai repetir o bloco acima uma vez para cada tema de cor. No nosso caso, 3 vezes: uma para azul, vermelho e amarelo.&lt;/p&gt;

&lt;p&gt;Novamente: isso salva vidas.&lt;/p&gt;

&lt;p&gt;A única coisa que você vai gerenciar depois são as variáveis para modificar ou inserir novas cores.&lt;/p&gt;

&lt;p&gt;Veja abaixo um exemplo mais completo, mostrando o código final do CSS gerado:&lt;/p&gt;

&lt;p class=&#34;sassmeister&#34; data-gist-id=&#34;9fc788894331313ce485&#34; data-height=&#34;480&#34;&gt;
  &lt;a href=&#34;http://sassmeister.com/gist/9fc788894331313ce485&#34;&gt;Play with this gist on SassMeister.&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://viget.com/extend/sass-maps-are-awesome&#34;&gt;O pessoal do Viget explorou outro problema&lt;/a&gt; para resolver. Na verdade, as implicações são diversas. A qualquer momento que você tiver um bloco de código repetitivo e que depende de muitas variações, o &lt;code&gt;maps&lt;/code&gt; é indicado.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>