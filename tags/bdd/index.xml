<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bdd on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/bdd/index.xml</link>
    <description>Recent content in Bdd on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/bdd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Introdução ao Behavior Driven Development</title>
      <link>https://tableless.github.io/hugo-public/introducao-ao-behavior-driven-development/</link>
      <pubDate>Fri, 21 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-ao-behavior-driven-development/</guid>
      <description>

&lt;p&gt;O &lt;strong&gt;BDD&lt;/strong&gt; &lt;em&gt;(Behavior Driven Development ou Desenvolvimento guiado por comportamento)&lt;/em&gt;, é uma resposta ao &lt;strong&gt;TDD&lt;/strong&gt;, criado em 2003, por &lt;em&gt;Dan North&lt;/em&gt;, e tem se expandido bastante nos últimos anos. Seu foco é obter um código testado a partir de um conjunto de cenários que descrevem como a aplicação ou unidade de código deverá se comportar em determinada situação.&lt;/p&gt;

&lt;h3 id=&#34;as-práticas-de-bdd-incluem&#34;&gt;As práticas de &lt;strong&gt;BDD&lt;/strong&gt; incluem:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Envolver as partes interessadas no processo através de &lt;em&gt;Outside-in Development&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Usar linguagem ubíqua para descrever o comportamento de uma aplicação&lt;/li&gt;
&lt;li&gt;Automatizar os exemplos para provê um feedback rápido e testes de regressão&lt;/li&gt;
&lt;li&gt;Usar &lt;strong&gt;&lt;em&gt;SHOULD&lt;/em&gt;&lt;/strong&gt; na hora de descrever o comportamento de software para ajudar esclarecer responsabilidades e permitir que funcionalidades do software sejam questionadas&lt;/li&gt;
&lt;li&gt;Usar dublês de teste &lt;em&gt;(mocks, stubs, fakes, dummies, spies)&lt;/em&gt; para auxiliar na colaboração entre módulos e códigos que ainda não foram escritos&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;e-8230&#34;&gt;E&amp;#8230;&lt;/h2&gt;

&lt;p&gt;O grande lance do BDD, é que nos trabalhamos com comportamentos de uma maneira que&lt;/p&gt;

&lt;p&gt;qualquer pessoa possa entender ou escrever novos testes. Baseado no que espera que&lt;/p&gt;

&lt;p&gt;a aplicação executa o aferir uma ação específica.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Qual a vantagem disso?&lt;/em&gt; O especialista do domínio pode escrever testes.&lt;/p&gt;

&lt;p&gt;O gerente de projetos pode escrever testes. o PO pode escrever testes baseados&lt;/p&gt;

&lt;p&gt;no que ele espera da aplicação. O padeiro da esquina pode escrever testes&lt;/p&gt;

&lt;p&gt;também. Qualquer um pode descrever o que espera da aplicação sem a necessidade&lt;/p&gt;

&lt;p&gt;de ter habilidades de um programador.&lt;/p&gt;

&lt;h2 id=&#34;cenários&#34;&gt;Cenários&lt;/h2&gt;

&lt;p&gt;Cada cenário descreve uma ação que será aferida e testada. Eles devem conter&lt;/p&gt;

&lt;p&gt;passos lógicos e simple de como obter um resultado específico a partir de uma sequência&lt;/p&gt;

&lt;p&gt;de ações.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cenário 1:&lt;/strong&gt; &lt;em&gt;Quantidade de items no estoque&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dado que há 5 items no estoque&lt;/li&gt;
&lt;li&gt;E um cliente comprou 2 items do estoque&lt;/li&gt;
&lt;li&gt;Então quando contar os items restantes no estoque&lt;/li&gt;
&lt;li&gt;Terei 3 items&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como podemos perceber, desenvolvedores podem se concentrar exclusivamente nas razões pelas quais o código deve ser criado, e não em detalhes técnicos, além de minimizar traduções entre a linguagem técnica na qual o código é escrito e outras linguagens de domínio.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução ao Selenium 2</title>
      <link>https://tableless.github.io/hugo-public/introducao-ao-selenium-2/</link>
      <pubDate>Wed, 18 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-ao-selenium-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.seleniumhq.org/docs/01_introducing_selenium.jsp&#34; title=&#34;introdução ao selenium no site oficial&#34;&gt;Selenium&lt;/a&gt; é uma ferramenta de apoio às necessidades de testes em aplicações web. Altamente flexível, permite muitas opções para a localização de elementos de interface no navegador e simular comportamentos reais de um usuário. A &lt;a href=&#34;http://www.seleniumhq.org/docs/03_webdriver.jsp&#34; title=&#34;introdução ao selenium webdriver no site oficial&#34;&gt;versão 2.0&lt;/a&gt; tem como funcionalidade primária a integração da API WebDriver. Projetado para fornecer uma interface ainda mais simples, concisa e orientada a objeto, o que melhora de forma significativa o suporte aos problemas complexos que são enfrentados ao testar uma aplicação web.&lt;/p&gt;

&lt;p&gt;Essa API pode ser chamada através de diversas linguagem de programação, porém, em nosso exemplo, iremos utilizar o NodeJS (JavaScript), que pode ser baixado no &lt;a href=&#34;http://nodejs.org/download/&#34; title=&#34;site oficial do NodeJS&#34;&gt;site oficial&lt;/a&gt; e que possui um gerenciador de pacotes (Node Package Manager – NPM), o qual permite a interação com um repositório online via linha de comando, facilitando a instalação de várias outras ferramentas.&lt;/p&gt;

&lt;p&gt;Nesse exemplo, será utilizado uma ferramenta chamada &lt;a href=&#34;http://vowsjs.org/&#34; title=&#34;site oficial do vows&#34;&gt;Vows&lt;/a&gt;, gerenciada e instalada pelo NPM, que ajuda no desenvolvimento orientado a comportamento assíncrono. Usar testes assíncronos no NodeJS tem dois motivos. Primeiro (e talvez óbvio), é que o NodeJS é assíncrono e por isso os testes também deveriam ser. Segundo, é fazer com que os testes, os quais lidam com entrada e saída de dados, rodem mais rápido.&lt;/p&gt;

&lt;p&gt;Breve resumo dos conceitos do Vows. &lt;strong&gt;Suite&lt;/strong&gt;: um objeto que contêm um ou mais batches, e pode ser executado ou exportado. &lt;strong&gt;Batch&lt;/strong&gt;: uma estrutura de contextos. &lt;strong&gt;Context&lt;/strong&gt;: um objeto que pode conter um &lt;em&gt;topic&lt;/em&gt;(opcional), nenhum ou mais &lt;em&gt;vows&lt;/em&gt;, nenhum ou mais &lt;em&gt;sub-contexts&lt;/em&gt;. &lt;strong&gt;Topic&lt;/strong&gt;: pode ser tanto um valor ou uma função de código assíncrono. &lt;strong&gt;Vow&lt;/strong&gt;: é uma função que recebe o _topic_ como um argumento e roda assertivas no &lt;em&gt;topic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O teste que será feito possui quatro passos: _(i)&lt;em&gt; abrir o navegador, &lt;/em&gt;(ii)&lt;em&gt; acessar uma &lt;a href=&#34;https://saucelabs.com/test/guinea-pig&#34; title=&#34;página oficial de teste do SauceLabs&#34;&gt;página de teste&lt;/a&gt;, &lt;/em&gt;(iii)&lt;em&gt; verificar o título da página e &lt;/em&gt;(iv)_ fechar o navegador. Algo bem simples. Suficiente para experimentar a versão 2.0 do Selenium.&lt;/p&gt;

&lt;p&gt;As dependências necessárias podem ser instaladas usando o NPM, digitando o seguinte _script_ no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;npm install -g phantomjs vows &lt;/pre&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt; npm install chai wd vows &lt;/pre&gt;

&lt;p&gt;Há duas maneiras de instalar &lt;a href=&#34;http://blog.nodejs.org/2011/03/23/npm-1-0-global-vs-local-installation/&#34; title=&#34;artigo do blog oficial do NodeJS sobre os tipos de dependências&#34;&gt;dependências no NodeJS&lt;/a&gt;: globalmente ou localmente. Quando uma dependência é global, os arquivos são executáveis, tornando possível a utilização de uma dependência através da linha de comando. Quanto às dependências locais, estas são instaladas no diretório corrente, dentro de um diretório chamado _node&lt;em&gt;modules&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O primeiro &lt;em&gt;script&lt;/em&gt;, utilizando o parâmetro &lt;strong&gt;-g&lt;/strong&gt;, instala duas dependências globais: phantomjs e vows.&lt;a href=&#34;http://phantomjs.org/&#34; title=&#34;site oficial do PhantomJS&#34;&gt;PhantomsJS é um headless WebKit&lt;/a&gt;, feito totalmente em javascript e possui suporte rápido e nativo para vários padrões web como manipulação de DOM, seletores CSS, JSON, Canvas e SVG.&lt;/p&gt;

&lt;p&gt;Já o segundo &lt;em&gt;script&lt;/em&gt;, instala três dependências locais: chai, wd e vows. &lt;a href=&#34;http://chaijs.com/&#34; title=&#34;site oficial do Chai&#34;&gt;Chai&lt;/a&gt; é uma biblioteca de assertivas BDD/TDD para NodeJS e navegadores, a qual pode ser &amp;#8216;graciosamente&amp;#8217; utilizada com qualquer framework de teste JS. &lt;a href=&#34;https://github.com/admc/wd&#34; title=&#34;repositorio oficial do WebDriver no github&#34;&gt;WD&lt;/a&gt; é um cliente em NodeJS para facilitar o acesso à API do Selenium 2, a qual suporta métodos como: fazer requisições GET e POST, clicar no botão VOLTAR do navegador, fazer refresh no navegador, pegar um printscreen da tela corrente, redimensionar e mover a janela do navegador, submeter formulário, digitar texto, usar cookies, selecionar um elemento DOM, clicar e mover um elemento DOM selecionado, etc.&lt;/p&gt;

&lt;p&gt;Após a instalação de todas as dependências necessárias, vamos criar dois arquivos: _&lt;strong&gt;configuracao-webdriver-usando-phantom.js&lt;/strong&gt;&lt;em&gt; com as informações de configurações do webdriver e &lt;/em&gt;&lt;strong&gt;apenas-um-exemplo.js&lt;/strong&gt;_ com os passos-a-passos simulando o comportamento real de um usuário.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;configuracao-webdriver-usando-phantom.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;var exports   = module.exports = {},
    webdriver = require(&#39;wd&#39;),
    browser   = exports.browser = webdriver.remote({
      hostname: &#34;localhost&#34;,
      port: 8910
    });
 
/**
Vows Errored » callback not fired
http://birkett.no/blog/2013/05/01/vows-errored-callback-not-fired/
*/
process.on( &#39;uncaughtException&#39;, function(err) {
  console.error(&#39;Caught exception: &#39; + err.stack );
});
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;apenas-um-exemplo.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;var vows    = require(&#39;vows&#39;),
    expect  = require(&#39;chai&#39;).expect,
    browser = require(&#39;./configuracao-webdriver-usando-phantom.js&#39;).browser;
 
vows.describe(&#39;Apenas um exemplo&#39;)
.addBatch({
  &#39;Criando uma nova sessão no WebDriver&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.init( {}, function(err, sessionID, capabilities) {
        callback( err );
      });
    },
    &#39;Sessão criada&#39;: function() { /**...*/ }
  }
})
.addBatch({
  &#39;Acessando a página de teste do SauceLabs&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.get( &#39;http://saucelabs.com/test/guinea-pig&#39;, function(err) {
        callback( err );
      });
    },
    &#39;Página de teste aberta&#39;: function() { /**...*/ }
  }
})
.addBatch({
  &#39;Verificando o título da página&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.title( function(err, title) {
        callback( err, title );
      });
    },
    &#34;O título da página deve conter &#39;Sauce Labs&#39;&#34;: function(title) {
      expect(title).to.contain(&#39;Sauce Labs&#39;);
    },
    &#34;O título da página deve conter &#39;page title&#39;&#34;: function(title) {
      expect(title).to.contain(&#39;page title&#39;);
    },
    &#34;O título da página deve conter &#39;I am a&#39;&#34;: function(title) {
      expect(title).to.contain(&#39;I am a&#39;);
    }
  }
})
.addBatch({
  &#39;Fechando o navegador&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.quit( function(err){
        callback( err );
      });
    },
    &#39;Fim&#39;: function() { /**...*/ }
  }
}).export(module);
&lt;/pre&gt;

&lt;p&gt;Criado esses dois arquivos, é preciso, em um outro terminal, rodar o PhantomJS em modo WebDriver, digitando o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lanh-ssh&#34;&gt;phantomjs --webdriver=localhost:8910 &lt;/pre&gt;

&lt;p&gt;Uma vez o PhantomJS rodando em segundo plano, basta rodar o &lt;em&gt;vows&lt;/em&gt;, o parâmetro &lt;strong&gt;&amp;#8211;spec&lt;/strong&gt; serve apenas para ter um diferente tipo de &amp;#8216;reporter&amp;#8217;, segue o comando e uma ilustração do resultado obtido:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;vows apenas-um-exemplo.js --spec &lt;/pre&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; alt=&#34;Resultado obtido&#34; src=&#34;https://camo.githubusercontent.com/67da73c5f31ecbfaee938cf04056d96c4f2ada41/687474703a2f2f69313336382e70686f746f6275636b65742e636f6d2f616c62756d732f61673138322f69676f727269626569726f6c696d612f315f626173685f616e645f556d615f696e74726f647563636564696c6174696c64656f5f616f5f53656c656e69756d5f325f616e645f6170656e61732d756d2d6578656d706c6f6a735f6d646173685f696e74726f647563616f2d73656c656e69756d2d74776f2d31335f7a707334333166383131372e706e67&#34; width=&#34;897&#34; height=&#34;445&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Esse exemplo contempla de forma bem simples a utilização da API do WebDriver/Selenium 2. Essa abordagem também pode ser feita em &lt;a href=&#34;http://tableless.com.br/introducao-de-como-executar-testes-unitarios-em-diferentes-tipos-de-navegadores&#34; title=&#34;introdução de como executar testes unitários em diferentes tipos de navegadores&#34;&gt;diferentes tipos de navegadores&lt;/a&gt;. Como é sempre melhor começarmos aos poucos, aplicando pequenos passos de cada vez, isso ficará para uma próxima discussão. Para quem se interessar, todo código está disponível em um &lt;a href=&#34;https://gist.github.com/igorlima/7826752&#34; title=&#34;gist introduzindo o Selenium 2&#34;&gt;gist&lt;/a&gt;. Muito obrigado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução de como executar testes unitários em diferentes tipos de navegadores</title>
      <link>https://tableless.github.io/hugo-public/introducao-de-como-executar-testes-unitarios-em-diferentes-tipos-de-navegadores/</link>
      <pubDate>Wed, 04 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-de-como-executar-testes-unitarios-em-diferentes-tipos-de-navegadores/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://saucelabs.com/&#34; title=&#34;SauceLabs&#34;&gt;SauceLabs&lt;/a&gt; é uma plataforma de teste que possibilita realizar testes automáticos ou manuais em aplicações móveis e web (incluindo navegadores como Internet Explorer, Opera, Safari, Android, iPhone, Chrome etc). Essa plataforma permite executar os testes em diversas linguagem de programação, porém, em nosso exemplo, iremos utilizar o NodeJS (JavaScript).&lt;/p&gt;

&lt;p&gt;O NodeJS e o Gerenciador de Pacotes do Node (traduzido do inglês Node Package Manager &amp;#8211; NPM) podem ser baixados no &lt;a href=&#34;http://nodejs.org/download/&#34; title=&#34;site oficial NodeJS&#34;&gt;site oficial&lt;/a&gt;. Esse gerenciador de pacotes permite a interação com um repositório online via linha de comando, facilitando a instalação de várias ferramentas.&lt;/p&gt;

&lt;p&gt;Nesse exemplo, será utilizado uma ferramenta chamada &lt;a href=&#34;https://github.com/airportyh/testem&#34; title=&#34;documentação do Test&#39;em&#34;&gt;Test&amp;#8217;em&lt;/a&gt;, que é gerenciada e instalada pelo NPM. Essa ferramenta permite rodar os testes unitários de JavaScript localmente em diferentes plataformas, tornando a execução mais fácil e divertida. Test&amp;#8217;em suporta vários frameworks de teste, tais como: Jasmine, QUnit e Mocha. Para instalar, basta digitar no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;npm install testem -g&lt;/pre&gt;

&lt;p&gt;No exemplo, será utilizado o framework Jasmine. Mesmo código do &lt;a href=&#34;https://saucelabs.com/docs/javascript-unit-testing-tutorial&#34; title=&#34;tutorial oficial do SauceLabs&#34;&gt;tutorial oficial do SauceLabs&lt;/a&gt;. As especificações do código estão descritas no arquivo PastaSpec.js e a implementação no arquivo Pasta.js. Ambos arquivos encontra-se abaixo:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PastaSpec.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;describe(&#34;Pasta&#34;, function() { 
  it(&#34;should make spaghetti bolognese&#34;, function() { 
    var pasta = new Pasta(); 
    pasta.add(&#34;tomatoes&#34;); 
    pasta.add(&#34;garlic&#34;); 
    pasta.add(&#34;olive&#34;); 
    pasta.add(&#34;herbs&#34;); 
    pasta.add(&#34;meat&#34;); 
    expect(pasta.getType()).toEqual(&#34;bolognese&#34;); 
    expect(pasta.isTasty()).toEqual(true); 
  }); 

  it(&#34;should make pasta with no sauce&#34;, function() { 
    var pasta = new Pasta(); 
    pasta.add(&#34;meat&#34;); 
    expect(pasta.getType()).toEqual(undefined); 
    // pasta with no sauce? yeah that&#39;s not too tasty 
    expect(pasta.isTasty()).toEqual(false); 
  }); 
});&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Pasta.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function Pasta() { 
  // recipes for good pasta sauces 
  this.sauces = { 
    &#39;bolognese&#39;: [&#34;tomatoes&#34;, &#34;garlic&#34;, &#34;olive&#34;, &#34;herbs&#34;, &#34;meat&#34;] 
  }; 
  this.sauceIngredients = []; 
} 

Pasta.prototype.add = function (ingredient) { 
  this.sauceIngredients.push(ingredient); 
}; 

Pasta.prototype.getType = function () { 
  for (var posssibleSauce in this.sauces) { 
    var ingredientsValid = true; 
    // checking if arrays are equal 
    if (!(this.sauceIngredients.sort() &amp;gt; this.sauces[posssibleSauce].sort() || 
          this.sauceIngredients.sort() &amp;lt; this.sauces[posssibleSauce].sort())) { 
      return posssibleSauce; 
    } 
  } 
  return undefined; 
}; 

Pasta.prototype.isTasty = function () { 
  if (this.getType() !== undefined) { return true; } 
  return false; 
};&lt;/pre&gt;

&lt;p&gt;Uma vez criado o arquivo de especificação &amp;#8216;PastaSpec.js&amp;#8217; e a implementação &amp;#8216;Pasta.js&amp;#8217;, é preciso criar um arquivo de configuração &amp;#8216;&lt;em&gt;testem.json&lt;/em&gt;&amp;#8216;. Necessário apenas informar o framework utilizado e os arquivos JavaScript. Conforme escrito abaixo:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;testem.json&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;{ 
  &#34;framework&#34;: &#34;jasmine&#34;, 
  &#34;src_files&#34;: [ 
    &#34;Pasta.js&#34;, 
    &#34;PastaSpec.js&#34; 
  ] 
}&lt;/pre&gt;

&lt;p&gt;O Test&amp;#8217;em usa como padrão a porta 7357. O parâmetro &amp;#8216;&amp;#8211;port&amp;#8217; serve para especificar uma outra. Nesse caso, vamos utilizar a 8080, digitando:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;testem --port=8080&lt;/pre&gt;

&lt;p&gt;Após a execução do comando, o resultado dos testes pode ser visto pela url &lt;strong&gt;&lt;a href=&#34;http://localhost:8080/&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/strong&gt;. Caso a url seja aberta no Chrome, os testes serão executados no navegador Chrome. Caso aberta no Safari, será executado no Safari. Como ilustra a figura seguinte.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/4c25f04b60b6f6aaff1b50a0069ca0f5487860be/687474703a2f2f7332312e706f7374696d672e6f72672f6e72393273783469762f6a61736d696e655f74657374735f6f6e5f74657374656d2e706e67&#34; alt=&#34;testing Jasmine code on Test&#39;em&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para testar o código em diversos navegadores ou diversos sistemas operacionais, não é necessário ter máquinas virtuais nem mesmo outros dispositivos, como celulares ou tablet. O Sauce Labs prover o conector &lt;a href=&#34;http://saucelabs.com/downloads/Sauce-Connect-latest.zip&#34; title=&#34;Sauce Connect&#34;&gt;Sauce Connect&lt;/a&gt;. Com ele é possível criar uma conexão entre a nossa máquina e os servidores do SauceLabs, assim é possível rodar os testes dentro do firewall do Sauce Labs Cloud. Cloud que disponibiliza mais de &lt;a href=&#34;https://saucelabs.com/docs/platforms&#34; title=&#34;plataformas SauceLabs&#34;&gt;200 plataformas&lt;/a&gt;, que inclui dispositivos móveis, diversos SO e navegadores. Uma vez baixado o Sauce Connect, essa conexão é feita pelo comando:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;java -jar Sauce-Connect.jar --tunnel-identifier &#34;tabless&#34; $SAUCE_USERNAME $SAUCE_ACCESS_KEY&lt;/pre&gt;

&lt;p&gt;Vale ressaltar que _$SAUCE&lt;em&gt;USERNAME&lt;/em&gt; e &lt;em&gt;$SAUCE_ACCESS_KEY&lt;/em&gt; são variáveis de ambientes. Método recomendado para evitar a divulgação de dados privados. Para obter dados de acesso, acesse a &lt;a href=&#34;https://saucelabs.com/signup&#34; title=&#34;página de cadastro do SauceLabs&#34;&gt;página de cadastro&lt;/a&gt;. Após a criação da conta, uma chave de acesso já é fornecida, conforme é ilustrado na figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/b29a04372bbe9224392df879736467128316054e/687474703a2f2f7332312e706f7374696d672e6f72672f63673666346a786e722f73617563656c6162735f6163636f756e745f706167652e706e67&#34; alt=&#34;página inicial da conta SauceLabs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Na página inicial, o botão &lt;strong&gt;New Interactive Session&lt;/strong&gt; permite a criação de uma instância de navegador. Uma popup (ilustrada na imagem abaixo) será exibida ao clicar no botão, com várias opções de sistema operacional e de navegador.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/7de3c788dc9a56a153bada645514034a442ae6d4/687474703a2f2f7332312e706f7374696d672e6f72672f736f693230616834372f6e65775f696e7465726163746976655f73657373696f6e5f706f7075702e706e67&#34; alt=&#34;popup para a criação de uma nova instância de navegador do SauceLabs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ao instanciar o navegador, é possível visualizar o resultado dos testes no terminal (ilustração na imagem abaixo). Os testes sempre serão executados novamente caso haja alguma alteração tanto no código quanto nas especificações, possibilitando assim a prática de TDD ou BDD, utilizando qualquer tipo de navegador.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/404afe58a076603719c0448fbc1a41ca92c85e0c/687474703a2f2f7332312e706f7374696d672e6f72672f74687a39366e6369762f697061645f73617563656c6162735f73657373696f6e2e706e67&#34; alt=&#34;instancia de um iPad do SauceLabs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Esse exemplo contempla apenas a execução de testes de forma manual. Essas ferramentas que foram utilizadas também oferecem suporte para a automatização de testes, mas isso ficará para um próximo capítulo. Para quem se interessar, todo código está disponível em um &lt;a href=&#34;https://gist.github.com/igorlima/7649954&#34; title=&#34;gist do exemplo&#34;&gt;gist&lt;/a&gt;. Muito obrigado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testando seu código jQuery com Jasmine – Parte 2</title>
      <link>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-2/</link>
      <pubDate>Tue, 04 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-2/</guid>
      <description>

&lt;p&gt;Jasmine é um framework para testes focado em BDD (&lt;em&gt;Behavior Driven Development&lt;/em&gt;). Na &lt;a href=&#34;http://tableless.com.br/testando-seu-codigo-jquery-com-jasmine-parte-1/&#34;&gt;primeira parte&lt;/a&gt; deste artigo aprendemos seus métodos básicos e realizamos alguns testes simples. Agora chegou a hora de ir um pouco além e conhecer técnicas mais avançadas.&lt;/p&gt;

&lt;p&gt;Vale lembrar que, em nossos exemplos, utilizamos uma versão modificada da biblioteca, adaptada para jQuery: &lt;a href=&#34;https://github.com/velesin/jasmine-jquery&#34;&gt;jasmine-jquery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Utilizaremos os dados de um outro artigo, &lt;a href=&#34;http://tableless.com.br/conteudo-sob-demanda-com-jquery/&#34;&gt;Conteúdo sob demanda com jQuery&lt;/a&gt;. O objetivo é testar as solicitações AJAX do carregamento da lista de tweets do Tableless.&lt;/p&gt;

&lt;h3 id=&#34;fixtures&#34;&gt;Fixtures&lt;/h3&gt;

&lt;p&gt;Antes dos testes propriamente ditos vamos conhecer uma forma prática de carregar nosso conteúdo HTM. Fixtures são arquivos carregados através do método &lt;strong&gt;loadFixtures&lt;/strong&gt;. Esta funcionalidade, aliás, está disponível apenas no jasmine-jquery.&lt;/p&gt;

&lt;p&gt;Vamos salvar o código HTML abaixo no arquivo &lt;strong&gt;tweets.html&lt;/strong&gt;, dentro do diretório de fixtures.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;xml&amp;#8221;]&lt;/p&gt;

&lt;div id=&amp;#8221;container&amp;#8221;&gt;
    
&lt;h1&gt;Tweets do Tableless&lt;/h1&gt;
    
&lt;ul id=&amp;#8221;lista-tweets&amp;#8221;&gt;&lt;/ul&gt;
    
&lt;p&gt;&lt;a href=&amp;#8221;#&amp;#8221; id=&amp;#8221;carrega-tweets&amp;#8221; data-pagina=&amp;#8221;1&amp;#8243;&gt;Mais!&lt;/a&gt;&lt;/p&gt;
  
&lt;/div&gt;
  

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Por padrão, o jasmine-jquery procura as fixtures no diretório &lt;strong&gt;spec/javascripts/fixtures&lt;/strong&gt;. Como na primeira parte do artigo indicamos uma estrutura diferente, utilizando o diretório &lt;strong&gt;spec/fixtures&lt;/strong&gt;, precisamos atualizar a propriedade fixturesPath nas configurações do Jasmine.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;jasmine.getFixtures().fixturesPath = &amp;#8216;spec/fixtures/&amp;#8217;;&lt;/p&gt;

&lt;p&gt;describe(&amp;#8216;Exibição dos últimos tweets do Tableless&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;beforeEach(function(){&lt;/p&gt;

&lt;p&gt;loadFixtures(&amp;#8216;tweets.html&amp;#8217;);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8216;Deve carregar na primeira página&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;expect($(&amp;#8216;#carrega-tweets&amp;#8217;).data(&amp;#8216;pagina&amp;#8217;)).toEqual(1);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Outra forma de utilizarmos fixtures é carregando diretamente no código, sem a necessidade de um arquivo HTML. Esse caso é mais indicado para templates mais simples, com poucos elementos.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;setFixtures(&amp;#8216;&lt;ul id=&amp;#8221;lista-tweets&amp;#8221; /&gt;&amp;#8217;);&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;testando-código-assíncrono&#34;&gt;Testando código assíncrono&lt;/h3&gt;

&lt;p&gt;Testar código AJAX pode ser um pouco mais complicado. No nosso exemplo, como acessamos uma URL externa à nossa aplicação, o tempo de resposta vai depender de vários fatores, como velocidade da conexão, estabilidade do Twitter etc.&lt;/p&gt;

&lt;p&gt;Os métodos &lt;strong&gt;runs&lt;/strong&gt; e &lt;strong&gt;waits&lt;/strong&gt; são úteis para tentar simular esse tempo de carregamento. O &lt;strong&gt;runs&lt;/strong&gt; executa os testes e funções um escopo próprio e, além disso, são executados em sequência (quando um termina, o outro começa). Já o método &lt;strong&gt;waits&lt;/strong&gt; funciona como uma espécie de pausa/sleep e recebe como parâmetro o tempo em milissegundos.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;it(&amp;#8216;Deve carregar os últimos 20 tweets&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;runs(function(){&lt;/p&gt;

&lt;p&gt;Tableless.retorna_tweets(1);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;waits(1500);&lt;/p&gt;

&lt;p&gt;runs(function(){&lt;/p&gt;

&lt;p&gt;expect($(&amp;#8216;#lista-tweets li&amp;#8217;).length).toEqual(20);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;espionando-métodos&#34;&gt;Espionando métodos&lt;/h3&gt;

&lt;p&gt;Às vezes precisamos testar se um método de um objeto é chamado (e com que parâmetros) &amp;mdash; e não testar apenas seu resultado. O Jasmine oferece a função &lt;strong&gt;spyOn&lt;/strong&gt; para capturar e validar essas chamadas. O &lt;strong&gt;spyOn&lt;/strong&gt; recebe dois parâmetros: o objeto e o nome do método.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;it(&amp;#8216;Deve executar função para retornar tweets&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;spyOn(Tableless, &amp;#8216;retorna_tweets&amp;#8217;);&lt;/p&gt;

&lt;p&gt;Tableless.retorna_tweets(1);&lt;/p&gt;

&lt;p&gt;expect(Tableless.retorna_tweets).toHaveBeenCalledWith(1);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Acima testamos se o método foi chamado com o parâmetro 1 (página). Poderíamos ter utilizado também &lt;strong&gt;toHaveBeenCalled&lt;/strong&gt;, testando apenas a chamada. As funções de spy podem ainda ser combinadas com o not, por exemplo:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;expect(Tableless.retorna_tweets).not.toHaveBeenCalled();&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;matchers-personalizados&#34;&gt;Matchers personalizados&lt;/h3&gt;

&lt;p&gt;Outra funcionalidade poderosa do Jasmine é a possibilidade de criação de matchers personalizados. Os matchers são asserts para seus tests. No exemplo abaixo, criamos o matcher &lt;strong&gt;toBeATweet&lt;/strong&gt; para validar se um elemento possui a classe &amp;#8220;tweet&amp;#8221;.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;beforeEach(function(){&lt;/p&gt;

&lt;p&gt;this.addMatchers({&lt;/p&gt;

&lt;p&gt;toBeATweet: function(){&lt;/p&gt;

&lt;p&gt;return this.actual.hasClass(&amp;#8216;tweet&amp;#8217;);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;expect($(&amp;#8216;#lista-tweets li:first&amp;#8217;)).toBeATweet();&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;O método addMatchers deve ser executado dentro do beforeEach, utilizando o Jasmine como contexto. Notem que ele recebe um objeto que pode conter um ou mais matchers personalizados. No código, &lt;strong&gt;this.actual&lt;/strong&gt; representa a variável, elemento, ou objeto que estará sendo passado ao &lt;strong&gt;expect&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;outros-projetos-utilizando-jasmine&#34;&gt;Outros projetos utilizando Jasmine&lt;/h3&gt;

&lt;p&gt;Nesses dois artigos vocês conheceram o jasmine-jquery, mas existem diversos outros projetos baseados no framework Jasmine, incluindo adaptações para NodeJS, Rails e iPhone e snippets para Vim e TextMate. A lista completa você confere no &lt;a href=&#34;https://github.com/pivotal/jasmine/wiki/Related-projects&#34;&gt;wiki do projeto no Github&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;referências&#34;&gt;Referências&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tableless/exemplos/tree/gh-pages/jasmine-parte-2&#34;&gt;Código fonte dos exemplos deste artigo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.github.com/exemplos/jasmine-parte-2/tests/SpecRunner.html&#34;&gt;SpecRunner dos exemplos rodando no browser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://f.souza.cc/2011/05/testing-jquery-plugins-with-jasmine/&#34;&gt;Testing jQuery plugins with Jasmine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://testdrivenwebsites.com/2010/07/29/html-fixtures-in-jasmine-using-jasmine-jquery/&#34;&gt;HTML fixtures in Jasmine (using jasmine-jquery)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Testando seu código jQuery com Jasmine – Parte 1</title>
      <link>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-1/</link>
      <pubDate>Mon, 12 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-1/</guid>
      <description>

&lt;p&gt;Durante muito tempo testar/debugar JavaScript era uma tarefa árdua (infelizmente, em alguns navegadores, ainda é). Quem aí se lembra do tempo em que não existia Firebug, por exemplo? E o tamanho dos scripts? Um simples menu drop-drown possuía umas 1.500 linhas de código. Não existia jQuery ou qualquer outro tipo de framework. Tempos difíceis.&lt;/p&gt;

&lt;p&gt;Hoje a tarefa do desenvolvedor é muito mais fácil. Para debug temos o já citado Firebug e o Developer Tools do Chrome, entre outros. Nos testes, além do &lt;a href=&#34;http://pivotal.github.com/jasmine/&#34; target=&#34;_blank&#34;&gt;Jasmine&lt;/a&gt;, outro framework bem legal é o &lt;a href=&#34;http://docs.jquery.com/Qunit&#34;&gt;QUnit&lt;/a&gt;. O Jasmine, por focar em BDD, possui uma sintaxe mais fluida. Quem programa em Ruby/Rails vai notar a enorme semelhança com a ferramenta RSpec.&lt;/p&gt;

&lt;p&gt;Nos exemplos vou utilizar uma versão modificada do Jasmine, jasmine-jquery. Ela possui alguns métodos próprios para o framework além de funções para carregar fixtures (templates).&lt;/p&gt;

&lt;h3 id=&#34;baby-steps&#34;&gt;Baby steps&lt;/h3&gt;

&lt;p&gt;Começar a trabalhar com uma cultura de testar sempre antes de desenvolver é bem difícil, principalmente para quem já está acostumado a programar antes e testar depois (manualmente). Comece devagar, sem medo. No início as coisas serão um pouco confusas, mas depois de adotar essa prática, você vai se perguntar como era possível programar sem testes.&lt;/p&gt;

&lt;p&gt;O que testar e que testes escrever? Isso também vem com o tempo. Comece testando uma ou outra funcionalidade principal de um aplicativo já existente. Entenda como funciona a sua ferramenta de testes. Depois de um tempo comece a acreditar e confiar na sua intuição.&lt;/p&gt;

&lt;p&gt;Procure sempre utilizar um conjunto variado de possibilidades, desde as mais óbvias até as mais inusitadas. Pense nos diferentes contextos, em tudo que interage com seu aplicativo: navegadores, sistemas operacionais, usuários, dados de entrada, scripts de terceiros etc.&lt;/p&gt;

&lt;p&gt;Testes não evitam que seu software, uma vez finalizado, tenha bugs; não são a solução para todos os seus problemas de &lt;em&gt;deploy&lt;/em&gt;, mas facilitam bastante essas etapas.&lt;/p&gt;

&lt;h3 id=&#34;red-rarr-green-rarr-refactor&#34;&gt;Red &amp;rarr; Green &amp;rarr; Refactor&lt;/h3&gt;

&lt;p&gt;O padrão básico a ser seguido é o seguinte:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Escreva o teste &amp;mdash; naturalmente, ele vai falhar;&lt;/li&gt;
&lt;li&gt;Escreva, sem se preocupar muito com qualidade, o código mais simples, que faça o teste passar;&lt;/li&gt;
&lt;li&gt;Reescreva seu código, implementando melhorias de performance, escalabilidade e removendo duplicidades.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;configurando-o-jasmine-jquery&#34;&gt;Configurando o jasmine-jquery&lt;/h3&gt;

&lt;p&gt;Baixe a última versão do &lt;a href=&#34;https://github.com/velesin/jasmine-jquery&#34; target=&#34;_blank&#34;&gt;jasmine-jquery&lt;/a&gt; e vamos começar com nossos primeiros testes. A estrutura de pastas do nosso aplicativo deve ficar da seguinte maneira:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;xml&amp;#8221;]- /&lt;/p&gt;

&lt;p&gt;&amp;#8211; /tests&lt;/p&gt;

&lt;p&gt;&amp;#8211; /lib&lt;/p&gt;

&lt;p&gt;&amp;#8211; /spec&lt;/p&gt;

&lt;p&gt;&amp;#8211; /fixtures&lt;/p&gt;

&lt;p&gt;&amp;#8211; /suites&lt;/p&gt;

&lt;p&gt;&amp;#8211; saudacao-spec.js&lt;/p&gt;

&lt;p&gt;&amp;#8211; /vendor&lt;/p&gt;

&lt;p&gt;&amp;#8211; SpecRunner.html&lt;/p&gt;

&lt;p&gt;&amp;#8211; tableless.js&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Note que criamos um diretório &amp;#8220;tests&amp;#8221; onde ficarão todos os arquivos dos nossos testes, incluindo a biblioteca Jasmine. O arquivo SpecRunner.html é o responsável por executar e exibir os resultados dos testes, basta abri-lo no navegador. Dentro do diretório “tests/spec” ficarão nossos conjuntos de testes (suites) e nossos templates HTML (fixtures).&lt;/p&gt;

&lt;p&gt;No início do SpecRunner ficam as chamadas para os testes:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;script type=&amp;#8221;text/javascript&amp;#8221; src=&amp;#8221;spec/suites/saudacao-spec.js&amp;#8221;&gt;&lt;/script&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Você também pode incluir aqui qualquer javascript personalizado necessário para os testes. No nosso caso vamos incluir o arquivo tableless.js, que fica na raiz do nosso aplicativo.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;script type=&amp;#8221;text/javascript&amp;#8221; src=&amp;#8221;../tableless.js&amp;#8221;&gt;&lt;/script&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;nosso-primeiro-teste&#34;&gt;Nosso primeiro teste&lt;/h3&gt;

&lt;p&gt;Vamos supor o seguinte: uma página deve exibir uma mensagem de boas-vindas para o usuário que varia de acordo com o horário. De 5 da manhã ao meio-dia, exibe &amp;#8220;Bom dia!&amp;#8221;; de meio-dia até 6 da tarde, exibe &amp;#8220;Boa tarde!&amp;#8221;; de 6 à meia-noite, exibe &amp;#8220;Boa noite!&amp;#8221;; e, por fim, de meia-noite até 6 da manhã exibe &amp;#8220;Dormir é para os fracos!&amp;#8221;. A mensagem fica sempre dentro de um elemento div com id &amp;#8220;mensagem&amp;#8221;. Os horários vão desde a hora inicial (incluída) até a hora final. A função pode receber como parâmetro uma hora no formato hh:mm ou, caso não receba nada, exibe a mensagem de acordo com a hora do usuário.&lt;/p&gt;

&lt;p&gt;Esse é um bom começo para seus testes, tente escrever, em um parágrafo, o que deve ser executado e o que é esperado. Trabalhe sempre com um pedaço de papel por perto, para rascunhos.&lt;/p&gt;

&lt;p&gt;Vejamos como ficaria o desenho inicial dos nossos testes. Crie o arquivo /tests/spec/suites/saudacao-spec.js e digite o seguinte código:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]describe(&amp;#8216;Exibição da mensagem de boas-vindas&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;beforeEach(function(){&lt;/p&gt;

&lt;p&gt;setFixtures(&amp;#8216;&lt;div id=&amp;#8221;mensagem&amp;#8221; /&gt;&amp;#8217;);&lt;/p&gt;

&lt;p&gt;this.mensagem = $(&amp;#8216;#mensagem&amp;#8217;);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;afterEach(function(){&lt;/p&gt;

&lt;p&gt;this.horas = [];&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Bom-dia!&amp;#8217; entre 5:00 e 11:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Boa-tarde!&amp;#8217; entre 12:00 e 17:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Boa-noite!&amp;#8217; entre 18:00 e 23:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Dormir é para os fracos!&amp;#8217; de 00:00 a 04:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir, por padrão, a mensagem de acordo com a hora do cliente&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});[/cce]&lt;/p&gt;

&lt;p&gt;Na raiz do aplicativo, crie um arquivo chamado &amp;#8220;tableless.js&amp;#8221;. Nele nós escreveremos nossa função para exibir a mensagem de acordo com a hora. Sua estrutura inicial é a seguinte:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]function saudacao(hora_atual){&lt;/p&gt;

&lt;p&gt;var hora;&lt;/p&gt;

&lt;p&gt;}[/cce]&lt;/p&gt;

&lt;p&gt;Os conceitos básicos dos nossos testes giram em torno de três funções: &lt;strong&gt;describe&lt;/strong&gt;, &lt;strong&gt;it&lt;/strong&gt; e &lt;strong&gt;expect&lt;/strong&gt;. Outras funções úteis, mas que nem sempre estarão presentes, são as funções &lt;strong&gt;beforeEach&lt;/strong&gt; e &lt;strong&gt;afterEach&lt;/strong&gt;. Também trabalhamos com uma função do jasmine-jquery, a &lt;strong&gt;setFixtures&lt;/strong&gt; &amp;mdash; falarei mais sobre ela na parte 2, por enquanto você só precisa saber que ela define templates/elementos no DOM.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;describe&lt;/strong&gt; &amp;mdash; representa um conjunto de testes/comportamentos. Podem existir situações dentro de situações, por exemplo:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]describe(&amp;#8216;Login&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;describe(&amp;#8216;Sucesso&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;
describe(&amp;#8216;Falha&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});[/cce] &lt;/li&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;it&lt;/strong&gt; &amp;mdash; define um teste, uma ação. Por exemplo, &amp;#8220;It should validate the username&amp;#8221;, ou, &amp;#8220;Deve validar o nome do usuário&amp;#8221;, seria uma boa situação para nosso teste de login.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;expect&lt;/strong&gt; &amp;mdash; espera que alguma variável ou retorno de função seja igual a alguma coisa, ou verdadeiro, ou falso etc. Nos testes acima utilizamos apenas um tipo de validação, o matcher &amp;#8220;toEqual&amp;#8221;. Todo o teste deve ser chamado com a função expect, utilizando um dos matchers disponíveis (mais sobre eles na parte 2). Os principais são: toEqual, toContains, toBeTruthy e toBeFalsy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;beforeEach&lt;/strong&gt; &amp;mdash; executada antes de cada teste dentro de um conjunto, muito útil para configurar elementos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;afterEach&lt;/strong&gt; &amp;mdash; executada depois de cada teste dentro de um conjunto, ideal para reiniciar variáveis.&lt;/ul&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;escrevendo-os-testes&#34;&gt;Escrevendo os testes&lt;/h3&gt;

&lt;p&gt;Agora chegou a hora de preencher os nossos testes. Os testes que verificam a mensagem entre uma hora e outra seguirão um mesmo padrão. Dado um conjunto de horas válidas, a função saudacao deve retornar a mensagem correta.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]it(&amp;#8220;Deve exibir &amp;#8216;Bom-dia!&amp;#8217; entre 5:00 e 11:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;this.horas = [&amp;#8217;05:00&amp;#8242;, &amp;#8217;09:33&amp;#8242;, &amp;#8217;10:22&amp;#8242;, &amp;#8217;11:59&amp;#8242;];&lt;/p&gt;

&lt;p&gt;for(i in this.horas){&lt;/p&gt;

&lt;p&gt;saudacao(this.horas[i]);&lt;/p&gt;

&lt;p&gt;expect(this.mensagem.text()).toEqual(&amp;#8216;Bom-dia!&amp;#8217;);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;});[/cce]&lt;/p&gt;

&lt;p&gt;O teste que valida o retorno da função saudacao sem passagem de parâmetro busca a hora do cliente e exibe a mensagem de acordo com ela.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]it(&amp;#8220;Deve exibir, por padrão, a mensagem de acordo com a hora do cliente&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;var data = new Date;&lt;/p&gt;

&lt;p&gt;data.setTime(data.getTime());&lt;/p&gt;

&lt;p&gt;var hora = data.getHours();&lt;/p&gt;

&lt;p&gt;saudacao();&lt;/p&gt;

&lt;p&gt;var texto = this.mensagem.text();&lt;/p&gt;

&lt;p&gt;if(hora &amp;lt; 5)&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Dormir é para os fracos!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;if(hora &amp;lt; 12)&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Bom-dia!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else if(hora &amp;lt; 18)&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Boa-tarde!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Boa-noite!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;});[/cce]&lt;/p&gt;

&lt;p&gt;Nesse momento, abrindo o SpecRunner no navegador, todos os nossos testes estarão falhando. Lembra da nossa regra? Red (falhou), Green (passou) e Refactor.&lt;/p&gt;

&lt;h3 id=&#34;a-função-saudacao&#34;&gt;A função saudacao()&lt;/h3&gt;

&lt;p&gt;Abaixo segue a minha implementação da função saudacao(). Não me preocupei muito com repetições e performance. Meu objetivo principal era fazer o teste passar.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]function saudacao(hora_atual){&lt;/p&gt;

&lt;p&gt;var hora;&lt;/p&gt;

&lt;p&gt;if(typeof hora_atual == &amp;#8216;undefined&amp;#8217;){&lt;/p&gt;

&lt;p&gt;var data = new Date;&lt;/p&gt;

&lt;p&gt;data.setTime(data.getTime());&lt;/p&gt;

&lt;p&gt;hora = data.getHours();&lt;/p&gt;

&lt;p&gt;}else{&lt;/p&gt;

&lt;p&gt;hora = hora_atual.split(&amp;#8216;:&amp;#8217;);&lt;/p&gt;

&lt;p&gt;hora = parseInt(hora[0].replace(/^0/, &amp;#8221;));&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;if(hora &amp;lt; 5)&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Dormir é para os fracos!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else if(hora &amp;lt; 12)&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Bom-dia!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else if(hora &amp;lt; 18)&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Boa-tarde!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Boa-noite!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;}[/cce]&lt;/p&gt;

&lt;p&gt;Atualizando nossa SpecRunner veremos agora que todos os testes estão passando. Você pode (e deve) desenvolver aos poucos. Valide um teste de cada vez. Desenvolva com calma.&lt;/p&gt;

&lt;h3 id=&#34;melhorando-nosso-código&#34;&gt;Melhorando nosso código&lt;/h3&gt;

&lt;p&gt;Como de praxe, vou deixar um dever de casa para vocês: a etapa de refactoring. O que podemos melhorar na nossa função saudacao()? E se o usuário passar uma hora atualmente inválida para nossa função, como &amp;#8220;meio-dia&amp;#8221;, &amp;#8220;nove horas&amp;#8221; etc. E se quisermos mudar o id do elemento #mensagem? E se quisermos exibir a saudação em mais de um elemento? Podemos melhorar algum nome de variável? Podemos reduzir o tamanho da nossa função? Nossa função está cumprindo seu objetivo? Tem algum código/texto repetido? E nossos testes? Estão cobrindo tudo? Prevendo todos os cenários?&lt;/p&gt;

&lt;p&gt;O que não falta é opção para um bom refactoring.&lt;/p&gt;

&lt;p&gt;Na segunda parte veremos a função spy, além de mais sobre fixtures, matchers personalizados e outros recursos avançados.&lt;/p&gt;

&lt;h3 id=&#34;referências&#34;&gt;Referências&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tableless/exemplos/tree/gh-pages/jasmine-parte-1&#34;&gt;Código fonte dos exemplos deste artigo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.github.com/exemplos/jasmine-parte-1/tests/SpecRunner.html&#34;&gt;SpecRunner do exemplo rodando no github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pivotal.github.com/jasmine/&#34; target=&#34;_blank&#34;&gt;Jasmine BDD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/velesin/jasmine-jquery&#34; target=&#34;_blank&#34;&gt;jasmine-jquery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pt.wikipedia.org/wiki/Behavior_Driven_Development&#34; target=&#34;_blank&#34;&gt;BDD segundo a Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>