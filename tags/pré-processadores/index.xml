<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pré Processadores on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/pr%C3%A9-processadores/index.xml</link>
    <description>Recent content in Pré Processadores on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/pr%C3%A9-processadores/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sass vs. LESS vs. Stylus: Batalha dos Pré-processadores</title>
      <link>https://tableless.github.io/hugo-public/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</link>
      <pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar:&lt;/p&gt;

&lt;h2 id=&#34;sintaxe&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Essa sintaxe não é por causa de ser mais antiga e sim pois no início o &lt;strong&gt;Sass&lt;/strong&gt; era parte de um outro pré-processador chamado &lt;strong&gt;Haml&lt;/strong&gt; criado por desenvolvedores &lt;strong&gt;Ruby&lt;/strong&gt;, e por causa disso as folhas de estilo escritas com &lt;strong&gt;Sass&lt;/strong&gt; utilizavam uma sintaxe como a do &lt;strong&gt;Ruby&lt;/strong&gt;, sem chaves, ponto e vírgula e controlado por identação.&lt;/p&gt;

&lt;h3 id=&#34;stylus&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-1&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-1&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-1&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-1&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-2&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-2&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-2&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Como mencionado nos comentários, o LESS tem suporte a herança e pode ser feita com a seguinte sintaxe:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p {
        &amp;:extend(.block);
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;h2 id=&#34;importação&#34;&gt;Importação&lt;/h2&gt;

&lt;p&gt;Na comunidade CSs, importar CSS é visto com maus olhos por utilizar diversas chamadas HTTP. Importar com um pré-processador funciona de forma diferente no entanto. Se você importar um arquivo com qualquer um dos três pré-processadores, ele irá literalmente pegar todo o conteúdo do arquivo durante a importação e gerar apenas um arquivo. Lembre-se que arquivos .css comuns importados compilam com o código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;file.css&#34;;
&lt;/pre&gt;

&lt;p&gt;Lembre-se também que mixins e variáveis podem ser importadas e usadas em sua folha de estilo principal. Importação faz com que possamos criar arquivos separados para uma melhor organização.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-1&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* arquivo.{extensao} */
body {
    background: #eee;
}
&lt;/pre&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
@import &#34;arquivo.{extensao}&#34;;
 
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-3&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;h2 id=&#34;introdução-1&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;-&amp;gt;Pré-processadores produzem CSS que funciona em todos os browsers&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Eles fazem isso compilando o código que escrevemos em CSS puro que pode ser usado em qualquer browser de agora até a era das pedras. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar&lt;/p&gt;

&lt;h2 id=&#34;sintaxe-1&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador CSS é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less-1&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-3&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis-1&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass-2&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-3&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-4&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-4&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento-1&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-2&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-5&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins-1&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-3&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-4&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-5&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-6&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança-1&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus-1&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus-1&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-5&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less-1&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
body {
    background: #eee;
}
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h2 id=&#34;funções-de-cores&#34;&gt;Funções de Cores&lt;/h2&gt;

&lt;p&gt;Funções de cores são funções nativas que transformam uma cor por compilação. Podem ser extremamente úteis para criar gradientes, escurecer cores no &amp;#8220;hover&amp;#8221; de elementos e muito mais.&lt;/p&gt;

&lt;h3 id=&#34;sass-4&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten($color, 10%); /* retorna uma cor 10% mais clara que $color */
darken($color, 10%);  /* retorna uma cor 10% mais escura $color */
 
saturate($color, 10%);   /* retorna uma cor 10% mais saturada que $color */
desaturate($color, 10%); /* retorna uma cor 10% menos saturada que $color */
 
grayscale($color);  /* retorna $color na escala de cinza */
complement($color); /* retorna cor complementar de $color */
invert($color);     /* retorna cor inversa de $color */
 
mix($color1, $color2, 50%); /* mistura $color1 com $color2 com um peso de 50% */
&lt;/pre&gt;

&lt;p&gt;Essas é apenas uma pequena lista de funções de cores disponíveis no Sass. A lista completa das funções de cores disponíveis no Sass pode ser encontrada na &lt;a href=&#34;http://sass-lang.com/documentation/Sass/Script/Functions.html&#34; target=&#34;_blank&#34;&gt;documentação do Sass&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Funções de cores podem ser usadas em qualquer lugar que uma cor é válida no CSS. Veja um exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$color: #0982C1;
 
h1 {
    background: $color;
    border: 3px solid darken($color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-6&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(@color, 10%); /* retorna uma cor 10% mais clara que @color */
darken(@color, 10%);  /* retorna uma cor 10% mais escura @color */
 
saturate(@color, 10%);   /* retorna uma cor 10% mais saturada que @color */
desaturate(@color, 10%); /* retorna uma cor 10% menos saturada que @color */
 
spin(@color, 10); /* retorna uma cor 10 graus acima na matiz/tonalidade que @color */
spin(@color, -10); /* retorna uma cor 10 graus abaixo na matiz/tonalidade que @color */
 
mix(@color1, @color2); /* mistura @color1 com @color2 */
&lt;/pre&gt;

&lt;p&gt;A lista de todas as funções disponíveis no LESS pode encontrada na &lt;a href=&#34;http://lesscss.org/#-color-functions&#34; target=&#34;_blank&#34;&gt;documentação LESS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no LESS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@color: #0982C1;
 
h1 {
    background: @color;
    border: 3px solid darken(@color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-6&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(color, 10%); /* retorna uma cor 10% mais clara que &#39;color&#39; */
darken(color, 10%);  /* retorna uma cor 10% mais escura &#39;color&#39; */
 
saturate(color, 10%);   /* retorna uma cor 10% mais saturada que &#39;color&#39; */
desaturate(color, 10%); /* retorna uma cor 10% menos saturada que &#39;color&#39; */
&lt;/pre&gt;

&lt;p&gt;A lista completa de todas funções de cores disponíveis no Stylus pode ser encontrada na &lt;a href=&#34;http://stylus-lang.com/docs/bifs.html&#34; target=&#34;_blank&#34;&gt;documentação Stylus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no Stylus:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;color = #0982C1
 
h1
    background color
    border 3px solid darken(color, 50%)
&lt;/pre&gt;

&lt;h2 id=&#34;operações&#34;&gt;Operações&lt;/h2&gt;

&lt;p&gt;Fazer cálculos no CSS é bastante útil e agora totalmente possível. É bem simples e é dessa maneira que fazemos:&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-3&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: (14px/2);
    top: 50px + 100px;
    right: 100px - 50px;
    left: 10 * 10;
}
&lt;/pre&gt;

&lt;h2 id=&#34;aplicações-práticas&#34;&gt;Aplicações Práticas&lt;/h2&gt;

&lt;p&gt;Nós falamos de diversas funcionalidades e novas coisas que pré-processadores podem fazer, mas não mostramos nada na prática ainda. Veja uma pequena lista de aplicações no mundo real em que um pré-processador é um salva-vidas.&lt;/p&gt;

&lt;h3 id=&#34;vendor-prefixes&#34;&gt;Vendor Prefixes&lt;/h3&gt;

&lt;p&gt;Essa é uma das principais razões para se usar um pré-processador e por um motivo bom &amp;#8211; economia gigante de tempo e lágrimas. Criar um mixin para cuidar dos vendor prefixes é fácil e nos salva de uma codificação repetitiva e dolorosa. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-5&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin border-radius($values) {
    -webkit-border-radius: $values;
        -moz-border-radius: $values;
            border-radius: $values;
}
 
div {
    @include border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-7&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.border-radius(@values) {
    -webkit-border-radius: @values;
        -moz-border-radius: @values;
            border-radius: @values;
}
 
div {
    .border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-7&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;border-radius(values) {
    -webkit-border-radius: values;
        -moz-border-radius: values;
            border-radius: values;
}
 
div {
    border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-7&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;div {
    -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
            border-radius: 10px;
}
&lt;/pre&gt;

&lt;h3 id=&#34;texto-3d&#34;&gt;Texto 3D&lt;/h3&gt;

&lt;p&gt;Simular um texto 3D utilizando diversos text-shadows é uma grande ideia. O único problema é que mudar a cor depois de criar é difícil e incômodo. Usando mixins e funções de cores, podemos criar um texto 3D e mudar sua cor sem nenhuma dificuldade.&lt;/p&gt;

&lt;h4 id=&#34;sass-6&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin text3d($color) {
    color: $color;
    text-shadow: 1px 1px 0px darken($color, 5%),
            2px 2px 0px darken($color, 10%),
            3px 3px 0px darken($color, 15%),
            4px 4px 0px darken($color, 20%),
            4px 4px 2px #000;
}
 
h1 {
    font-size: 32pt;
    @include text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-8&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.text3d(@color) {
    color: @color;
    text-shadow: 1px 1px 0px darken(@color, 5%),
            2px 2px 0px darken(@color, 10%),
            3px 3px 0px darken(@color, 15%),
            4px 4px 0px darken(@color, 20%),
            4px 4px 2px #000;
}
 
span {
    font-size: 32pt;
    .text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-8&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;text3d(color)
    color: color
    text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000
span
    font-size: 32pt
    text3d(#0982c1)
&lt;/pre&gt;

&lt;p&gt;Escolhi escrever os &amp;#8220;text-shadows&amp;#8221; do Stylus em apenas uma linha pois omiti as chaves.&lt;/p&gt;

&lt;h4 id=&#34;css-compilado-8&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;span {
    font-size: 32pt;
    color: #0982c1;
    text-shadow: 1px 1px 0px #097bb7, 
            2px 2px 0px #0875ae, 
            3px 3px 0px #086fa4, 
            4px 4px 0px #07689a, 
            4px 4px 2px #000;
}
&lt;/pre&gt;

&lt;h4 id=&#34;resultado-final&#34;&gt;Resultado Final&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.tutsplus.com/net/uploads/legacy/1144_preprocshootout/text3d.png&#34; alt=&#34;Texto 3D&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;colunas&#34;&gt;Colunas&lt;/h3&gt;

&lt;p&gt;Usar operações numéricas e variáveis para colunas é uma ideia que tive da primeira vez que estava brincando com pré-processadores CSS. Declarando a largura desejada em uma variável, podemos facilmente alterá-la sem precisar de nenhum cálculo mental. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-7&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$siteWidth: 1024px;
$gutterWidth: 20px;
$sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: $siteWidth;
}
.content {
    float: left;
    width: $siteWidth - ($sidebarWidth+$gutterWidth);
}
.sidebar {
    float: left;
    margin-left: $gutterWidth;
    width: $sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-9&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@siteWidth: 1024px;
@gutterWidth: 20px;
@sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: @siteWidth;
}
.content {
    float: left;
    width: @siteWidth - (@sidebarWidth+@gutterWidth);
}
.sidebar {
    float: left;
    margin-left: @gutterWidth;
    width: @sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-9&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;siteWidth = 1024px;
gutterWidth = 20px;
sidebarWidth = 300px;
 
body {
    margin: 0 auto;
    width: siteWidth;
}
.content {
    float: left;
    width: siteWidth - (sidebarWidth+gutterWidth);
}
.sidebar {
    float: left;
    margin-left: gutterWidth;
    width: sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-9&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: 0 auto;
    width: 1024px;
}
.content {
    float: left;
    width: 704px;
}
.sidebar {
    float: left;
    margin-left: 20px;
    width: 300px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;peculiaridades-notáveis&#34;&gt;Peculiaridades Notáveis&lt;/h2&gt;

&lt;p&gt;Existem algumas peculiaridades ao usar um pré-processador CSS. Irei falar de algumas engraçadas, mas se você está realmente interessado em encontrar todas elas eu recomendo você vasculhar toda a documentação, ou melhor, começar a usar um pré-processador na sua codificação diária.&lt;/p&gt;

&lt;h3 id=&#34;relatório-de-erros&#34;&gt;Relatório de Erros&lt;/h3&gt;

&lt;p&gt;Se você já escreveu CSS por uma boa quantia de tempo, tenho certeza que você já chegou a um ponto onde você tinha um erro em algum lugar e simplesmente não conseguia o encontrar. Se você é como eu, provavelmente passou a tarde toda arrancando os cabelos fora e comentando diversas coisas para caçar o erro.&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS relatam os erros. Simples assim. Se tem alguma coisa errada em seu códigom ele te fala onde e, se você estiver com sorte até mesmo o porquê. Você pode dar uma olhada &lt;a href=&#34;http://tjholowaychuk.com/post/5002088731/stylus-vs-sass-vs-less-error-reporting&#34; target=&#34;_blank&#34;&gt;nesse post&lt;/a&gt; caso esteja interessado em ver como os erros são relatados em diferentes pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;comentários&#34;&gt;Comentários&lt;/h3&gt;

&lt;p&gt;Quando um pré-processador CSS está compilando, qualquer comentário escrito com barras duplas &amp;#8220;//&amp;#8221; é excluído e qualquer comentários escrito com barra e asterisco &amp;#8220;/* */&amp;#8221; não é alterado. Dito isso, use comentários com barras duplas para comentários que você queira na versão não compilada e comentários com barra e asterisco para comentários que serão visíveis após a compilação.&lt;/p&gt;

&lt;p&gt;Observação: Se você compilar os arquivos, minificando-os, todos comentários são excluídos.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Cada um dos pré-processadores que falamos (Sass, LESS e Stylus) possui um modo único de realizar a mesma tarefa &amp;#8211; dando a nós desenvolvedor a habilidade de usar funcionalidades úteis mantendo a compatibilidade entre browsers e um código limpo.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mesmo não sendo uma exigência para o desenvolvimento, pré-processadores podem economizar muito tempo e tem funcionalidades bastante úteis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu aconselho todos vocês a utilizar e testar a maior quantidade de pré-processadores possível, pois assim você poderá escolher efetivamente um favorito e saber o porquê ele é seu favorito dentre tantos outros. Se você ainda não testou usar nenhum pré-processador para escrever seu CSS, eu recomendo grandemente a você testar.&lt;/p&gt;

&lt;p&gt;Você tem alguma funcionalidade de seu pré-processador favorito que não foi mencionada? Há algo que algum pré-processador possa fazer e outros não? Conte-nos nos comentários abaixo!&lt;/p&gt;

&lt;p&gt;Traduzido e adaptado de: &lt;a href=&#34;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320&#34;&gt;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout&amp;#8211;net-24320&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SASS: Mixin ou Placeholder?</title>
      <link>https://tableless.github.io/hugo-public/sass-mixin-ou-placeholder/</link>
      <pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/sass-mixin-ou-placeholder/</guid>
      <description>

&lt;p&gt;Se é um tema que sempre vejo a respeito da utilização ou não, é sobre o uso de pré processadores CSS. Alguns &lt;em&gt;devs&lt;/em&gt; que costumo seguir e ler os artigos, e que pra mim são algumas das nossas referências, apontam as suas considerações sobre o tema. O Miller Medeiros, em um &lt;a href=&#34;http://blog.millermedeiros.com/the-problem-with-css-pre-processors/&#34;&gt;post&lt;/a&gt; mostra alguns pontos negativos na utilização de pré processadores. O Jean Carlos Emer em um outro &lt;a href=&#34;http://tableless.com.br/css-steroids/&#34; title=&#34;CSS on steroids&#34;&gt;post&lt;/a&gt; mostra as reais vantagens de se utilizar um pré-processador. O Diego Eis, em um outro &lt;a href=&#34;http://tableless.com.br/pre-processadores-usar-ou-nao-usar/&#34; title=&#34;Pré processadores: usar ou não usar?&#34;&gt;post&lt;/a&gt; faz uma conclusão muito boa sobre a utilização ou não:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pré processadores podem ajudar como também podem maltratar bastante. Basta um escorregão para que seu projeto vire um inferno. &amp;#8211; Diego Eis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A utilização ou não de um pré processador fica a seu critério mas, se você já utiliza nos seus projetos ou está pensando em usar, você sabe o que são um &lt;strong&gt;placeholder&lt;/strong&gt; e um &lt;strong&gt;mixin&lt;/strong&gt;? Se sim, sabe qual a principal diferença entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um &lt;a href=&#34;http://www.sitepoint.com/sass-mixin-placeholder/&#34;&gt;artigo&lt;/a&gt; do &lt;a href=&#34;https://twitter.com/HugoGiraudel&#34; title=&#34;Perfil do twitter do desenvolvedor Hugo Giraudel&#34;&gt;Hugo Giraudel&lt;/a&gt;, um dev front-end francês, no &lt;a href=&#34;http://www.sitepoint.com/&#34; title=&#34;Link do website SitePoint&#34;&gt;SitePoint&lt;/a&gt; que trata exatamente sobre esse assunto.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Quando comecei a trabalhar com SASS cerca de um ano e meio atrás, uma coisa que me levou tempo para entender foi a diferença entre &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins&#34;&gt;incluir um mixin&lt;/a&gt;&lt;/em&gt; e &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders&#34;&gt;estender um placeholder&lt;/a&gt;&lt;/em&gt;. Na verdade, até mesmo a noção de &lt;em&gt;placeholder&lt;/em&gt; era uma espécie de magia negra vodu naquela época.&lt;/p&gt;

&lt;p&gt;Se você estiver em uma situação semelhante, não se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um &lt;em&gt;mixin&lt;/em&gt;, e quando usar um &lt;em&gt;placeholder do SASS&lt;/em&gt;. Você vai entender que ambos tem diferentes finalidades e não devem ser confundidas.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro pré-processador CSS, seja Stylus, LESS, ou outro que você venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteúdo deste artigo para a ferramenta de sua escolha&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos &lt;strong&gt;placeholder e mixins do SASS&lt;/strong&gt;, então vamos fazer isso já.&lt;/p&gt;

&lt;h2 id=&#34;entendendo-o-mixin&#34;&gt;Entendendo o mixin&lt;/h2&gt;

&lt;p&gt;Um mixin é uma diretiva que permite que você defina várias regras com diversos argumentos. Pense nisso como uma função que irá retornar conteúdo CSS ao invés de um valor. Aqui está a definição de &lt;em&gt;mixin&lt;/em&gt; da &lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;referência do SASS&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote cite=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;
  &lt;p&gt;
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes não semânticas como &lt;i&gt;.float-left&lt;/i&gt;. Mixins podem também conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem até mesmo possuírem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agora que cobrimos a terminologia, vamos dizer que você encontra algumas declarações que são repetidas várias vezes ao longo da sua folha de estilos. Você que está familiarizado com o conceito de DRY (&lt;a href=&#34;http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself&#34;&gt;Don&amp;#8217;t Repeat Yourself&lt;/a&gt;), sabe que a repetição de código é ruim. Para corrigir isso, você pode escrever um mixin para todas aquelas declarações repetidas:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Se você não passar um argumento para um mixin, você pode omitir os parênteses. Na verdade, você pode até omiti-los na definição do &lt;code&gt;@mixin&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com este mixin recém-criado, você não precisa repetir aquelas três linhas de código cada vez que precisar centralizar um elemento; você simplesmente inclui o mixin. Muito prático, não é?!&lt;/p&gt;

&lt;p&gt;Algumas vezes você vai querer um mixin para construir o que você chamaria de &lt;em&gt;shorthand&lt;/em&gt; para algumas propriedades. Por exemplo, largura e altura. Você não está cansado de escrever as duas linhas várias e várias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
&lt;/pre&gt;

&lt;p&gt;Muito simples, não é? Note como deixamos o parâmetro &lt;code&gt;$height&lt;/code&gt; ser opcional e, por padrão assumir o mesmo valor do parâmetro &lt;code&gt;$width&lt;/code&gt; na assinatura do mixin. Agora, sempre que você precisar definir as dimensões para um elemento, você pode simplesmente fazer isso:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Um outro bom exemplo de mixin seria &lt;a href=&#34;http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/&#34;&gt;este aqui&lt;/a&gt; que eu fiz para evitar de escrever as posições &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; e &lt;code&gt;bottom&lt;/code&gt; toda vez que quiser utilizar um sistema de posicionamento diferente do estático.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;conhecendo-seu-placeholder&#34;&gt;Conhecendo seu Placeholder&lt;/h2&gt;

&lt;p&gt;Placeholders são um tipo de coisa estranha. Eles são classes que não são retornadas quando o seu SCSS é compilado. Você deve então pensar: &lt;em&gt;&amp;#8220;Qual é o sentido disso?&amp;#8221;&lt;/em&gt;. Na verdade, o ponto seria minímo senão fosse a expressão &lt;code&gt;@extend&lt;/code&gt;. Mas vamos por partes. Essa é a forma que você escreve um placeholder:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota do editor: Como um placeholder, um mixin é igualmente inútil, a menos que seja referenciado, assim essa seção não está dizendo que eles são diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareça similar com um bloco de declaração CSS, não será gerado por conta própria.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Basicamente você escreve exatamente como uma classe &lt;code&gt;CSS&lt;/code&gt; exceto pelo símbolo % ao invés do ponto. Além disso, segue as mesmas &lt;a href=&#34;http://www.w3.org/TR/html401/types.html#type-cdata&#34;&gt;regras de nomenclatura&lt;/a&gt; das classes.&lt;/p&gt;

&lt;p&gt;Agora, se você tentar compilar seu SCSS, você não vai ver esse pedaço de código no arquivo gerado. Como eu disse: &lt;strong&gt;placeholders não são compilados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Então, por agora, esse placeholder é totalmente inútil. Você não consegue fazer qualquer uso dele a não ser que você veja o &lt;code&gt;@extend&lt;/code&gt;. Um &lt;code&gt;@extend&lt;/code&gt; tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usá-lo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Ao fazer isso, o arquivo SASS vai pegar o conteúdo do placeholder &lt;code&gt;%center&lt;/code&gt; e aplicá-lo no &lt;code&gt;.container&lt;/code&gt; (mesmo que isso não aconteça exatamente assim &amp;#8211; mas isso não é importante agora). Como eu disse, você também pode &lt;em&gt;estender&lt;/em&gt; seletores CSS já existentes (além de placeholders SCSS) dessa maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
&lt;/pre&gt;

&lt;p&gt;Esse é um caso muito comum para o uso do &lt;code&gt;@extend&lt;/code&gt;. Nesse caso, pedimos para a classe &lt;code&gt;.table-zebra&lt;/code&gt; se comportar exatamente como a classe &lt;code&gt;.table&lt;/code&gt; e então adicionamos as regras específicas da classe &lt;code&gt;.table-zebra&lt;/code&gt;. &lt;em&gt;Estender&lt;/em&gt; seletores é bastante conveniente quando você desenvolve seu site ou aplicação em componentes modulares.&lt;/p&gt;

&lt;h2 id=&#34;qual-utilizar&#34;&gt;Qual utilizar?&lt;/h2&gt;

&lt;p&gt;Então, a pergunta permanece: o que você deve usar? Bem, como tudo em nossa área: &lt;strong&gt;depende&lt;/strong&gt;. Depende do contexto e, em uma outra análise, do que você está querendo fazer.&lt;/p&gt;

&lt;p&gt;O melhor conselho seria: se você precisa de variáveis, utilize o mixin. Caso contrário, use o placeholder. Há duas razões para isso:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primeiro, você não pode usar variáveis em um placeholder. Na verdade, até pode, mas você não consegue &lt;em&gt;passar&lt;/em&gt; uma variável em um placeholder para gerar um conteúdo específico de CSS, como você faria em um mixin.&lt;/li&gt;
&lt;li&gt;Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando você os utiliza sem variáveis contextuais. Simplificando: o SASS vai duplicar a saída de um mixin toda vez que você o utilizá-lo, resultando não apenas em CSS duplicado, mas também em uma folha de estilos maior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considere o primeiro exemplo desse artigo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
&lt;/pre&gt;

&lt;p&gt;O CSS compilado seria esse:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Observou o CSS duplicado? Ele não é tão prejudicial se forem apenas três linhas duplicadas, mas se você tiver muitos mixins que são usados várias vezes em um projeto, essas três linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, só que dessa vez utilizando o placeholder?&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Agora, esse é o CSS gerado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Muito melhor! A compilação leva vantagem &lt;a href=&#34;http://reference.sitepoint.com/css/selectorgrouping&#34;&gt;agrupando seletores&lt;/a&gt;, sem nenhum estilo repetido. Assim, sempre que você quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas não mudarão, é uma boa idéia &lt;em&gt;estender&lt;/em&gt; um placeholder. Isso resultará em um código CSS compilado muito mais limpo.&lt;/p&gt;

&lt;p&gt;Por outro lado, se você precisa escrever as mesmas propriedades em vários lugares mas com valores diferentes (tamanho, cores, etc), um mixin é o melhor caminho a seguir. Agora se você possui ambos, um grupo de valores fixos e outro de valores variáveis, você deve tentar usar uma combinação dos dois.&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
&lt;/pre&gt;

&lt;p&gt;Neste caso, o mixin está &lt;em&gt;estendendo&lt;/em&gt; o placeholder para os valores fixos em vez de jogá-los diretamente em seu corpo. Isso gera um CSS mais limpo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É isso. Espero ter deixado claro não só o que são mixins e placeholders, mas também quando você deve usá-los e qual os efeitos sobre o CSS compilado.&lt;/p&gt;

&lt;p&gt;Se você tiver alguma coisa a acrescentar sobre suas experiências com essas &lt;em&gt;features&lt;/em&gt; dos pré-processadores de CSS, sinta-se livre para compartilhar nos comentários.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Texto traduzido e adaptado do [Se é um tema que sempre vejo a respeito da utilização ou não, é sobre o uso de pré processadores CSS. Alguns &lt;em&gt;devs&lt;/em&gt; que costumo seguir e ler os artigos, e que pra mim são algumas das nossas referências, apontam as suas considerações sobre o tema. O Miller Medeiros, em um &lt;a href=&#34;http://blog.millermedeiros.com/the-problem-with-css-pre-processors/&#34;&gt;post&lt;/a&gt; mostra alguns pontos negativos na utilização de pré processadores. O Jean Carlos Emer em um outro &lt;a href=&#34;http://tableless.com.br/css-steroids/&#34; title=&#34;CSS on steroids&#34;&gt;post&lt;/a&gt; mostra as reais vantagens de se utilizar um pré-processador. O Diego Eis, em um outro &lt;a href=&#34;http://tableless.com.br/pre-processadores-usar-ou-nao-usar/&#34; title=&#34;Pré processadores: usar ou não usar?&#34;&gt;post&lt;/a&gt; faz uma conclusão muito boa sobre a utilização ou não:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pré processadores podem ajudar como também podem maltratar bastante. Basta um escorregão para que seu projeto vire um inferno. &amp;#8211; Diego Eis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A utilização ou não de um pré processador fica a seu critério mas, se você já utiliza nos seus projetos ou está pensando em usar, você sabe o que são um &lt;strong&gt;placeholder&lt;/strong&gt; e um &lt;strong&gt;mixin&lt;/strong&gt;? Se sim, sabe qual a principal diferença entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um &lt;a href=&#34;http://www.sitepoint.com/sass-mixin-placeholder/&#34;&gt;artigo&lt;/a&gt; do &lt;a href=&#34;https://twitter.com/HugoGiraudel&#34; title=&#34;Perfil do twitter do desenvolvedor Hugo Giraudel&#34;&gt;Hugo Giraudel&lt;/a&gt;, um dev front-end francês, no &lt;a href=&#34;http://www.sitepoint.com/&#34; title=&#34;Link do website SitePoint&#34;&gt;SitePoint&lt;/a&gt; que trata exatamente sobre esse assunto.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Quando comecei a trabalhar com SASS cerca de um ano e meio atrás, uma coisa que me levou tempo para entender foi a diferença entre &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins&#34;&gt;incluir um mixin&lt;/a&gt;&lt;/em&gt; e &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders&#34;&gt;estender um placeholder&lt;/a&gt;&lt;/em&gt;. Na verdade, até mesmo a noção de &lt;em&gt;placeholder&lt;/em&gt; era uma espécie de magia negra vodu naquela época.&lt;/p&gt;

&lt;p&gt;Se você estiver em uma situação semelhante, não se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um &lt;em&gt;mixin&lt;/em&gt;, e quando usar um &lt;em&gt;placeholder do SASS&lt;/em&gt;. Você vai entender que ambos tem diferentes finalidades e não devem ser confundidas.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro pré-processador CSS, seja Stylus, LESS, ou outro que você venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteúdo deste artigo para a ferramenta de sua escolha&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos &lt;strong&gt;placeholder e mixins do SASS&lt;/strong&gt;, então vamos fazer isso já.&lt;/p&gt;

&lt;h2 id=&#34;entendendo-o-mixin-1&#34;&gt;Entendendo o mixin&lt;/h2&gt;

&lt;p&gt;Um mixin é uma diretiva que permite que você defina várias regras com diversos argumentos. Pense nisso como uma função que irá retornar conteúdo CSS ao invés de um valor. Aqui está a definição de &lt;em&gt;mixin&lt;/em&gt; da &lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;referência do SASS&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote cite=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;
  &lt;p&gt;
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes não semânticas como &lt;i&gt;.float-left&lt;/i&gt;. Mixins podem também conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem até mesmo possuírem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agora que cobrimos a terminologia, vamos dizer que você encontra algumas declarações que são repetidas várias vezes ao longo da sua folha de estilos. Você que está familiarizado com o conceito de DRY (&lt;a href=&#34;http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself&#34;&gt;Don&amp;#8217;t Repeat Yourself&lt;/a&gt;), sabe que a repetição de código é ruim. Para corrigir isso, você pode escrever um mixin para todas aquelas declarações repetidas:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Se você não passar um argumento para um mixin, você pode omitir os parênteses. Na verdade, você pode até omiti-los na definição do &lt;code&gt;@mixin&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com este mixin recém-criado, você não precisa repetir aquelas três linhas de código cada vez que precisar centralizar um elemento; você simplesmente inclui o mixin. Muito prático, não é?!&lt;/p&gt;

&lt;p&gt;Algumas vezes você vai querer um mixin para construir o que você chamaria de &lt;em&gt;shorthand&lt;/em&gt; para algumas propriedades. Por exemplo, largura e altura. Você não está cansado de escrever as duas linhas várias e várias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
&lt;/pre&gt;

&lt;p&gt;Muito simples, não é? Note como deixamos o parâmetro &lt;code&gt;$height&lt;/code&gt; ser opcional e, por padrão assumir o mesmo valor do parâmetro &lt;code&gt;$width&lt;/code&gt; na assinatura do mixin. Agora, sempre que você precisar definir as dimensões para um elemento, você pode simplesmente fazer isso:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Um outro bom exemplo de mixin seria &lt;a href=&#34;http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/&#34;&gt;este aqui&lt;/a&gt; que eu fiz para evitar de escrever as posições &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; e &lt;code&gt;bottom&lt;/code&gt; toda vez que quiser utilizar um sistema de posicionamento diferente do estático.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;conhecendo-seu-placeholder-1&#34;&gt;Conhecendo seu Placeholder&lt;/h2&gt;

&lt;p&gt;Placeholders são um tipo de coisa estranha. Eles são classes que não são retornadas quando o seu SCSS é compilado. Você deve então pensar: &lt;em&gt;&amp;#8220;Qual é o sentido disso?&amp;#8221;&lt;/em&gt;. Na verdade, o ponto seria minímo senão fosse a expressão &lt;code&gt;@extend&lt;/code&gt;. Mas vamos por partes. Essa é a forma que você escreve um placeholder:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota do editor: Como um placeholder, um mixin é igualmente inútil, a menos que seja referenciado, assim essa seção não está dizendo que eles são diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareça similar com um bloco de declaração CSS, não será gerado por conta própria.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Basicamente você escreve exatamente como uma classe &lt;code&gt;CSS&lt;/code&gt; exceto pelo símbolo % ao invés do ponto. Além disso, segue as mesmas &lt;a href=&#34;http://www.w3.org/TR/html401/types.html#type-cdata&#34;&gt;regras de nomenclatura&lt;/a&gt; das classes.&lt;/p&gt;

&lt;p&gt;Agora, se você tentar compilar seu SCSS, você não vai ver esse pedaço de código no arquivo gerado. Como eu disse: &lt;strong&gt;placeholders não são compilados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Então, por agora, esse placeholder é totalmente inútil. Você não consegue fazer qualquer uso dele a não ser que você veja o &lt;code&gt;@extend&lt;/code&gt;. Um &lt;code&gt;@extend&lt;/code&gt; tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usá-lo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Ao fazer isso, o arquivo SASS vai pegar o conteúdo do placeholder &lt;code&gt;%center&lt;/code&gt; e aplicá-lo no &lt;code&gt;.container&lt;/code&gt; (mesmo que isso não aconteça exatamente assim &amp;#8211; mas isso não é importante agora). Como eu disse, você também pode &lt;em&gt;estender&lt;/em&gt; seletores CSS já existentes (além de placeholders SCSS) dessa maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
&lt;/pre&gt;

&lt;p&gt;Esse é um caso muito comum para o uso do &lt;code&gt;@extend&lt;/code&gt;. Nesse caso, pedimos para a classe &lt;code&gt;.table-zebra&lt;/code&gt; se comportar exatamente como a classe &lt;code&gt;.table&lt;/code&gt; e então adicionamos as regras específicas da classe &lt;code&gt;.table-zebra&lt;/code&gt;. &lt;em&gt;Estender&lt;/em&gt; seletores é bastante conveniente quando você desenvolve seu site ou aplicação em componentes modulares.&lt;/p&gt;

&lt;h2 id=&#34;qual-utilizar-1&#34;&gt;Qual utilizar?&lt;/h2&gt;

&lt;p&gt;Então, a pergunta permanece: o que você deve usar? Bem, como tudo em nossa área: &lt;strong&gt;depende&lt;/strong&gt;. Depende do contexto e, em uma outra análise, do que você está querendo fazer.&lt;/p&gt;

&lt;p&gt;O melhor conselho seria: se você precisa de variáveis, utilize o mixin. Caso contrário, use o placeholder. Há duas razões para isso:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primeiro, você não pode usar variáveis em um placeholder. Na verdade, até pode, mas você não consegue &lt;em&gt;passar&lt;/em&gt; uma variável em um placeholder para gerar um conteúdo específico de CSS, como você faria em um mixin.&lt;/li&gt;
&lt;li&gt;Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando você os utiliza sem variáveis contextuais. Simplificando: o SASS vai duplicar a saída de um mixin toda vez que você o utilizá-lo, resultando não apenas em CSS duplicado, mas também em uma folha de estilos maior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considere o primeiro exemplo desse artigo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
&lt;/pre&gt;

&lt;p&gt;O CSS compilado seria esse:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Observou o CSS duplicado? Ele não é tão prejudicial se forem apenas três linhas duplicadas, mas se você tiver muitos mixins que são usados várias vezes em um projeto, essas três linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, só que dessa vez utilizando o placeholder?&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Agora, esse é o CSS gerado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Muito melhor! A compilação leva vantagem &lt;a href=&#34;http://reference.sitepoint.com/css/selectorgrouping&#34;&gt;agrupando seletores&lt;/a&gt;, sem nenhum estilo repetido. Assim, sempre que você quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas não mudarão, é uma boa idéia &lt;em&gt;estender&lt;/em&gt; um placeholder. Isso resultará em um código CSS compilado muito mais limpo.&lt;/p&gt;

&lt;p&gt;Por outro lado, se você precisa escrever as mesmas propriedades em vários lugares mas com valores diferentes (tamanho, cores, etc), um mixin é o melhor caminho a seguir. Agora se você possui ambos, um grupo de valores fixos e outro de valores variáveis, você deve tentar usar uma combinação dos dois.&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
&lt;/pre&gt;

&lt;p&gt;Neste caso, o mixin está &lt;em&gt;estendendo&lt;/em&gt; o placeholder para os valores fixos em vez de jogá-los diretamente em seu corpo. Isso gera um CSS mais limpo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;conclusão-1&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É isso. Espero ter deixado claro não só o que são mixins e placeholders, mas também quando você deve usá-los e qual os efeitos sobre o CSS compilado.&lt;/p&gt;

&lt;p&gt;Se você tiver alguma coisa a acrescentar sobre suas experiências com essas &lt;em&gt;features&lt;/em&gt; dos pré-processadores de CSS, sinta-se livre para compartilhar nos comentários.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Texto traduzido e adaptado do]&lt;a href=&#34;http://www.sitepoint.com/sass-mixin-placeholder/&#34;&gt;4&lt;/a&gt; escrito pelo &lt;a href=&#34;https://twitter.com/HugoGiraudel&#34; title=&#34;Perfil do twitter&#34;&gt;Hugo Giraudel&lt;/a&gt; em 30 de janeiro de 2014.&lt;/p&gt;

&lt;p&gt;Tradução autorizada pelo &lt;a href=&#34;http://www.sitepoint.com/&#34;&gt;SitePoint&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Qualquer erro ou sugestão de melhoria na tradução, é bem vinda! 🙂&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>