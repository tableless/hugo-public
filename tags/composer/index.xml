<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Composer on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/composer/index.xml</link>
    <description>Recent content in Composer on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/composer/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Instalando Laravel 5.2</title>
      <link>https://tableless.github.io/hugo-public/instalando-laravel-5-2/</link>
      <pubDate>Wed, 13 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/instalando-laravel-5-2/</guid>
      <description>

&lt;p&gt;Neste artigo irei demonstrar como instalar e começar a utilizar o &lt;a class=&#34;markup--anchor markup--p-anchor&#34; href=&#34;http://laravel.com/&#34; rel=&#34;nofollow&#34;&gt;Laravel&lt;/a&gt; 5.2, framework que vem ganhando visibilidade no mercado.&lt;/p&gt;

&lt;p id=&#34;42c9&#34; class=&#34;graf--p graf-after--p&#34;&gt;
  O que iremos utilizar:
&lt;/p&gt;

&lt;ul class=&#34;postList&#34;&gt;
  &lt;li id=&#34;1067&#34; class=&#34;graf--li graf-after--p&#34;&gt;
    &lt;a class=&#34;markup--anchor markup--li-anchor&#34; href=&#34;http://getcomposer.org/&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;Composer&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p id=&#34;a825&#34; class=&#34;graf--p graf-after--li&#34;&gt;
  Requisitos do servidor:
&lt;/p&gt;

&lt;ul class=&#34;postList&#34;&gt;
  &lt;li id=&#34;e023&#34; class=&#34;graf--li graf-after--p&#34;&gt;
    PHP versão maior ou igual a 5.5.9;
  &lt;/li&gt;
  &lt;li id=&#34;9d69&#34; class=&#34;graf--li graf-after--li&#34;&gt;
    OpenSSL PHP Extension;
  &lt;/li&gt;
  &lt;li id=&#34;9f4e&#34; class=&#34;graf--li graf-after--li&#34;&gt;
    PDO PHP Extension;
  &lt;/li&gt;
  &lt;li id=&#34;f2d1&#34; class=&#34;graf--li graf-after--li&#34;&gt;
    Mbstring PHP Extension;
  &lt;/li&gt;
  &lt;li id=&#34;ee0f&#34; class=&#34;graf--li graf-after--li&#34;&gt;
    Tokenizer PHP Extension;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;00b3.graf--h4.graf-after--li&#34;&gt;Instalando o Composer&lt;/h4&gt;

&lt;p id=&#34;d940&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  Na pasta onde localiza-se a aplicação, abra o terminal e digite:
&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;#Caso tenha o Curl instalado
curl -s https://getcomposer.org/installer | php
## ou ##
#Caso não possua o Curl instalado
php -r &#34;readfile(&#39;https://getcomposer.org/installer&#39;);&#34; | php&lt;/pre&gt;

&lt;h4 id=&#34;87d9.graf--h4.graf-after--p&#34;&gt;Baixando o Laravel Installer&lt;/h4&gt;

&lt;p id=&#34;25d6&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  Para baixar o instalador do Laravel, execute o seguinte comando:
&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;composer global require &#34;laravel/installer&#34;
&lt;/pre&gt;

&lt;p&gt;Agora é necessário adicioná-lo ao PATH do sistema, para que ele possa ser executado de qualquer lugar.&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;export PATH=&#34;$PATH:$HOME/.composer/vendor/bin&#34;
&lt;/pre&gt;

&lt;p&gt;Uma vez feito esta sequência, o comando “laravel” já está disponível para ser usado. Para criar um novo projeto, execute o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;laravel new AppName
&lt;/pre&gt;

&lt;p&gt;Este comando irá criar toda a estrutura necessária para sua aplicação.&lt;/p&gt;

&lt;h4 id=&#34;e83c.graf--h4.graf-after--p&#34;&gt;Configurando&lt;/h4&gt;

&lt;p id=&#34;f600&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  Todas as configurações do Laravel estão armazenadas no diretório “config” e estão bem documentadas.
&lt;/p&gt;

&lt;h4 id=&#34;2c0c.graf--h4.graf-after--p&#34;&gt;Permissões de Pasta&lt;/h4&gt;

&lt;p id=&#34;3fdf&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  As pastas “storage” e “bootstrap/cache” precisam ter permissão de escrita pelo servidor, ou o Laravel não funcionará corretamente.
&lt;/p&gt;

&lt;h4 id=&#34;629e.graf--h4.graf-after--p&#34;&gt;Configuração Local&lt;/h4&gt;

&lt;p id=&#34;c0d5&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  Em desenvolvimento de softwares é normal termos uma equipe para todo o processo de criação do software, e cada membro da equipe possui suas preferências quanto a nome de banco de dados, senhas etc. Para tratar isto, o Laravel utiliza arquivos “.env” (&lt;a class=&#34;markup--anchor markup--p-anchor&#34; href=&#34;https://github.com/vlucas/phpdotenv&#34; target=&#34;_blank&#34; rel=&#34;nofollow&#34;&gt;leia mais sobre este projeto&lt;/a&gt;). O arquivo .env deve ser ignorado em seu controle de versão. Para criar seu arquivo .env utilize o exemplo do próprio Laravel e altere as configurações de acordo com seu ambiente.
&lt;/p&gt;

&lt;h4 id=&#34;5e69.graf--h4.graf-after--p&#34;&gt;Application Key&lt;/h4&gt;

&lt;p id=&#34;a431&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  O próximo passo é setar a &lt;em&gt;application key&lt;/em&gt;, chave de segurança que será utilizada para encriptar dados em sua aplicação. Utilize o comando no Artisan para gerar sua &lt;em&gt;application key&lt;/em&gt;.
&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php artisan key:generate&lt;/pre&gt;

&lt;h4 id=&#34;61a4.graf--h4.graf-after--figure&#34;&gt;Testando sua instalação&lt;/h4&gt;

&lt;p id=&#34;e0c1&#34; class=&#34;graf--p graf-after--h4&#34;&gt;
  Para verificar se a instalação está funcionando, utilize o Artisan para subir um servidor &lt;em&gt;built-in&lt;/em&gt;. No terminal exibirá um endereço como: http://localhost:8000. Digite o comando &amp;#8220;serve&amp;#8221; (sem r mesmo):
&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;php artisan serve
&lt;/pre&gt;

&lt;p&gt;E é isto pessoal, mais nenhuma configuração adicional é necessária para começar a brincar com o Laravel. Agora é com você, pois há muito o que explorar neste fascinante framework. &lt;em&gt;Regards&lt;/em&gt;!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Conhecendo e instalando o Silex</title>
      <link>https://tableless.github.io/hugo-public/conhecendo-e-instalando-o-silex/</link>
      <pubDate>Tue, 30 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/conhecendo-e-instalando-o-silex/</guid>
      <description>

&lt;p&gt;O &lt;a href=&#34;http://silex.sensiolabs.org/&#34; target=&#34;_blank&#34;&gt;Silex&lt;/a&gt; é um micro framework baseado nos componentes do &lt;a href=&#34;http://symfony.com/&#34; target=&#34;_blank&#34;&gt;Symfony&lt;/a&gt;. Foi desenvolvido por &lt;a href=&#34;http://fabien.potencier.org/&#34; target=&#34;_blank&#34;&gt;Fabien Potencier&lt;/a&gt;, o mesmo criador do Symfony.&lt;/p&gt;

&lt;p&gt;O Silex foi concebido para a criação de aplicações pequenas com foco na agilidade, extensibilidade e para ser facilmente testável. Ele provê um sistema de rotas muito poderoso, e se propõe a resolvê-las através dos Services e Providers, conceitos que veremos mais à frente. Você perceberá que ele é facilmente estendido e suas funcionalidades recebem uma vantagem através dessas integrações.&lt;/p&gt;

&lt;h2 id=&#34;instalação&#34;&gt;Instalação&lt;/h2&gt;

&lt;p&gt;Para instalar o Silex em nossos projetos é muito simples: precisamos apenas do &lt;a href=&#34;https://getcomposer.org&#34; target=&#34;_blank&#34;&gt;Composer&lt;/a&gt; para gerenciar nossas dependências.&lt;/p&gt;

&lt;p&gt;Mas afinal, o que é o Composer? O Composer é um gerenciador de dependências para aplicações PHP, baseado nas GEMs do Ruby e no NPM do Node.JS. Com o Composer você pode facilmente gerenciar a instalação de pacotes de terceiros, bem como preparar o seu pacote para que ele fique disponível para os desenvolvedores que utilizam essa ferramenta. Tudo que precisaremos é de um arquivo composer.json na raiz de nosso projeto. Utilizaremos &lt;code&gt;api-events&lt;/code&gt; como nome da nossa pasta.&lt;/p&gt;

&lt;p&gt;Na raiz dessa pasta crie um arquivo composer.json com o seguinte conteúdo:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;require&#34; : {
    &#34;silex/silex&#34; : &#34;^1.2&#34;
    }
}
&lt;/pre&gt;

&lt;p&gt;O composer.json é o arquivo que o Composer lê para poder realizar as tarefas de download e instalação dos pacotes especificados.&lt;/p&gt;

&lt;p&gt;Agora vamos instalar o Composer em nosso projeto. O Composer pode ser utilizado de duas maneiras: de forma local e de forma global. Abordarei aqui a forma local. Para instalá-lo em sistemas Unix, você precisará da &lt;em&gt;lib curl&lt;/em&gt; disponível. Se você utiliza o Windows, baixe o executável &lt;a href=&#34;https://getcomposer.org/Composer-Setup.exe&#34; target=&#34;_blank&#34;&gt;aqui&lt;/a&gt;. O seguinte comando, executado via terminal (e na raiz de nosso projeto), deve instalar o Composer para você:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/curl-composer.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-49783 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/curl-composer.png&#34; alt=&#34;Curl Composer&#34; width=&#34;902&#34; height=&#34;72&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O comando fará o download e irá compilar o composer.phar e arquivos &lt;a href=&#34;http://php.net/phar&#34;&gt;&lt;code&gt;.phar&lt;/code&gt;&lt;/a&gt;, que são extensões executáveis do PHP. Agora que temos o arquivo de configuração e o Composer em nosso projeto, podemos instalar nossas dependências, ou seja, o Silex propriamente dito. É muito simples realizar a instalação dos pacotes: na raiz do seu projeto, execute o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php composer.phar install&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;É preciso que você tenha o &lt;a href=&#34;http://www.php-cli.com/&#34; target=&#34;_blank&#34;&gt;php-cli&lt;/a&gt; disponível em seu terminal. O comando acima verificará o arquivo &lt;code&gt;composer.json&lt;/code&gt; e logo em seguida fará o download do Silex, conforme requerido no arquivo &lt;code&gt;.json&lt;/code&gt; da versão 1.2. Após tudo concluído, você verá uma imagem semelhante a essa:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/packages-installed.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-49784 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/packages-installed.png&#34; alt=&#34;Silex - Packages instalados&#34; width=&#34;742&#34; height=&#34;769&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O Composer instalou o Silex bem como as dependências utilizadas pelo mesmo dentro da pasta &lt;code&gt;vendor&lt;/code&gt; do nosso projeto. Além do download, ele também mapeia os &lt;em&gt;namespaces&lt;/em&gt; dos pacotes e cria um _autoload._ Através deste &lt;em&gt;autoload&lt;/em&gt; teremos acesso a todos os pacotes baixados até o momento.&lt;/p&gt;

&lt;h2 id=&#34;silex-hello-world&#34;&gt;Silex: Hello World!&lt;/h2&gt;

&lt;p&gt;Agora que nossas dependências foram baixadas e instaladas, podemos começar a utilizar nosso micro framework: crie um arquivo &lt;code&gt;index.php&lt;/code&gt; na raiz da sua pasta e adicione a abertura do código PHP utilizando o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;echo &amp;quot;&amp;lt;?php &amp;quot; &amp;gt; index.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Abaixo segue o código do index na íntegra:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
use Silex\Application;
require &#39;vendor/autoload.php&#39;;
$app = new Application();
$app-&amp;gt;get(&#39;/&#39;, function(){
    return &#39;Hello World&#39;;
});
$app-&amp;gt;run();
&lt;/pre&gt;

&lt;p&gt;Na linha 2 informo ao meu script para utilizar o Silex com o namespace &lt;code&gt;Silex\Application&lt;/code&gt;. Para ter acesso aos namespaces dos pacotes baixados (como comentado anteriormente sobre o autoload) precisamos adicionar o mesmo em nosso index. Para isso utilizamos o &lt;code&gt;require&lt;/code&gt; na linha 3. Na linha 4 simplesmente instanciamos nosso micro framework. O já citado poderoso sistema de rotas pode ser visto das linhas 5 a 6, onde utilizamos o método &lt;code&gt;get&lt;/code&gt;. O método &lt;code&gt;get&lt;/code&gt; manipula as requisições GET vindas do _client_ e no nosso caso fazemos o seguinte:&lt;/p&gt;

&lt;p&gt;Quando o cliente realizar uma requisição do tipo GET em nossa rota raiz, referenciada através da &lt;code&gt;/&lt;/code&gt;, nós executaremos o que for passado dentro do &lt;em&gt;callback&lt;/em&gt;, o segundo parâmetro do método &lt;code&gt;get&lt;/code&gt; do &lt;code&gt;Silex\Application&lt;/code&gt;. Como queremos apenas realizar (imprimir) um &amp;#8220;Hello World&amp;#8221;, vamos retornar essa &lt;em&gt;string&lt;/em&gt; em nosso &lt;em&gt;callback&lt;/em&gt; para a rota raiz.&lt;/p&gt;

&lt;p&gt;E por fim, para que as respostas emitidas pelo Silex sejam enviadas ao browser ou a quem as solicitou, utilizamos o método &lt;code&gt;run&lt;/code&gt; em nossa linha 8. Ao rodar nosso app no browser, temos a seguinte resposta:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Hello World&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Podemos ver o quão simples é utilizar esse micro framework através dos processos vistos até aqui. Para os próximos artigos, vamos nos aprofundar mais neste micro framework e ver como utilizá-lo melhor em casos reais.&lt;/p&gt;

&lt;p&gt;Por hora, pratique os conhecimentos aqui passados. Nos vemos em breve!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Entendendo o padrão MVC na prática</title>
      <link>https://tableless.github.io/hugo-public/entendendo-o-padrao-mvc-na-pratica/</link>
      <pubDate>Thu, 25 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/entendendo-o-padrao-mvc-na-pratica/</guid>
      <description>&lt;p&gt;Práticas modernas do PHP exigem estudo e preparação, e o padrão de projeto que merece muita atenção é o MVC. Muita gente conhece este padrão através dos &lt;em&gt;frameworks&lt;/em&gt; (isso não é um problema, eu mesmo estou neste grupo), mas ir a fundo é essencial para evitar erros e falar coisas como:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Seu MVC está errado, o &lt;em&gt;controller&lt;/em&gt; está maior que o &lt;em&gt;model&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Este erro de definição acontece pois em nenhum lugar está escrito que a quantidade de linhas define o padrão MVC, mas vamos entender isto melhor?&lt;/p&gt;

&lt;h2 id=&#34;as-camadas-do-mvc&#34;&gt;As camadas do MVC&lt;/h2&gt;

&lt;h3 id=&#34;o-que-é-model&#34;&gt;O que é &lt;em&gt;Model&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Model&lt;/em&gt; é onde fica a lógica da aplicação. Só isso.&lt;/p&gt;

&lt;p&gt;Vai disparar um e-mail? Validar um formulário? Enviar ou receber dados do banco? Não importa. A &lt;em&gt;model&lt;/em&gt; deve saber como executar as tarefas mais diversa, mas não precisa saber quando deve ser feito, nem como mostrar estes dados.&lt;/p&gt;

&lt;h3 id=&#34;o-que-é-view&#34;&gt;O que é &lt;em&gt;View&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;View&lt;/em&gt; exibe os dados. Só isso.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;View&lt;/em&gt; não é só o HTML, mas qualquer tipo de retorno de dados, como &lt;em&gt;PDF&lt;/em&gt;, &lt;em&gt;Json&lt;/em&gt;, &lt;em&gt;XML&lt;/em&gt;, o retorno dos dados do servidor &lt;em&gt;RESTFull&lt;/em&gt;, os &lt;em&gt;tokens&lt;/em&gt; de autenticação &lt;em&gt;OAuth2&lt;/em&gt;, entre outro. Qualquer retorno de dados para uma interface qualquer (o navegador, por exemplo) é responsabilidade da &lt;em&gt;view&lt;/em&gt;. A &lt;em&gt;view&lt;/em&gt; deve saber renderizar os dados corretamente, mas não precisa saber como obtê-los ou quando renderizá-los.&lt;/p&gt;

&lt;h3 id=&#34;o-que-é-controller&#34;&gt;O que é &lt;em&gt;Controller&lt;/em&gt;?&lt;/h3&gt;

&lt;p&gt;O &lt;em&gt;controller&lt;/em&gt; diz quando as coisas devem acontecer. Só isso.&lt;/p&gt;

&lt;p&gt;É usado para intermediar a &lt;em&gt;model&lt;/em&gt; e a _view_ de uma camada. Por exemplo, para pegar dados da &lt;em&gt;model&lt;/em&gt; (guardados em um banco) e exibir na &lt;em&gt;view&lt;/em&gt; (em uma página HTML), ou pegar os dados de um formulário (&lt;em&gt;view&lt;/em&gt;) e enviar para alguém (&lt;em&gt;model&lt;/em&gt;). Também é responsabilidade do &lt;em&gt;controller&lt;/em&gt; cuidar das requisições (&lt;em&gt;request&lt;/em&gt; e &lt;em&gt;response&lt;/em&gt;) e isso também inclui os famosos &lt;em&gt;middlewares&lt;/em&gt; (&lt;a href=&#34;http://laravel.com/&#34; target=&#34;_blank&#34;&gt;Laravel&lt;/a&gt;, &lt;a href=&#34;http://www.slimframework.com/&#34; target=&#34;_blank&#34;&gt;Slim Framework&lt;/a&gt;, &lt;a href=&#34;http://expressjs.com/&#34; target=&#34;_blank&#34;&gt;Express&lt;/a&gt;, &lt;a href=&#34;http://www.rubyonrails.com.br/&#34; target=&#34;_blank&#34;&gt;Ruby on Rails&lt;/a&gt;, etc.). O &lt;em&gt;controller&lt;/em&gt; não precisa saber como obter os dados nem como exibi-los, só quando fazer isso.&lt;/p&gt;

&lt;h2 id=&#34;na-prática&#34;&gt;Na prática&lt;/h2&gt;

&lt;p&gt;Uma sugestão aos desenvolvedores é criar seu próprio &lt;em&gt;framework&lt;/em&gt; de estudo (e publicar no &lt;a href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;) mas nunca os usar em produção. Esta prática te faz compreender o quanto você conhece da linguagem, e daqui a algum tempo, ver o quanto melhorou.&lt;/p&gt;

&lt;p&gt;Neste estudo, vamos criar uma aplicação MVC simples com PHP, usando práticas modernas.&lt;/p&gt;

&lt;p&gt;Para começar, vamos utilizar a ideia de que não devemos criar nada que já existe: este é o princípio da interoperabilidade buscada pelo &lt;a href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;PHP-FIG&lt;/a&gt; (grupo formado pelas principais empresas e grupos PHP para definir boas práticas e padrões). Utilizaremos &lt;a href=&#34;http://www.php-fig.org/psr/psr-4/&#34; target=&#34;_blank&#34;&gt;PSR-4&lt;/a&gt; e &lt;a href=&#34;https://getcomposer.org/&#34; target=&#34;_blank&#34;&gt;Composer&lt;/a&gt; para gerenciar o carregamento das classes.&lt;/p&gt;

&lt;p&gt;Para instalar o Composer, cito uma parte do artigo &lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34; target=&#34;_blank&#34;&gt;Composer para iniciantes&lt;/a&gt; de &lt;a href=&#34;http://www.andrebian.com/&#34; target=&#34;_blank&#34;&gt;Andre Cardoso&lt;/a&gt; aqui no Tableless:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primeiramente você precisa realizar o download do &lt;em&gt;phar&lt;/em&gt; do composer. O &lt;a title=&#34;Descubra o que é um arquivo Phar&#34; href=&#34;https://php.net/manual/pt_BR/book.phar.php&#34; target=&#34;_blank&#34;&gt;phar&lt;/a&gt; é um empacotamento de uma aplicação e é utilizado para fornecer bibliotecas e ferramentas nas quais o desenvolvedor não tem de se preocupar com sua estrutura. Em outras palavras, é pegar e usar.&lt;/li&gt;
&lt;li&gt;Para que você obtenha o composer há duas maneiras distintas. Através da biblioteca &lt;a title=&#34;Descubra o que é cURL&#34; href=&#34;http://en.wikipedia.org/wiki/CURL&#34; target=&#34;_blank&#34;&gt;cURL&lt;/a&gt; e através do próprio PHP. Basta selecionar uma das opções abaixo e executar em seu terminal.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instalando via cURL:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -sS https://getcomposer.org/installer | php&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instalando via PHP:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;php -r “readfile(‘https://getcomposer.org/installer’);” | php&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Para saber mais sobre &lt;a href=&#34;http://www.php-fig.org/psr/psr-4/&#34; target=&#34;_blank&#34;&gt;PSR-4 veja o guia oficial aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Na raiz do diretório do seu projeto crie estes 5 arquivos (e diretórios):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;src/App/Mvc/Controller.php&lt;/li&gt;
&lt;li&gt;src/App/Mvc/Model.php&lt;/li&gt;
&lt;li&gt;src/App/Mvc/View.php&lt;/li&gt;
&lt;li&gt;composer.json&lt;/li&gt;
&lt;li&gt;index.php&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ao baixar o composer.phar (explicado acima) você também o terá no diretório raiz, junto ao composer.json e ao index.php&lt;/p&gt;

&lt;p&gt;O seu arquivo composer.json deverá ter o conteúdo a seguir:&lt;/p&gt;

&lt;pre&gt;{
   &#34;autoload&#34;: {
      &#34;psr-4&#34;: {
         &#34;App\\&#34;: &#34;src/App&#34;
      }
   }
}&lt;/pre&gt;

&lt;p&gt;Rode o comando &lt;code&gt;php composer.phar install.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A ideia é que o nosso &lt;em&gt;controller&lt;/em&gt; carregue as informações da _model _e as envie para a &lt;em&gt;view&lt;/em&gt;. Pensando nisso, faremos com que o &lt;em&gt;controller&lt;/em&gt; carregue ambas as classes: &lt;em&gt;Model&lt;/em&gt; e &lt;em&gt;View&lt;/em&gt;. A sequência para criá-las é:&lt;/p&gt;

&lt;p&gt;Conteúdo do arquivo src/App/Mvc/Controller.php:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class Controller
   {
      ...
   }&lt;/pre&gt;

&lt;p&gt;Conteúdo do arquivo src/App/Mvc/Model.php:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class Model
   {
      ...
   }&lt;/pre&gt;

&lt;p&gt;Conteúdo do arquivo src/App/Mvc/View.php:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class View
   {
      ...
   }&lt;/pre&gt;

&lt;p&gt;Seguimos algumas regras da PSR-4: primeiro registramos um &lt;em&gt;namespace&lt;/em&gt; no composer.json que vai até o diretório src/App. Toda classe tem um &lt;em&gt;namespace&lt;/em&gt; e o App do começo indica o diretório que registramos (src/App). O Mvc é o diretório seguinte (ficando src/App/Mvc) e a classe tem o mesmo nome do arquivo (src/App/Mvc/Controller.php). Com isso podemos carregar as classes dinamicamente:&lt;/p&gt;

&lt;p&gt;Conteúdo do arquivo index.php:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   require &#39;vendor/autoload.php&#39;;
   $controller = new App\Mvc\Controller();&lt;/pre&gt;

&lt;p&gt;Nossa classe ainda não faz nada, então vamos testar com algo mais concreto: no Controller.php adicione um novo método chamado index() &amp;#8211; os métodos públicos de um &lt;em&gt;Controller&lt;/em&gt; são chamados de &lt;em&gt;actions&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class Controller
   {
      public function index()
      {
         echo &#39;Olá mundo!&#39;;
      }
   }&lt;/pre&gt;

&lt;p&gt;E no index.php adicione no final a linha:&lt;/p&gt;

&lt;pre&gt;$controller-&amp;gt;index();&lt;/pre&gt;

&lt;p&gt;Ao rodar o index.php você verá um &lt;em&gt;&amp;#8220;Olá mundo!&amp;#8221;&lt;/em&gt; na tela. Agora vamos separar este código nas camadas do MVC.&lt;/p&gt;

&lt;p&gt;No &lt;em&gt;model&lt;/em&gt;, vamos criar o método que serve o texto em questão. Ele poderia carregar um componente que facilitaria as tarefas com o banco de dados, como o &lt;a href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;Doctrine&lt;/a&gt;, por exemplo, mas aqui só retorna um texto.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class Model
   {
      public function getText($str = &#39;Olá mundo!&#39;)
      {
         return $str;
      }
   }&lt;/pre&gt;

&lt;p&gt;Na &lt;em&gt;view&lt;/em&gt; vamos imprimir este texto na tela. Poderíamos carregar um &lt;em&gt;template engine&lt;/em&gt; (&lt;a href=&#34;http://laravel.com/docs/5.0/templates&#34; target=&#34;_blank&#34;&gt;Blade&lt;/a&gt;, &lt;a href=&#34;http://twig.sensiolabs.org/&#34; target=&#34;_blank&#34;&gt;Twig&lt;/a&gt;, etc.), ou até criar o nosso próprio, mas ele só fará um &lt;em&gt;echo&lt;/em&gt; mesmo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class View
   {
      public function render($str)
      {
         echo $str;
      }
   }&lt;/pre&gt;

&lt;p&gt;E o &lt;em&gt;controller&lt;/em&gt; intermediando tudo isso:&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
   namespace App\Mvc;
   class Controller
   {
      public function index()
      {
         $model = new Model;
         $view = new View;
         $view-&amp;gt;render($model-&amp;gt;getText());
      }
   }&lt;/pre&gt;

&lt;p&gt;Rode o index.php novamente e você vai obter o mesmo resultado anterior, mas agora com uma estrutura MVC.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Note que neste exemplo a maior classe é o &lt;em&gt;controller&lt;/em&gt; (com 14 linhas) e mesmo assim não estamos &amp;#8220;quebrando o MVC&amp;#8221;. Também não há nada de absurdo, como carregar a classe &lt;em&gt;Model&lt;/em&gt; no &lt;em&gt;Controller&lt;/em&gt; e passar todas as configurações gigantescas ali dentro. Mesmo que não seja uma quebra de MVC, o &lt;em&gt;Model&lt;/em&gt; ainda vai cuidar de tudo. O ideal é mover o máximo de lógica para dentro da &lt;em&gt;Model&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Apenas para reforçar, o exemplo abaixo deveria estar dentro de um arquivo de &lt;em&gt;Model&lt;/em&gt;, e nunca no &lt;em&gt;Controller&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;$users = User::whereRaw(&#39;age &amp;gt; ? and votes = 100&#39;, [25])-&amp;gt;get();&lt;/pre&gt;

&lt;p&gt;Este último exemplo foi retirado de &lt;a href=&#34;http://laravel.com/docs/5.0/eloquent&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://laravel.com/docs/5.0/eloquent&#34;&gt;http://laravel.com/docs/5.0/eloquent&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Quanto mais organizada e centralizada a lógica, melhor. Pense nisso e comece a pesquisar &lt;a href=&#34;https://www.google.com.br/search?q=Dependency+Injection&amp;oq=Dependency+Injection&amp;aqs=chrome..69i57&amp;sourceid=chrome&amp;es_sm=122&amp;ie=UTF-8&#34; target=&#34;_blank&#34;&gt;Dependency Injection&lt;/a&gt;. Isso organiza seu código ainda mais.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Instalando o CAKEPHP 3.0 via Composer</title>
      <link>https://tableless.github.io/hugo-public/instalando-o-cakephp-3-0-via-composer/</link>
      <pubDate>Sun, 07 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/instalando-o-cakephp-3-0-via-composer/</guid>
      <description>

&lt;p&gt;Requisitos do tutorial:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;PHP instalado e configurado&lt;/li&gt;
&lt;li&gt;Ambiente Linux&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;No dia 22/03/2015 foi disponibilizado para download no &lt;a href=&#34;http://cakephp.org&#34;&gt;site do CakePHP&lt;/a&gt; a &lt;a href=&#34;http://book.cakephp.org/3.0/en/installation.html&#34;&gt;versão 3.0 do framework para PHP CakePHP&lt;/a&gt;. Já utilizamos a versão 2.x em projetos aqui na empresa e tivemos bons resultados.&lt;/p&gt;

&lt;p&gt;Com o lançamento desta nova versão, muita coisa mudou: um novo ORM foi lançado; o uso de namespaces foi adotado; entre outras features que iremos abordar em outras publicações.&lt;/p&gt;

&lt;p&gt;Neste artigo irei realizar um passo a passo da instalação do Cakephp 3.0 &lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34;&gt;utilizando o Composer&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;o-que-é-o-composer&#34;&gt;O que é o Composer&lt;/h3&gt;

&lt;p&gt;O Composer é o gerenciador de dependências do PHP, com ele é possível definir uma lista de bibliotecas que sua aplicação necessita para funcionar, além de poder definir requisitos como, versão do PHP, extensions etc.&lt;/p&gt;

&lt;p&gt;Para aprender mais sobre o Composer, listei alguns artigos abaixo:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://blog.thiagobelem.net/gerenciando-dependencias-com-o-composer/&#34;&gt;http://blog.thiagobelem.net/gerenciando-dependencias-com-o-composer/&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34;&gt;http://tableless.com.br/composer-para-iniciantes/&lt;/a&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://getcomposer.org ( site oficial)&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://getcomposer.org&#34;&gt;http://getcomposer.org&lt;/a&gt; ( site oficial)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;instalando-o-composer&#34;&gt;Instalando o Composer&lt;/h3&gt;

&lt;p&gt;Na pasta onde irá ficar localizada a aplicação, abra o terminal e digite o seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;#Caso tenha o Curl instalado
curl -s https://getcomposer.org/installer | php
## ou ##
#Caso não possua o Curl instalado
php -r &#34;readfile(&#39;https://getcomposer.org/installer&#39;);&#34; | php&lt;/pre&gt;

&lt;p&gt;Documentação do comando usado: &lt;a href=&#34;http://php.net/manual/pt_BR/features.commandline.options.php%20http://curl.haxx.se/mail/lib-2004-07/0017.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://php.net/manual/pt_BR/features.commandline.options.php&#34;&gt;http://php.net/manual/pt_BR/features.commandline.options.php&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://php.net/manual/pt_BR/features.commandline.options.php%20http://curl.haxx.se/mail/lib-2004-07/0017.html&#34;&gt;http://curl.haxx.se/mail/lib-2004-07/0017.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;instalando-o-cakephp-3&#34;&gt;Instalando o CakePHP 3&lt;/h3&gt;

&lt;h4 id=&#34;requisitos-mínimos&#34;&gt;Requisitos Mínimos&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;HTTP Server. Exemplo: Apache, Ngix. Com mod_rewrite habilitado de preferência, mas não é obrigatório.&lt;/li&gt;
&lt;li&gt;PHP 5.4.16 ou maior&lt;/li&gt;
&lt;li&gt;extensão mbstring&lt;/li&gt;
&lt;li&gt;extensão intl (Como instalar/habilitar: &lt;a href=&#34;http://goo.gl/qz6tqT&#34;&gt;http://goo.gl/qz6tqT&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Para instalar o framework, na pasta do projeto onde também o Composer foi instalado e digite o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;#Install cakephp3
composer create-project --prefer-dist cakephp/app [nome da app]&lt;/pre&gt;

&lt;p&gt;Documentação do comando usado: &lt;a href=&#34;https://getcomposer.org/doc/03-cli.md#create-project&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://getcomposer.org/doc/03-cli.md#create-project&#34;&gt;https://getcomposer.org/doc/03-cli.md#create-project&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Para testar se a aplicação foi instalada com sucesso, acesse a pasta da aplicação, no caso o mesmo nome que digitou em [nome da app] e digite o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;#Inicia built-in server
./bin/cake server&lt;/pre&gt;

&lt;p&gt;Documentação do comando usado: &lt;a href=&#34;http://book.cakephp.org/3.0/en/console-and-shells.html&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;http://book.cakephp.org/3.0/en/console-and-shells.html&#34;&gt;http://book.cakephp.org/3.0/en/console-and-shells.html&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Após, se tudo ocorrer bem, uma mensagem será exibida no terminal informando que o servidor embutido foi iniciado e que se encontra disponível no endereço: &lt;a href=&#34;http://localhost:8765/&#34;&gt;http://localhost:8765/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Por enquanto é só galera, caso tenham alguma dúvida ou problema durante a instalação, ficarei feliz em ajudar.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHPUnit – persistência e configurações avançadas</title>
      <link>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</link>
      <pubDate>Thu, 08 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</guid>
      <description>

&lt;p&gt;Neste artigo você verá como utilizar o &lt;a title=&#34;PHPUnit - site oficial&#34; href=&#34;http://phpunit.de/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; para realizar testes com persistência de dados utilizando o &lt;a title=&#34;Projeto Doctrine&#34; href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;Doctrine&lt;/a&gt; um &lt;a title=&#34;O que é um ORM?&#34; href=&#34;http://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional&#34; target=&#34;_blank&#34;&gt;ORM&lt;/a&gt; open-source e como definir configurações avançadas para personalizar sua suíte de testes e gerar relatórios de testes executados bem como cobertura do código de produção.&lt;/p&gt;

&lt;h2 id=&#34;começando&#34;&gt; Começando&lt;/h2&gt;

&lt;p&gt;Para começar o projeto crie um arquivo chamado &lt;em&gt;composer.json&lt;/em&gt;. Nele listaremos todos os pacotes/bibliotecas de terceiros que utilizaremos. Para este post utilizaremos o Doctrine e vários elementos do Zend Framework 2 além de é claro o próprio PHPUnit. Abaixo segue a lista de todas as bibliotecas que serão utilizadas.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;require&#34; : {
    &#34;doctrine/common&#34; : &#34;*&#34;,
    &#34;doctrine/dbal&#34;: &#34;*&#34;,
    &#34;doctrine/orm&#34; : &#34;*&#34;,
    &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;,
    &#34;zendframework/zend-stdlib&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-filter&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-servicemanager&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-crypt&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-math&#34;: &#34;2.3.*@dev&#34;
 }&lt;/pre&gt;

&lt;p&gt;Seguindo as recomendações da &lt;a title=&#34;FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt;, utilizaremos a &lt;a title=&#34;PSR-0&#34; href=&#34;http://www.php-fig.org/psr/psr-0/&#34; target=&#34;_blank&#34;&gt;PSR-0&lt;/a&gt; que trata sobre a forma de carregarmento de classes na aplicação que estamos desenvolvendo. Com isso trabalharemos com namespaces e não precisaremos utilizar require ou include nas classes que utilizaremos. Para que o projeto tenha suas classes carregadas conforme a PSR-0 podemos informar isso no arquivo &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;autoload&#34; : {
    &#34;psr-0&#34;: {
        &#34;Tableless\\&#34;: &#34;src/&#34;
    }
 }&lt;/pre&gt;

&lt;p&gt;Isto nos diz que o namespace “Tableless” estará presente na pasta &lt;em&gt;src&lt;/em&gt; e para isto se faz necessária a criação da pasta &lt;em&gt;src&lt;/em&gt; e dentro da mesma a pasta &lt;em&gt;Tableless&lt;/em&gt;. Há outra maneira de registrar o namespace através do _boostrap._&lt;em&gt;php&lt;/em&gt; que seria algo como:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; $load = require __DIR__ . &#39;/vendor/autoload.php&#39;;
 $load-&amp;gt;add(&#39;Tableless&#39;, __DIR__ . &#39;/src&#39;);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p class=&#34;lang-php&#34;&gt;
  O arquivo &lt;em&gt;bootstrap.php &lt;/em&gt;é comumente utilizado para realizar as configurações iniciais em vários frameworks. Basicamente ele inclui o &lt;em&gt;autoload.php&lt;/em&gt; gerado pelo composer e podem ser definidas as mais diversas configurações globais de sua aplicação no mesmo.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isso baixamos o composer utilizando o comando &lt;strong&gt;curl -sS &lt;a href=&#34;https://getcomposer.org/installer&#34;&gt;https://getcomposer.org/installer&lt;/a&gt; | php&lt;/strong&gt; e em seguida instalamos as dependências através do comando &lt;strong&gt;php composer.phar install&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41342&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png&#34; alt=&#34;Instalando composer e dependências&#34; width=&#34;403&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png 403w, uploads/2014/03/02-instalando-composer-e-dependencias-218x168.png 218w, uploads/2014/03/02-instalando-composer-e-dependencias.png 791w&#34; sizes=&#34;(max-width: 403px) 100vw, 403px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Com a instalação das dependências agora temos a nova estrutura contendo uma pasta &lt;em&gt;vendor&lt;/em&gt; contendo todas as bibliotecas de terceiros, um novo arquivo &lt;em&gt;composer.lock&lt;/em&gt; e &lt;em&gt;composer.phar&lt;/em&gt; os quais já foram descritos em outro artigo sobre PHPUnit com composer e que pode ser acessado &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41343&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/03-nova-estrutura-490x310.png&#34; alt=&#34;Nova Estrutura&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/03-nova-estrutura-490x310.png 490w, uploads/2014/03/03-nova-estrutura-265x168.png 265w, uploads/2014/03/03-nova-estrutura-400x252.png 400w, uploads/2014/03/03-nova-estrutura.png 1086w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;próximo-passo&#34;&gt;Próximo passo&lt;/h2&gt;

&lt;p&gt;Agora temos de criar um arquivo que será o pontapé inicial da aplicação, arquivo este comumente nomeado de bootstrap conforme já mencionado anteriormente. Nele são configurados onde se encontram as entidades – que serão explicadas mais a frente deste tutorial, configuração do banco de dados entre outras configurações. Como neste exemplo será utilizado o Doctrine, precisamos configurar o mesmo.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado &lt;em&gt;bootstrap.php&lt;/em&gt; na raiz de seu projeto, o fonte do &lt;em&gt;bootstrap.php&lt;/em&gt; está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
// Carregando o autoload que o composer gerou
require __DIR__ . &#39;/vendor/autoload.php&#39;;
// indicando tudo que usaremos no bootstrap
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Tools\Setup;
use Doctrine\ORM\Mapping\Driver\AnnotationDriver;
use Doctrine\Common\Annotations\AnnotationReader;
use Doctrine\Common\Annotations\AnnotationRegistry;
/**
* Definindo se é modo desenvolvimento
* 
* Caso true: o cache do Doctrine é realizado em formato de array
* Caso false: o cache é conforme configuração (memcache, APC..)
* 
* Somente trabalharemos aqui com o modo TRUE, cache em array
*/
$config = Setup::createConfiguration( true );
// pasta onde encontram-se nossas entidades
$entitypath = array( __DIR__ . &#39;/src/Tableless/Entity&#39; );
// registrando as entidades
$driver = new AnnotationDriver(new AnnotationReader(), $entitypath);
$config-&gt;setMetadataDriverImpl($driver);
/**
* indicando que trabalharemos com o modo annotations para
* as entidades. Pode ser também via arquivo yaml e xml
* 
*/
AnnotationRegistry::registerFile(__DIR__ 
. &#39;/vendor/doctrine/orm/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php&#39;);
// configurando a conexão com o banco de dados
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_mysql&#39;,    
    &#39;user&#39; =&gt; &#39;root&#39;,
    &#39;password&#39; =&gt; &#39;root&#39;,
    &#39;dbname&#39; =&gt; &#39;tableless_tdd&#39;,
);
// E finalmente criando o manipulador de entidades
$entityManager = EntityManager::create($conn, $config);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Até agora você viu várias vezes a palavra “Entidade” mas o que ela significa? Entidade é um objeto que tem um significado conceitual dentro de um domínio. Em outras palavras, cada entidade no Doctrine é a representação de uma tabela no banco de dados e cada registro é uma instância desta entidade. A entidade não manipula o banco de dados, apenas representa-o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pronto, a nível de produção já temos a configuração, agora criaremos a estrutura e configurações para testes.&lt;/p&gt;

&lt;p&gt;Na raiz de seu projeto crie uma pasta chamada &lt;em&gt;tests&lt;/em&gt;, dentro dela uma pasta chamada &lt;em&gt;src&lt;/em&gt; e dentro da src uma pasta chamada &lt;em&gt;Tableless&lt;/em&gt;. Perceba que o namespace ficará na mesma estrutura do código de produção, desta forma para utilizarmos uma entidade chamada &lt;em&gt;User&lt;/em&gt; por exemplo, usaremos a seguinte declaração: &lt;strong&gt;use Tableless\Entity\User;&lt;/strong&gt;. Para a classe de testes de User se for necessária declarar em algum lugar será desta forma: &lt;strong&gt;use Tableless\Entity\UserTest;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41345&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/04-estrutura-inicial-testes-398x310.png&#34; alt=&#34;Estrutura inicial testes&#34; width=&#34;398&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/04-estrutura-inicial-testes-398x310.png 398w, uploads/2014/03/04-estrutura-inicial-testes-215x168.png 215w, uploads/2014/03/04-estrutura-inicial-testes-400x311.png 400w, uploads/2014/03/04-estrutura-inicial-testes.png 542w&#34; sizes=&#34;(max-width: 398px) 100vw, 398px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a criação das pastas necessárias falta a criação do bootstrap de testes e de um arquivo de configurações de execução do PHPUnit.&lt;/p&gt;

&lt;p&gt;Começando com o bootstrap, o código novamente está comentado explicando porque determinadas coisas estão sendo feitas. Crie o arquivo &lt;em&gt;bootstrap.php&lt;/em&gt; dentro da pasta de testes (&lt;em&gt;tests&lt;/em&gt;).&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&lt;?php
// utilizando o bootstrap de produção
require __DIR__ . &#39;/../bootstrap.php&#39;;
use Doctrine\ORM\EntityManager;
/*
* Sobrescrevendo a conexão com banco de dados.
* 
* Isto faz-se necessário para que ao rodar os testes 
* o banco de produção não sofra alterações
*/
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_sqlite&#39;,
    &#39;dbname&#39; =&gt; &#39;:memory:&#39;,
);
return $entityManager = EntityManager::create($conn, $config);
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;O bootstrap de testes se faz necessário para sobrescrever a conexão com o banco de dados, caso contrário, todos os testes realizariam alterações no banco de dados de produção e isto jamais deve acontecer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isto agora é o momento de criar o arquivo xml de configurações do PHPUnit. Crie um arquivo chamado &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;phpunit.xm&lt;/i&gt;l dentro de sua pasta &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;tests&lt;/i&gt; e adicione o conteúdo abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;

&amp;lt;!-- Indicando qual é o diretório onde as classes de teste se encontram --&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&#34;Tableless TDD Test Suite&#34;&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;src/&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;

&amp;lt;!-- Adicionando filtros, basicamente whitelist (diretórios que serão executados), 
dentro temos o exclude (diretórios que não serão executados pelos testes) --&amp;gt;

&amp;lt;filter&amp;gt;
    &amp;lt;whitelist&amp;gt;
        &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;../src/&amp;lt;/directory&amp;gt;
        &amp;lt;exclude&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;./vendor/&amp;lt;/directory&amp;gt;
        &amp;lt;/exclude&amp;gt;
    &amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;/phpunit&amp;gt;&lt;/pre&gt;

&lt;p&gt;Quase pronto, se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; dentro da raiz do projeto teremos a mensagem de que nenhum teste foi executado como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41346&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/05-nenhum-teste-490x310.png&#34; alt=&#34;Nenhum Teste&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/05-nenhum-teste-490x310.png 490w, uploads/2014/03/05-nenhum-teste-265x168.png 265w, uploads/2014/03/05-nenhum-teste-400x253.png 400w, uploads/2014/03/05-nenhum-teste.png 803w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; Como estamos trabalhando com um arquivo de configurações, para rodarmos o phpunit seguindo as definições do arquivo precisamos utilizar o parâmetro &lt;strong&gt;-c&lt;/strong&gt; seguido do nome do arquivo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Obviamente que nenhum teste ainda foi executado porque não temos nenhuma classe de testes. Vamos começar então. Crie uma pasta &lt;em&gt;Entity&lt;/em&gt; dentro de &lt;em&gt;tests/src&lt;/em&gt;. Dentro desta pasta crie um arquivo chamado &lt;em&gt;UsertTest.php&lt;/em&gt;. A nova estrutura de testes deve estar como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41347&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/06-nova-estrutura-de-testes-379x310.png&#34; alt=&#34;Nova estrutura de testes&#34; width=&#34;379&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/06-nova-estrutura-de-testes-379x310.png 379w, uploads/2014/03/06-nova-estrutura-de-testes-205x168.png 205w, uploads/2014/03/06-nova-estrutura-de-testes-400x326.png 400w, uploads/2014/03/06-nova-estrutura-de-testes.png 695w&#34; sizes=&#34;(max-width: 379px) 100vw, 379px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;UserTest.php&lt;/em&gt; adicione o namespace do mesmo que é Tableless\Entity.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;namespace Tableless\Entity;&lt;/pre&gt;

&lt;p&gt;Agora definimos quais classes utilizaremos para este teste. Como estamos testando a entidade &lt;em&gt;User&lt;/em&gt; precisaremos utilizar o Tableless\Entity\User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;&lt;/pre&gt;

&lt;p&gt;No entanto aí tem um detalhe. A entidade User ainda não existe, mas a criaremos dentro de instantes pois ainda temos uma classe que devemos criar antes mesmo da &lt;em&gt;User&lt;/em&gt;. Ela se chama &lt;em&gt;TestCase&lt;/em&gt; e deve estar no namespace Tableless\Test. Crie em &lt;em&gt;src/Tableless&lt;/em&gt; (não em tests/src/Tableless) uma pasta chamada Test e dentro dela um arquivo chamado &lt;em&gt;TestCase.php&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41348&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/07-criando-test-case-426x310.png&#34; alt=&#34;Criando o TestCase&#34; width=&#34;426&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/07-criando-test-case-426x310.png 426w, uploads/2014/03/07-criando-test-case-230x168.png 230w, uploads/2014/03/07-criando-test-case-400x291.png 400w, uploads/2014/03/07-criando-test-case.png 602w&#34; sizes=&#34;(max-width: 426px) 100vw, 426px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Neste arquivo copie e cole o código abaixo que está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
namespace Tableless\Test;

use Doctrine\ORM\Tools\SchemaTool;
use PHPUnit_Framework_TestCase as PHPUnit;

abstract class TestCase extends PHPUnit
{
    protected $entityManager = null;

    /**
    * Executado antes de cada teste unitário
    */
    public function setup() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Cria a base de dados necessária com suas determinadas tabelas
        $tool-&amp;gt;createSchema($classes);

        parent::setup();
    } 

    /**
    * Executado após a execução de cada um dos testes unitários
    */
    public function tearDown() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Desfaz o banco criado no setUp
        $tool-&amp;gt;dropSchema($classes);

        parent::tearDown();
    }

    /**
    * 
    * @return \Doctrine\ORM\EntityManager
    */
    public function getEntityManager() 
    {
        if (! $this-&amp;gt;entityManager) {
            $this-&amp;gt;entityManager = require __DIR__ . &#39;/../../../tests/bootstrap.php&#39;;
        } 
        return $this-&amp;gt;entityManager; 
    } 
}&lt;/pre&gt;

&lt;p&gt;Pronto, já estamos com tudo o que precisamos para começar escrever os testes. Detalhe que esta configuração foi criada para que fosse possível utilizar e testar a persistência de dados utilizando o Doctrine. Para demais testes em controllers, services, views, forms ou o que mais você desejar esta configuração realizada até o momento permanece podendo ser acrescida de novos elementos, tudo depende da necessidade.&lt;/p&gt;

&lt;h2 id=&#34;criando-o-primeiro-teste&#34;&gt;Criando o primeiro teste&lt;/h2&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt; começaremos a definir nossos testes. Lembre-se que a ideia do TDD é que o teste seja criado antes do código de produção, e assim faremos.&lt;/p&gt;

&lt;p&gt;Pra início de conversa utilizaremos a classe &lt;em&gt;TestCase&lt;/em&gt; previamente criada e a entidade User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;
use Tableless\Test\TestCase;&lt;/pre&gt;

&lt;p&gt;A classe de testes atual (UserTest) extende de TestCase e adicionaremos o atributo protegido $entity.&lt;/p&gt;

&lt;pre&gt;class UserTest extends TestCase
{
    protected $entity;
}&lt;/pre&gt;

&lt;p&gt;Assim como a classe TestCase, nossa classe UserTest também possuirá um métdo setUp e um tearDown que servirão para as configurações da mesma. De momento apenas setaremos o valor default do atributo entity no setUp.&lt;/p&gt;

&lt;pre&gt;public function setUp()
{
    $this-&amp;gt;entity = &#39;Tableless\Entity\User&#39;;
};&lt;/pre&gt;

&lt;p&gt;Agora segue o nosso primeiro teste: Novamente há comentários explicando cada ação.&lt;/p&gt;

&lt;pre&gt;public function testIfIsSavingAsExpected()
{
    // Criando os dados necessários para salvar o usuário
    $userData = array(
        &#39;id&#39; =&amp;gt; 1,
        &#39;name&#39; =&amp;gt; &#39;Nome do usuário&#39;,
        &#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;,
        &#39;password&#39; =&amp;gt; &#39;xpto&#39;,
        &#39;profilePic&#39; =&amp;gt; &#39;image.png&#39;
    );
    /* o Id é gerado automaticamente pelo Doctrine, neste caso estou forçando
    * um Id desejado, mas somente para o teste, para o código de produção
    * isto não se faz necessário
    */

    // Instanciando a entidade usuário definindo todos os atributos à ela
    $user = new User( $userData );

    // salvando o usuário no banco de dados
    $this-&amp;gt;getEntityManager()-&amp;gt;persist( $user );
    $this-&amp;gt;getEntityManager()-&amp;gt;flush();

    // Obtendo o usuário salvo
    $registeredUser = $this-&amp;gt;getEntityManager()
            -&amp;gt;getRepository($this-&amp;gt;entity)
            -&amp;gt;findOneBy(array(&#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;));

    // Garantindo que tudo funcionou conforme o esperado
    $this-&amp;gt;assertInstanceOf($this-&amp;gt;entity, $registeredUser);
    $this-&amp;gt;assertEquals($userData[&#39;name&#39;], $registeredUser-&amp;gt;getName());
}&lt;/pre&gt;

&lt;p&gt;Se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; da raiz de nosso projeto deveremos ver o seguinte erro: “PHP Fatal error: Class &amp;#8216;Tableless\Entity\User &amp;#8230;&amp;#8217;” isto porque ainda não existe a entidade &lt;em&gt;User&lt;/em&gt; pois realizamos o primeiro passo do TDD, o “Red”. Em seguida realizaremos o passo “Green” que consiste em criarmos o código que faça o teste passar e por último o passo “Refactor” que é onde faremos algumas melhorias no código. No código exemplo não existirá duplicidade e/ou partes inconsistentes com isso o Refactor realizará apenas algumas pequenas melhorias, nada mais.&lt;/p&gt;

&lt;p&gt;Crie na pasta &lt;em&gt;src&lt;/em&gt; (não em tests/src) uma pasta chamada &lt;em&gt;Entity&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;User.php&lt;/em&gt;. Eis a estrutura da entidade &lt;em&gt;User&lt;/em&gt;. Por ser um arquivo muito extenso, colocarei apenas o link do mesmo que encontra-se no github. &lt;a title=&#34;Tableless\Entity\user&#34; href=&#34;https://gist.github.com/andrebian/11389706&#34; target=&#34;_blank&#34;&gt;Tableless\Entity\User&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perceba que existem comentários acima de cada um dos atributos da classe. Isto se dá por estarmos utilizando o Annotations do Doctrine para que os mesmos sejam lidos e mapeados no banco de dados. Em outras palavras, o Doctrine lê a anotação e cria a estrutura da tabela conforme as definições nos comentários. Há a possibilidade de realizar tais definições via xml e também via yaml o que não veremos neste tutorial.&lt;/p&gt;

&lt;p&gt;Agora se rodarmos nosso teste novamente o mesmo passará. Ou seja, já temos um código minimamente testado com um início de noção de persistência de dados, veremos uma pequena melhora no código agora e em seguida algumas configurações para a execução dos testes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41349&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/08-primeiro-teste-passando-575x310.png&#34; alt=&#34;Primeiro teste passando&#34; width=&#34;575&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/08-primeiro-teste-passando-575x310.png 575w, uploads/2014/03/08-primeiro-teste-passando-312x168.png 312w, uploads/2014/03/08-primeiro-teste-passando-400x215.png 400w, uploads/2014/03/08-primeiro-teste-passando.png 797w&#34; sizes=&#34;(max-width: 575px) 100vw, 575px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;definindo-hash-para-senha&#34;&gt;Definindo hash para senha&lt;/h2&gt;

&lt;p&gt;Primeiramente no teste adicionaremos uma asserção de que a senha do usuário registrado não é igual a senha que definimos, em string pura. Adicione o trecho de código abaixo em seu teste logo após $this-&amp;gt;assertEquals($userData[&amp;#8216;name&amp;#8217;], $registeredUser-&amp;gt;getName());&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;// verificando se hash de senha funcionou
$this-&amp;gt;assertNotEquals($userData[&#39;password&#39;], $registeredUser-&amp;gt;getPassword());&lt;/pre&gt;

&lt;p&gt;Ao rodarmos o teste o mesmo deve quebrar pois ainda não criamos um hash para a senha, desta forma a senha fornecida está em string pura no banco de dados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41350&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/09-teste-falhando-hash-523x310.png&#34; alt=&#34;Teste falhando hash&#34; width=&#34;523&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/09-teste-falhando-hash-523x310.png 523w, uploads/2014/03/09-teste-falhando-hash-283x168.png 283w, uploads/2014/03/09-teste-falhando-hash-400x237.png 400w, uploads/2014/03/09-teste-falhando-hash.png 800w&#34; sizes=&#34;(max-width: 523px) 100vw, 523px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, na classe Tableless\Entity\User usaremos as seguintes classes do Zend:&lt;/p&gt;

&lt;pre&gt;use Zend\Math\Rand;
use Zend\Crypt\Key\Derivation\Pbkdf2;&lt;/pre&gt;

&lt;p&gt;em setPassword deixaremos adicionaremos a chamada ao método encryptPassword&lt;/p&gt;

&lt;pre&gt;public function setPassword( $password )
{
    $this-&amp;gt;password = $this-&amp;gt;encryptPassword($password);
    return $this;
}&lt;/pre&gt;

&lt;p&gt;E criaremos o método encryptPassword.&lt;/p&gt;

&lt;pre&gt;public function encryptPassword( $password )
{
   return base64_encode(
    Pbkdf2::calc(&#39;sha256&#39;, $password, $this-&amp;gt;salt, 
            10000, strlen($password*2)));
}&lt;/pre&gt;

&lt;p&gt;Agora rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; o teste passa novamente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41351&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/10-teste-passando-hash-375x310.png&#34; alt=&#34;teste passando hash&#34; width=&#34;375&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/10-teste-passando-hash-375x310.png 375w, uploads/2014/03/10-teste-passando-hash-203x168.png 203w, uploads/2014/03/10-teste-passando-hash-400x330.png 400w, uploads/2014/03/10-teste-passando-hash.png 795w&#34; sizes=&#34;(max-width: 375px) 100vw, 375px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Assim finalizamos o básico da realização de testes utilizando persitência de dados. A partir de agora veremos algumas configurações avançadas que lhe ajudarão muito no feedback dos testes.&lt;/p&gt;

&lt;h2 id=&#34;algumas-configurações-avançadas&#34;&gt;Algumas configurações avançadas&lt;/h2&gt;

&lt;p&gt;Através do arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; podemos definir algumas configurações avançadas para a execução dos testes. Começando pela declaração &lt;phpunit&gt;. Atualmente encontra-se desta forma:&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que utilizaremos um arquivo de bootstrap e dizemos qual arquivo é e também que queremos coloração no output. Caso colors=”true” não estivesse presente nossa visão ficaria desta forma.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41352&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/11-colors-482x310.png&#34; alt=&#34;Colors&#34; width=&#34;482&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/11-colors-482x310.png 482w, uploads/2014/03/11-colors-261x168.png 261w, uploads/2014/03/11-colors-400x257.png 400w, uploads/2014/03/11-colors.png 806w&#34; sizes=&#34;(max-width: 482px) 100vw, 482px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos definir erros e avisos sendo tratados como exceções.&lt;/p&gt;

&lt;pre&gt;&amp;lt;phpunit 
    convertErrorsToExceptions=&#34;true&#34; 
    convertNoticesToExceptions=&#34;true&#34;
    convertWarningsToExceptions=&#34;true&#34;
    colors=&#34;true&#34;
    bootstrap=&#34;bootstrap.php&#34;
&amp;gt;&lt;/pre&gt;

&lt;p&gt;E muitas outras opções. Para conhecer todas as opções de configurações acesse &lt;a title=&#34;Visualizar as configurações do PHPUnit&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/appendixes.configuration.html&#34; target=&#34;_blank&#34;&gt;este link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Certamente que a configuração a seguir é uma que empolga muitos desenvolvedores, logs e coverage. Com logs e coverage você identifica quais testes passaram, quais tiveram exceções, quais não passaram e o mais legal de tudo, o percentual de cobertura de testes que há em seu código de produção. Basicamente ao rodar um teste unitário, ele cobre uma pequena parte de seu código de produção, habilitando coverage você pode verificar quais linhas estão realmente garantidas por testes e quais você ainda tem de trabalhar mais tempo para garantir um mínimo de cobertura necessário para perfeito funcionamento mas principalmente para garantia de evolução de seu software.&lt;/p&gt;

&lt;p&gt;Para criar logs utilizamos a tag logging no arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; logo após o fechamento da tag &lt;/filter&gt;.&lt;/p&gt;

&lt;pre&gt;&amp;lt;logging&amp;gt;
    &amp;lt;log type=&#34;testdox-text&#34; target=&#34;data/testdox.txt&#34; /&amp;gt;
&amp;lt;/logging&amp;gt;&lt;/pre&gt;

&lt;p&gt;O log acima está gravando em formato de texto um checklist dos testes que existem em todas as classes de teste dentro da suite de testes marcando com x os que foram executados.&lt;/p&gt;

&lt;p&gt;Rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; será criada a pasta &lt;em&gt;tests/data&lt;/em&gt; contento o arquivo &lt;em&gt;testdox.txt&lt;/em&gt; O nome do arquivo é de sua escolha.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41353&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/12-testdox-569x310.png&#34; alt=&#34;Testdox&#34; width=&#34;569&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/12-testdox-569x310.png 569w, uploads/2014/03/12-testdox-308x168.png 308w, uploads/2014/03/12-testdox-400x217.png 400w, uploads/2014/03/12-testdox.png 891w&#34; sizes=&#34;(max-width: 569px) 100vw, 569px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Também é possível gerar o testdox em formato html, basta alterar testdox-text para testdox-html e testdox.txt para testdox.html mas o mais comum é ser utilizado em formato txt mesmo.&lt;/p&gt;

&lt;p&gt;Existe também a possibilidade de habilitar o testdox em tempo de execução. Basta apenas adicionar o parâmetro &amp;#8211;testdox ao rodar os testes. O resultado será como abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --testdox
PHPUnit 3.7.35 by Sebastian Bergmann.
Configuration read from /home/andre/Documents/Posts/tableless/phpunit-persistencia-de-dados-e-configuracoes-avancadas/sources/tests/phpunit.xml
Tableless\Entity\User
  [x] If is saving as expected
Generating code coverage report in HTML format ... done&lt;/pre&gt;

&lt;h2 id=&#34;agrupamento-de-testes&#34;&gt;Agrupamento de testes&lt;/h2&gt;

&lt;p&gt;Por certas vezes necessitamos agrupar testes para que rodemos somente determinada sequência sem que os demais sejam executados. Isto é útil para quando temos de realizar uma pequena alteração e não se faça necessário a execução de todos os testes já criados tornando o feedback mais rápido. Comumente isto é utilizado quando se deseja realizar um ajuste pontual e ao ser finalizado todos os testes são executados novamente.&lt;/p&gt;

&lt;p&gt;O PHPUnit nos permite trabalhar com grupos os quais veremos sua definição a seguir.&lt;/p&gt;

&lt;p&gt;Crie uma pasta chamada &lt;em&gt;Filter&lt;/em&gt; em &lt;em&gt;tests/src/Tableless&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;CurrencyTest.php&lt;/em&gt;. O conteúdo deste arquivo está abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
namespace Tableless\Filter;
use Tableless\Test\TestCase;
/**
* @group Filter
*/
class CurrencyTest extends TestCase 
{
    public function testIfClassExists()
    {
        $this-&amp;gt;assertTrue(class_exists(&#39;Tableless\Filter\Currency&#39;));
    }
}&lt;/pre&gt;

&lt;p&gt;Perceba que antes de ser declarado o nome da classe existe uma anotação @group Filter. É isto que define o grupo ao qual este teste pertence. Faça o mesmo para o teste já existente (tests/src/Tableless/Entity/UserTest.php) anotando-o como @group Entity.&lt;/p&gt;

&lt;pre&gt;...
/**
* @group Entity
*/
class UserTest extends TestCase
...&lt;/pre&gt;

&lt;p&gt;Agora que temos a definição dos grupos podemos rodar nossos testes somente de 1 grupo, de um conjunto de grupos ou de todos os grupos sem distinção. Existem duas formas de rodar os testes por grupos, através de parâmetro informado no momento da execução dos testes ou através do arquivo xml de configurações do PHPUnit, veremos ambas.&lt;/p&gt;

&lt;h3 id=&#34;via-parâmetro&#34;&gt;Via parâmetro&lt;/h3&gt;

&lt;h4 id=&#34;somente-um-grupo&#34;&gt;Somente um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity
&lt;/pre&gt;

&lt;h4 id=&#34;mais-de-um-grupo&#34;&gt;Mais de um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity,Filter
&lt;/pre&gt;

&lt;p&gt;Para que todos os grupos de testes sejam executados basta que não seja informado o parâmetro &amp;#8211;group.&lt;/p&gt;

&lt;h3 id=&#34;via-arquivo-de-configuração&#34;&gt;Via arquivo de configuração&lt;/h3&gt;

&lt;p&gt;No arquivo tests/phpunit.xml adicione uma tag &lt;groups&gt; e dentro dela liste os grupos desejados.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;groups&amp;gt;
    &amp;lt;include&amp;gt;
        &amp;lt;group&amp;gt;Entity&amp;lt;/group&amp;gt;
    &amp;lt;/include&amp;gt;
&amp;lt;/groups&amp;gt;&lt;/pre&gt;

&lt;p&gt;Você deve estar imaginando, se existe uma tag &lt;strong&gt;include &lt;/strong&gt;deve existir uma tag &lt;strong&gt;exclude &lt;/strong&gt;também. Imaginou certo! Dentro de include você adiciona todos os grupos que deseja que sejam executados nos testes já em exclude, todos que NÃO devem ser executados. O excclude é ideal para testes que foram marcados como incompletos ou pulados (skipped).&lt;/p&gt;

&lt;p&gt;Após adicionar as tags referentes aos grupos de testes no arquivo xml de configurações não se faz mais necessário informar o parâmetro  &amp;#8211;group, basta rodar normalmente.&lt;/p&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/pre&gt;

&lt;h2 id=&#34;agora-sim-o-mais-legal-de-todos-coverage-em-html&#34;&gt;Agora sim, o mais legal de todos, Coverage em Html!&lt;/h2&gt;

&lt;p&gt;Dentro de &lt;logging&gt; adicione uma nova tag chamada &lt;log&gt; conforme o exemplo abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;log 
    type=&#34;coverage-html&#34; 
    target=&#34;data/coverage&#34; 
    charset=&#34;UTF-8&#34; 
    yui=&#34;true&#34; 
    highlight=&#34;true&#34;
    lowUpperBound=&#34;35&#34;
    highUpperBound=&#34;70&#34; /&amp;gt;&lt;/pre&gt;

&lt;p&gt;Basicamente estamos definindo que o coverage será em formato html, que o considerado baixo coverage será de 35% e um bom coverage se dará a partir de 70%. O highlight serve para destacar as linhas que foram cobertas com verde, não cobertas com vermelho e ignoradas permanecem com a cor padrão. Rode o teste novamente.&lt;/p&gt;

&lt;p&gt;Agora no browser entre em seu localhost na pasta do projeto em que está trabalhando. Em seguida entre na pasta &lt;em&gt;tests&lt;/em&gt;, após isto em &lt;em&gt;data&lt;/em&gt; e por último em coverage. Surpreenda-se!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41354&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/13-coverage-588x223.png&#34; alt=&#34;Coverage&#34; width=&#34;588&#34; height=&#34;223&#34; srcset=&#34;uploads/2014/03/13-coverage-588x223.png 588w, uploads/2014/03/13-coverage-329x125.png 329w, uploads/2014/03/13-coverage-660x251.png 660w, uploads/2014/03/13-coverage-400x152.png 400w, uploads/2014/03/13-coverage.png 1324w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Navegando pelos arquivos você identificará o que já está bom e o que precisa ser mais testado. Neste nosso caso chegar a 100% é muito fácil, basta lermos todos os dados do usuário.&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt;, dentro do único teste que temos adicione os seguintes asserts:&lt;/p&gt;

&lt;pre&gt;$this-&amp;gt;assertEquals(1, $registeredUser-&amp;gt;getId());
$this-&amp;gt;assertEquals(&#39;usuario@dominio.com&#39;, $registeredUser-&amp;gt;getEmail());
$this-&amp;gt;assertNotNull($registeredUser-&amp;gt;getSalt());
$this-&amp;gt;assertEquals(&#39;image.png&#39;, $registeredUser-&amp;gt;getProfilePic());&lt;/pre&gt;

&lt;p&gt;Rode os testes novamente e corra pro abraço!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41355&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/14-coverage-100-588x237.png&#34; alt=&#34;Coverage 100%&#34; width=&#34;588&#34; height=&#34;237&#34; srcset=&#34;uploads/2014/03/14-coverage-100-588x237.png 588w, uploads/2014/03/14-coverage-100-329x132.png 329w, uploads/2014/03/14-coverage-100-660x266.png 660w, uploads/2014/03/14-coverage-100-400x161.png 400w, uploads/2014/03/14-coverage-100.png 1303w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lembrando novamente que para entendimento deste tutorial se faz necessário a leitura dos conteúdos anteriores sobre o tema, sendo eles &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar/&#34; title=&#34;TDD, por que usar?&#34;&gt;TDD, por que usar?&lt;/a&gt;  e &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;PHPUnit, como iniciar sem dores&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;bonus&#34;&gt;Bonus.&lt;/h2&gt;

&lt;p&gt;O que fizemos até o momento foi preparar o ambiente de testes e executá-los mas este ambiente ainda não está totalmente pronto para o código de produção pois precisamos de conexão com um banco de dados além de mais uma configuração do Doctrine para que possamos criar o banco de dados a partir de nossas entidades. Ou seja, lembra daquele processo de criar o banco de dados, definir as tabelas e relacionamentos todos antes do código? Com o Doctrine isto não se faz mais necessário, pode ser feito da forma descrita (e tradicional) mas há outra forma bem legal que é uma mão na roda e que mostrarei agora.&lt;/p&gt;

&lt;p&gt;Primeiramente precisamos criar um arquivo de configuração para o cli (Command Line Interface) do Doctrine. Na pasta raiz de sua aplicação crie um arquivo chamado &lt;em&gt;cli-config.php&lt;/em&gt; e cole o seguinte conteúdo:&lt;/p&gt;

&lt;pre&gt;//cli-config.php
require &#39;bootstrap.php&#39;;

return \Doctrine\ORM\Tools\Console\ConsoleRunner::createHelperSet($entityManager);&lt;/pre&gt;

&lt;div id=&#34;LC3&#34;&gt;
  Após a criação deste arquivo podemos rodar o seguinte comando &lt;b&gt;./vendor/bin/doctrine&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;Aparecerão várias opções de uso que vão desde checagem de status de conexão, validação das entidades, além de outras funcionalidades. Uma coisa que o doctrine não faz realmente é criar a base de dados pois isto depende de cada base pois Mysql é de um jeito, Postgres é de outro, SQL Server é de outro ainda, então esta tarefa ainda é manual.&lt;/p&gt;

&lt;p&gt;Para fins didáticos criei uma base chamada tableless_tdd no mysql como definido no arquivo bootstrap.php da raiz do projeto. Você pode alterar o nome se quiser, bem como o próprio banco, experimente o Sqlite se quiser.&lt;/p&gt;

&lt;p&gt;Com a base criada rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;. Se estiver tudo ok aparecerá algo como a imagem abaixo. Nela informa que o mapeamento das entidades está correto mas o banco ainda não está sincronizado, para sincronizar rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;. Isto lerá todas as entidades contidas em src/Tableless/Entity e criará a estrutura de tabelas a partir delas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41356&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/15-doctrine-validate-500x310.png&#34; alt=&#34;Doctrine Validate Schema&#34; width=&#34;500&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/15-doctrine-validate-500x310.png 500w, uploads/2014/03/15-doctrine-validate-271x168.png 271w, uploads/2014/03/15-doctrine-validate-400x247.png 400w, uploads/2014/03/15-doctrine-validate.png 797w&#34; sizes=&#34;(max-width: 500px) 100vw, 500px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41357&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/16-doctrine-create-validate-459x310.png&#34; alt=&#34;Doctrine create validate&#34; width=&#34;459&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/16-doctrine-create-validate-459x310.png 459w, uploads/2014/03/16-doctrine-create-validate-249x168.png 249w, uploads/2014/03/16-doctrine-create-validate-400x269.png 400w, uploads/2014/03/16-doctrine-create-validate.png 820w&#34; sizes=&#34;(max-width: 459px) 100vw, 459px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Atualmente possuímos somente a entidade User que indica que uma tabela users será criada no banco de dados. Após a finalização da execução do comando anterior seu banco de dados já estará com a nova estrutura. Ao realizar qualquer alteração na entidade User ou mesmo criar novas entidades você precisará rodar o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:update&lt;/strong&gt; com isso aparecerá uma mensagem informando que já há uma estrutura no banco de dados e lhe pede confirmação sobre o que fazer. Você pode ignorar, ver as alterações ou forçar se tiver certeza do que está fazendo ou mesmo se já visualizou as alterações que serão realizadas e está ciente de que está tudo certo. Basta ler as intruções que o próprio Doctrine fornece que você saberá o que fazer, é muito intuitivo.&lt;/p&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;Agora que você já configurou o Doctrine, já conhece como criar testes unitários resta apenas aperfeiçoar a cada dia. Não existe uma receita, tudo requer empenho e dedicação mas que no final quando você ver aquelas barrinhas verdes mostrando 100% de cobertura se sentirá cada vez mais empolgado e com um código mais estável mas o principal, com um código que pode facilmente evoluir.&lt;/p&gt;

&lt;p&gt;Para baixar o código-fonte gerado neste artigo acesse este link do &lt;a title=&#34;Baixar o código-fonte&#34; href=&#34;https://github.com/andrebian/tdd-persistencia-de-dados&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Composer – um pouco além do básico</title>
      <link>https://tableless.github.io/hugo-public/composer-um-pouco-alem-basico/</link>
      <pubDate>Tue, 01 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/composer-um-pouco-alem-basico/</guid>
      <description>

&lt;p&gt;No post anterior expliquei o que vem a ser o composer, como baixar, criar o arquivo de configurações e instalar pacotes ou bibliotecas. Agora veremos algumas questões um pouco mais avançadas sobre o uso do composer.&lt;/p&gt;

&lt;h2 id=&#34;instalação-global&#34;&gt;Instalação global&lt;/h2&gt;

&lt;p&gt;O composer suporta instalação global para que seja utilizado apenas um &amp;#8220;executável&amp;#8221; para todo e qualquer projeto. Usei o termo executável pois refere-se ao composer.phar, que como explicado no post anterior é uma forma de empacotamento no PHP que transforma a aplicação toda em um único arquivo que é facilmente executável em qualquer local de seu sistema operacional.&lt;/p&gt;

&lt;p&gt;O processo de instalação global do composer se dá das mesmas formas que a instalação já mostrada no post anterior com uma pequena diferença, selecionamos um diretório para manter o composer e quando utilizarmos, utilizamos sempre a partir deste diretório.&lt;/p&gt;

&lt;p&gt;Mãos na massa!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Todos os exemplos aqui criados foram realizados em ambiente Linux. No Mac OS X é semelhante e no Windows há algumas pequenas diferenças com relação à execução do PHP, com isso sugiro que leia a &lt;a title=&#34;Documentação oficial do composer&#34; href=&#34;https://getcomposer.org/doc/&#34; target=&#34;_blank&#34;&gt;documentação oficial&lt;/a&gt; do composer para maiores detalhes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Instalarei o composer no diretório /opt de meu Linux, você pode selecionar o diretório de sua preferência pois funcionará da mesma forma, desde que você tenha o PHP instalado é claro.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;$ cd /opt &amp;&amp; mkdir composer &amp;&amp; cd composer&lt;/pre&gt;

&lt;p&gt;O comando acima em 3 passos (separados por &lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;). No passo 1, entro no diretório /opt. No passo 2 crio uma pasta chamada composer e no passo 3 entro na pasta _composer_ recém criada.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lembrando que você deve possuir permissão de escrita no diretório que pretende instalar o composer globalmente.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agora dentro da pasta /opt/composer basta que baixemos o composer através de uma das opções abaixo:&lt;/p&gt;

&lt;pre&gt;curl -sS https://getcomposer.org/installer | php&lt;/pre&gt;

&lt;p&gt;ou&lt;/p&gt;

&lt;pre&gt;php -r &#34;readfile(&#39;https://getcomposer.org/installer&#39;);&#34; | php&lt;/pre&gt;

&lt;p&gt;Com isso dentro da pasta /opt/composer deve agora existir o arquivo &lt;em&gt;composer.phar&lt;/em&gt;. Os passos descritos até aqui são ilustrados na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/01-download-do-composer.jpg&#34; alt=&#34;Download do composer&#34; width=&#34;1320&#34; height=&#34;621&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ainda dentro de _/opt/composer_ rodamos o comando &lt;strong&gt;php composer.phar&lt;/strong&gt;, é exibido o menu de ajuda do composer indicando que foi instalado corretamente.&lt;/p&gt;

&lt;h3 id=&#34;utilizando-o-composer-global-em-um-projeto&#34;&gt;Utilizando o composer global em um projeto&lt;/h3&gt;

&lt;p&gt;Criamos um projeto qualquer em um diretório de sua escolha. Farei o mesmo em meu Desktop em uma pasta chamada &lt;em&gt;composer-alem-do-basico&lt;/em&gt;. Dentro desta pasta crio um arquivo chamado _composer.json_ adicionando a seguinte estrutura:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;authors&#34;: [
        {
            &#34;name&#34;: &#34;Seu nome&#34;,
            &#34;email&#34;: &#34;seu email&#34;
        }
    ],
    &#34;require&#34;: {
        &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    }
}&lt;/pre&gt;

&lt;p&gt;Perceba que não temos nenhum pacote de terceiro como dependência ainda, somente definimos que a versão mínima do PHP para rodarmos a aplicação é a 5.2.8, deixaremos esta versão por enquanto e adicionaremos em &amp;#8220;require&amp;#8221; o &lt;a title=&#34;ORM Doctrine&#34; href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;ORM Doctrine&lt;/a&gt;. Não será criado nenhum código utilizando o Doctrine, apenas está sendo incluso por ser um projeto que não possui muitas dependências fazendo a instalação ser mais rápida. Então nosso require agora fica assim:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34; : &#34;2.4.*&#34;
}&lt;/pre&gt;

&lt;p&gt;Note que na versão desejada do Doctrine informei 2.4.*, isto significa que sempre será utilizada a versão mais recente dentro do release 2.4. Caso você queira estar sempre com a mais atual possível basta remover a numeração da versão e adicionar somente &amp;#8220;*&amp;#8221;, desta forma nosso require no _composer.json_ tem esta estrutura:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34; : &#34;*&#34;
}&lt;/pre&gt;

&lt;p&gt;Agora que está configurada nossa primeira dependência do projeto basta que rodemos o comando &lt;strong&gt;php /opt/composer/composer.phar install&lt;/strong&gt;. Atenção ao caminho de onde está sendo rodado o composer, perceba que é a pasta que instalamos ele anteriormente. Com isso não preciso ficar para cada projeto baixando o &lt;em&gt;composer.phar&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/02-instalando-primeiras-dependencias.jpg&#34; alt=&#34;instalação via composer&#34; width=&#34;877&#34; height=&#34;692&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O Doctrine assim como todas as suas dependências são instaladas e temos agora esta estrutura dentro de nosso projeto:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/03-nova-estrutura-vendor.jpg&#34; alt=&#34;Estrutura inicial&#34; width=&#34;791&#34; height=&#34;615&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;qual-a-vantagem-do-composer-com-instalação-global&#34;&gt;Qual a vantagem do composer com instalação global?&lt;/h2&gt;

&lt;p&gt;Apesar de muitos pensarem e economia de espaço isso é irrelevante pois o _composer.phar_ &amp;#8220;pesa&amp;#8221; apenas 1MB aproximadamente. Há a vantagem que o composer sempre estará disponível para qualquer aplicação eliminando possíveis erros de tentar rodar o comando &lt;strong&gt;php composer.phar alguma-coisa&lt;/strong&gt; e o composer.phar não estar presente, ou seja, basicamente a vantagem em possuir uma instalação global é você nunca esquecer de instalá-lo para cada aplicação sua.&lt;/p&gt;

&lt;p&gt;No demais não há vantagens pois para cada aplicação o composer realizará o download de todas suas dependências individualmente para cada aplicação, ou seja, se você possuir 3 aplicações, o &lt;em&gt;composer.phar&lt;/em&gt; será somente 1 (na pasta /opt/composer/composer.phar) no entanto os vendors serão específicos para cada aplicação como mostra a imagem abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/04-dois-projetos-com-vendors-distintos.jpg&#34; alt=&#34;Vendors&#34; width=&#34;792&#34; height=&#34;465&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;errata&#34;&gt;Errata&lt;/h2&gt;

&lt;p&gt;Conforme mencionado em um cometário pelo Marcel dos Santos o correto para a instalação ser de fato global seria que o composer estivesse em &lt;em&gt;/usr/local/bin&lt;/em&gt;. Você pode simplesmente mover o composer.phar que atualmente encontra-se em &lt;em&gt;/opt/composer&lt;/em&gt; para a pasta &lt;em&gt;/usr/local/bin&lt;/em&gt; e para que seja executado basta em seu terminal digitar &lt;strong&gt;composer.phar&lt;/strong&gt; em qualquer ponto do seu sistema operacional.&lt;/p&gt;

&lt;h2 id=&#34;direcionamento-de-vendors&#34;&gt;Direcionamento de vendors&lt;/h2&gt;

&lt;p&gt;Por padrão o composer entende que as bibliotecas de terceiros devem ficar dentro do diretório _vendor_ mas é possível alterar. Pense em uma situação em que você está trabalhando com algum framework que fornece uma estrutura de diferente da estabelecida pelo composer, o CakePHP por exemplo, por padrão neste framework as bibliotecas de terceiros são instaladas em _vendors_ (no plural mesmo).&lt;/p&gt;

&lt;p&gt;Isto é facilmente configurado através do arquivo &lt;em&gt;composer.json&lt;/em&gt;. Decalararei que minhas bibliotecas de terceiros serão acondicionadas em &lt;em&gt;3rdparty&lt;/em&gt; apenas para fins didáticos. Para direcionar os vendors do composer precisamos adicionar a informação de onde nossos vendors serão acondicionados:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;....
&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34;: &#34;*&#34;
},
&#34;config&#34;: {
    &#34;vendor-dir&#34;: &#34;3rdparty&#34;
}
.....&lt;/pre&gt;

&lt;p&gt;Feito isto basta rodar o comando &lt;strong&gt;php /opt/composer/composer.phar install&lt;/strong&gt; caso não tenha instalado ainda ou &lt;strong&gt;php /opt/composer/composer.phar update&lt;/strong&gt; caso já tenha realizado alguma instalação anteriormente.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Caso você execute o update do composer ( &amp;#8230; composer.phar update) e alterou a pasta de vendors, esteja ciente de que a pasta que existia antes permanecerá em sua aplicação e você terá de removê-la manualmente pois o composer perdeu a referência da mesma a partir do momento que você alterou o &amp;#8220;vendor-dir&amp;#8221;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A nova estrutura de nossa aplicação será esta:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/05-nova-estrutura-vendor-path.jpg&#34; alt=&#34;Nova estrutura vendor&#34; width=&#34;809&#34; height=&#34;550&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;direcionando-pacotes&#34;&gt;Direcionando pacotes&lt;/h2&gt;

&lt;p&gt;Cada pacote que você define como uma dependência de sua aplicação possui uma série de configurações e podem conter dependências também que são listadas em seus composer.json. Ou seja, cada pacote possui (comumente) dentro dele um json informando do que eles dependem, se são plugins de algum framework ou CMS entre outras configurações.&lt;/p&gt;

&lt;p&gt;Um bom exemplo de plugins que são instalados em seus diretórios corretos são os plugins do wordpress, desde que você informe que estará utilizando os instaladores do composer &lt;em&gt;&amp;#8220;composer/installers&amp;#8221;: &amp;#8220;*&amp;#8221;&lt;/em&gt;. Caso você não esteja utilizando os instaladores do composer pode simplesmente direcionar cada pacote para onde bem entender.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;....
&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34;: &#34;*&#34;,
    &#34;josegonzalez/cakephp-upload&#34;: &#34;*&#34;
},
&#34;extra&#34; : {
    &#34;installer-paths&#34; : {
        &#34;plugins/Upload&#34; : [&#34;josegonzalez/cakephp-upload&#34;]
    }
},
....&lt;/pre&gt;

&lt;p&gt;Mesmo que você esteja utilizando os instaladores ainda sim pode personalizar pacote por pacote onde quer que eles sejam instalados dentro de sua aplicação.&lt;/p&gt;

&lt;p&gt;No novo exemplo do composer estou informando que o plugin de upload do CakePHP será instalado na pasta _plugins/Upload_ ao invés de &lt;em&gt;app/Plugin/Upload&lt;/em&gt; como seria instalado pelo CakePHPInstaller do composer.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/06-pacote-em-diretorio-personalizado.jpg&#34; alt=&#34;pacote em diretorio personalizado&#34; width=&#34;795&#34; height=&#34;456&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Como você pode ver, é possível personalizar a instalação cada pacote com simples configuração através de nosso arquivo &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;require-ou-require-dev&#34;&gt;Require ou require-dev?&lt;/h2&gt;

&lt;p&gt;O composer trabalha basicamente com dois tipos de dependências, os _require _que são os estritamente necessários para o funcionamento da aplicação e os _require-dev_ que são dependências utilizadas em ambiente de desenvolvimento, são elas ferramentas como PHPUnit, ferramentas de log, entre outras. No exemplo abaixo informamos que para nossa aplicação utilizaremos o ORM Doctrine e para o ambiente de desenvolvimento somente utilizaremos o PHPUnit.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34;: &#34;*&#34;,
    &#34;josegonzalez/cakephp-upload&#34;: &#34;*&#34;
},
&#34;require-dev&#34; : {
    &#34;phpunit/phpunit&#34; : &#34;4.0.*&#34;
},&lt;/pre&gt;

&lt;p&gt;Com a configuração distinta podemos instalar no ambiente de produção somente as dependências necessárias para o funcionamento correto da aplicação deixando de lado as dependências de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Como já realizamos a primeira instalação através do composer agora apenas utilizamos o comando &lt;strong&gt;php /opt/composer/composer.phar update&lt;/strong&gt; (se for a instalação global do composer) ou &lt;strong&gt;php composer.phar update&lt;/strong&gt; (se o composer.phar foi baixado na raiz de sua aplicação). Com este comando todos os pacotes serão instalados.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/07-atualizando-dev.jpg&#34; alt=&#34;Atualização dev&#34; width=&#34;834&#34; height=&#34;615&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a atualização (que baixará muitos pacotes) a nova estrutura de nosso projeto é a seguinte.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/08-estrutura-com-dev.jpg&#34; alt=&#34;Nova estrutura com Dev&#34; width=&#34;960&#34; height=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pensemos agora que estamos no ambiente de produção ou homologação onde não se faz necessário o PHPUnit. Não é necessária a remoção do mesmo no arquivo *composer.json* e sim rodarmos o comando &lt;strong&gt;php composer.phar update &amp;#8211;no-dev&lt;/strong&gt; e o resultado será como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/09-update-sem-dev.jpg&#34; alt=&#34;Update sem Dev&#34; width=&#34;955&#34; height=&#34;499&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note apenas que na imagem acima eu rodei o update em meu ambiente de desenvolvimento apenas excluindo os pacotes de modo &lt;em&gt;dev&lt;/em&gt; para ilustrar o funcionamento. Na imagem também é possível perceber que o PHPUnit e suas dependências que já estavam instalados foram removidos por não serem mais necessários em modo produção. Na imagem abaixo está a nova estrutura de nossa aplicação.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/06-pacote-em-diretorio-personalizado.jpg&#34; alt=&#34;Pacote personalizado&#34; width=&#34;795&#34; height=&#34;456&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;definição-de-autoload&#34;&gt;Definição de Autoload&lt;/h2&gt;

&lt;p&gt;Para quem não conhece existe a &lt;a title=&#34;FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; (Framework Interop Group) que visa sugerir padrões de desenvolvimento através de suas PSRs. Atualmente são 4 recomendações sendo a primeira delas (&lt;a title=&#34;Conheça a PSR-0&#34; href=&#34;http://www.php-fig.org/psr/psr-0/&#34; target=&#34;_blank&#34;&gt;PSR-0&lt;/a&gt;) a que trata de como o carregamento de sua aplicação deve ocorrer. Basicamente é a informação de onde será definido o namespace de sua aplicação.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;autoload&#34; : {
    &#34;psr-0&#34;: {
         &#34;Tableless\\&#34;: &#34;src/&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;Note que foi definido o namespace _Tableless_ indicando que o mesmo está dentro da pasta &lt;em&gt;src&lt;/em&gt;. O nome da pasta pode ser outro qualquer e não somente &lt;em&gt;src&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com isso a nova estrutura de nossa aplicação é esta&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/21-namespace.jpg&#34; alt=&#34;Nova estrutura com namespace&#34; width=&#34;958&#34; height=&#34;596&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para utilizar todo o projeto entitulado como Tableless neste exemplo basta informá-lo onde o mesmo se faça necessário:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Tableless;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;criando-um-pacote-do-composer&#34;&gt;Criando um pacote do composer&lt;/h2&gt;

&lt;p&gt;Pra finalizar criaremos um pacote do composer. Primeiramente você precisa ter uma conta no &lt;a title=&#34;Ir ao Github&#34; href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt; ou &lt;a title=&#34;Ir ao bitbucket&#34; href=&#34;https://bitbucket.org/&#34; target=&#34;_blank&#34;&gt;bitbucket&lt;/a&gt; (trabalharemos apenas com versionamento em git). Também será necessária uma conta no &lt;a title=&#34;Ir ao Packegist&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;Packagist&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tendo os requisitos atendidos agora deve ser criado um repositório no github, se você não sabe criar ou não utilizou o github ainda leia &lt;a title=&#34;Criando repositório no Github&#34; href=&#34;https://help.github.com/articles/create-a-repo&#34; target=&#34;_blank&#34;&gt;este tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Feito isto é hora de clonar o repositório em uma pasta de sua preferência, utilize o comando &lt;strong&gt;git clone git@github.com:username/repo-name.git&lt;/strong&gt; no meu caso é: git clone git@github.com:andrebian/exemplo-composer-tableless.git. Na imagem abaixo é possível ver o git realizando o clone e a estrutura inicial do projeto que contém além dos arquivos do git somente o arquivo README.md que foi criado juntamente com a criação do repositório no github.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/10-clonando-novo-projeto.jpg&#34; alt=&#34;Clonando novo projeto&#34; width=&#34;874&#34; height=&#34;451&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora temos de criar nosso arquivo _composer.json_ para que sejam adicionadas as informações de nosso novo pacote. Sua estrutura é a seguinte.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;name&#34;: &#34;andrebian/exemplo-composer-tableless&#34;,
    &#34;description&#34;: &#34;Este pacote foi criado apenas para complementar o post no Tableless&#34;,
    &#34;authors&#34;: [ 
        {
            &#34;name&#34;: &#34;Andre Cardoso&#34;,
            &#34;email&#34;: &#34;andrecardosodev@gmail.com&#34;
        }
    ],
    &#34;require&#34;: {
         &#34;php&#34;: &#34;&amp;gt;=5.3.17&#34;,
         &#34;kevinlebrun/slug.php&#34;: &#34;1.*&#34;
    }
 }&lt;/pre&gt;

&lt;p&gt;A chave &amp;#8220;name&amp;#8221; deve possuir o vendor (seu username) e o slug do nome  do projeto.&lt;/p&gt;

&lt;p&gt;Note que adicionei uma dependência ao meu projeto, com isso mesmo se o pacote slug.php não estiver setado no composer que engloba toda a aplicação será instalado porque eu informei que meu pacote precisa dele para funcionar corretamente.&lt;/p&gt;

&lt;p&gt;Feito isto basta que as alterações realizadas sejam enviadas ao github e podemos prosseguir com a criação do pacote no packagist. Não vou explicar o funcionamento do git (commit, pull, push e outros) pois o foco deste post é o composer. Se você ainda não conhece o git sujiro a leitura de &lt;a href=&#34;http://tableless.com.br/iniciando-no-git-parte-1/&#34; title=&#34;Iniciando no git parte 1&#34;&gt;Iniciando no git&lt;/a&gt; que foi escrito pelo Diego Eis e está divido em duas partes que lhe mostram conceitos e utilização do mesmo. A imagem abaixo mostra o repositório no github já com a nova estrutura contendo o &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/11-projeto-no-github.jpg&#34; alt=&#34;Configurações&#34; width=&#34;1088&#34; height=&#34;641&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora que já temos nosso repositório no github basta criarmos nosso pacote no packagist. Acessando &lt;a href=&#34;https://packagist.org/&#34;&gt;https://packagist.org/&lt;/a&gt; e estando logado clique em &amp;#8220;Submit package&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/12-submit-package.jpg&#34; alt=&#34;Enviar pacote&#34; width=&#34;1068&#34; height=&#34;457&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Informe a URL em que o mesmo se encontra, neste caso &lt;a href=&#34;https://github.com/andrebian/exemplo-composer-tableless&#34;&gt;https://github.com/andrebian/exemplo-composer-tableless&lt;/a&gt; e clique em Check&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/13-package-url.jpg&#34; alt=&#34;Check&#34; width=&#34;954&#34; height=&#34;551&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a verificação e confirmação de que está tudo ok basta clicar em Submit&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/14-confirm-submit.jpg&#34; alt=&#34;Confirm&#34; width=&#34;927&#34; height=&#34;557&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Na imagem seguinte você pode ver que o pacote foi criado com sucesso e já está disponível para ser adicionado como dependência em qualquer projeto que você desejar.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/15-package-created.jpg&#34; alt=&#34;Created&#34; width=&#34;1150&#34; height=&#34;556&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note apenas que há uma chamada de atenção ali informando que o pacote não é atualizável automaticamente, vamos corrigir isto agora.&lt;/p&gt;

&lt;p&gt;Acessando sua conta no github navegue pelos seus repositórios até encontrar o desejado e entre em suas configurações.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/16-settings.jpg&#34; alt=&#34;Settings&#34; width=&#34;1138&#34; height=&#34;664&#34; /&gt;&lt;/p&gt;

&lt;p&gt;À esquerda há um menu com algumas opções, clique em &lt;strong&gt;Webhooks &amp;amp; Services&lt;/strong&gt; e em seguida em configurar serviços.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/17-webhooks.jpg&#34; alt=&#34;Service&#34; width=&#34;1115&#34; height=&#34;572&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Role a tela até localizar o serviço &lt;strong&gt;Packagist&lt;/strong&gt; e clique no mesmo. Uma nova tela será aberta solicitando os dados de sua conta. Forneça &amp;#8220;user&amp;#8221; e &amp;#8220;token&amp;#8221;, o &amp;#8220;domain&amp;#8221; é opcional, em seguida marque a opção &amp;#8220;Active&amp;#8221; e clique em Update Settings.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/18-packagist-token.jpg&#34; alt=&#34;Token&#34; width=&#34;781&#34; height=&#34;599&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para obter o token, vá até sua conta no Packagist e clique em &amp;#8220;Show API Token&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/19-show-api-token.jpg&#34; alt=&#34;Show API Token&#34; width=&#34;922&#34; height=&#34;591&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após confirmado o user e token nas configurações de webhooks do github, acesse novamente Webhooks &amp;amp; Services, vá novamente até Packagist e perceba que agora existe um botão de teste para confirmar que o serviço foi habilitado com sucesso, clique sobre o mesmo e certifique-se de que uma mensagem de sucesso foi retornarda.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/20-confirm-service.jpg&#34; alt=&#34;Confirm service&#34; width=&#34;1129&#34; height=&#34;662&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Quase lá, agora falta somente acessarmos nosso pacote no composer para certificar que a mensagem de que o mesmo não é atualizado automaticamente não aparece mais.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/20-success.jpg&#34; alt=&#34;Success&#34; width=&#34;920&#34; height=&#34;547&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Prontinho! Tudo funcionando perfeitamente. Agora sempre que você der um push no github o pacote do composer é atualizado automaticamente.&lt;/p&gt;

&lt;h2 id=&#34;concluindo&#34;&gt;Concluindo&lt;/h2&gt;

&lt;p&gt;Como você pode ver o composer é muito versátil, pode (e deve preferencialmente) ser utilizado em todo e qualquer projeto em PHP. Obviamente que existem configurações mais avançadas no entanto elas não vem ao caso neste momento por serem muito específicas de cada projeto/pacote. A ideia deste post era fornecer um pouco mais de informações sobre a utilização do composer que foi iniciada no post anterior &lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34; title=&#34;Composer para iniciantes&#34;&gt;Composer para iniciantes&lt;/a&gt; para maiores informações a documentação oficial sempre será a melhor fonte.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Composer para iniciantes</title>
      <link>https://tableless.github.io/hugo-public/composer-para-iniciantes/</link>
      <pubDate>Tue, 18 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/composer-para-iniciantes/</guid>
      <description>

&lt;p&gt;&lt;a title=&#34;Ir para a homepage do Composer&#34; href=&#34;https://getcomposer.org/&#34; target=&#34;_blank&#34;&gt;Composer&lt;/a&gt; é uma ferramenta para gerenciamento de dependências para o PHP que vem ganhando espaço e se tornando cada vez mais indispensável. Com algumas poucas linhas de configurações você define todas as bibliotecas de terceiros ou mesmo suas que deseja/precisa utilizar em seu projeto, o composer encarrega-se de baixá-las e criar um autoloader deixando-as prontas para uso.&lt;/p&gt;

&lt;p&gt;Para muitos o composer ainda é um mistério então o intuito deste post é mostrar ao usuário que ainda não conhece como baixar, configurar e utilizar o composer de forma básica.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;do-que-preciso&#34;&gt;Do que preciso?&lt;/h2&gt;

&lt;p&gt;Basicamente precisará do PHP em sua versão a partir da 5.3.2.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Os exemplos criados neste post serão baseados em ambiente Linux, em sua maioria funcionará da mesma forma no Mac OS X mas para o Windows recomendo que leia a documentação oficial. O conceito é o mesmo nos três Sistemas Operacionais no entanto no Windows há algumas mínimas diferenças.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;como-começo&#34;&gt;Como começo?&lt;/h2&gt;

&lt;p&gt;Primeiramente você precisa realizar o download do phar do composer. O &lt;a title=&#34;Descubra o que é um arquivo Phar&#34; href=&#34;https://php.net/manual/pt_BR/book.phar.php&#34; target=&#34;_blank&#34;&gt;phar&lt;/a&gt; é um empacotamento de uma aplicação e é utilizado para fornecer bibliotecas e ferramentas nas quais o desenvolvedor não tem de se preocupar com sua estrutura. Em outras palavras, é pegar e usar.&lt;/p&gt;

&lt;p&gt;Para que você obtenha o composer há duas maneiras distintas. Através da biblioteca &lt;a title=&#34;Descubra o que é cURL&#34; href=&#34;http://en.wikipedia.org/wiki/CURL&#34; target=&#34;_blank&#34;&gt;cURL&lt;/a&gt; e através do próprio PHP. Basta selecionar uma das opções abaixo e executar em seu terminal.&lt;/p&gt;

&lt;p&gt;Instalando via cURL:&lt;/p&gt;

&lt;p&gt;curl -sS &lt;a href=&#34;https://getcomposer.org/installer&#34;&gt;https://getcomposer.org/installer&lt;/a&gt; | php&lt;/p&gt;

&lt;p&gt;Instalando via PHP:&lt;/p&gt;

&lt;p&gt;php -r &amp;#8220;readfile(&amp;#8216;&lt;a href=&#34;https://getcomposer.org/installer&amp;amp;#8217;);&amp;amp;#8221&#34;&gt;https://getcomposer.org/installer&amp;amp;#8217;);&amp;amp;#8221&lt;/a&gt;; | php&lt;/p&gt;

&lt;p&gt;Existem outras maneiras de instalar, na verdade são configurações mais avançadas de instalação que não serão abordadas aqui por se tratar de ser um conteudo voltado à iniciantes.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;qual-o-próximo-passo&#34;&gt;Qual o próximo passo?&lt;/h2&gt;

&lt;p&gt;Antes de você sair querendo fazer as coisas acontecerem precisamos passar alguns conceitos básicos.&lt;/p&gt;

&lt;p&gt;O composer facilita o gerenciamento de dependências em seus projetos, com isso houve a necessidade de uma padronização para a interoperabilidade entre os mais diversos frameworks PHP do mercado. Mas detalhe que o composer não limita-se à uso somente em frameworks, você pode tranquilamente utilizá-lo em seus projetos com PHP puro desde que siga as recomendações da &lt;a title=&#34;Descubra o que é FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; (Framework Interoperability Group).&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;o-arquivo-de-configurações&#34;&gt;O arquivo de configurações&lt;/h2&gt;

&lt;p&gt;Agora que você já tem uma noção do que é o composer está na hora de botar a mão na massa.&lt;/p&gt;

&lt;p&gt;Primeiramente crie um arquivo chamado &lt;em&gt;composer.json&lt;/em&gt;. Este arquivo possuirá as configurações de dependências de sua aplicação em formato &lt;a title=&#34;Veja mais sobre a estrutura de um arquivo Json&#34; href=&#34;http://json.org/json-pt.html&#34; target=&#34;_blank&#34;&gt;Json&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo segue um esqueleto básico do _composer.json_ – o arquivo em que as dependências serão descritas, em seguida o mesmo será esclarescido.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-json&#34;&gt;{
    &#34;name&#34;: &#34;Nome do projeto&#34;,
    &#34;description&#34;: &#34;Breve descrição do que a aplicação se propoe a fazer&#34;,
    &#34;authors&#34;: [
        {
            &#34;name&#34;: &#34;Seu nome&#34;,
            &#34;email&#34;: &#34;seu-email@seu-dominio.com&#34;
        }
    ],
    &#34;require&#34;: {
        &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;O “name” é o nome de sua aplicação. Esta marcação é opcional mas recomendada.&lt;/p&gt;

&lt;p&gt;O “description” é uma breve descrição do que sua aplicação se propõe a fazer. Também opcional.&lt;/p&gt;

&lt;p&gt;Em “authors” aparecem os créditos de desenvolvedores que contribuiram com o projeto.&lt;/p&gt;

&lt;p&gt;O “require” basicamente deixa claro quais são as dependências de sua aplicação. Neste caso se a versão do PHP for abaixo da 5.2.8 simplesmente uma mensagem de erro será lançada ao instalar as dependências lhe informando que não é possível prosseguir por nem todos os requisitos estarem satisfeitos.&lt;/p&gt;

&lt;p&gt;Como você pode ver acima este é o esqueleto de uma aplicação muito básica, sem configurações avançadas e sem indicação de nenhuma biblioteca de terceiro.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;ok-mas-e-agora&#34;&gt;Ok, mas e agora?&lt;/h2&gt;

&lt;p&gt;Agora que você já tem o esqueleto de seu composer configurado em sua aplicação falta incluir alguns pacotes. O composer utiliza como seu repositório o &lt;a title=&#34;Pacotes do composer&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;Packagist&lt;/a&gt; onde qualquer desenvolvedor pode criar seus próprios pacotes e disponibilizá-los para a comunidade semelhante o &lt;a title=&#34;Ir ao Github&#34; href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;. O Packagist lhe fornece o total de instalações dos pacotes por dia, mês e o total. O mais legal é que estas estatísticas são fiéis, ou seja, se alguém remover um pacote do seu _composer.json_ o total de instalações é reduzido. Com esta informação restam contagens apenas aplicações que realmente estão utilizando determinado pacote.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;um-pequeno-exemplo&#34;&gt;Um pequeno exemplo.&lt;/h2&gt;

&lt;p&gt;Para fins didáticos mostrarei aqui a utilização de uma biblioteca para slug criada por &lt;a title=&#34;Perfil de Kevin Le Brun no Github&#34; href=&#34;https://github.com/kevinlebrun&#34; target=&#34;_blank&#34;&gt;Kevin Le Brun&lt;/a&gt;, o &lt;a title=&#34;Slug PHP no Github&#34; href=&#34;https://github.com/kevinlebrun/slug.php&#34; target=&#34;_blank&#34;&gt;slug.php&lt;/a&gt;. Na seção em que são definidos os requerimentos (require) no arquivo _composer.json _basta adicionar logo abaixo da linha que define que o necessita do PHP o nome do pacote desejado e a sua versão. Neste caso o pacote é &amp;#8220;kevinlebrun/slug.php&amp;#8221; e a versão é &amp;#8220;1.*&amp;#8221;. Com isso a nova estrutura do composer.json é:&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-json&#34;&gt;...
&#34;require&#34;: {
        &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
        &#34;kevinlebrun/slug.php&#34;: &#34;1.*&#34;
}
...&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Muito bem, agora está tudo pronto para que você veja o composer em ação. Na pasta raíz de sua aplicação (que é a mesma que o _composer.json_ e o _composer.phar_ se encontram) rode o comando &lt;strong&gt;php composer.phar install&lt;/strong&gt;. Este comando fará o composer ler as configurações setadas no arquivo json e instalar todas as bibliotecas/pacotes necessários para a sua aplicação e também estas mesmas bibliotecas que possuírem dependências terão as mesmas resolvidas. Pense no composer mais ou menos como o apt-get do Linux debian-like. Nele, ao instalar um pacote qualquer todas suas dependências são resolvidas automaticamente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-large wp-image-41193&#34; alt=&#34;Estruturdo composer e instalação&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/estrutura-e-instalacao-660x292.png&#34; width=&#34;660&#34; height=&#34;292&#34; srcset=&#34;uploads/2014/02/estrutura-e-instalacao-660x292.png 660w, uploads/2014/02/estrutura-e-instalacao-329x146.png 329w, uploads/2014/02/estrutura-e-instalacao-588x261.png 588w, uploads/2014/02/estrutura-e-instalacao-400x177.png 400w, uploads/2014/02/estrutura-e-instalacao.png 1275w&#34; sizes=&#34;(max-width: 660px) 100vw, 660px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Perceba que na pasta em que encontra-se sua aplicação agora existem a pasta &lt;em&gt;vendor&lt;/em&gt;, um arquivo _composer.phar_ (que já encontrava-se ali), um arquivo _composer.json_ (que já encontrava-se ali) e um arquivo _composer.lock_ – que é o arquivo gerado automaticamente após a instalação com sucesso.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-41194&#34; alt=&#34;Estrutura de arquivos após a instalação via composer&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/estrutura-arquivos.png&#34; width=&#34;682&#34; height=&#34;333&#34; srcset=&#34;uploads/2014/02/estrutura-arquivos.png 682w, uploads/2014/02/estrutura-arquivos-329x160.png 329w, uploads/2014/02/estrutura-arquivos-588x287.png 588w, uploads/2014/02/estrutura-arquivos-634x310.png 634w, uploads/2014/02/estrutura-arquivos-400x195.png 400w&#34; sizes=&#34;(max-width: 682px) 100vw, 682px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;o-próximo-passo-mais-um&#34;&gt;O próximo passo (mais um)&lt;/h2&gt;

&lt;p&gt;Agora já temos tudo. O composer gerenciando as dependências, as dependências definidas em nosso arquivo composer.json, e uma pasta contendo todas as dependências necessárias juntamente com o autoloader do composer que encarrega-se de registar todos os namespaces dos arquivos baixados na pasta &lt;em&gt;vendor&lt;/em&gt;. Com isso basta utilizarmos.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado index.php e inclua o autoloader do composer conforme o exemplo abaixo.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-php&#34;&gt;&amp;lt;?php
header(&#39;Content-Type: text/html; charset=utf-8&#39;);

require &#39;vendor/autoload.php&#39;;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Importante que esteja definido que o conteúdo será exibido utilizando a codificação UTF-8 pois problemas podem ocorrer no tratamento de caracteres especiais como acentuações.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Com isso em mãos, basta apenas utlizarmos nosso slug.php.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-php&#34;&gt;$slugifier = new \Slug\Slugifier();

// Definindo tratamento de caracteres com acentuação
$slugifier-&amp;gt;setTransliterate(true); 

$frase = &#39;Frase com acentuação para teste de criação de slug&#39;;

$slug = $slugifier-&amp;gt;slugify($frase);

echo &#39;&amp;lt;b&amp;gt;Frase natural: &amp;lt;/b&amp;gt;&#39; . $frase . &#34;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&#34;;
echo &#39;&amp;lt;b&amp;gt;Frase com aplicação de slug: &amp;lt;/b&amp;gt;&#39; . $slug . &#34;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&#34;;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Perfeito, agora basta exibir no seu browser ou mesmo via terminal.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-41196&#34; alt=&#34;Slug rodando no terminal&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/slug-terminal.png&#34; width=&#34;816&#34; height=&#34;424&#34; srcset=&#34;uploads/2014/02/slug-terminal.png 816w, uploads/2014/02/slug-terminal-323x168.png 323w, uploads/2014/02/slug-terminal-588x305.png 588w, uploads/2014/02/slug-terminal-596x310.png 596w, uploads/2014/02/slug-terminal-400x207.png 400w&#34; sizes=&#34;(max-width: 816px) 100vw, 816px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Acessando nosso localhost através de um browser o resultado será este&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-41195&#34; alt=&#34;Slug rodando no navegador&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/slug-browser.png&#34; width=&#34;621&#34; height=&#34;353&#34; srcset=&#34;uploads/2014/02/slug-browser.png 621w, uploads/2014/02/slug-browser-295x168.png 295w, uploads/2014/02/slug-browser-545x310.png 545w, uploads/2014/02/slug-browser-400x227.png 400w&#34; sizes=&#34;(max-width: 621px) 100vw, 621px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;complementando&#34;&gt;Complementando&lt;/h2&gt;

&lt;p&gt;O comando &lt;strong&gt;php composer.phar install&lt;/strong&gt; é utilizado somente uma vez em seu repositório. Para qualquer alteração do _composer.json_ que caracteriza-se como uma nova dependência ou remoção de uma existente deve ser utilizado o comando &lt;strong&gt;php composer.phar update&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O composer ainda possui um self-update em que baixa a sua última versão. Normalmente ao rodar qualquer comando você verá uma mensagem dizendo que a sua versão do composer precisa ser atualizada. Para isto basta o comando &lt;strong&gt;php composer.phar self-update&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;O composer está se tornando a cada dia mais utilizado entre desenvolvedores e vale muito a pena se aprofundar no assunto.&lt;/p&gt;

&lt;p&gt;O código-fonte deste exemplo está no github para eventuais consultas &lt;a title=&#34;Código-fonte do projeto criado para este post&#34; href=&#34;https://github.com/andrebian/posts/blob/master/tableless/tableless-composer-para-iniciantes/sources/sources.zip&#34; target=&#34;_blank&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>