<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tdd on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/tdd/index.xml</link>
    <description>Recent content in Tdd on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/tdd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PHPUnit – persistência e configurações avançadas</title>
      <link>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</link>
      <pubDate>Thu, 08 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</guid>
      <description>

&lt;p&gt;Neste artigo você verá como utilizar o &lt;a title=&#34;PHPUnit - site oficial&#34; href=&#34;http://phpunit.de/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; para realizar testes com persistência de dados utilizando o &lt;a title=&#34;Projeto Doctrine&#34; href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;Doctrine&lt;/a&gt; um &lt;a title=&#34;O que é um ORM?&#34; href=&#34;http://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional&#34; target=&#34;_blank&#34;&gt;ORM&lt;/a&gt; open-source e como definir configurações avançadas para personalizar sua suíte de testes e gerar relatórios de testes executados bem como cobertura do código de produção.&lt;/p&gt;

&lt;h2 id=&#34;começando&#34;&gt; Começando&lt;/h2&gt;

&lt;p&gt;Para começar o projeto crie um arquivo chamado &lt;em&gt;composer.json&lt;/em&gt;. Nele listaremos todos os pacotes/bibliotecas de terceiros que utilizaremos. Para este post utilizaremos o Doctrine e vários elementos do Zend Framework 2 além de é claro o próprio PHPUnit. Abaixo segue a lista de todas as bibliotecas que serão utilizadas.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;require&#34; : {
    &#34;doctrine/common&#34; : &#34;*&#34;,
    &#34;doctrine/dbal&#34;: &#34;*&#34;,
    &#34;doctrine/orm&#34; : &#34;*&#34;,
    &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;,
    &#34;zendframework/zend-stdlib&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-filter&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-servicemanager&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-crypt&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-math&#34;: &#34;2.3.*@dev&#34;
 }&lt;/pre&gt;

&lt;p&gt;Seguindo as recomendações da &lt;a title=&#34;FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt;, utilizaremos a &lt;a title=&#34;PSR-0&#34; href=&#34;http://www.php-fig.org/psr/psr-0/&#34; target=&#34;_blank&#34;&gt;PSR-0&lt;/a&gt; que trata sobre a forma de carregarmento de classes na aplicação que estamos desenvolvendo. Com isso trabalharemos com namespaces e não precisaremos utilizar require ou include nas classes que utilizaremos. Para que o projeto tenha suas classes carregadas conforme a PSR-0 podemos informar isso no arquivo &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;autoload&#34; : {
    &#34;psr-0&#34;: {
        &#34;Tableless\\&#34;: &#34;src/&#34;
    }
 }&lt;/pre&gt;

&lt;p&gt;Isto nos diz que o namespace “Tableless” estará presente na pasta &lt;em&gt;src&lt;/em&gt; e para isto se faz necessária a criação da pasta &lt;em&gt;src&lt;/em&gt; e dentro da mesma a pasta &lt;em&gt;Tableless&lt;/em&gt;. Há outra maneira de registrar o namespace através do _boostrap._&lt;em&gt;php&lt;/em&gt; que seria algo como:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; $load = require __DIR__ . &#39;/vendor/autoload.php&#39;;
 $load-&amp;gt;add(&#39;Tableless&#39;, __DIR__ . &#39;/src&#39;);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p class=&#34;lang-php&#34;&gt;
  O arquivo &lt;em&gt;bootstrap.php &lt;/em&gt;é comumente utilizado para realizar as configurações iniciais em vários frameworks. Basicamente ele inclui o &lt;em&gt;autoload.php&lt;/em&gt; gerado pelo composer e podem ser definidas as mais diversas configurações globais de sua aplicação no mesmo.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isso baixamos o composer utilizando o comando &lt;strong&gt;curl -sS &lt;a href=&#34;https://getcomposer.org/installer&#34;&gt;https://getcomposer.org/installer&lt;/a&gt; | php&lt;/strong&gt; e em seguida instalamos as dependências através do comando &lt;strong&gt;php composer.phar install&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41342&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png&#34; alt=&#34;Instalando composer e dependências&#34; width=&#34;403&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png 403w, uploads/2014/03/02-instalando-composer-e-dependencias-218x168.png 218w, uploads/2014/03/02-instalando-composer-e-dependencias.png 791w&#34; sizes=&#34;(max-width: 403px) 100vw, 403px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Com a instalação das dependências agora temos a nova estrutura contendo uma pasta &lt;em&gt;vendor&lt;/em&gt; contendo todas as bibliotecas de terceiros, um novo arquivo &lt;em&gt;composer.lock&lt;/em&gt; e &lt;em&gt;composer.phar&lt;/em&gt; os quais já foram descritos em outro artigo sobre PHPUnit com composer e que pode ser acessado &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41343&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/03-nova-estrutura-490x310.png&#34; alt=&#34;Nova Estrutura&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/03-nova-estrutura-490x310.png 490w, uploads/2014/03/03-nova-estrutura-265x168.png 265w, uploads/2014/03/03-nova-estrutura-400x252.png 400w, uploads/2014/03/03-nova-estrutura.png 1086w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;próximo-passo&#34;&gt;Próximo passo&lt;/h2&gt;

&lt;p&gt;Agora temos de criar um arquivo que será o pontapé inicial da aplicação, arquivo este comumente nomeado de bootstrap conforme já mencionado anteriormente. Nele são configurados onde se encontram as entidades – que serão explicadas mais a frente deste tutorial, configuração do banco de dados entre outras configurações. Como neste exemplo será utilizado o Doctrine, precisamos configurar o mesmo.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado &lt;em&gt;bootstrap.php&lt;/em&gt; na raiz de seu projeto, o fonte do &lt;em&gt;bootstrap.php&lt;/em&gt; está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
// Carregando o autoload que o composer gerou
require __DIR__ . &#39;/vendor/autoload.php&#39;;
// indicando tudo que usaremos no bootstrap
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Tools\Setup;
use Doctrine\ORM\Mapping\Driver\AnnotationDriver;
use Doctrine\Common\Annotations\AnnotationReader;
use Doctrine\Common\Annotations\AnnotationRegistry;
/**
* Definindo se é modo desenvolvimento
* 
* Caso true: o cache do Doctrine é realizado em formato de array
* Caso false: o cache é conforme configuração (memcache, APC..)
* 
* Somente trabalharemos aqui com o modo TRUE, cache em array
*/
$config = Setup::createConfiguration( true );
// pasta onde encontram-se nossas entidades
$entitypath = array( __DIR__ . &#39;/src/Tableless/Entity&#39; );
// registrando as entidades
$driver = new AnnotationDriver(new AnnotationReader(), $entitypath);
$config-&gt;setMetadataDriverImpl($driver);
/**
* indicando que trabalharemos com o modo annotations para
* as entidades. Pode ser também via arquivo yaml e xml
* 
*/
AnnotationRegistry::registerFile(__DIR__ 
. &#39;/vendor/doctrine/orm/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php&#39;);
// configurando a conexão com o banco de dados
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_mysql&#39;,    
    &#39;user&#39; =&gt; &#39;root&#39;,
    &#39;password&#39; =&gt; &#39;root&#39;,
    &#39;dbname&#39; =&gt; &#39;tableless_tdd&#39;,
);
// E finalmente criando o manipulador de entidades
$entityManager = EntityManager::create($conn, $config);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Até agora você viu várias vezes a palavra “Entidade” mas o que ela significa? Entidade é um objeto que tem um significado conceitual dentro de um domínio. Em outras palavras, cada entidade no Doctrine é a representação de uma tabela no banco de dados e cada registro é uma instância desta entidade. A entidade não manipula o banco de dados, apenas representa-o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pronto, a nível de produção já temos a configuração, agora criaremos a estrutura e configurações para testes.&lt;/p&gt;

&lt;p&gt;Na raiz de seu projeto crie uma pasta chamada &lt;em&gt;tests&lt;/em&gt;, dentro dela uma pasta chamada &lt;em&gt;src&lt;/em&gt; e dentro da src uma pasta chamada &lt;em&gt;Tableless&lt;/em&gt;. Perceba que o namespace ficará na mesma estrutura do código de produção, desta forma para utilizarmos uma entidade chamada &lt;em&gt;User&lt;/em&gt; por exemplo, usaremos a seguinte declaração: &lt;strong&gt;use Tableless\Entity\User;&lt;/strong&gt;. Para a classe de testes de User se for necessária declarar em algum lugar será desta forma: &lt;strong&gt;use Tableless\Entity\UserTest;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41345&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/04-estrutura-inicial-testes-398x310.png&#34; alt=&#34;Estrutura inicial testes&#34; width=&#34;398&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/04-estrutura-inicial-testes-398x310.png 398w, uploads/2014/03/04-estrutura-inicial-testes-215x168.png 215w, uploads/2014/03/04-estrutura-inicial-testes-400x311.png 400w, uploads/2014/03/04-estrutura-inicial-testes.png 542w&#34; sizes=&#34;(max-width: 398px) 100vw, 398px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a criação das pastas necessárias falta a criação do bootstrap de testes e de um arquivo de configurações de execução do PHPUnit.&lt;/p&gt;

&lt;p&gt;Começando com o bootstrap, o código novamente está comentado explicando porque determinadas coisas estão sendo feitas. Crie o arquivo &lt;em&gt;bootstrap.php&lt;/em&gt; dentro da pasta de testes (&lt;em&gt;tests&lt;/em&gt;).&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&lt;?php
// utilizando o bootstrap de produção
require __DIR__ . &#39;/../bootstrap.php&#39;;
use Doctrine\ORM\EntityManager;
/*
* Sobrescrevendo a conexão com banco de dados.
* 
* Isto faz-se necessário para que ao rodar os testes 
* o banco de produção não sofra alterações
*/
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_sqlite&#39;,
    &#39;dbname&#39; =&gt; &#39;:memory:&#39;,
);
return $entityManager = EntityManager::create($conn, $config);
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;O bootstrap de testes se faz necessário para sobrescrever a conexão com o banco de dados, caso contrário, todos os testes realizariam alterações no banco de dados de produção e isto jamais deve acontecer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isto agora é o momento de criar o arquivo xml de configurações do PHPUnit. Crie um arquivo chamado &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;phpunit.xm&lt;/i&gt;l dentro de sua pasta &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;tests&lt;/i&gt; e adicione o conteúdo abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;

&amp;lt;!-- Indicando qual é o diretório onde as classes de teste se encontram --&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&#34;Tableless TDD Test Suite&#34;&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;src/&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;

&amp;lt;!-- Adicionando filtros, basicamente whitelist (diretórios que serão executados), 
dentro temos o exclude (diretórios que não serão executados pelos testes) --&amp;gt;

&amp;lt;filter&amp;gt;
    &amp;lt;whitelist&amp;gt;
        &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;../src/&amp;lt;/directory&amp;gt;
        &amp;lt;exclude&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;./vendor/&amp;lt;/directory&amp;gt;
        &amp;lt;/exclude&amp;gt;
    &amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;/phpunit&amp;gt;&lt;/pre&gt;

&lt;p&gt;Quase pronto, se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; dentro da raiz do projeto teremos a mensagem de que nenhum teste foi executado como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41346&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/05-nenhum-teste-490x310.png&#34; alt=&#34;Nenhum Teste&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/05-nenhum-teste-490x310.png 490w, uploads/2014/03/05-nenhum-teste-265x168.png 265w, uploads/2014/03/05-nenhum-teste-400x253.png 400w, uploads/2014/03/05-nenhum-teste.png 803w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; Como estamos trabalhando com um arquivo de configurações, para rodarmos o phpunit seguindo as definições do arquivo precisamos utilizar o parâmetro &lt;strong&gt;-c&lt;/strong&gt; seguido do nome do arquivo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Obviamente que nenhum teste ainda foi executado porque não temos nenhuma classe de testes. Vamos começar então. Crie uma pasta &lt;em&gt;Entity&lt;/em&gt; dentro de &lt;em&gt;tests/src&lt;/em&gt;. Dentro desta pasta crie um arquivo chamado &lt;em&gt;UsertTest.php&lt;/em&gt;. A nova estrutura de testes deve estar como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41347&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/06-nova-estrutura-de-testes-379x310.png&#34; alt=&#34;Nova estrutura de testes&#34; width=&#34;379&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/06-nova-estrutura-de-testes-379x310.png 379w, uploads/2014/03/06-nova-estrutura-de-testes-205x168.png 205w, uploads/2014/03/06-nova-estrutura-de-testes-400x326.png 400w, uploads/2014/03/06-nova-estrutura-de-testes.png 695w&#34; sizes=&#34;(max-width: 379px) 100vw, 379px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;UserTest.php&lt;/em&gt; adicione o namespace do mesmo que é Tableless\Entity.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;namespace Tableless\Entity;&lt;/pre&gt;

&lt;p&gt;Agora definimos quais classes utilizaremos para este teste. Como estamos testando a entidade &lt;em&gt;User&lt;/em&gt; precisaremos utilizar o Tableless\Entity\User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;&lt;/pre&gt;

&lt;p&gt;No entanto aí tem um detalhe. A entidade User ainda não existe, mas a criaremos dentro de instantes pois ainda temos uma classe que devemos criar antes mesmo da &lt;em&gt;User&lt;/em&gt;. Ela se chama &lt;em&gt;TestCase&lt;/em&gt; e deve estar no namespace Tableless\Test. Crie em &lt;em&gt;src/Tableless&lt;/em&gt; (não em tests/src/Tableless) uma pasta chamada Test e dentro dela um arquivo chamado &lt;em&gt;TestCase.php&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41348&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/07-criando-test-case-426x310.png&#34; alt=&#34;Criando o TestCase&#34; width=&#34;426&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/07-criando-test-case-426x310.png 426w, uploads/2014/03/07-criando-test-case-230x168.png 230w, uploads/2014/03/07-criando-test-case-400x291.png 400w, uploads/2014/03/07-criando-test-case.png 602w&#34; sizes=&#34;(max-width: 426px) 100vw, 426px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Neste arquivo copie e cole o código abaixo que está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
namespace Tableless\Test;

use Doctrine\ORM\Tools\SchemaTool;
use PHPUnit_Framework_TestCase as PHPUnit;

abstract class TestCase extends PHPUnit
{
    protected $entityManager = null;

    /**
    * Executado antes de cada teste unitário
    */
    public function setup() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Cria a base de dados necessária com suas determinadas tabelas
        $tool-&amp;gt;createSchema($classes);

        parent::setup();
    } 

    /**
    * Executado após a execução de cada um dos testes unitários
    */
    public function tearDown() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Desfaz o banco criado no setUp
        $tool-&amp;gt;dropSchema($classes);

        parent::tearDown();
    }

    /**
    * 
    * @return \Doctrine\ORM\EntityManager
    */
    public function getEntityManager() 
    {
        if (! $this-&amp;gt;entityManager) {
            $this-&amp;gt;entityManager = require __DIR__ . &#39;/../../../tests/bootstrap.php&#39;;
        } 
        return $this-&amp;gt;entityManager; 
    } 
}&lt;/pre&gt;

&lt;p&gt;Pronto, já estamos com tudo o que precisamos para começar escrever os testes. Detalhe que esta configuração foi criada para que fosse possível utilizar e testar a persistência de dados utilizando o Doctrine. Para demais testes em controllers, services, views, forms ou o que mais você desejar esta configuração realizada até o momento permanece podendo ser acrescida de novos elementos, tudo depende da necessidade.&lt;/p&gt;

&lt;h2 id=&#34;criando-o-primeiro-teste&#34;&gt;Criando o primeiro teste&lt;/h2&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt; começaremos a definir nossos testes. Lembre-se que a ideia do TDD é que o teste seja criado antes do código de produção, e assim faremos.&lt;/p&gt;

&lt;p&gt;Pra início de conversa utilizaremos a classe &lt;em&gt;TestCase&lt;/em&gt; previamente criada e a entidade User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;
use Tableless\Test\TestCase;&lt;/pre&gt;

&lt;p&gt;A classe de testes atual (UserTest) extende de TestCase e adicionaremos o atributo protegido $entity.&lt;/p&gt;

&lt;pre&gt;class UserTest extends TestCase
{
    protected $entity;
}&lt;/pre&gt;

&lt;p&gt;Assim como a classe TestCase, nossa classe UserTest também possuirá um métdo setUp e um tearDown que servirão para as configurações da mesma. De momento apenas setaremos o valor default do atributo entity no setUp.&lt;/p&gt;

&lt;pre&gt;public function setUp()
{
    $this-&amp;gt;entity = &#39;Tableless\Entity\User&#39;;
};&lt;/pre&gt;

&lt;p&gt;Agora segue o nosso primeiro teste: Novamente há comentários explicando cada ação.&lt;/p&gt;

&lt;pre&gt;public function testIfIsSavingAsExpected()
{
    // Criando os dados necessários para salvar o usuário
    $userData = array(
        &#39;id&#39; =&amp;gt; 1,
        &#39;name&#39; =&amp;gt; &#39;Nome do usuário&#39;,
        &#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;,
        &#39;password&#39; =&amp;gt; &#39;xpto&#39;,
        &#39;profilePic&#39; =&amp;gt; &#39;image.png&#39;
    );
    /* o Id é gerado automaticamente pelo Doctrine, neste caso estou forçando
    * um Id desejado, mas somente para o teste, para o código de produção
    * isto não se faz necessário
    */

    // Instanciando a entidade usuário definindo todos os atributos à ela
    $user = new User( $userData );

    // salvando o usuário no banco de dados
    $this-&amp;gt;getEntityManager()-&amp;gt;persist( $user );
    $this-&amp;gt;getEntityManager()-&amp;gt;flush();

    // Obtendo o usuário salvo
    $registeredUser = $this-&amp;gt;getEntityManager()
            -&amp;gt;getRepository($this-&amp;gt;entity)
            -&amp;gt;findOneBy(array(&#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;));

    // Garantindo que tudo funcionou conforme o esperado
    $this-&amp;gt;assertInstanceOf($this-&amp;gt;entity, $registeredUser);
    $this-&amp;gt;assertEquals($userData[&#39;name&#39;], $registeredUser-&amp;gt;getName());
}&lt;/pre&gt;

&lt;p&gt;Se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; da raiz de nosso projeto deveremos ver o seguinte erro: “PHP Fatal error: Class &amp;#8216;Tableless\Entity\User &amp;#8230;&amp;#8217;” isto porque ainda não existe a entidade &lt;em&gt;User&lt;/em&gt; pois realizamos o primeiro passo do TDD, o “Red”. Em seguida realizaremos o passo “Green” que consiste em criarmos o código que faça o teste passar e por último o passo “Refactor” que é onde faremos algumas melhorias no código. No código exemplo não existirá duplicidade e/ou partes inconsistentes com isso o Refactor realizará apenas algumas pequenas melhorias, nada mais.&lt;/p&gt;

&lt;p&gt;Crie na pasta &lt;em&gt;src&lt;/em&gt; (não em tests/src) uma pasta chamada &lt;em&gt;Entity&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;User.php&lt;/em&gt;. Eis a estrutura da entidade &lt;em&gt;User&lt;/em&gt;. Por ser um arquivo muito extenso, colocarei apenas o link do mesmo que encontra-se no github. &lt;a title=&#34;Tableless\Entity\user&#34; href=&#34;https://gist.github.com/andrebian/11389706&#34; target=&#34;_blank&#34;&gt;Tableless\Entity\User&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perceba que existem comentários acima de cada um dos atributos da classe. Isto se dá por estarmos utilizando o Annotations do Doctrine para que os mesmos sejam lidos e mapeados no banco de dados. Em outras palavras, o Doctrine lê a anotação e cria a estrutura da tabela conforme as definições nos comentários. Há a possibilidade de realizar tais definições via xml e também via yaml o que não veremos neste tutorial.&lt;/p&gt;

&lt;p&gt;Agora se rodarmos nosso teste novamente o mesmo passará. Ou seja, já temos um código minimamente testado com um início de noção de persistência de dados, veremos uma pequena melhora no código agora e em seguida algumas configurações para a execução dos testes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41349&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/08-primeiro-teste-passando-575x310.png&#34; alt=&#34;Primeiro teste passando&#34; width=&#34;575&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/08-primeiro-teste-passando-575x310.png 575w, uploads/2014/03/08-primeiro-teste-passando-312x168.png 312w, uploads/2014/03/08-primeiro-teste-passando-400x215.png 400w, uploads/2014/03/08-primeiro-teste-passando.png 797w&#34; sizes=&#34;(max-width: 575px) 100vw, 575px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;definindo-hash-para-senha&#34;&gt;Definindo hash para senha&lt;/h2&gt;

&lt;p&gt;Primeiramente no teste adicionaremos uma asserção de que a senha do usuário registrado não é igual a senha que definimos, em string pura. Adicione o trecho de código abaixo em seu teste logo após $this-&amp;gt;assertEquals($userData[&amp;#8216;name&amp;#8217;], $registeredUser-&amp;gt;getName());&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;// verificando se hash de senha funcionou
$this-&amp;gt;assertNotEquals($userData[&#39;password&#39;], $registeredUser-&amp;gt;getPassword());&lt;/pre&gt;

&lt;p&gt;Ao rodarmos o teste o mesmo deve quebrar pois ainda não criamos um hash para a senha, desta forma a senha fornecida está em string pura no banco de dados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41350&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/09-teste-falhando-hash-523x310.png&#34; alt=&#34;Teste falhando hash&#34; width=&#34;523&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/09-teste-falhando-hash-523x310.png 523w, uploads/2014/03/09-teste-falhando-hash-283x168.png 283w, uploads/2014/03/09-teste-falhando-hash-400x237.png 400w, uploads/2014/03/09-teste-falhando-hash.png 800w&#34; sizes=&#34;(max-width: 523px) 100vw, 523px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, na classe Tableless\Entity\User usaremos as seguintes classes do Zend:&lt;/p&gt;

&lt;pre&gt;use Zend\Math\Rand;
use Zend\Crypt\Key\Derivation\Pbkdf2;&lt;/pre&gt;

&lt;p&gt;em setPassword deixaremos adicionaremos a chamada ao método encryptPassword&lt;/p&gt;

&lt;pre&gt;public function setPassword( $password )
{
    $this-&amp;gt;password = $this-&amp;gt;encryptPassword($password);
    return $this;
}&lt;/pre&gt;

&lt;p&gt;E criaremos o método encryptPassword.&lt;/p&gt;

&lt;pre&gt;public function encryptPassword( $password )
{
   return base64_encode(
    Pbkdf2::calc(&#39;sha256&#39;, $password, $this-&amp;gt;salt, 
            10000, strlen($password*2)));
}&lt;/pre&gt;

&lt;p&gt;Agora rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; o teste passa novamente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41351&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/10-teste-passando-hash-375x310.png&#34; alt=&#34;teste passando hash&#34; width=&#34;375&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/10-teste-passando-hash-375x310.png 375w, uploads/2014/03/10-teste-passando-hash-203x168.png 203w, uploads/2014/03/10-teste-passando-hash-400x330.png 400w, uploads/2014/03/10-teste-passando-hash.png 795w&#34; sizes=&#34;(max-width: 375px) 100vw, 375px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Assim finalizamos o básico da realização de testes utilizando persitência de dados. A partir de agora veremos algumas configurações avançadas que lhe ajudarão muito no feedback dos testes.&lt;/p&gt;

&lt;h2 id=&#34;algumas-configurações-avançadas&#34;&gt;Algumas configurações avançadas&lt;/h2&gt;

&lt;p&gt;Através do arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; podemos definir algumas configurações avançadas para a execução dos testes. Começando pela declaração &lt;phpunit&gt;. Atualmente encontra-se desta forma:&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que utilizaremos um arquivo de bootstrap e dizemos qual arquivo é e também que queremos coloração no output. Caso colors=”true” não estivesse presente nossa visão ficaria desta forma.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41352&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/11-colors-482x310.png&#34; alt=&#34;Colors&#34; width=&#34;482&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/11-colors-482x310.png 482w, uploads/2014/03/11-colors-261x168.png 261w, uploads/2014/03/11-colors-400x257.png 400w, uploads/2014/03/11-colors.png 806w&#34; sizes=&#34;(max-width: 482px) 100vw, 482px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos definir erros e avisos sendo tratados como exceções.&lt;/p&gt;

&lt;pre&gt;&amp;lt;phpunit 
    convertErrorsToExceptions=&#34;true&#34; 
    convertNoticesToExceptions=&#34;true&#34;
    convertWarningsToExceptions=&#34;true&#34;
    colors=&#34;true&#34;
    bootstrap=&#34;bootstrap.php&#34;
&amp;gt;&lt;/pre&gt;

&lt;p&gt;E muitas outras opções. Para conhecer todas as opções de configurações acesse &lt;a title=&#34;Visualizar as configurações do PHPUnit&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/appendixes.configuration.html&#34; target=&#34;_blank&#34;&gt;este link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Certamente que a configuração a seguir é uma que empolga muitos desenvolvedores, logs e coverage. Com logs e coverage você identifica quais testes passaram, quais tiveram exceções, quais não passaram e o mais legal de tudo, o percentual de cobertura de testes que há em seu código de produção. Basicamente ao rodar um teste unitário, ele cobre uma pequena parte de seu código de produção, habilitando coverage você pode verificar quais linhas estão realmente garantidas por testes e quais você ainda tem de trabalhar mais tempo para garantir um mínimo de cobertura necessário para perfeito funcionamento mas principalmente para garantia de evolução de seu software.&lt;/p&gt;

&lt;p&gt;Para criar logs utilizamos a tag logging no arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; logo após o fechamento da tag &lt;/filter&gt;.&lt;/p&gt;

&lt;pre&gt;&amp;lt;logging&amp;gt;
    &amp;lt;log type=&#34;testdox-text&#34; target=&#34;data/testdox.txt&#34; /&amp;gt;
&amp;lt;/logging&amp;gt;&lt;/pre&gt;

&lt;p&gt;O log acima está gravando em formato de texto um checklist dos testes que existem em todas as classes de teste dentro da suite de testes marcando com x os que foram executados.&lt;/p&gt;

&lt;p&gt;Rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; será criada a pasta &lt;em&gt;tests/data&lt;/em&gt; contento o arquivo &lt;em&gt;testdox.txt&lt;/em&gt; O nome do arquivo é de sua escolha.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41353&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/12-testdox-569x310.png&#34; alt=&#34;Testdox&#34; width=&#34;569&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/12-testdox-569x310.png 569w, uploads/2014/03/12-testdox-308x168.png 308w, uploads/2014/03/12-testdox-400x217.png 400w, uploads/2014/03/12-testdox.png 891w&#34; sizes=&#34;(max-width: 569px) 100vw, 569px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Também é possível gerar o testdox em formato html, basta alterar testdox-text para testdox-html e testdox.txt para testdox.html mas o mais comum é ser utilizado em formato txt mesmo.&lt;/p&gt;

&lt;p&gt;Existe também a possibilidade de habilitar o testdox em tempo de execução. Basta apenas adicionar o parâmetro &amp;#8211;testdox ao rodar os testes. O resultado será como abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --testdox
PHPUnit 3.7.35 by Sebastian Bergmann.
Configuration read from /home/andre/Documents/Posts/tableless/phpunit-persistencia-de-dados-e-configuracoes-avancadas/sources/tests/phpunit.xml
Tableless\Entity\User
  [x] If is saving as expected
Generating code coverage report in HTML format ... done&lt;/pre&gt;

&lt;h2 id=&#34;agrupamento-de-testes&#34;&gt;Agrupamento de testes&lt;/h2&gt;

&lt;p&gt;Por certas vezes necessitamos agrupar testes para que rodemos somente determinada sequência sem que os demais sejam executados. Isto é útil para quando temos de realizar uma pequena alteração e não se faça necessário a execução de todos os testes já criados tornando o feedback mais rápido. Comumente isto é utilizado quando se deseja realizar um ajuste pontual e ao ser finalizado todos os testes são executados novamente.&lt;/p&gt;

&lt;p&gt;O PHPUnit nos permite trabalhar com grupos os quais veremos sua definição a seguir.&lt;/p&gt;

&lt;p&gt;Crie uma pasta chamada &lt;em&gt;Filter&lt;/em&gt; em &lt;em&gt;tests/src/Tableless&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;CurrencyTest.php&lt;/em&gt;. O conteúdo deste arquivo está abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
namespace Tableless\Filter;
use Tableless\Test\TestCase;
/**
* @group Filter
*/
class CurrencyTest extends TestCase 
{
    public function testIfClassExists()
    {
        $this-&amp;gt;assertTrue(class_exists(&#39;Tableless\Filter\Currency&#39;));
    }
}&lt;/pre&gt;

&lt;p&gt;Perceba que antes de ser declarado o nome da classe existe uma anotação @group Filter. É isto que define o grupo ao qual este teste pertence. Faça o mesmo para o teste já existente (tests/src/Tableless/Entity/UserTest.php) anotando-o como @group Entity.&lt;/p&gt;

&lt;pre&gt;...
/**
* @group Entity
*/
class UserTest extends TestCase
...&lt;/pre&gt;

&lt;p&gt;Agora que temos a definição dos grupos podemos rodar nossos testes somente de 1 grupo, de um conjunto de grupos ou de todos os grupos sem distinção. Existem duas formas de rodar os testes por grupos, através de parâmetro informado no momento da execução dos testes ou através do arquivo xml de configurações do PHPUnit, veremos ambas.&lt;/p&gt;

&lt;h3 id=&#34;via-parâmetro&#34;&gt;Via parâmetro&lt;/h3&gt;

&lt;h4 id=&#34;somente-um-grupo&#34;&gt;Somente um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity
&lt;/pre&gt;

&lt;h4 id=&#34;mais-de-um-grupo&#34;&gt;Mais de um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity,Filter
&lt;/pre&gt;

&lt;p&gt;Para que todos os grupos de testes sejam executados basta que não seja informado o parâmetro &amp;#8211;group.&lt;/p&gt;

&lt;h3 id=&#34;via-arquivo-de-configuração&#34;&gt;Via arquivo de configuração&lt;/h3&gt;

&lt;p&gt;No arquivo tests/phpunit.xml adicione uma tag &lt;groups&gt; e dentro dela liste os grupos desejados.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;groups&amp;gt;
    &amp;lt;include&amp;gt;
        &amp;lt;group&amp;gt;Entity&amp;lt;/group&amp;gt;
    &amp;lt;/include&amp;gt;
&amp;lt;/groups&amp;gt;&lt;/pre&gt;

&lt;p&gt;Você deve estar imaginando, se existe uma tag &lt;strong&gt;include &lt;/strong&gt;deve existir uma tag &lt;strong&gt;exclude &lt;/strong&gt;também. Imaginou certo! Dentro de include você adiciona todos os grupos que deseja que sejam executados nos testes já em exclude, todos que NÃO devem ser executados. O excclude é ideal para testes que foram marcados como incompletos ou pulados (skipped).&lt;/p&gt;

&lt;p&gt;Após adicionar as tags referentes aos grupos de testes no arquivo xml de configurações não se faz mais necessário informar o parâmetro  &amp;#8211;group, basta rodar normalmente.&lt;/p&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/pre&gt;

&lt;h2 id=&#34;agora-sim-o-mais-legal-de-todos-coverage-em-html&#34;&gt;Agora sim, o mais legal de todos, Coverage em Html!&lt;/h2&gt;

&lt;p&gt;Dentro de &lt;logging&gt; adicione uma nova tag chamada &lt;log&gt; conforme o exemplo abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;log 
    type=&#34;coverage-html&#34; 
    target=&#34;data/coverage&#34; 
    charset=&#34;UTF-8&#34; 
    yui=&#34;true&#34; 
    highlight=&#34;true&#34;
    lowUpperBound=&#34;35&#34;
    highUpperBound=&#34;70&#34; /&amp;gt;&lt;/pre&gt;

&lt;p&gt;Basicamente estamos definindo que o coverage será em formato html, que o considerado baixo coverage será de 35% e um bom coverage se dará a partir de 70%. O highlight serve para destacar as linhas que foram cobertas com verde, não cobertas com vermelho e ignoradas permanecem com a cor padrão. Rode o teste novamente.&lt;/p&gt;

&lt;p&gt;Agora no browser entre em seu localhost na pasta do projeto em que está trabalhando. Em seguida entre na pasta &lt;em&gt;tests&lt;/em&gt;, após isto em &lt;em&gt;data&lt;/em&gt; e por último em coverage. Surpreenda-se!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41354&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/13-coverage-588x223.png&#34; alt=&#34;Coverage&#34; width=&#34;588&#34; height=&#34;223&#34; srcset=&#34;uploads/2014/03/13-coverage-588x223.png 588w, uploads/2014/03/13-coverage-329x125.png 329w, uploads/2014/03/13-coverage-660x251.png 660w, uploads/2014/03/13-coverage-400x152.png 400w, uploads/2014/03/13-coverage.png 1324w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Navegando pelos arquivos você identificará o que já está bom e o que precisa ser mais testado. Neste nosso caso chegar a 100% é muito fácil, basta lermos todos os dados do usuário.&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt;, dentro do único teste que temos adicione os seguintes asserts:&lt;/p&gt;

&lt;pre&gt;$this-&amp;gt;assertEquals(1, $registeredUser-&amp;gt;getId());
$this-&amp;gt;assertEquals(&#39;usuario@dominio.com&#39;, $registeredUser-&amp;gt;getEmail());
$this-&amp;gt;assertNotNull($registeredUser-&amp;gt;getSalt());
$this-&amp;gt;assertEquals(&#39;image.png&#39;, $registeredUser-&amp;gt;getProfilePic());&lt;/pre&gt;

&lt;p&gt;Rode os testes novamente e corra pro abraço!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41355&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/14-coverage-100-588x237.png&#34; alt=&#34;Coverage 100%&#34; width=&#34;588&#34; height=&#34;237&#34; srcset=&#34;uploads/2014/03/14-coverage-100-588x237.png 588w, uploads/2014/03/14-coverage-100-329x132.png 329w, uploads/2014/03/14-coverage-100-660x266.png 660w, uploads/2014/03/14-coverage-100-400x161.png 400w, uploads/2014/03/14-coverage-100.png 1303w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lembrando novamente que para entendimento deste tutorial se faz necessário a leitura dos conteúdos anteriores sobre o tema, sendo eles &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar/&#34; title=&#34;TDD, por que usar?&#34;&gt;TDD, por que usar?&lt;/a&gt;  e &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;PHPUnit, como iniciar sem dores&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;bonus&#34;&gt;Bonus.&lt;/h2&gt;

&lt;p&gt;O que fizemos até o momento foi preparar o ambiente de testes e executá-los mas este ambiente ainda não está totalmente pronto para o código de produção pois precisamos de conexão com um banco de dados além de mais uma configuração do Doctrine para que possamos criar o banco de dados a partir de nossas entidades. Ou seja, lembra daquele processo de criar o banco de dados, definir as tabelas e relacionamentos todos antes do código? Com o Doctrine isto não se faz mais necessário, pode ser feito da forma descrita (e tradicional) mas há outra forma bem legal que é uma mão na roda e que mostrarei agora.&lt;/p&gt;

&lt;p&gt;Primeiramente precisamos criar um arquivo de configuração para o cli (Command Line Interface) do Doctrine. Na pasta raiz de sua aplicação crie um arquivo chamado &lt;em&gt;cli-config.php&lt;/em&gt; e cole o seguinte conteúdo:&lt;/p&gt;

&lt;pre&gt;//cli-config.php
require &#39;bootstrap.php&#39;;

return \Doctrine\ORM\Tools\Console\ConsoleRunner::createHelperSet($entityManager);&lt;/pre&gt;

&lt;div id=&#34;LC3&#34;&gt;
  Após a criação deste arquivo podemos rodar o seguinte comando &lt;b&gt;./vendor/bin/doctrine&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;Aparecerão várias opções de uso que vão desde checagem de status de conexão, validação das entidades, além de outras funcionalidades. Uma coisa que o doctrine não faz realmente é criar a base de dados pois isto depende de cada base pois Mysql é de um jeito, Postgres é de outro, SQL Server é de outro ainda, então esta tarefa ainda é manual.&lt;/p&gt;

&lt;p&gt;Para fins didáticos criei uma base chamada tableless_tdd no mysql como definido no arquivo bootstrap.php da raiz do projeto. Você pode alterar o nome se quiser, bem como o próprio banco, experimente o Sqlite se quiser.&lt;/p&gt;

&lt;p&gt;Com a base criada rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;. Se estiver tudo ok aparecerá algo como a imagem abaixo. Nela informa que o mapeamento das entidades está correto mas o banco ainda não está sincronizado, para sincronizar rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;. Isto lerá todas as entidades contidas em src/Tableless/Entity e criará a estrutura de tabelas a partir delas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41356&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/15-doctrine-validate-500x310.png&#34; alt=&#34;Doctrine Validate Schema&#34; width=&#34;500&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/15-doctrine-validate-500x310.png 500w, uploads/2014/03/15-doctrine-validate-271x168.png 271w, uploads/2014/03/15-doctrine-validate-400x247.png 400w, uploads/2014/03/15-doctrine-validate.png 797w&#34; sizes=&#34;(max-width: 500px) 100vw, 500px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41357&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/16-doctrine-create-validate-459x310.png&#34; alt=&#34;Doctrine create validate&#34; width=&#34;459&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/16-doctrine-create-validate-459x310.png 459w, uploads/2014/03/16-doctrine-create-validate-249x168.png 249w, uploads/2014/03/16-doctrine-create-validate-400x269.png 400w, uploads/2014/03/16-doctrine-create-validate.png 820w&#34; sizes=&#34;(max-width: 459px) 100vw, 459px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Atualmente possuímos somente a entidade User que indica que uma tabela users será criada no banco de dados. Após a finalização da execução do comando anterior seu banco de dados já estará com a nova estrutura. Ao realizar qualquer alteração na entidade User ou mesmo criar novas entidades você precisará rodar o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:update&lt;/strong&gt; com isso aparecerá uma mensagem informando que já há uma estrutura no banco de dados e lhe pede confirmação sobre o que fazer. Você pode ignorar, ver as alterações ou forçar se tiver certeza do que está fazendo ou mesmo se já visualizou as alterações que serão realizadas e está ciente de que está tudo certo. Basta ler as intruções que o próprio Doctrine fornece que você saberá o que fazer, é muito intuitivo.&lt;/p&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;Agora que você já configurou o Doctrine, já conhece como criar testes unitários resta apenas aperfeiçoar a cada dia. Não existe uma receita, tudo requer empenho e dedicação mas que no final quando você ver aquelas barrinhas verdes mostrando 100% de cobertura se sentirá cada vez mais empolgado e com um código mais estável mas o principal, com um código que pode facilmente evoluir.&lt;/p&gt;

&lt;p&gt;Para baixar o código-fonte gerado neste artigo acesse este link do &lt;a title=&#34;Baixar o código-fonte&#34; href=&#34;https://github.com/andrebian/tdd-persistencia-de-dados&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução ao Behavior Driven Development</title>
      <link>https://tableless.github.io/hugo-public/introducao-ao-behavior-driven-development/</link>
      <pubDate>Fri, 21 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-ao-behavior-driven-development/</guid>
      <description>

&lt;p&gt;O &lt;strong&gt;BDD&lt;/strong&gt; &lt;em&gt;(Behavior Driven Development ou Desenvolvimento guiado por comportamento)&lt;/em&gt;, é uma resposta ao &lt;strong&gt;TDD&lt;/strong&gt;, criado em 2003, por &lt;em&gt;Dan North&lt;/em&gt;, e tem se expandido bastante nos últimos anos. Seu foco é obter um código testado a partir de um conjunto de cenários que descrevem como a aplicação ou unidade de código deverá se comportar em determinada situação.&lt;/p&gt;

&lt;h3 id=&#34;as-práticas-de-bdd-incluem&#34;&gt;As práticas de &lt;strong&gt;BDD&lt;/strong&gt; incluem:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Envolver as partes interessadas no processo através de &lt;em&gt;Outside-in Development&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Usar linguagem ubíqua para descrever o comportamento de uma aplicação&lt;/li&gt;
&lt;li&gt;Automatizar os exemplos para provê um feedback rápido e testes de regressão&lt;/li&gt;
&lt;li&gt;Usar &lt;strong&gt;&lt;em&gt;SHOULD&lt;/em&gt;&lt;/strong&gt; na hora de descrever o comportamento de software para ajudar esclarecer responsabilidades e permitir que funcionalidades do software sejam questionadas&lt;/li&gt;
&lt;li&gt;Usar dublês de teste &lt;em&gt;(mocks, stubs, fakes, dummies, spies)&lt;/em&gt; para auxiliar na colaboração entre módulos e códigos que ainda não foram escritos&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;e-8230&#34;&gt;E&amp;#8230;&lt;/h2&gt;

&lt;p&gt;O grande lance do BDD, é que nos trabalhamos com comportamentos de uma maneira que&lt;/p&gt;

&lt;p&gt;qualquer pessoa possa entender ou escrever novos testes. Baseado no que espera que&lt;/p&gt;

&lt;p&gt;a aplicação executa o aferir uma ação específica.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Qual a vantagem disso?&lt;/em&gt; O especialista do domínio pode escrever testes.&lt;/p&gt;

&lt;p&gt;O gerente de projetos pode escrever testes. o PO pode escrever testes baseados&lt;/p&gt;

&lt;p&gt;no que ele espera da aplicação. O padeiro da esquina pode escrever testes&lt;/p&gt;

&lt;p&gt;também. Qualquer um pode descrever o que espera da aplicação sem a necessidade&lt;/p&gt;

&lt;p&gt;de ter habilidades de um programador.&lt;/p&gt;

&lt;h2 id=&#34;cenários&#34;&gt;Cenários&lt;/h2&gt;

&lt;p&gt;Cada cenário descreve uma ação que será aferida e testada. Eles devem conter&lt;/p&gt;

&lt;p&gt;passos lógicos e simple de como obter um resultado específico a partir de uma sequência&lt;/p&gt;

&lt;p&gt;de ações.&lt;/p&gt;

&lt;p&gt;Exemplo:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cenário 1:&lt;/strong&gt; &lt;em&gt;Quantidade de items no estoque&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Dado que há 5 items no estoque&lt;/li&gt;
&lt;li&gt;E um cliente comprou 2 items do estoque&lt;/li&gt;
&lt;li&gt;Então quando contar os items restantes no estoque&lt;/li&gt;
&lt;li&gt;Terei 3 items&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como podemos perceber, desenvolvedores podem se concentrar exclusivamente nas razões pelas quais o código deve ser criado, e não em detalhes técnicos, além de minimizar traduções entre a linguagem técnica na qual o código é escrito e outras linguagens de domínio.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHPUnit, como iniciar sem dores</title>
      <link>https://tableless.github.io/hugo-public/phpunit-como-iniciar-sem-dores/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-como-iniciar-sem-dores/</guid>
      <description>

&lt;p&gt;Como já mencionei em um artigo anterior, o &lt;a title=&#34;Ir ao repositório do PHPUnit&#34; href=&#34;https://github.com/sebastianbergmann/phpunit/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; é um framework de testes unitários para a linguagem PHP. Ele provê um ecossistema para a execução de testes de forma automatizada.&lt;/p&gt;

&lt;p&gt;Neste artigo veremos a sua instalação utilizando o gerenciador de pacotes &lt;a title=&#34;Ir à página oficial do Composer&#34; href=&#34;http://getcomposer.org/&#34; target=&#34;_blank&#34;&gt;composer&lt;/a&gt;, configuração e estrutura de pastas e alguns testes simples sem persistência de dados.&lt;/p&gt;

&lt;h2 id=&#34;instalando-o-phpunit&#34;&gt;Instalando o PHPUnit&lt;/h2&gt;

&lt;p&gt;Para iniciar a instalação do PHPUnit precisamos primeiramente de um diretório que será nosso diretório de trabalho neste exemplo. Após criado o diretório é necessário criar um arquivo chamado &lt;a title=&#34;Ir ao modelo do arquivo composer.json&#34; href=&#34;http://getcomposer.org/doc/04-schema.md&#34; target=&#34;_blank&#34;&gt;&lt;i&gt;composer&lt;/i&gt;&lt;i&gt;.json&lt;/i&gt;&lt;/a&gt; para que seja definida a necessidade do PHP Unit no projeto. O arquivo _composer_&lt;em&gt;.json&lt;/em&gt; é responsável por declarar todas as bibliotecas que serão necessárias para o projeto em questão, em suma todas soluções de terceiros, incluindo suas soluções genéricas que encontrem-se no &lt;a title=&#34;Ir ao Packagist, repositório do composer&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;repositório do composer&lt;/a&gt; serão gerenciadas conforme a especificação do arquivo &lt;em&gt;composer.json.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;O arquivo para este artigo deverá conter o seguinte conteúdo:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;require-dev&#34;: {
        &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que estamos registrando como uma dependência de nosso projeto o PHPUnit em sua versão 3.7 sempre solicitando a última atualização. Para que sempre seja utilizada a última versão do PHPUnit basta remover a sequência &amp;#8220;3.7.*&amp;#8221; por simplesmente &amp;#8220;*&amp;#8221;. O mesmo é possível com qualquer biblioteca gerenciada pelo composer.&lt;/p&gt;

&lt;p&gt;Agora já estão prontas as declarações de nossas dependências basta baixar o gerenciador de dependência &lt;a title=&#34;Baixar o composer&#34; href=&#34;http://getcomposer.org/download/&#34; target=&#34;_blank&#34;&gt;composer&lt;/a&gt; e rodar o comando&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;php composer.phar install.&lt;/pre&gt;

&lt;p&gt;Isto irá de maneira automática baixar todas as dependências que foram especificadas no arquivo composer.json, e neste exemplo trata-se apenas do PHPUnit no entanto o próprio PHP Unit requer algumas bibliotecas de terceiros então outras bibliotecas estarão disponíveis além do mesmo dentro da pasta &lt;em&gt;vendor&lt;/em&gt; que será criada.&lt;/p&gt;

&lt;div id=&#34;attachment_40041&#34; style=&#34;width: 407px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40041 &#34; alt=&#34;PHPUnit - Instalação a partir do composer&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/01-composer-install-397x310.png&#34; width=&#34;397&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/01-composer-install-397x310.png 397w, uploads/2013/12/01-composer-install-215x168.png 215w, uploads/2013/12/01-composer-install.png 881w&#34; sizes=&#34;(max-width: 397px) 100vw, 397px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Instalação a partir do composer
  &lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;attachment_40049&#34; style=&#34;width: 394px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40049 &#34; alt=&#34;PHPUnit - Estrutura de pastas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/02-estrutura-pastas-384x310.png&#34; width=&#34;384&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/02-estrutura-pastas-384x310.png 384w, uploads/2013/12/02-estrutura-pastas-208x168.png 208w, uploads/2013/12/02-estrutura-pastas.png 784w&#34; sizes=&#34;(max-width: 384px) 100vw, 384px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Estrutura de pastas
  &lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Existe uma convenção de padrões definidos pela &lt;a title=&#34;Ir à página do Framework Interop Group&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; chamada &lt;a title=&#34;Ver todas as PSRs&#34; href=&#34;https://github.com/php-fig/fig-standards/tree/master/accepted&#34; target=&#34;_blank&#34;&gt;PSR (Proposal Standards Recommendation)&lt;/a&gt;. Para facilitar será utilizada a definição do Autoloader para o exemplo que está descrito na PSR-0. Após a correta instalação via composer devem ser criadas os diretórios &lt;em&gt;src&lt;/em&gt; e dentro dele &lt;em&gt;Application&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Com a definição do Autoloader a nova estrutura do composer é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;autoload&#34;: {
        &#34;psr-0&#34;: {&#34;Application\\&#34;: &#34;src/&#34;}
    },
    &#34;require-dev&#34;: {
        &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;No arquivo composer.json agora é dito que o autoloader deve reconhecer o namespace &amp;#8220;Application&amp;#8221; que encontra-se dentro do diretorio &lt;em&gt;src&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div id=&#34;attachment_40044&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40044 &#34; alt=&#34;PHPUnit - Nova estrutura de pastas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/4-nova-estrutura-pastas-588x303.png&#34; width=&#34;588&#34; height=&#34;303&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Nova estrutura de pastas
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;iniciando-com-um-simples-teste&#34;&gt;Iniciando com um simples teste&lt;/h2&gt;

&lt;p&gt;Como o PHPUnit já está instalado corretamente no projeto agora vem a parte legal que é criar pequenos testes (unitários, obviamente) e colocar em prática o vermelho-verde-refatora já mencionado no meu post anterior &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar&#34; title=&#34;Ler mais sobre TDD&#34;&gt;TDD, por que usar?&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Primeiramente deve ser criada a pasta &lt;em&gt;tests&lt;/em&gt; que servirá para acomodar todos os casos de teste a serem executados.&lt;/p&gt;

&lt;p&gt;Começando com um teste simples, e na verdade este artigo somente mostrará o uso simplificado pois a finalidade do mesmo é apenas mostrar o caminho das pedras, como começar, instalar, configurar e rodar os primeiros testes. A partir daí cabe à necessidade de cada desenvolvedor.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Aqui será criado um arquivo PHPNativeElements onde serão testados algumas funções nativas do PHP e seus comportamentos. Obviamente que este caso de teste calha somente em modo didático pois tais testes e classe testada terá muito mais de uma única responsabilidade, é somente em caráter demonstrativo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Criado o arquivo _PHPNativeElementsTest.php_ dentro do diretório tests, siga o exemplo abaixo.&lt;/p&gt;

&lt;div id=&#34;attachment_40045&#34; style=&#34;width: 383px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40045  &#34; alt=&#34;PHPUnit - Estrutura inicial do primeiro teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/5-estrutura-primeiro-teste-373x310.png&#34; width=&#34;373&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/5-estrutura-primeiro-teste-373x310.png 373w, uploads/2013/12/5-estrutura-primeiro-teste-202x168.png 202w, uploads/2013/12/5-estrutura-primeiro-teste.png 738w&#34; sizes=&#34;(max-width: 373px) 100vw, 373px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Estrutura inicial do primeiro teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt; Para que seja reconhecido como um teste o arquivo deve conter a sufixo Test.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;executando-de-forma-simples&#34;&gt;Executando de forma simples&lt;/h2&gt;

&lt;p&gt;Como o PHPUnit foi instalado a partir do composer, é a partir da estrutura montada pelo mesmo que este será executado digitando no terminal&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;./vendor/bin/phpunit&lt;/pre&gt;

&lt;p&gt;Com isto uma tela de ajuda deve aparecer com todas as opções disponíveis para a utilização do PHPUnit. Seguem as definições do comando que será executado neste primeiro momento.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #000080&#34;&gt;./vendor/bin/phpunit&lt;/span&gt; &lt;span style=&#34;color: #333333&#34;&gt;&amp;#8211;colors&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;#8211;debug&lt;/span&gt; &lt;span style=&#34;color: #800000&#34;&gt;tests/PHPNativeElements &lt;/span&gt;onde:&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #000080&#34;&gt;./vendor/bin/phpunit&lt;/span&gt;: o próprio executável do PHPUnit&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #333333&#34;&gt;&amp;#8211;colors&lt;/span&gt;: habilita coloração ( assim podemos ver os estágios vermelho-verde de forma mais simples)&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #008000&#34;&gt;&amp;#8211;debug&lt;/span&gt;: habilita o modo debug para detalhamento das ações que estão sendo tomadas durante os testes – Esta ação serve como ótima documentação como já mencionado em meu artigo anterior.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #800000&#34;&gt;tests/PHPNativeElements&lt;/span&gt;: o nome da classe de testes a ser testada.&lt;/p&gt;

&lt;p&gt;Ao rodarmos o comando acima a mensagem resultante deverá ser a de que não há testes disponíveis na classe testada.&lt;/p&gt;

&lt;div id=&#34;attachment_40050&#34; style=&#34;width: 484px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40050  &#34; alt=&#34;PHPUnit - Falta de testes&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/6-falta-de-testes-474x310.png&#34; width=&#34;474&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/6-falta-de-testes-474x310.png 474w, uploads/2013/12/6-falta-de-testes-256x168.png 256w, uploads/2013/12/6-falta-de-testes.png 881w&#34; sizes=&#34;(max-width: 474px) 100vw, 474px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Informação de que ainda não há testes
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;fazendo-o-primeiro-teste-passar&#34;&gt;Fazendo o primeiro teste passar&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;O TDD define que o desenvolvimento deve ser orientado a testes, com isso, criaremos primeiramente a expectativa na nossa classe de testes e em seguida a implementação no código de produção.&lt;/p&gt;

&lt;p&gt;Após o método &lt;em&gt;tearDown&lt;/em&gt; que já encontra-se na classe &lt;em&gt;PHPNativeElementsTest&lt;/em&gt; crie um método chamado &lt;em&gt;testOperacaoMatematica&lt;/em&gt;. Assim como a classe de teste possui uma convenção com os métodos também é necessário especificar qual trata-se de um teste a partir do prefixo &lt;em&gt;test.&lt;/em&gt; Por este motivo nosso primeiro caso de teste se chamar testOperacaoMatematica. Caso não contenha o prefixo test e, não sendo os métodos setUp e tearDown, o PHPUnit simplesmente não executa o método.&lt;/p&gt;

&lt;p&gt;Como estamos utilizando o Autoloader, em nossa classe de teste usaremos o namespace &amp;#8220;_Application_&lt;em&gt;NativeElements\Math&amp;#8221;&lt;/em&gt; para carregar a nossa classe que será testada a partir da classe de testes. Como atributo de nossa classe de teste adicionaremos &amp;#8220;$math&amp;#8221; e nele instanciaremos a classe _Application_&lt;em&gt;NativeElements\Math&lt;/em&gt; dentro do método &lt;em&gt;setUp&lt;/em&gt;.&lt;/p&gt;

&lt;div id=&#34;attachment_40052&#34; style=&#34;width: 434px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40052 &#34; alt=&#34;PHPUnit - Nova estrutura da classe de teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/7-nova-estrutura-classe-de-testes1-424x310.png&#34; width=&#34;424&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/7-nova-estrutura-classe-de-testes1-424x310.png 424w, uploads/2013/12/7-nova-estrutura-classe-de-testes1-230x168.png 230w, uploads/2013/12/7-nova-estrutura-classe-de-testes1.png 804w&#34; sizes=&#34;(max-width: 424px) 100vw, 424px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Nova estrutura da classe de teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Ao rodarmos novamente o PHPUnit o teste simplesmente quebra. Isto porque a classe&lt;/p&gt;

&lt;p&gt;_Application_&lt;em&gt;NativeElements\Math&lt;/em&gt; ainda não existe. Este é o próximo passo, o código que fará o testes passar.&lt;/p&gt;

&lt;div id=&#34;attachment_40053&#34; style=&#34;width: 498px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40053 &#34; alt=&#34;PHPUnit - Quebra do teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/8-quebra-do-teste-488x310.png&#34; width=&#34;488&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/8-quebra-do-teste-488x310.png 488w, uploads/2013/12/8-quebra-do-teste-264x168.png 264w, uploads/2013/12/8-quebra-do-teste.png 875w&#34; sizes=&#34;(max-width: 488px) 100vw, 488px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Quebra do teste por não existir a classe testada
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Criamos o arquivo&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Math.php&lt;/em&gt; dentro do diretório &lt;em&gt;Application/NativeElements&lt;/em&gt; e no mesmo a classe &lt;em&gt;Math&lt;/em&gt; definindo como namespace &lt;em&gt;Application\NativeElements&lt;/em&gt;. Por hora nenhum método é criado nesta nova classe.&lt;/p&gt;

&lt;div id=&#34;attachment_40056&#34; style=&#34;width: 514px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40056 &#34; alt=&#34;PHPUnit - Classe de produção, nela os problemas criados nos testes serão solucionados&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/9-class-504x310.png&#34; width=&#34;504&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/9-class-504x310.png 504w, uploads/2013/12/9-class-273x168.png 273w, uploads/2013/12/9-class.png 955w&#34; sizes=&#34;(max-width: 504px) 100vw, 504px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Classe de produção, nela os problemas criados nos testes serão solucionados
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Rodando nosso teste novamente ele quebra mais uma vez. Agora o que está faltando é o método testado (&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sum&lt;/em&gt; ).&lt;/p&gt;

&lt;div id=&#34;attachment_40057&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40057 &#34; alt=&#34;PHPUnit - Faltando método sum&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/10-method-missing-588x289.png&#34; width=&#34;588&#34; height=&#34;289&#34; srcset=&#34;uploads/2013/12/10-method-missing-588x289.png 588w, uploads/2013/12/10-method-missing-329x162.png 329w, uploads/2013/12/10-method-missing-628x310.png 628w, uploads/2013/12/10-method-missing.png 880w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Faltando método sum
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Ao criar o método sum e sua lógica estando correta o teste atual passará, então passamos do estágio vermelho para o estágio verde. Como este exemplo é uma simples operação matemática muito provavelmente não será necessária uma refatoração. No entanto sendo um lógica mais complexa o ideal é que sempre comece testando pequenos passos, que são chamados de baby steps ou passos de bebê. Ao se deparar com uma situação complexa em que o resultado depende de N variáveis, trata-se sempre o meio mais simples e os testes passando passa-se a procurar solucionar uma nova condição para o resultado.&lt;/p&gt;

&lt;div id=&#34;attachment_40058&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40058 &#34; alt=&#34;PHPUnit - Método com a lógica necessária e primeiro teste passando&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/11-pass-588x262.png&#34; width=&#34;588&#34; height=&#34;262&#34; srcset=&#34;uploads/2013/12/11-pass-588x262.png 588w, uploads/2013/12/11-pass-329x146.png 329w, uploads/2013/12/11-pass-660x294.png 660w, uploads/2013/12/11-pass.png 1364w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Método com a lógica necessária e primeiro teste passando
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Agora basta adicionar os asserts para as demais operações matemáticas.&lt;/p&gt;

&lt;div id=&#34;attachment_40059&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40059 &#34; alt=&#34;PHPUnit - Outros métodos de operações matemáticas simples&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/12-other-methods-588x272.png&#34; width=&#34;588&#34; height=&#34;272&#34; srcset=&#34;uploads/2013/12/12-other-methods-588x272.png 588w, uploads/2013/12/12-other-methods-329x152.png 329w, uploads/2013/12/12-other-methods-660x305.png 660w, uploads/2013/12/12-other-methods.png 1358w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Outros métodos de operações matemáticas simples
  &lt;/p&gt;
&lt;/div&gt;

&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;

&lt;blockquote&gt;
&lt;p&gt;Como pode ser percebido, como terceiro parâmetro do assert foi adicionada uma mensagem opcional, isso para que ao dar erro da asserção tal mensagem seja exibida, conforme a imagem seguinte.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div id=&#34;attachment_40060&#34; style=&#34;width: 507px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40060 &#34; alt=&#34;PHPUnit - Mensagem de erro de asserção&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/13-message-497x310.png&#34; width=&#34;497&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/13-message-497x310.png 497w, uploads/2013/12/13-message-269x168.png 269w, uploads/2013/12/13-message.png 809w&#34; sizes=&#34;(max-width: 497px) 100vw, 497px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Mensagem de erro de asserção
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;refatorando&#34;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Agora voltando ao código originado na classe&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Math&lt;/em&gt;, dá pra perceber que há muita repetição pois todos os métodos recebem dois valores e retornam uma operação correspondente. Como utilizando TDD temos segurança em desenvolver, podemos tranquilamente remover tais repetições criando uma interface onde é previamente definida a operação a ser realizada e retorna o resultado desta operação. Obviamente com esta atitude o teste também sofrerá alterações e isso é algo comum pois uma aplicação está sempre evoluindo.&lt;/p&gt;

&lt;p&gt;Frenta à necessidade de refatoração novamente começamos a partir do teste e ele fica como na imagem a seguir:&lt;/p&gt;

&lt;div id=&#34;attachment_40061&#34; style=&#34;width: 498px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40061 &#34; alt=&#34;PHPUnit - Alterações na classe de teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/14-test-refactor-488x310.png&#34; width=&#34;488&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/14-test-refactor-488x310.png 488w, uploads/2013/12/14-test-refactor-264x168.png 264w, uploads/2013/12/14-test-refactor.png 899w&#34; sizes=&#34;(max-width: 488px) 100vw, 488px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Alterações na classe de teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Com a refatoração nossa classe Math é modificada e criada uma interface:&lt;/p&gt;

&lt;div id=&#34;attachment_40063&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40063 &#34; alt=&#34;PHPUnit - refatoração da classe Math&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/15-refactor-588x284.png&#34; width=&#34;588&#34; height=&#34;284&#34; srcset=&#34;uploads/2013/12/15-refactor-588x284.png 588w, uploads/2013/12/15-refactor-329x159.png 329w, uploads/2013/12/15-refactor-640x310.png 640w, uploads/2013/12/15-refactor.png 1354w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Refatoração da classe Math
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;E agora rodando novamente o teste após a refatoração, simplesmente continuamos com tudo verde, ou seja, alteramos muito a forma de implementação de uma classe e ela continua executando seu papel como deve.&lt;/p&gt;

&lt;div id=&#34;attachment_40064&#34; style=&#34;width: 587px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40064 &#34; alt=&#34;PHPUnit - Teste passando após refatoração&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/16-refactor-pass-577x310.png&#34; width=&#34;577&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/16-refactor-pass-577x310.png 577w, uploads/2013/12/16-refactor-pass-313x168.png 313w, uploads/2013/12/16-refactor-pass.png 818w&#34; sizes=&#34;(max-width: 577px) 100vw, 577px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Teste passando após refatoração
  &lt;/p&gt;
&lt;/div&gt;

&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;

&lt;blockquote&gt;
&lt;p&gt;Este é apenas um exemplo didático de refatoração, mas mesmo com ele dá pra perceber como houve a anulação de código repetido e para um futura manutenção basta que mexa-se em um local somente para que surta efeitos à todas as operações matemáticas.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Neste artigo foi abordado apenas a instalação do PHPUnit e a execução de um teste muito simples. Para testes mais avançados serão criados novos artigos sempre em sequência para que o estudo de desenvolvimento orientado a testes siga um fluxo sadio. Já fora criado um artigo explicando os por ques de se utilizar e não se utilizar TDD que encontra-se neste&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar&#34; title=&#34;Ler mais sobre TDD&#34;&gt;link&lt;/a&gt; e é o primeiro artigo da sequência.&lt;/p&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Os próximos artigos seguirão a sequência abaixo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configurações avançadas – Apenas uma breve abordagem de como realizar configurações avançadas na execução do PHPUnit gerando reports como coverage.&lt;/li&gt;
&lt;li&gt;Persistência – Será utilizado o ORM Doctrine para complementarmos o projeto&lt;/li&gt;
&lt;li&gt;Mockery – Utilizando objetos simulados para atender certos comportamentos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Você pode baixar o código-fonte dos exemplos apresentados aqui no &lt;a title=&#34;Ir para o repositório de exemplos desenvolvidos neste artigo&#34; href=&#34;https://github.com/andrebian/phpunit-como-iniciar-sem-dores&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução ao Selenium 2</title>
      <link>https://tableless.github.io/hugo-public/introducao-ao-selenium-2/</link>
      <pubDate>Wed, 18 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-ao-selenium-2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://www.seleniumhq.org/docs/01_introducing_selenium.jsp&#34; title=&#34;introdução ao selenium no site oficial&#34;&gt;Selenium&lt;/a&gt; é uma ferramenta de apoio às necessidades de testes em aplicações web. Altamente flexível, permite muitas opções para a localização de elementos de interface no navegador e simular comportamentos reais de um usuário. A &lt;a href=&#34;http://www.seleniumhq.org/docs/03_webdriver.jsp&#34; title=&#34;introdução ao selenium webdriver no site oficial&#34;&gt;versão 2.0&lt;/a&gt; tem como funcionalidade primária a integração da API WebDriver. Projetado para fornecer uma interface ainda mais simples, concisa e orientada a objeto, o que melhora de forma significativa o suporte aos problemas complexos que são enfrentados ao testar uma aplicação web.&lt;/p&gt;

&lt;p&gt;Essa API pode ser chamada através de diversas linguagem de programação, porém, em nosso exemplo, iremos utilizar o NodeJS (JavaScript), que pode ser baixado no &lt;a href=&#34;http://nodejs.org/download/&#34; title=&#34;site oficial do NodeJS&#34;&gt;site oficial&lt;/a&gt; e que possui um gerenciador de pacotes (Node Package Manager – NPM), o qual permite a interação com um repositório online via linha de comando, facilitando a instalação de várias outras ferramentas.&lt;/p&gt;

&lt;p&gt;Nesse exemplo, será utilizado uma ferramenta chamada &lt;a href=&#34;http://vowsjs.org/&#34; title=&#34;site oficial do vows&#34;&gt;Vows&lt;/a&gt;, gerenciada e instalada pelo NPM, que ajuda no desenvolvimento orientado a comportamento assíncrono. Usar testes assíncronos no NodeJS tem dois motivos. Primeiro (e talvez óbvio), é que o NodeJS é assíncrono e por isso os testes também deveriam ser. Segundo, é fazer com que os testes, os quais lidam com entrada e saída de dados, rodem mais rápido.&lt;/p&gt;

&lt;p&gt;Breve resumo dos conceitos do Vows. &lt;strong&gt;Suite&lt;/strong&gt;: um objeto que contêm um ou mais batches, e pode ser executado ou exportado. &lt;strong&gt;Batch&lt;/strong&gt;: uma estrutura de contextos. &lt;strong&gt;Context&lt;/strong&gt;: um objeto que pode conter um &lt;em&gt;topic&lt;/em&gt;(opcional), nenhum ou mais &lt;em&gt;vows&lt;/em&gt;, nenhum ou mais &lt;em&gt;sub-contexts&lt;/em&gt;. &lt;strong&gt;Topic&lt;/strong&gt;: pode ser tanto um valor ou uma função de código assíncrono. &lt;strong&gt;Vow&lt;/strong&gt;: é uma função que recebe o _topic_ como um argumento e roda assertivas no &lt;em&gt;topic&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O teste que será feito possui quatro passos: _(i)&lt;em&gt; abrir o navegador, &lt;/em&gt;(ii)&lt;em&gt; acessar uma &lt;a href=&#34;https://saucelabs.com/test/guinea-pig&#34; title=&#34;página oficial de teste do SauceLabs&#34;&gt;página de teste&lt;/a&gt;, &lt;/em&gt;(iii)&lt;em&gt; verificar o título da página e &lt;/em&gt;(iv)_ fechar o navegador. Algo bem simples. Suficiente para experimentar a versão 2.0 do Selenium.&lt;/p&gt;

&lt;p&gt;As dependências necessárias podem ser instaladas usando o NPM, digitando o seguinte _script_ no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;npm install -g phantomjs vows &lt;/pre&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt; npm install chai wd vows &lt;/pre&gt;

&lt;p&gt;Há duas maneiras de instalar &lt;a href=&#34;http://blog.nodejs.org/2011/03/23/npm-1-0-global-vs-local-installation/&#34; title=&#34;artigo do blog oficial do NodeJS sobre os tipos de dependências&#34;&gt;dependências no NodeJS&lt;/a&gt;: globalmente ou localmente. Quando uma dependência é global, os arquivos são executáveis, tornando possível a utilização de uma dependência através da linha de comando. Quanto às dependências locais, estas são instaladas no diretório corrente, dentro de um diretório chamado _node&lt;em&gt;modules&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O primeiro &lt;em&gt;script&lt;/em&gt;, utilizando o parâmetro &lt;strong&gt;-g&lt;/strong&gt;, instala duas dependências globais: phantomjs e vows.&lt;a href=&#34;http://phantomjs.org/&#34; title=&#34;site oficial do PhantomJS&#34;&gt;PhantomsJS é um headless WebKit&lt;/a&gt;, feito totalmente em javascript e possui suporte rápido e nativo para vários padrões web como manipulação de DOM, seletores CSS, JSON, Canvas e SVG.&lt;/p&gt;

&lt;p&gt;Já o segundo &lt;em&gt;script&lt;/em&gt;, instala três dependências locais: chai, wd e vows. &lt;a href=&#34;http://chaijs.com/&#34; title=&#34;site oficial do Chai&#34;&gt;Chai&lt;/a&gt; é uma biblioteca de assertivas BDD/TDD para NodeJS e navegadores, a qual pode ser &amp;#8216;graciosamente&amp;#8217; utilizada com qualquer framework de teste JS. &lt;a href=&#34;https://github.com/admc/wd&#34; title=&#34;repositorio oficial do WebDriver no github&#34;&gt;WD&lt;/a&gt; é um cliente em NodeJS para facilitar o acesso à API do Selenium 2, a qual suporta métodos como: fazer requisições GET e POST, clicar no botão VOLTAR do navegador, fazer refresh no navegador, pegar um printscreen da tela corrente, redimensionar e mover a janela do navegador, submeter formulário, digitar texto, usar cookies, selecionar um elemento DOM, clicar e mover um elemento DOM selecionado, etc.&lt;/p&gt;

&lt;p&gt;Após a instalação de todas as dependências necessárias, vamos criar dois arquivos: _&lt;strong&gt;configuracao-webdriver-usando-phantom.js&lt;/strong&gt;&lt;em&gt; com as informações de configurações do webdriver e &lt;/em&gt;&lt;strong&gt;apenas-um-exemplo.js&lt;/strong&gt;_ com os passos-a-passos simulando o comportamento real de um usuário.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;configuracao-webdriver-usando-phantom.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;var exports   = module.exports = {},
    webdriver = require(&#39;wd&#39;),
    browser   = exports.browser = webdriver.remote({
      hostname: &#34;localhost&#34;,
      port: 8910
    });
 
/**
Vows Errored » callback not fired
http://birkett.no/blog/2013/05/01/vows-errored-callback-not-fired/
*/
process.on( &#39;uncaughtException&#39;, function(err) {
  console.error(&#39;Caught exception: &#39; + err.stack );
});
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;apenas-um-exemplo.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;var vows    = require(&#39;vows&#39;),
    expect  = require(&#39;chai&#39;).expect,
    browser = require(&#39;./configuracao-webdriver-usando-phantom.js&#39;).browser;
 
vows.describe(&#39;Apenas um exemplo&#39;)
.addBatch({
  &#39;Criando uma nova sessão no WebDriver&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.init( {}, function(err, sessionID, capabilities) {
        callback( err );
      });
    },
    &#39;Sessão criada&#39;: function() { /**...*/ }
  }
})
.addBatch({
  &#39;Acessando a página de teste do SauceLabs&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.get( &#39;http://saucelabs.com/test/guinea-pig&#39;, function(err) {
        callback( err );
      });
    },
    &#39;Página de teste aberta&#39;: function() { /**...*/ }
  }
})
.addBatch({
  &#39;Verificando o título da página&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.title( function(err, title) {
        callback( err, title );
      });
    },
    &#34;O título da página deve conter &#39;Sauce Labs&#39;&#34;: function(title) {
      expect(title).to.contain(&#39;Sauce Labs&#39;);
    },
    &#34;O título da página deve conter &#39;page title&#39;&#34;: function(title) {
      expect(title).to.contain(&#39;page title&#39;);
    },
    &#34;O título da página deve conter &#39;I am a&#39;&#34;: function(title) {
      expect(title).to.contain(&#39;I am a&#39;);
    }
  }
})
.addBatch({
  &#39;Fechando o navegador&#39;: {
    topic: function() {
      var callback = this.callback;
      browser.quit( function(err){
        callback( err );
      });
    },
    &#39;Fim&#39;: function() { /**...*/ }
  }
}).export(module);
&lt;/pre&gt;

&lt;p&gt;Criado esses dois arquivos, é preciso, em um outro terminal, rodar o PhantomJS em modo WebDriver, digitando o seguinte comando:&lt;/p&gt;

&lt;pre class=&#34;lanh-ssh&#34;&gt;phantomjs --webdriver=localhost:8910 &lt;/pre&gt;

&lt;p&gt;Uma vez o PhantomJS rodando em segundo plano, basta rodar o &lt;em&gt;vows&lt;/em&gt;, o parâmetro &lt;strong&gt;&amp;#8211;spec&lt;/strong&gt; serve apenas para ter um diferente tipo de &amp;#8216;reporter&amp;#8217;, segue o comando e uma ilustração do resultado obtido:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;vows apenas-um-exemplo.js --spec &lt;/pre&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; alt=&#34;Resultado obtido&#34; src=&#34;https://camo.githubusercontent.com/67da73c5f31ecbfaee938cf04056d96c4f2ada41/687474703a2f2f69313336382e70686f746f6275636b65742e636f6d2f616c62756d732f61673138322f69676f727269626569726f6c696d612f315f626173685f616e645f556d615f696e74726f647563636564696c6174696c64656f5f616f5f53656c656e69756d5f325f616e645f6170656e61732d756d2d6578656d706c6f6a735f6d646173685f696e74726f647563616f2d73656c656e69756d2d74776f2d31335f7a707334333166383131372e706e67&#34; width=&#34;897&#34; height=&#34;445&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Esse exemplo contempla de forma bem simples a utilização da API do WebDriver/Selenium 2. Essa abordagem também pode ser feita em &lt;a href=&#34;http://tableless.com.br/introducao-de-como-executar-testes-unitarios-em-diferentes-tipos-de-navegadores&#34; title=&#34;introdução de como executar testes unitários em diferentes tipos de navegadores&#34;&gt;diferentes tipos de navegadores&lt;/a&gt;. Como é sempre melhor começarmos aos poucos, aplicando pequenos passos de cada vez, isso ficará para uma próxima discussão. Para quem se interessar, todo código está disponível em um &lt;a href=&#34;https://gist.github.com/igorlima/7826752&#34; title=&#34;gist introduzindo o Selenium 2&#34;&gt;gist&lt;/a&gt;. Muito obrigado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TDD, por que usar?</title>
      <link>https://tableless.github.io/hugo-public/tdd-por-que-usar/</link>
      <pubDate>Tue, 17 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/tdd-por-que-usar/</guid>
      <description>

&lt;p&gt;TDD é o desenvolvimento de software orientado a testes, ou em inglês, &lt;a title=&#34;Test Driven Development&#34; href=&#34;http://pt.wikipedia.org/wiki/Test_Driven_Development&#34; target=&#34;_blank&#34;&gt;Test Driven Development&lt;/a&gt;. Mas mais do que simplesmente testar seu código, TDD é uma filosofia, uma cultura. Neste artigo você conhecerá um pouco sobre sua motivação e também saberá os fatores que contribuem e dificultam sua prática.&lt;/p&gt;

&lt;h2 id=&#34;por-que-muitos-não-praticam&#34;&gt;Por que muitos não praticam?&lt;/h2&gt;

&lt;p&gt;Muitos fatores contribuem para que inúmeros programadores deixem de utilizar TDD logo no início. Alguns deles são:&lt;/p&gt;

&lt;h3 id=&#34;dificuldade-em-começar&#34;&gt;Dificuldade em começar&lt;/h3&gt;

&lt;p&gt;Apesar de uma extensa e clara documentação, iniciar o desenvolvimento orientado a testes pode ser um trabalho árduo para muitos pelo simples fato de que geralmente muitos iniciantes tentam praticá-lo em código já existente. Este definitivamente não é o caminho. A principal característica do desenvolvimento orientado a testes é que ele seja orientado a testes. Em outras palavras o código que realizará sua lógica deve ser criado somente após a criação do teste e isso torna-se algo de difícil aceitação pois ainda não se tem nada e já se faz necessário testar.&lt;/p&gt;

&lt;h3 id=&#34;curva-de-apendizado&#34;&gt;Curva de apendizado&lt;/h3&gt;

&lt;p&gt;Complementando o item anterior, este é outro motivo que faz programadores desistirem do desenvolvimento orientado a testes. Como qualquer nova tecnologia, para a pratica de TDD leva-se um bom tempo dependendo disponibilidade e principalmente da vontade do programador.&lt;/p&gt;

&lt;p&gt;Tempo&lt;/p&gt;

&lt;p&gt;Engana-se quem pensa que produzirá mais código pelo simples fato de utilizar TDD. O TDD na verdade chega a desacelerar a produção de código. Quando falo em produção de código, me refiro à quantidade de linhas escritas. Mas nisso tudo há vantagens e elas serão descritas mais a frente.&lt;/p&gt;

&lt;h3 id=&#34;cultura&#34;&gt;Cultura&lt;/h3&gt;

&lt;p&gt;Muito fala-se de TDD no Brasil, mas ao questionarmos programadores de diversas empresas muitos apresentam os motivos citados acima para não utilizá-lo. Existem sim muitas empresas e programadores que levam a prática a sério e a evangelizam justamente por conhecerem as vantagens que o TDD nos traz.&lt;/p&gt;

&lt;h2 id=&#34;nem-tudo-é-tão-ruim&#34;&gt;Nem tudo é tão ruim&lt;/h2&gt;

&lt;p&gt;Vistos alguns pontos que dificultam programadores a aderirem ao TDD, listamos agora alguns benefícios que esta prática nos fornece.&lt;/p&gt;

&lt;h3 id=&#34;qualidade-do-código&#34;&gt;Qualidade do código&lt;/h3&gt;

&lt;p&gt;Um dos principais ensinamentos, senão o principal, do TDD é que se algo não é possível de ser testado então foi desenvolvido de forma errada. Parece um pouco drástico mas não é. Em pouco tempo utilizando testes o programador percebe mudanças relevantes em sua forma de programar. Em suma o uso de TDD ajuda o programador a elaborar um código com cada vez mais qualidade criando objetos concisos e com menos dependências.&lt;/p&gt;

&lt;h3 id=&#34;raciocínio&#34;&gt;Raciocínio&lt;/h3&gt;

&lt;p&gt;Para que o código torne-se mais conciso, tenha menos acoplamentos e dependências o programador deve forçar seu raciocínio a níveis elevados. É muito difícil criar algo que realmente tenha um bom design. Utilizando TDD o programador praticamente obriga-se a olhar seu código de outra forma normalmente jamais vista antes. Aí é que está a parte legal da coisa toda.&lt;/p&gt;

&lt;h3 id=&#34;segurança&#34;&gt;Segurança&lt;/h3&gt;

&lt;p&gt;Ponto importantíssimo para qualquer software nos dias de hoje. Mas não se engane, não estou falando de segurança da informação e sim de segurança ao desenvolver. Pense em uma situação em que o programador tenha um código que desenvolvera ha cerca de um ano. Como normalmente vivemos em um mundo com inúmeros softwares desenvolvidos ao longo de cada ano, torna-se muito difícil lembrar de tudo a respeito de um que merece nossa atenção em determinado momento. Normalmente deve-se realizar um trabalho bastante cauteloso para nova implementação em um software que encontra-se em produção. Toda e qualquer alteração deve ser minunciosamente testada e garantida que não afetará demais módulos do software. Fazer isto manualmente é realmente complicado pois até então não sabe-se (ou lembra-se) ao certo quem afeta quem no sistema. Com a prática de TDD cada pequeno passo do software está devidamente testado. Ou seja, com este cenário o programador pode realizar qualquer alteração sem medo e sem culpa.&lt;/p&gt;

&lt;p&gt;Como cada pequeno passo tomado pelo sistema está testado ao qualquer módulo ou funcionalidade sofrer alteração, com poucos segundos descobre-se se houveram quebras e o melhor de tudo, onde foram essas quebras. Com isso em mãos a correção das quebras torna-se uma tarefa simples sem frustrar o cliente e o usuário.&lt;/p&gt;

&lt;h3 id=&#34;trabalho-em-equipe&#34;&gt;Trabalho em equipe&lt;/h3&gt;

&lt;p&gt;Por prover mais segurança o trabalho em equipe torna-se muito mais proveitoso eliminando discussões e dúvidas desnecessárias. Ao entrar no desenvolvimento do projeto o novo desenvolvedor tem apenas o trabalho de entender qual task deve ser realizada e ler os testes das features já desenvolvidas. Ao rodar os testes pela primeira vez o programador descobre se está no caminho de ter um entregável mais rapidamente e com segurança. Existem empresas em que um novo programador tem entregáveis logo no primeiro dia de trabalho. Sem testes normalmente haveria um período de adaptação para prévio entendimento do que há no sistema no momento de seu ingresso ao time de desenvolvimento.&lt;/p&gt;

&lt;h3 id=&#34;documentação&#34;&gt;Documentação&lt;/h3&gt;

&lt;p&gt;Ao criar testes descritivos estes servem como uma excelente documentação para o software. Quando qualquer programador for rodar os testes, basta habilitar o modo verbose que uma “história” é contada eliminando o árduo trabalho de documentar um software onde nos meios tradicionais tende a defasar-se. O problema é que a documentação tradicional raramente segue o mesmo ritmo do desenvolvimento. Com os testes unitários a “documentação” é gerada antes mesmo da nova feature ser implementada e permanece fiel a qualquer alteração.&lt;/p&gt;

&lt;h2 id=&#34;o-que-resume-se-disto-tudo&#34;&gt;O que resume-se disto tudo?&lt;/h2&gt;

&lt;p&gt;Até aqui temos os pontos negativos e positivos do desenvolvimento orientado a testes. Agora vamos aprender um pouco sobre o que é TDD.&lt;/p&gt;

&lt;p&gt;O TDD (Test Driven Development) baseia-se em três passos, vermelho-verde-refatora. O vermelho é a escrita do primeiro teste antes mesmo da lógica existir. O verde é o ponto em que a lógica para que o teste previamente criado passe. Esta lógica deve ser desenvolvida da forma mais simples possível eliminando complexidades desnecessárias fazendo com que a evolução do código ocorra de forma segura. O refatora é a melhoria do código. Neste ponto são removidas duplicações, múltiplas responsabilidades e o código fica cada vez mais próximo de sua versão final.&lt;/p&gt;

&lt;p&gt;Para que o processo vermelho-verde-refatora seja de fato implementado, utiliza-se baby steps ou passos de bebê. Esta técnica consiste em realizar um pequeno passo de cada vez, se uma lógica é complexa de ser desenvolvida ela é dividida em muitas pequenas partes que evoluem até sua solução final. Obviamente que esta técnica é aplicável preferencialmente em processos complexos que dependem de muitas variáveis. Para processos simples nem sempre é a mais indicada.&lt;/p&gt;

&lt;p&gt;Os testes devem ser unitários. Isto implica em um teste automatizado certificar-se de apenas uma funcionalidade do código utilizando para isso quantos asserts forem necessários. Por serem testes automatizados são fácil e rapidamente executados eliminando testes manuais que encarecem o software em vários aspectos. Devido à dinâmica de tais testes é possível vincular o software com ferramentas de integração contínua como Jenkins reduzindo ainda mais o custo (tempo de desenvolvimento) do mesmo.&lt;/p&gt;

&lt;p&gt;Concluindo&lt;/p&gt;

&lt;p&gt;Como ficou claro a prática do desenvolvimento orientado a testes pode ser penosa para quem está começando mas muito satisfatória para quem já a tem como parte de seu dia a dia. Ao utilizar TDD o programador “perde” em linhas de código por hora mas ganha horas, dias, quem sabe até semanas na prevenção de novos erros e correção dos que ocorrem durante a implementação de uma nova feature. Detalhe que o método TDD parte do princípio que o teste sempre deve ser implementado antes do código de produção.&lt;/p&gt;

&lt;p&gt;Em suma tudo vai depender to porte do projeto em que se está trabalhando, da cultura da empresa e da vontade de programadores mas sabe-se que quem utiliza TDD reconhece suas vantagens.&lt;/p&gt;

&lt;p&gt;Agora que você já tem uma noção do que é TDD, suas vantagens e desvantagens, sugiro a ler sobre &lt;a title=&#34;xUnit - Framework de testes unitários&#34; href=&#34;http://www.martinfowler.com/bliki/Xunit.html&#34; target=&#34;_blank&#34;&gt;xUnit&lt;/a&gt;. O xUnit é um framework de testes disponível para várias linguagens de programação. Em PHP temos o &lt;a title=&#34;PHPUnit - Framework de testes unitários para PHP&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/automating-tests.html&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt;, em java o &lt;a title=&#34;jUnit - Framework de testes unitários para Java&#34; href=&#34;http://junit.org/&#34; target=&#34;_blank&#34;&gt;jUnit&lt;/a&gt; e demais linguagens possuem seus frameworks que tem a mesma finalidade, criar um ecossistema para que o programador desenvolva orientando-se a testes.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introdução de como executar testes unitários em diferentes tipos de navegadores</title>
      <link>https://tableless.github.io/hugo-public/introducao-de-como-executar-testes-unitarios-em-diferentes-tipos-de-navegadores/</link>
      <pubDate>Wed, 04 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/introducao-de-como-executar-testes-unitarios-em-diferentes-tipos-de-navegadores/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://saucelabs.com/&#34; title=&#34;SauceLabs&#34;&gt;SauceLabs&lt;/a&gt; é uma plataforma de teste que possibilita realizar testes automáticos ou manuais em aplicações móveis e web (incluindo navegadores como Internet Explorer, Opera, Safari, Android, iPhone, Chrome etc). Essa plataforma permite executar os testes em diversas linguagem de programação, porém, em nosso exemplo, iremos utilizar o NodeJS (JavaScript).&lt;/p&gt;

&lt;p&gt;O NodeJS e o Gerenciador de Pacotes do Node (traduzido do inglês Node Package Manager &amp;#8211; NPM) podem ser baixados no &lt;a href=&#34;http://nodejs.org/download/&#34; title=&#34;site oficial NodeJS&#34;&gt;site oficial&lt;/a&gt;. Esse gerenciador de pacotes permite a interação com um repositório online via linha de comando, facilitando a instalação de várias ferramentas.&lt;/p&gt;

&lt;p&gt;Nesse exemplo, será utilizado uma ferramenta chamada &lt;a href=&#34;https://github.com/airportyh/testem&#34; title=&#34;documentação do Test&#39;em&#34;&gt;Test&amp;#8217;em&lt;/a&gt;, que é gerenciada e instalada pelo NPM. Essa ferramenta permite rodar os testes unitários de JavaScript localmente em diferentes plataformas, tornando a execução mais fácil e divertida. Test&amp;#8217;em suporta vários frameworks de teste, tais como: Jasmine, QUnit e Mocha. Para instalar, basta digitar no terminal:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;npm install testem -g&lt;/pre&gt;

&lt;p&gt;No exemplo, será utilizado o framework Jasmine. Mesmo código do &lt;a href=&#34;https://saucelabs.com/docs/javascript-unit-testing-tutorial&#34; title=&#34;tutorial oficial do SauceLabs&#34;&gt;tutorial oficial do SauceLabs&lt;/a&gt;. As especificações do código estão descritas no arquivo PastaSpec.js e a implementação no arquivo Pasta.js. Ambos arquivos encontra-se abaixo:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PastaSpec.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;describe(&#34;Pasta&#34;, function() { 
  it(&#34;should make spaghetti bolognese&#34;, function() { 
    var pasta = new Pasta(); 
    pasta.add(&#34;tomatoes&#34;); 
    pasta.add(&#34;garlic&#34;); 
    pasta.add(&#34;olive&#34;); 
    pasta.add(&#34;herbs&#34;); 
    pasta.add(&#34;meat&#34;); 
    expect(pasta.getType()).toEqual(&#34;bolognese&#34;); 
    expect(pasta.isTasty()).toEqual(true); 
  }); 

  it(&#34;should make pasta with no sauce&#34;, function() { 
    var pasta = new Pasta(); 
    pasta.add(&#34;meat&#34;); 
    expect(pasta.getType()).toEqual(undefined); 
    // pasta with no sauce? yeah that&#39;s not too tasty 
    expect(pasta.isTasty()).toEqual(false); 
  }); 
});&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Pasta.js&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;function Pasta() { 
  // recipes for good pasta sauces 
  this.sauces = { 
    &#39;bolognese&#39;: [&#34;tomatoes&#34;, &#34;garlic&#34;, &#34;olive&#34;, &#34;herbs&#34;, &#34;meat&#34;] 
  }; 
  this.sauceIngredients = []; 
} 

Pasta.prototype.add = function (ingredient) { 
  this.sauceIngredients.push(ingredient); 
}; 

Pasta.prototype.getType = function () { 
  for (var posssibleSauce in this.sauces) { 
    var ingredientsValid = true; 
    // checking if arrays are equal 
    if (!(this.sauceIngredients.sort() &amp;gt; this.sauces[posssibleSauce].sort() || 
          this.sauceIngredients.sort() &amp;lt; this.sauces[posssibleSauce].sort())) { 
      return posssibleSauce; 
    } 
  } 
  return undefined; 
}; 

Pasta.prototype.isTasty = function () { 
  if (this.getType() !== undefined) { return true; } 
  return false; 
};&lt;/pre&gt;

&lt;p&gt;Uma vez criado o arquivo de especificação &amp;#8216;PastaSpec.js&amp;#8217; e a implementação &amp;#8216;Pasta.js&amp;#8217;, é preciso criar um arquivo de configuração &amp;#8216;&lt;em&gt;testem.json&lt;/em&gt;&amp;#8216;. Necessário apenas informar o framework utilizado e os arquivos JavaScript. Conforme escrito abaixo:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;testem.json&lt;/strong&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-js&#34;&gt;{ 
  &#34;framework&#34;: &#34;jasmine&#34;, 
  &#34;src_files&#34;: [ 
    &#34;Pasta.js&#34;, 
    &#34;PastaSpec.js&#34; 
  ] 
}&lt;/pre&gt;

&lt;p&gt;O Test&amp;#8217;em usa como padrão a porta 7357. O parâmetro &amp;#8216;&amp;#8211;port&amp;#8217; serve para especificar uma outra. Nesse caso, vamos utilizar a 8080, digitando:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;testem --port=8080&lt;/pre&gt;

&lt;p&gt;Após a execução do comando, o resultado dos testes pode ser visto pela url &lt;strong&gt;&lt;a href=&#34;http://localhost:8080/&#34;&gt;http://localhost:8080/&lt;/a&gt;&lt;/strong&gt;. Caso a url seja aberta no Chrome, os testes serão executados no navegador Chrome. Caso aberta no Safari, será executado no Safari. Como ilustra a figura seguinte.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/4c25f04b60b6f6aaff1b50a0069ca0f5487860be/687474703a2f2f7332312e706f7374696d672e6f72672f6e72393273783469762f6a61736d696e655f74657374735f6f6e5f74657374656d2e706e67&#34; alt=&#34;testing Jasmine code on Test&#39;em&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para testar o código em diversos navegadores ou diversos sistemas operacionais, não é necessário ter máquinas virtuais nem mesmo outros dispositivos, como celulares ou tablet. O Sauce Labs prover o conector &lt;a href=&#34;http://saucelabs.com/downloads/Sauce-Connect-latest.zip&#34; title=&#34;Sauce Connect&#34;&gt;Sauce Connect&lt;/a&gt;. Com ele é possível criar uma conexão entre a nossa máquina e os servidores do SauceLabs, assim é possível rodar os testes dentro do firewall do Sauce Labs Cloud. Cloud que disponibiliza mais de &lt;a href=&#34;https://saucelabs.com/docs/platforms&#34; title=&#34;plataformas SauceLabs&#34;&gt;200 plataformas&lt;/a&gt;, que inclui dispositivos móveis, diversos SO e navegadores. Uma vez baixado o Sauce Connect, essa conexão é feita pelo comando:&lt;/p&gt;

&lt;pre class=&#34;lang-ssh&#34;&gt;java -jar Sauce-Connect.jar --tunnel-identifier &#34;tabless&#34; $SAUCE_USERNAME $SAUCE_ACCESS_KEY&lt;/pre&gt;

&lt;p&gt;Vale ressaltar que _$SAUCE&lt;em&gt;USERNAME&lt;/em&gt; e &lt;em&gt;$SAUCE_ACCESS_KEY&lt;/em&gt; são variáveis de ambientes. Método recomendado para evitar a divulgação de dados privados. Para obter dados de acesso, acesse a &lt;a href=&#34;https://saucelabs.com/signup&#34; title=&#34;página de cadastro do SauceLabs&#34;&gt;página de cadastro&lt;/a&gt;. Após a criação da conta, uma chave de acesso já é fornecida, conforme é ilustrado na figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/b29a04372bbe9224392df879736467128316054e/687474703a2f2f7332312e706f7374696d672e6f72672f63673666346a786e722f73617563656c6162735f6163636f756e745f706167652e706e67&#34; alt=&#34;página inicial da conta SauceLabs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Na página inicial, o botão &lt;strong&gt;New Interactive Session&lt;/strong&gt; permite a criação de uma instância de navegador. Uma popup (ilustrada na imagem abaixo) será exibida ao clicar no botão, com várias opções de sistema operacional e de navegador.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/7de3c788dc9a56a153bada645514034a442ae6d4/687474703a2f2f7332312e706f7374696d672e6f72672f736f693230616834372f6e65775f696e7465726163746976655f73657373696f6e5f706f7075702e706e67&#34; alt=&#34;popup para a criação de uma nova instância de navegador do SauceLabs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ao instanciar o navegador, é possível visualizar o resultado dos testes no terminal (ilustração na imagem abaixo). Os testes sempre serão executados novamente caso haja alguma alteração tanto no código quanto nas especificações, possibilitando assim a prática de TDD ou BDD, utilizando qualquer tipo de navegador.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/404afe58a076603719c0448fbc1a41ca92c85e0c/687474703a2f2f7332312e706f7374696d672e6f72672f74687a39366e6369762f697061645f73617563656c6162735f73657373696f6e2e706e67&#34; alt=&#34;instancia de um iPad do SauceLabs&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Esse exemplo contempla apenas a execução de testes de forma manual. Essas ferramentas que foram utilizadas também oferecem suporte para a automatização de testes, mas isso ficará para um próximo capítulo. Para quem se interessar, todo código está disponível em um &lt;a href=&#34;https://gist.github.com/igorlima/7649954&#34; title=&#34;gist do exemplo&#34;&gt;gist&lt;/a&gt;. Muito obrigado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testando seu código jQuery com Jasmine – Parte 2</title>
      <link>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-2/</link>
      <pubDate>Tue, 04 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-2/</guid>
      <description>

&lt;p&gt;Jasmine é um framework para testes focado em BDD (&lt;em&gt;Behavior Driven Development&lt;/em&gt;). Na &lt;a href=&#34;http://tableless.com.br/testando-seu-codigo-jquery-com-jasmine-parte-1/&#34;&gt;primeira parte&lt;/a&gt; deste artigo aprendemos seus métodos básicos e realizamos alguns testes simples. Agora chegou a hora de ir um pouco além e conhecer técnicas mais avançadas.&lt;/p&gt;

&lt;p&gt;Vale lembrar que, em nossos exemplos, utilizamos uma versão modificada da biblioteca, adaptada para jQuery: &lt;a href=&#34;https://github.com/velesin/jasmine-jquery&#34;&gt;jasmine-jquery&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Utilizaremos os dados de um outro artigo, &lt;a href=&#34;http://tableless.com.br/conteudo-sob-demanda-com-jquery/&#34;&gt;Conteúdo sob demanda com jQuery&lt;/a&gt;. O objetivo é testar as solicitações AJAX do carregamento da lista de tweets do Tableless.&lt;/p&gt;

&lt;h3 id=&#34;fixtures&#34;&gt;Fixtures&lt;/h3&gt;

&lt;p&gt;Antes dos testes propriamente ditos vamos conhecer uma forma prática de carregar nosso conteúdo HTM. Fixtures são arquivos carregados através do método &lt;strong&gt;loadFixtures&lt;/strong&gt;. Esta funcionalidade, aliás, está disponível apenas no jasmine-jquery.&lt;/p&gt;

&lt;p&gt;Vamos salvar o código HTML abaixo no arquivo &lt;strong&gt;tweets.html&lt;/strong&gt;, dentro do diretório de fixtures.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;xml&amp;#8221;]&lt;/p&gt;

&lt;div id=&amp;#8221;container&amp;#8221;&gt;
    
&lt;h1&gt;Tweets do Tableless&lt;/h1&gt;
    
&lt;ul id=&amp;#8221;lista-tweets&amp;#8221;&gt;&lt;/ul&gt;
    
&lt;p&gt;&lt;a href=&amp;#8221;#&amp;#8221; id=&amp;#8221;carrega-tweets&amp;#8221; data-pagina=&amp;#8221;1&amp;#8243;&gt;Mais!&lt;/a&gt;&lt;/p&gt;
  
&lt;/div&gt;
  

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Por padrão, o jasmine-jquery procura as fixtures no diretório &lt;strong&gt;spec/javascripts/fixtures&lt;/strong&gt;. Como na primeira parte do artigo indicamos uma estrutura diferente, utilizando o diretório &lt;strong&gt;spec/fixtures&lt;/strong&gt;, precisamos atualizar a propriedade fixturesPath nas configurações do Jasmine.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;jasmine.getFixtures().fixturesPath = &amp;#8216;spec/fixtures/&amp;#8217;;&lt;/p&gt;

&lt;p&gt;describe(&amp;#8216;Exibição dos últimos tweets do Tableless&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;beforeEach(function(){&lt;/p&gt;

&lt;p&gt;loadFixtures(&amp;#8216;tweets.html&amp;#8217;);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8216;Deve carregar na primeira página&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;expect($(&amp;#8216;#carrega-tweets&amp;#8217;).data(&amp;#8216;pagina&amp;#8217;)).toEqual(1);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Outra forma de utilizarmos fixtures é carregando diretamente no código, sem a necessidade de um arquivo HTML. Esse caso é mais indicado para templates mais simples, com poucos elementos.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;setFixtures(&amp;#8216;&lt;ul id=&amp;#8221;lista-tweets&amp;#8221; /&gt;&amp;#8217;);&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;testando-código-assíncrono&#34;&gt;Testando código assíncrono&lt;/h3&gt;

&lt;p&gt;Testar código AJAX pode ser um pouco mais complicado. No nosso exemplo, como acessamos uma URL externa à nossa aplicação, o tempo de resposta vai depender de vários fatores, como velocidade da conexão, estabilidade do Twitter etc.&lt;/p&gt;

&lt;p&gt;Os métodos &lt;strong&gt;runs&lt;/strong&gt; e &lt;strong&gt;waits&lt;/strong&gt; são úteis para tentar simular esse tempo de carregamento. O &lt;strong&gt;runs&lt;/strong&gt; executa os testes e funções um escopo próprio e, além disso, são executados em sequência (quando um termina, o outro começa). Já o método &lt;strong&gt;waits&lt;/strong&gt; funciona como uma espécie de pausa/sleep e recebe como parâmetro o tempo em milissegundos.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;it(&amp;#8216;Deve carregar os últimos 20 tweets&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;runs(function(){&lt;/p&gt;

&lt;p&gt;Tableless.retorna_tweets(1);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;waits(1500);&lt;/p&gt;

&lt;p&gt;runs(function(){&lt;/p&gt;

&lt;p&gt;expect($(&amp;#8216;#lista-tweets li&amp;#8217;).length).toEqual(20);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;espionando-métodos&#34;&gt;Espionando métodos&lt;/h3&gt;

&lt;p&gt;Às vezes precisamos testar se um método de um objeto é chamado (e com que parâmetros) &amp;mdash; e não testar apenas seu resultado. O Jasmine oferece a função &lt;strong&gt;spyOn&lt;/strong&gt; para capturar e validar essas chamadas. O &lt;strong&gt;spyOn&lt;/strong&gt; recebe dois parâmetros: o objeto e o nome do método.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;it(&amp;#8216;Deve executar função para retornar tweets&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;spyOn(Tableless, &amp;#8216;retorna_tweets&amp;#8217;);&lt;/p&gt;

&lt;p&gt;Tableless.retorna_tweets(1);&lt;/p&gt;

&lt;p&gt;expect(Tableless.retorna_tweets).toHaveBeenCalledWith(1);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Acima testamos se o método foi chamado com o parâmetro 1 (página). Poderíamos ter utilizado também &lt;strong&gt;toHaveBeenCalled&lt;/strong&gt;, testando apenas a chamada. As funções de spy podem ainda ser combinadas com o not, por exemplo:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;expect(Tableless.retorna_tweets).not.toHaveBeenCalled();&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;matchers-personalizados&#34;&gt;Matchers personalizados&lt;/h3&gt;

&lt;p&gt;Outra funcionalidade poderosa do Jasmine é a possibilidade de criação de matchers personalizados. Os matchers são asserts para seus tests. No exemplo abaixo, criamos o matcher &lt;strong&gt;toBeATweet&lt;/strong&gt; para validar se um elemento possui a classe &amp;#8220;tweet&amp;#8221;.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;beforeEach(function(){&lt;/p&gt;

&lt;p&gt;this.addMatchers({&lt;/p&gt;

&lt;p&gt;toBeATweet: function(){&lt;/p&gt;

&lt;p&gt;return this.actual.hasClass(&amp;#8216;tweet&amp;#8217;);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;/p&gt;

&lt;p&gt;expect($(&amp;#8216;#lista-tweets li:first&amp;#8217;)).toBeATweet();&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;O método addMatchers deve ser executado dentro do beforeEach, utilizando o Jasmine como contexto. Notem que ele recebe um objeto que pode conter um ou mais matchers personalizados. No código, &lt;strong&gt;this.actual&lt;/strong&gt; representa a variável, elemento, ou objeto que estará sendo passado ao &lt;strong&gt;expect&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&#34;outros-projetos-utilizando-jasmine&#34;&gt;Outros projetos utilizando Jasmine&lt;/h3&gt;

&lt;p&gt;Nesses dois artigos vocês conheceram o jasmine-jquery, mas existem diversos outros projetos baseados no framework Jasmine, incluindo adaptações para NodeJS, Rails e iPhone e snippets para Vim e TextMate. A lista completa você confere no &lt;a href=&#34;https://github.com/pivotal/jasmine/wiki/Related-projects&#34;&gt;wiki do projeto no Github&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;referências&#34;&gt;Referências&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tableless/exemplos/tree/gh-pages/jasmine-parte-2&#34;&gt;Código fonte dos exemplos deste artigo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.github.com/exemplos/jasmine-parte-2/tests/SpecRunner.html&#34;&gt;SpecRunner dos exemplos rodando no browser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://f.souza.cc/2011/05/testing-jquery-plugins-with-jasmine/&#34;&gt;Testing jQuery plugins with Jasmine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://testdrivenwebsites.com/2010/07/29/html-fixtures-in-jasmine-using-jasmine-jquery/&#34;&gt;HTML fixtures in Jasmine (using jasmine-jquery)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Testando seu código jQuery com Jasmine – Parte 1</title>
      <link>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-1/</link>
      <pubDate>Mon, 12 Sep 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/testando-seu-codigo-jquery-com-jasmine-parte-1/</guid>
      <description>

&lt;p&gt;Durante muito tempo testar/debugar JavaScript era uma tarefa árdua (infelizmente, em alguns navegadores, ainda é). Quem aí se lembra do tempo em que não existia Firebug, por exemplo? E o tamanho dos scripts? Um simples menu drop-drown possuía umas 1.500 linhas de código. Não existia jQuery ou qualquer outro tipo de framework. Tempos difíceis.&lt;/p&gt;

&lt;p&gt;Hoje a tarefa do desenvolvedor é muito mais fácil. Para debug temos o já citado Firebug e o Developer Tools do Chrome, entre outros. Nos testes, além do &lt;a href=&#34;http://pivotal.github.com/jasmine/&#34; target=&#34;_blank&#34;&gt;Jasmine&lt;/a&gt;, outro framework bem legal é o &lt;a href=&#34;http://docs.jquery.com/Qunit&#34;&gt;QUnit&lt;/a&gt;. O Jasmine, por focar em BDD, possui uma sintaxe mais fluida. Quem programa em Ruby/Rails vai notar a enorme semelhança com a ferramenta RSpec.&lt;/p&gt;

&lt;p&gt;Nos exemplos vou utilizar uma versão modificada do Jasmine, jasmine-jquery. Ela possui alguns métodos próprios para o framework além de funções para carregar fixtures (templates).&lt;/p&gt;

&lt;h3 id=&#34;baby-steps&#34;&gt;Baby steps&lt;/h3&gt;

&lt;p&gt;Começar a trabalhar com uma cultura de testar sempre antes de desenvolver é bem difícil, principalmente para quem já está acostumado a programar antes e testar depois (manualmente). Comece devagar, sem medo. No início as coisas serão um pouco confusas, mas depois de adotar essa prática, você vai se perguntar como era possível programar sem testes.&lt;/p&gt;

&lt;p&gt;O que testar e que testes escrever? Isso também vem com o tempo. Comece testando uma ou outra funcionalidade principal de um aplicativo já existente. Entenda como funciona a sua ferramenta de testes. Depois de um tempo comece a acreditar e confiar na sua intuição.&lt;/p&gt;

&lt;p&gt;Procure sempre utilizar um conjunto variado de possibilidades, desde as mais óbvias até as mais inusitadas. Pense nos diferentes contextos, em tudo que interage com seu aplicativo: navegadores, sistemas operacionais, usuários, dados de entrada, scripts de terceiros etc.&lt;/p&gt;

&lt;p&gt;Testes não evitam que seu software, uma vez finalizado, tenha bugs; não são a solução para todos os seus problemas de &lt;em&gt;deploy&lt;/em&gt;, mas facilitam bastante essas etapas.&lt;/p&gt;

&lt;h3 id=&#34;red-rarr-green-rarr-refactor&#34;&gt;Red &amp;rarr; Green &amp;rarr; Refactor&lt;/h3&gt;

&lt;p&gt;O padrão básico a ser seguido é o seguinte:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Escreva o teste &amp;mdash; naturalmente, ele vai falhar;&lt;/li&gt;
&lt;li&gt;Escreva, sem se preocupar muito com qualidade, o código mais simples, que faça o teste passar;&lt;/li&gt;
&lt;li&gt;Reescreva seu código, implementando melhorias de performance, escalabilidade e removendo duplicidades.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;configurando-o-jasmine-jquery&#34;&gt;Configurando o jasmine-jquery&lt;/h3&gt;

&lt;p&gt;Baixe a última versão do &lt;a href=&#34;https://github.com/velesin/jasmine-jquery&#34; target=&#34;_blank&#34;&gt;jasmine-jquery&lt;/a&gt; e vamos começar com nossos primeiros testes. A estrutura de pastas do nosso aplicativo deve ficar da seguinte maneira:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;xml&amp;#8221;]- /&lt;/p&gt;

&lt;p&gt;&amp;#8211; /tests&lt;/p&gt;

&lt;p&gt;&amp;#8211; /lib&lt;/p&gt;

&lt;p&gt;&amp;#8211; /spec&lt;/p&gt;

&lt;p&gt;&amp;#8211; /fixtures&lt;/p&gt;

&lt;p&gt;&amp;#8211; /suites&lt;/p&gt;

&lt;p&gt;&amp;#8211; saudacao-spec.js&lt;/p&gt;

&lt;p&gt;&amp;#8211; /vendor&lt;/p&gt;

&lt;p&gt;&amp;#8211; SpecRunner.html&lt;/p&gt;

&lt;p&gt;&amp;#8211; tableless.js&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Note que criamos um diretório &amp;#8220;tests&amp;#8221; onde ficarão todos os arquivos dos nossos testes, incluindo a biblioteca Jasmine. O arquivo SpecRunner.html é o responsável por executar e exibir os resultados dos testes, basta abri-lo no navegador. Dentro do diretório “tests/spec” ficarão nossos conjuntos de testes (suites) e nossos templates HTML (fixtures).&lt;/p&gt;

&lt;p&gt;No início do SpecRunner ficam as chamadas para os testes:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;script type=&amp;#8221;text/javascript&amp;#8221; src=&amp;#8221;spec/suites/saudacao-spec.js&amp;#8221;&gt;&lt;/script&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Você também pode incluir aqui qualquer javascript personalizado necessário para os testes. No nosso caso vamos incluir o arquivo tableless.js, que fica na raiz do nosso aplicativo.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]&lt;script type=&amp;#8221;text/javascript&amp;#8221; src=&amp;#8221;../tableless.js&amp;#8221;&gt;&lt;/script&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;nosso-primeiro-teste&#34;&gt;Nosso primeiro teste&lt;/h3&gt;

&lt;p&gt;Vamos supor o seguinte: uma página deve exibir uma mensagem de boas-vindas para o usuário que varia de acordo com o horário. De 5 da manhã ao meio-dia, exibe &amp;#8220;Bom dia!&amp;#8221;; de meio-dia até 6 da tarde, exibe &amp;#8220;Boa tarde!&amp;#8221;; de 6 à meia-noite, exibe &amp;#8220;Boa noite!&amp;#8221;; e, por fim, de meia-noite até 6 da manhã exibe &amp;#8220;Dormir é para os fracos!&amp;#8221;. A mensagem fica sempre dentro de um elemento div com id &amp;#8220;mensagem&amp;#8221;. Os horários vão desde a hora inicial (incluída) até a hora final. A função pode receber como parâmetro uma hora no formato hh:mm ou, caso não receba nada, exibe a mensagem de acordo com a hora do usuário.&lt;/p&gt;

&lt;p&gt;Esse é um bom começo para seus testes, tente escrever, em um parágrafo, o que deve ser executado e o que é esperado. Trabalhe sempre com um pedaço de papel por perto, para rascunhos.&lt;/p&gt;

&lt;p&gt;Vejamos como ficaria o desenho inicial dos nossos testes. Crie o arquivo /tests/spec/suites/saudacao-spec.js e digite o seguinte código:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]describe(&amp;#8216;Exibição da mensagem de boas-vindas&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;beforeEach(function(){&lt;/p&gt;

&lt;p&gt;setFixtures(&amp;#8216;&lt;div id=&amp;#8221;mensagem&amp;#8221; /&gt;&amp;#8217;);&lt;/p&gt;

&lt;p&gt;this.mensagem = $(&amp;#8216;#mensagem&amp;#8217;);&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;afterEach(function(){&lt;/p&gt;

&lt;p&gt;this.horas = [];&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Bom-dia!&amp;#8217; entre 5:00 e 11:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Boa-tarde!&amp;#8217; entre 12:00 e 17:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Boa-noite!&amp;#8217; entre 18:00 e 23:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir &amp;#8216;Dormir é para os fracos!&amp;#8217; de 00:00 a 04:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;it(&amp;#8220;Deve exibir, por padrão, a mensagem de acordo com a hora do cliente&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});[/cce]&lt;/p&gt;

&lt;p&gt;Na raiz do aplicativo, crie um arquivo chamado &amp;#8220;tableless.js&amp;#8221;. Nele nós escreveremos nossa função para exibir a mensagem de acordo com a hora. Sua estrutura inicial é a seguinte:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]function saudacao(hora_atual){&lt;/p&gt;

&lt;p&gt;var hora;&lt;/p&gt;

&lt;p&gt;}[/cce]&lt;/p&gt;

&lt;p&gt;Os conceitos básicos dos nossos testes giram em torno de três funções: &lt;strong&gt;describe&lt;/strong&gt;, &lt;strong&gt;it&lt;/strong&gt; e &lt;strong&gt;expect&lt;/strong&gt;. Outras funções úteis, mas que nem sempre estarão presentes, são as funções &lt;strong&gt;beforeEach&lt;/strong&gt; e &lt;strong&gt;afterEach&lt;/strong&gt;. Também trabalhamos com uma função do jasmine-jquery, a &lt;strong&gt;setFixtures&lt;/strong&gt; &amp;mdash; falarei mais sobre ela na parte 2, por enquanto você só precisa saber que ela define templates/elementos no DOM.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;describe&lt;/strong&gt; &amp;mdash; representa um conjunto de testes/comportamentos. Podem existir situações dentro de situações, por exemplo:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]describe(&amp;#8216;Login&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;describe(&amp;#8216;Sucesso&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;
describe(&amp;#8216;Falha&amp;#8217;, function(){&lt;/p&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;});[/cce] &lt;/li&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;it&lt;/strong&gt; &amp;mdash; define um teste, uma ação. Por exemplo, &amp;#8220;It should validate the username&amp;#8221;, ou, &amp;#8220;Deve validar o nome do usuário&amp;#8221;, seria uma boa situação para nosso teste de login.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;expect&lt;/strong&gt; &amp;mdash; espera que alguma variável ou retorno de função seja igual a alguma coisa, ou verdadeiro, ou falso etc. Nos testes acima utilizamos apenas um tipo de validação, o matcher &amp;#8220;toEqual&amp;#8221;. Todo o teste deve ser chamado com a função expect, utilizando um dos matchers disponíveis (mais sobre eles na parte 2). Os principais são: toEqual, toContains, toBeTruthy e toBeFalsy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;beforeEach&lt;/strong&gt; &amp;mdash; executada antes de cada teste dentro de um conjunto, muito útil para configurar elementos.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;afterEach&lt;/strong&gt; &amp;mdash; executada depois de cada teste dentro de um conjunto, ideal para reiniciar variáveis.&lt;/ul&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;escrevendo-os-testes&#34;&gt;Escrevendo os testes&lt;/h3&gt;

&lt;p&gt;Agora chegou a hora de preencher os nossos testes. Os testes que verificam a mensagem entre uma hora e outra seguirão um mesmo padrão. Dado um conjunto de horas válidas, a função saudacao deve retornar a mensagem correta.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]it(&amp;#8220;Deve exibir &amp;#8216;Bom-dia!&amp;#8217; entre 5:00 e 11:59&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;this.horas = [&amp;#8217;05:00&amp;#8242;, &amp;#8217;09:33&amp;#8242;, &amp;#8217;10:22&amp;#8242;, &amp;#8217;11:59&amp;#8242;];&lt;/p&gt;

&lt;p&gt;for(i in this.horas){&lt;/p&gt;

&lt;p&gt;saudacao(this.horas[i]);&lt;/p&gt;

&lt;p&gt;expect(this.mensagem.text()).toEqual(&amp;#8216;Bom-dia!&amp;#8217;);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;});[/cce]&lt;/p&gt;

&lt;p&gt;O teste que valida o retorno da função saudacao sem passagem de parâmetro busca a hora do cliente e exibe a mensagem de acordo com ela.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]it(&amp;#8220;Deve exibir, por padrão, a mensagem de acordo com a hora do cliente&amp;#8221;, function(){&lt;/p&gt;

&lt;p&gt;var data = new Date;&lt;/p&gt;

&lt;p&gt;data.setTime(data.getTime());&lt;/p&gt;

&lt;p&gt;var hora = data.getHours();&lt;/p&gt;

&lt;p&gt;saudacao();&lt;/p&gt;

&lt;p&gt;var texto = this.mensagem.text();&lt;/p&gt;

&lt;p&gt;if(hora &amp;lt; 5)&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Dormir é para os fracos!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;if(hora &amp;lt; 12)&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Bom-dia!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else if(hora &amp;lt; 18)&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Boa-tarde!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else&lt;/p&gt;

&lt;p&gt;expect(texto).toEqual(&amp;lsquo;Boa-noite!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;});[/cce]&lt;/p&gt;

&lt;p&gt;Nesse momento, abrindo o SpecRunner no navegador, todos os nossos testes estarão falhando. Lembra da nossa regra? Red (falhou), Green (passou) e Refactor.&lt;/p&gt;

&lt;h3 id=&#34;a-função-saudacao&#34;&gt;A função saudacao()&lt;/h3&gt;

&lt;p&gt;Abaixo segue a minha implementação da função saudacao(). Não me preocupei muito com repetições e performance. Meu objetivo principal era fazer o teste passar.&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;javascript&amp;#8221;]function saudacao(hora_atual){&lt;/p&gt;

&lt;p&gt;var hora;&lt;/p&gt;

&lt;p&gt;if(typeof hora_atual == &amp;#8216;undefined&amp;#8217;){&lt;/p&gt;

&lt;p&gt;var data = new Date;&lt;/p&gt;

&lt;p&gt;data.setTime(data.getTime());&lt;/p&gt;

&lt;p&gt;hora = data.getHours();&lt;/p&gt;

&lt;p&gt;}else{&lt;/p&gt;

&lt;p&gt;hora = hora_atual.split(&amp;#8216;:&amp;#8217;);&lt;/p&gt;

&lt;p&gt;hora = parseInt(hora[0].replace(/^0/, &amp;#8221;));&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;if(hora &amp;lt; 5)&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Dormir é para os fracos!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else if(hora &amp;lt; 12)&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Bom-dia!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else if(hora &amp;lt; 18)&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Boa-tarde!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;else&lt;/p&gt;

&lt;p&gt;$(&amp;lsquo;#mensagem&amp;rsquo;).text(&amp;lsquo;Boa-noite!&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;}[/cce]&lt;/p&gt;

&lt;p&gt;Atualizando nossa SpecRunner veremos agora que todos os testes estão passando. Você pode (e deve) desenvolver aos poucos. Valide um teste de cada vez. Desenvolva com calma.&lt;/p&gt;

&lt;h3 id=&#34;melhorando-nosso-código&#34;&gt;Melhorando nosso código&lt;/h3&gt;

&lt;p&gt;Como de praxe, vou deixar um dever de casa para vocês: a etapa de refactoring. O que podemos melhorar na nossa função saudacao()? E se o usuário passar uma hora atualmente inválida para nossa função, como &amp;#8220;meio-dia&amp;#8221;, &amp;#8220;nove horas&amp;#8221; etc. E se quisermos mudar o id do elemento #mensagem? E se quisermos exibir a saudação em mais de um elemento? Podemos melhorar algum nome de variável? Podemos reduzir o tamanho da nossa função? Nossa função está cumprindo seu objetivo? Tem algum código/texto repetido? E nossos testes? Estão cobrindo tudo? Prevendo todos os cenários?&lt;/p&gt;

&lt;p&gt;O que não falta é opção para um bom refactoring.&lt;/p&gt;

&lt;p&gt;Na segunda parte veremos a função spy, além de mais sobre fixtures, matchers personalizados e outros recursos avançados.&lt;/p&gt;

&lt;h3 id=&#34;referências&#34;&gt;Referências&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tableless/exemplos/tree/gh-pages/jasmine-parte-1&#34;&gt;Código fonte dos exemplos deste artigo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.github.com/exemplos/jasmine-parte-1/tests/SpecRunner.html&#34;&gt;SpecRunner do exemplo rodando no github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pivotal.github.com/jasmine/&#34; target=&#34;_blank&#34;&gt;Jasmine BDD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/velesin/jasmine-jquery&#34; target=&#34;_blank&#34;&gt;jasmine-jquery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://pt.wikipedia.org/wiki/Behavior_Driven_Development&#34; target=&#34;_blank&#34;&gt;BDD segundo a Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>