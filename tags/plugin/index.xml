<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Plugin on Tableless</title>
    <link>https://tableless.github.io/hugo-public/tags/plugin/index.xml</link>
    <description>Recent content in Plugin on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/tags/plugin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gulp: O novo automatizador</title>
      <link>https://tableless.github.io/hugo-public/gulp-o-novo-automatizador/</link>
      <pubDate>Mon, 20 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/gulp-o-novo-automatizador/</guid>
      <description>

&lt;p&gt;Se você não esteve morando em baixo de uma rocha pelos últimos meses, provavelmente conhece o automatizador de tarefas &lt;a href=&#34;http://tableless.com.br/grunt-voce-deveria-estar-usando/&#34;&gt;Grunt&lt;/a&gt;, que já dominava a área há algum tempo. Mas agora, chegou um novo automatizador chamado &lt;a href=&#34;http://gulpjs.com&#34;&gt;Gulp&lt;/a&gt; que promete realizar suas tarefas de forma mais rápida e simples do que seu concorrente.&lt;/p&gt;

&lt;p&gt;Caso você não saiba, automatizadores de tarefa são ferramentas que ajudam programadores &lt;del&gt;preguiçosos&lt;/del&gt; a realizarem tarefas repetitivas mas essenciais para o desenvolvimento como: concatenação de arquivos, minificação, testes e muitas outras coisas necessárias para a criação de um código rápido e eficiente.&lt;/p&gt;

&lt;h3 id=&#34;por-que-gulp&#34;&gt;Por que Gulp?&lt;/h3&gt;

&lt;p&gt;Se você já utiliza o Grunt em seus projetos, deve estar se perguntando por que mudar de automatizador. A resposta é simples: O Gulp é muito mais rápido que o Grunt, já que faz uso das streams do nodejs para escrever arquivos diretamente para o disco, dispensando intermediários. Sem falar na simplicidade do Gulpfile(equivalente ao Gruntfile), que utiliza uma sintaxe de código semelhante ao código comum do nodejs.&lt;/p&gt;

&lt;p&gt;Espero que até o final do texto você fique impressionado com a simplicidade do Gulp, e pense duas vezes antes de escolher o automatizador de tarefas para o seu próximo projeto.&lt;/p&gt;

&lt;h3 id=&#34;instalação&#34;&gt;Instalação&lt;/h3&gt;

&lt;p&gt;Lembrando que o Gulp roda no &lt;a href=&#34;http://nodejs.org/&#34;&gt;nodejs&lt;/a&gt; então é preciso que você o tenha instalado no seu computador, caso esteja tudo ok, basta rodar o comando abaixo na sua linha de comando para instalar o CLI:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;npm install -g gulp
&lt;/pre&gt;

&lt;p&gt;Caso você esteja em um sistema baseado em Unix, talvez seja preciso rodar `sudo` antes do comando acima. Agora você vai poder rodar o Gulp na sua linha de comando. Para ver a versão instalada, execute:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp -v
&lt;/pre&gt;

&lt;p&gt;Se o comando acima retornar a versão do Gulp instalada, a instalação foi um sucesso.&lt;/p&gt;

&lt;h3 id=&#34;iniciando-com-o-gulp&#34;&gt;Iniciando com o Gulp&lt;/h3&gt;

&lt;p&gt;Agora vamos ao que interessa, a automatização! O Gulp faz uso do Gulpfile para configuração das tarefas que ele vai rodar, que é o único arquivo necessário.&lt;/p&gt;

&lt;p&gt;Para nossos testes, criei uma estrutura desta forma:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;|projeto/
|--dist/
|--src/
|----source.js
|--Gulpfile.js
&lt;/pre&gt;

&lt;p&gt;Vou rodar três testes diferentes: Concatenação, minificação e teste de código com o jshint. O Gulp faz uso de &lt;a href=&#34;http://gratimax.github.io/search-gulp-plugins/&#34;&gt;plugins&lt;/a&gt; para facilitar a criação de tarefas, então vou instalar alguns para nós rodarmos nossos testes.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;npm install gulp gulp-jshint gulp-uglify gulp-concat gulp-rename --save-dev
&lt;/pre&gt;

&lt;p&gt;Note que eu instalei o próprio Gulp DE NOVO e alguns plugins. Isto é porque o Gulp instalado anteriormente foi o CLI, responsável por rodar o comando `gulp` na linha de comando e o instalado desta vez é o local que é usado para rodar os testes no projeto. Agora podemos criar nosso Gulpfile:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// Aqui nós carregamos o gulp e os plugins através da função `require` do nodejs
var gulp = require(&#39;gulp&#39;);
var jshint = require(&#39;gulp-jshint&#39;);
var uglify = require(&#39;gulp-uglify&#39;);
var concat = require(&#39;gulp-concat&#39;);
var rename = require(&#39;gulp-rename&#39;);

// Definimos o diretorio dos arquivos para evitar repetição futuramente
var files = &#34;./src/*.js&#34;;

//Aqui criamos uma nova tarefa através do ´gulp.task´ e damos a ela o nome &#39;lint&#39;
gulp.task(&#39;lint&#39;, function() {

// Aqui carregamos os arquivos que a gente quer rodar as tarefas com o `gulp.src`
// E logo depois usamos o `pipe` para rodar a tarefa `jshint`
gulp.src(files)
.pipe(jshint())
.pipe(jshint.reporter(&#39;default&#39;));
});

//Criamos outra tarefa com o nome &#39;dist&#39;
gulp.task(&#39;dist&#39;, function() {

// Carregamos os arquivos novamente
// E rodamos uma tarefa para concatenação
// Renomeamos o arquivo que sera minificado e logo depois o minificamos com o `uglify`
// E pra terminar usamos o `gulp.dest` para colocar os arquivos concatenados e minificados na pasta build/
gulp.src(files)
.pipe(concat(&#39;./dist&#39;))
.pipe(rename(&#39;dist.min.js&#39;))
.pipe(uglify())
.pipe(gulp.dest(&#39;./dist&#39;));
});

//Criamos uma tarefa &#39;default&#39; que vai rodar quando rodamos `gulp` no projeto
gulp.task(&#39;default&#39;, function() {

// Usamos o `gulp.run` para rodar as tarefas
// E usamos o `gulp.watch` para o Gulp esperar mudanças nos arquivos para rodar novamente
gulp.run(&#39;lint&#39;, &#39;dist&#39;);
gulp.watch(files, function(evt) {
gulp.run(&#39;lint&#39;, &#39;dist&#39;);
});
});
&lt;/pre&gt;

&lt;p&gt;O código acima está muito bem comentado e dispensa mais explicações. Caso você tenha usado o Grunt anteriormente, percebeu como a criação de tarefas com o Gulpfile é muito mais simples. Para rodar as tarefas, rode o comando:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp
&lt;/pre&gt;

&lt;p&gt;Perceba que ele executa a rotina de tarefas que você definiu e fica esperando mudanças no seu código para rodar novamente(lembra do watch?), mas se você quiser rodar apenas um tarefa específica, basta adicionar o nome da tarefa após o comando:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;gulp lint
&lt;/pre&gt;

&lt;p&gt;No exemplo acima rodamos o teste de código usando o nome da task que definimos anteriormente.&lt;/p&gt;

&lt;h3 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h3&gt;

&lt;p&gt;Enfim, neste texto vimos como usar o Gulp para automatizar as tarefas do seu próximo projeto de forma simples e eficiente. O Gulp é um projeto novo e que ainda deve amadurecer muito nas próximas semanas. Caso você queira contribuir de alguma maneira, acesse o projeto no &lt;a href=&#34;https://github.com/gulpjs/gulp&#34;&gt;github&lt;/a&gt; e veja como ajudar.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando um plugin JavaScript (sem jQuery!)</title>
      <link>https://tableless.github.io/hugo-public/criando-um-plugin-javascript-sem-jquery/</link>
      <pubDate>Wed, 07 Nov 2012 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/criando-um-plugin-javascript-sem-jquery/</guid>
      <description>

&lt;p&gt;Neste artigo vamos criar um slider de imagens utilizando apenas JavaScript e CSS3, sem nenhuma biblioteca. O resultado final é um script de aproximadamente 160 linhas e menos de 3kb minificado. Poderia ser menor do que isso, mas nosso código vai ser extensível e 100% válido em uma &lt;a href=&#34;http://tableless.com.br/qualidade-codigo-javascript/&#34; title=&#34;Assegurando a qualidade do seu código JavaScript&#34;&gt;verificação JSLint&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/anatomia-de-um-plugin-jquery/&#34; title=&#34;Anatomia de um plugin jQuery&#34;&gt;Um plugin jQuery&lt;/a&gt; é basicamente um código que pode ser aplicado em um ou mais elementos do DOM. Para justificar sua existência, um plugin precisa ser, principalmente, flexível.&lt;/p&gt;

&lt;p&gt;O objetivo final é podermos instanciar nosso plugin com a seguinte chamada:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var slider = new JSlider(&#39;.slider&#39;);&lt;/pre&gt;

&lt;p&gt;Antes de tudo vamos precisar de um pequeno trecho de CSS que garantirá o estilo básico do nosso slider.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.jslider-stage {
    position: relative;
}

.jslider-track {
    overflow: hidden;
}

.jslider-track ul {
    transition: margin-left .5s ease;
    -webkit-transition: margin-left .5s ease;
    -moz-transition: margin-left .5s ease;
    -o-transition: margin-left .5s ease;
}

.jslider-track ul li {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}

.jslider-navigation {
    position: absolute;
    top: 0;
    width: 60px;
    height: 80px;
    background: #000;
    color: #fff;
}
.jslider-stage .left {
    left: 0;
}&lt;/pre&gt;

&lt;p&gt;Não vou explicar muito as declarações acima já que o nosso foco principal é o código JavaScript. O mais importante é que toda a parte de animação, responsável pelas transições entre imagens, é feita via CSS3, representando um belo ganho de performance:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.jslider-track ul {
    transition: margin-left .5s ease;
    -webkit-transition: margin-left .5s ease;
    -moz-transition: margin-left .5s ease;
    -o-transition: margin-left .5s ease;
}&lt;/pre&gt;

&lt;p&gt;Pensando um pouco na composição do código do nosso plugin, vamos criar dois objetos: um que será responsável pelo plugin em si e outro para representar cada slider instanciado na página. O próximo passo, então, é criar duas funções construtoras para nossos objetos:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function JSlider(selector) {
    this.init(selector);
}

function JSliderStage(el) {
    this.doc = document;
    this.init(el);
}&lt;/pre&gt;

&lt;p&gt;JSlider é o objeto do nosso plugin que armazenará um ou mais objetos JSliderStage.&lt;/p&gt;

&lt;p&gt;O objeto JSlider possui um único método, &lt;em&gt;init&lt;/em&gt;, responsável por inicializar nosso plugin e os objetos do tipo stage. Este método receberá um único parâmetro, o seletor no qual aplicaremos o plugin.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;JSlider.prototype.init = function (selector) {
    var elements = document.querySelectorAll(selector),
        i;

    this.slidersList = [];

    if (elements.length &amp;lt; 1) {
        return;
    }

    for (i = 0; i &amp;lt; elements.length; i += 1) {
        this.slidersList.push(new JSliderStage(elements[i]));
    }
};&lt;/pre&gt;

&lt;p&gt;Não existem classes em JavaScript, tudo é um objeto. No entanto, com o uso de prototypes, conseguimos criar objetos que servem como modelos. Ao adicionar um método ao prototype de um objeto, todas as instâncias que compartilham o mesmo prototype automaticamente herdam este novo método.&lt;/p&gt;

&lt;p&gt;Agora chegou a hora de estruturarmos o objeto responsável pelo slider em si. Vamos, antes de tudo, montar uma lista das funcionalidades a serem implementadas.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;inicialização, listando as imagens encontradas no seletor;&lt;/li&gt;
&lt;li&gt;construção do &amp;#8220;palco&amp;#8221;, definindo as dimensões de acordo com a maior foto;&lt;/li&gt;
&lt;li&gt;construção do &amp;#8220;trilho&amp;#8221; e carregamento das imagens;&lt;/li&gt;
&lt;li&gt;construção e inicialização da navegação entre imagens e&lt;/li&gt;
&lt;li&gt;carregamento de uma nova página.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O palco &amp;#8220;esconde&amp;#8221; boa parte do trilho que armazena as imagens, exibindo apenas a imagem atual. Ao clicar nos botões de navegação, o usuário desloca esse trilho no eixo X.&lt;/p&gt;

&lt;h3 id=&#34;queryselectorall&#34;&gt;querySelectorAll&lt;/h3&gt;

&lt;p&gt;O método &lt;em&gt;querySelectorAll&lt;/em&gt;, nativo do JavaScript, tem funcionamento parecido com um seletor jQuery, podendo receber tanto um id como uma classe. Primeiro verificamos se foi encontrado algum elemento e depois instanciamos os objetos JSliderStage para cada elemento encontrado.&lt;/p&gt;

&lt;h2 id=&#34;1-inicialização&#34;&gt;1. Inicialização&lt;/h2&gt;

&lt;p&gt;A função de inicialização é responsável por configurar os valores padrões de algumas variáveis e listar as imagens disponíveis no elemento pai. Caso não exista nenhuma imagem, nosso plugin cancela qualquer execução.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;JSliderStage.prototype.init = function (el) {
    this.root = el;
    this.currentPage = 1;
    this.images = this.root.querySelectorAll(&#39;img&#39;);

    if (this.images.length === 0) {
        return;
    }

    this.build();
};&lt;/pre&gt;

&lt;h2 id=&#34;2-palco&#34;&gt;2. Palco&lt;/h2&gt;

&lt;p&gt;Para construir o palco precisamos definir uma largura e uma altura máxima, baseada nas maiores imagens &amp;#8211; é isso que o método &lt;em&gt;getPageDimensions&lt;/em&gt; faz.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;JSliderStage.prototype.build = function () {
    this.getPageDimensions()
        .createStage()
        .initNavigation();
    this.root.innerHTML = &#39;&#39;;
    this.root.appendChild(this.stage);
};

JSliderStage.prototype.getPageDimensions = function () {
    var i;
    this.pageWidth = this.pageHeight = 0;
    for (i = 0; i &amp;lt; this.images.length; i += 1) {
        if (this.images[i].width &amp;gt; this.pageWidth) {
            this.pageWidth = this.images[i].width;
        }
        if (this.images[i].height &amp;gt; this.pageHeight) {
            this.pageHeight = this.images[i].height;
        }
    }
    return this;
};

JSliderStage.prototype.createStage = function () {
    this.stage = this.doc.createElement(&#39;div&#39;);
    this.stage.className = &#39;jslider-stage&#39;;
    this.stage.style.width = this.pageWidth + &#39;px&#39;;

    this.buildTrack()
        .loadImages();

    this.stage.appendChild(this.sliderTrack);

    return this;
};&lt;/pre&gt;

&lt;p&gt;O método &lt;em&gt;createStage&lt;/em&gt; adiciona ao DOM os elementos necessários para nosso palco e executa dois outros métodos: um para carregar o trilho e outro para carregar as imagens. Por fim, iniciamos a navegação com o método &lt;em&gt;initNavigation&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&#34;createelement&#34;&gt;createElement&lt;/h3&gt;

&lt;p&gt;Este método da API JavaScript permite a criação de elementos que depois podem ser inseridos na árvore do DOM. É recomendado, por questões de performance, finalizar toda e qualquer manipulação antes de adicionar o elemento ao DOM.&lt;/p&gt;

&lt;h3 id=&#34;appendchild&#34;&gt;appendChild&lt;/h3&gt;

&lt;p&gt;O método appendChild adiciona um elemento criado a outro já existente na árvore do DOM. É semelhante aos métodos append/appendTo do jQuery.&lt;/p&gt;

&lt;h2 id=&#34;3-trilho&#34;&gt;3. Trilho&lt;/h2&gt;

&lt;p&gt;Nosso trilho é um elemento DIV com uma lista (UL) contendo as imagens do slider. A largura do DIV corresponde à largura da maior imagem, enquanto que a largura da lista representa a soma da largura de todas as imagens. Dessa forma, através do nosso CSS lá do início, a lista de imagens fica &amp;#8220;escondida&amp;#8221; atrás da DIV principal do trilho.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;JSliderStage.prototype.buildTrack = function () {
    this.sliderTrack = this.doc.createElement(&#39;div&#39;);
    this.sliderTrack.className = &#39;jslider-track&#39;;
    this.sliderTrack.style.height = this.pageHeight + &#39;px&#39;;
    return this;
};

JSliderStage.prototype.loadImages = function () {
    var i,
        li;

    this.imageList = this.doc.createElement(&#39;ul&#39;);
    this.imageList.style.width = (this.images.length * this.pageWidth) + &#39;px&#39;;

    for (i = 0; i &amp;lt; this.images.length; i += 1) {
        li = this.doc.createElement(&#39;li&#39;);
        li.style.width = this.pageWidth + &#39;px&#39;;
        li.style.height = this.pageHeight + &#39;px&#39;;
        li.appendChild(this.images[i]);
        this.imageList.appendChild(li);
    }

    this.sliderTrack.appendChild(this.imageList);
};&lt;/pre&gt;

&lt;h2 id=&#34;4-navegação&#34;&gt;4. Navegação&lt;/h2&gt;

&lt;p&gt;Finalizando nosso slide, precisamos implementar a navegação entre imagens. O método &lt;em&gt;initNavigation&lt;/em&gt; cria, caso necessário, os botões de anterior e próximo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;JSliderStage.prototype.initNavigation = function () {
    var positionTop = ((this.pageHeight / 2) - 40) + &#39;px&#39;;

    if (this.images.length &amp;lt; 2) {
        return this;
    }

    this.createNavigationButton(&#39;left&#39;, positionTop)
        .createNavigationButton(&#39;right&#39;, positionTop);

    this.navButtonsList = this.stage.querySelectorAll(&#39;.jslider-navigation&#39;);

    return this;
};

JSliderStage.prototype.createNavigationButton = function (direction, positionTop) {
    var navButton = this.doc.createElement(&#39;a&#39;),
        self = this,
        slidingLeft = (direction === &#39;left&#39;),
        page;

    navButton.className = &#39;jslider-navigation &#39; + direction + (slidingLeft ? &#39; off&#39; : &#39;&#39;);
    navButton.style.top = positionTop;
    navButton.href = &#39;#&#39;;
    navButton.innerHTML = (slidingLeft ? &#39;&amp;lsaquo;&#39; : &#39;&amp;rsaquo;&#39;);

    navButton.onclick = function (e) {
        e.preventDefault();
        page = (slidingLeft ? self.currentPage - 1 : self.currentPage + 1);
        self.gotoPage(page);
    };

    this.stage.appendChild(navButton);

    return this;
};&lt;/pre&gt;

&lt;p&gt;Já o método &lt;em&gt;gotoPage&lt;/em&gt; é responsável por carregar a imagem correta e habilitar/desabilitar os botões de navegação de acordo com a imagem atual.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;JSliderStage.prototype.gotoPage = function (page) {
    var marginLeft = (-1) * ((page - 1) * this.pageWidth);
    if (page &amp;lt; 1 || page &amp;gt; this.images.length) {
        return;
    }

    this.setNavigationState(page);

    this.imageList.style.marginLeft = marginLeft + &#39;px&#39;;
    this.currentPage = page;
};

JSliderStage.prototype.setNavigationState = function (page) {
    if (page === 1) {
        this.navButtonsList[0].classList.add(&#39;off&#39;);
        this.navButtonsList[1].classList.remove(&#39;off&#39;);
    } else {
        this.navButtonsList[0].classList.remove(&#39;off&#39;);
        if (page === this.images.length) {
            this.navButtonsList[1].classList.add(&#39;off&#39;);
        } else {
            this.navButtonsList[1].classList.remove(&#39;off&#39;);
        }
    }
};&lt;/pre&gt;

&lt;h3 id=&#34;escopo&#34;&gt;escopo&lt;/h3&gt;

&lt;p&gt;No método &lt;em&gt;createNavigationButton&lt;/em&gt; armazenamos o objeto &lt;em&gt;this&lt;/em&gt; na variável self. Isso é necessário porque precisamos referenciar o escopo anterior quando associamos a navegação no evento de clique dos links. Se tivéssemos utilizado diretamente o &lt;em&gt;this&lt;/em&gt;, estaríamos referenciando o escopo do clique, o que não era nosso objetivo. Além de self, é comum encontrar nomes como instance e that em variáveis que armazenam o escopo atual de um método.&lt;/p&gt;

&lt;h3 id=&#34;classlist&#34;&gt;classList&lt;/h3&gt;

&lt;p&gt;A propriedade classList permite a manipulação de classes em um elemento do DOM. Podemos consultar, remover a adicionar novas classes.&lt;/p&gt;

&lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;

&lt;p&gt;É claro que o código final é bem simples, mas a ideia principal era mostrar que nem sempre precisamos utilizar jQuery em nossas aplicações, mesmo com o jQuery disponível na estrutura do projeto.&lt;/p&gt;

&lt;p&gt;Finalizando, algumas melhorias que ficam de dever de casa para vocês:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;temporizador para trocar imagens, sendo configurável na inicialização do plugin&lt;/li&gt;
&lt;li&gt;suporte a browsers mais antigos, mantendo a funcionalidade&lt;/li&gt;
&lt;li&gt;carregamento de qualquer conteúdo nos slides, não só imagens&lt;/li&gt;
&lt;li&gt;navegação via teclado&lt;/li&gt;
&lt;li&gt;exibir miniaturas navegáveis&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.com.br/testando-seu-codigo-jquery-com-jasmine-parte-1/&#34; title=&#34;Testando seu código jQuery com Jasmine – Parte 1&#34;&gt;escrever testes com Jasmine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;código-completo-do-plugin&#34;&gt;Código completo do plugin&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://jsfiddle.net/jnQJu/&#34; target=&#34;_blank&#34;&gt;Nosso plugin em ação no jsFiddle&lt;/a&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;/*jslint browser:true */
&#39;use strict&#39;;

function JSlider(selector) {
    this.init(selector);
}

function JSliderStage(el) {
    this.doc = document;
    this.init(el);
}

JSlider.prototype.init = function (selector) {
    var elements = document.querySelectorAll(selector),
        i;

    this.slidersList = [];

    if (elements.length &amp;lt; 1) {
        return;
    }

    for (i = 0; i &amp;lt; elements.length; i += 1) {
        this.slidersList.push(new JSliderStage(elements[i]));
    }
};

JSliderStage.prototype.init = function (el) {
    this.root = el;
    this.currentPage = 1;
    this.images = this.root.querySelectorAll(&#39;img&#39;);

    if (this.images.length === 0) {
        return;
    }

    this.build();
};

JSliderStage.prototype.build = function () {
    this.getPageDimensions()
        .createStage()
        .initNavigation();
    this.root.innerHTML = &#39;&#39;;
    this.root.appendChild(this.stage);
};

JSliderStage.prototype.getPageDimensions = function () {
    var i;
    this.pageWidth = this.pageHeight = 0;
    for (i = 0; i &amp;lt; this.images.length; i += 1) {
        if (this.images[i].width &amp;gt; this.pageWidth) {
            this.pageWidth = this.images[i].width;
        }
        if (this.images[i].height &amp;gt; this.pageHeight) {
            this.pageHeight = this.images[i].height;
        }
    }
    return this;
};

JSliderStage.prototype.createStage = function () {
    this.stage = this.doc.createElement(&#39;div&#39;);
    this.stage.className = &#39;jslider-stage&#39;;
    this.stage.style.width = this.pageWidth + &#39;px&#39;;

    this.buildTrack()
        .loadImages();

    this.stage.appendChild(this.sliderTrack);

    return this;
};

JSliderStage.prototype.buildTrack = function () {
    this.sliderTrack = this.doc.createElement(&#39;div&#39;);
    this.sliderTrack.className = &#39;jslider-track&#39;;
    this.sliderTrack.style.height = this.pageHeight + &#39;px&#39;;
    return this;
};

JSliderStage.prototype.loadImages = function () {
    var i,
        li;

    this.imageList = this.doc.createElement(&#39;ul&#39;);
    this.imageList.style.width = (this.images.length * this.pageWidth) + &#39;px&#39;;

    for (i = 0; i &amp;lt; this.images.length; i += 1) {
        li = this.doc.createElement(&#39;li&#39;);
        li.style.width = this.pageWidth + &#39;px&#39;;
        li.style.height = this.pageHeight + &#39;px&#39;;
        li.appendChild(this.images[i]);
        this.imageList.appendChild(li);
    }

    this.sliderTrack.appendChild(this.imageList);
};

JSliderStage.prototype.initNavigation = function () {
    var positionTop = ((this.pageHeight / 2) - 40) + &#39;px&#39;;

    if (this.images.length &amp;lt; 2) {
        return this;
    }

    this.createNavigationButton(&#39;left&#39;, positionTop)
        .createNavigationButton(&#39;right&#39;, positionTop);

    this.navButtonsList = this.stage.querySelectorAll(&#39;.jslider-navigation&#39;);

    return this;
};

JSliderStage.prototype.createNavigationButton = function (direction, positionTop) {
    var navButton = this.doc.createElement(&#39;a&#39;),
        self = this,
        slidingLeft = (direction === &#39;left&#39;),
        page;

    navButton.className = &#39;jslider-navigation &#39; + direction + (slidingLeft ? &#39; off&#39; : &#39;&#39;);
    navButton.style.top = positionTop;
    navButton.href = &#39;#&#39;;
    navButton.innerHTML = (slidingLeft ? &#39;&amp;lsaquo;&#39; : &#39;&amp;rsaquo;&#39;);

    navButton.onclick = function (e) {
        e.preventDefault();
        page = (slidingLeft ? self.currentPage - 1 : self.currentPage + 1);
        self.gotoPage(page);
    };

    this.stage.appendChild(navButton);

    return this;
};

JSliderStage.prototype.gotoPage = function (page) {
    var marginLeft = (-1) * ((page - 1) * this.pageWidth);
    if (page &amp;lt; 1 || page &amp;gt; this.images.length) {
        return;
    }

    this.setNavigationState(page);

    this.imageList.style.marginLeft = marginLeft + &#39;px&#39;;
    this.currentPage = page;
};

JSliderStage.prototype.setNavigationState = function (page) {
    if (page === 1) {
        this.navButtonsList[0].classList.add(&#39;off&#39;);
        this.navButtonsList[1].classList.remove(&#39;off&#39;);
    } else {
        this.navButtonsList[0].classList.remove(&#39;off&#39;);
        if (page === this.images.length) {
            this.navButtonsList[1].classList.add(&#39;off&#39;);
        } else {
            this.navButtonsList[1].classList.remove(&#39;off&#39;);
        }
    }
};&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Otimizando seu site em WordPress para SEO</title>
      <link>https://tableless.github.io/hugo-public/otimizando-site-wordpress-seo/</link>
      <pubDate>Thu, 17 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/otimizando-site-wordpress-seo/</guid>
      <description>

&lt;p&gt;Uma característica que defina o WordPress é a &lt;strong&gt;customização&lt;/strong&gt;. Em poucas linhas conseguimos soluções significantes. Seja trabalhando com suas funções ou com seus plugins, temos resultados objetivos para preparar um Blog e até mesmo um site de grande porte, como temos hoje, vários exemplos disso.&lt;/p&gt;

&lt;p&gt;Elogiam muito o WordPress por ele ter uma facilidade para &lt;a href=&#34;http://www.oitobitdigital.com.br/servico/otimizacao-de-sites-seo/&#34;&gt;otimização de sites&lt;/a&gt; (SEO). Antes de começarem a ler as dicas que vou citar, faça a seguinte reflexão: O que é um site hoje, sem ser bem indexado pelos mecanismos de busca?&lt;/p&gt;

&lt;h3 id=&#34;melhore-a-tag-title-do-seu-site&#34;&gt;Melhore a tag title do seu site&lt;/h3&gt;

&lt;p&gt;Você acha mesmo que a tag de título do seu site não tem importância? Espero que não, pois é com ela que os mecanismos de busca reconhecem uma das primeiras informações do seu site.&lt;/p&gt;

&lt;p&gt;Coloque o seu título da seguinte forma:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;php&amp;#8221;]&lt;/p&gt;

&lt;p&gt;&lt;title&gt;
  &amp;lt;?php wp_title(“|”, true, ‘right’); ?&amp;gt;&amp;lt;?php bloginfo(‘name’); ?&amp;gt;
&lt;/title&gt;[/cce]&lt;/p&gt;

&lt;p&gt;A função &lt;strong&gt;wp_title&lt;/strong&gt; imprime vários resultados a depender da sua página.&lt;/p&gt;

&lt;h3 id=&#34;links-permanentes-permalinks&#34;&gt;Links permanentes (Permalinks)&lt;/h3&gt;

&lt;p&gt;Quem usa WordPress e não usa essa função básica, não sabe o que está perdendo. A URL também tem uma função importante para indexação de sites, pois também é reconhecido antes da página ser carregada. O seu site sairia na frente de diversas URL’s que usam aqueles parâmetros grandes e sem semântica.&lt;/p&gt;

&lt;p&gt;Dentro de seu painel de administração, procure por Settings (Configurações) e depois Links Permanentes (Permalinks). Selecione a opção Custom Structure (Estrutura Personalizada) e altere sua estrutura para:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;html&amp;#8221;]/%category%/%postname%/[/cce]&lt;/p&gt;

&lt;h3 id=&#34;otimizando-as-metas-do-seu-site&#34;&gt;Otimizando as metas do seu site&lt;/h3&gt;

&lt;p&gt;Para otimizar as metas, utilize o plug-in &lt;a href=&#34;http://wordpress.org/extend/plugins/all-in-one-seo-pack/&#34; title=&#34;Plug-in All in One SEO Pack&#34;&gt;All in One SEO Pack&lt;/a&gt;, com esse plug-in conseguimos facilmente manipular as metas e também títulos do site. Com ele, alteram-se as metas de descrição e keywords (palavras-chave) da página inicial e também dos posts, além dos títulos de cada página.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://wordpress.org/extend/plugins/all-in-one-seo-pack/&#34; title=&#34;Plug-in All in One SEO Pack&#34;&gt;Baixe o plug-in&lt;/a&gt;, instale-o e ative.&lt;/p&gt;

&lt;h3 id=&#34;mecanismos-de-busca-odeiam-spam&#34;&gt;Mecanismos de busca odeiam SPAM&lt;/h3&gt;

&lt;p&gt;Os mecanismos de busca odeiam SPAM, ou seja, odeiam conteúdo ruim e/ou desnecessário. Existe um plug-in que modera spam no seu site, chama-se Akismet. Geralmente ele já é incluído quando você instala o WordPress, mas caso não encontre depois que instalar, &lt;a href=&#34;http://wordpress.org/extend/plugins/akismet/&#34; title=&#34;Akismet plug-in&#34;&gt;baixe-o&lt;/a&gt; e ative-o.&lt;/p&gt;

&lt;p&gt;Para usar do plug-in é necessário resgatar um código gerado pelo &lt;a href=&#34;http://akismet.com/&#34; title=&#34;Site Akismet&#34;&gt;site&lt;/a&gt; deles.&lt;/p&gt;

&lt;h3 id=&#34;use-semântica-no-seu-código&#34;&gt;Use semântica no seu código&lt;/h3&gt;

&lt;p&gt;Do que adianta ter todos esses aperfeiçoamentos no seu site e seu site não estiver com um código semântico? Por isso trabalhe com um código de qualidade para que não haja dificuldade para seu código ser lido pelos mecanismos de busca.&lt;/p&gt;

&lt;p&gt;Use alt e title para as imagens, não esqueçam, pois as imagens só podem ser lidas desta maneira. Trabalhe bem com as tags de título &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt;, e estabeleça uma hierarquia entre elas.&lt;/p&gt;

&lt;h3 id=&#34;utilize-sempre-um-plug-in-de-cache&#34;&gt;Utilize sempre um plug-in de cache&lt;/h3&gt;

&lt;p&gt;A partir da demanda do seu site e ele for crescendo em questão de conteúdo, é sempre bom ter um plug-in de cache para diminuir o carregamento da sua página, sendo assim os mecanismos de busca não terão dificuldades para carregar seu site.&lt;/p&gt;

&lt;p&gt;Indico &lt;a href=&#34;http://wordpress.org/extend/plugins/wp-super-cache/&#34; title=&#34;WP Super Cache&#34;&gt;WP Super Cache&lt;/a&gt;, &lt;a href=&#34;http://wordpress.org/extend/plugins/wp-super-cache/&#34; title=&#34;W3 Total Cache&#34;&gt;W3 Total Cache&lt;/a&gt;, &lt;a href=&#34;http://wordpress.org/extend/plugins/batcache/&#34; title=&#34;Batcache&#34;&gt;Batcache&lt;/a&gt; ou &lt;a href=&#34;http://wordpress.org/extend/plugins/hyper-cache/&#34; title=&#34;Hyper Cache&#34;&gt;Hyper Cache.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tenho certeza que com um deles, seu site estará em boas mãos em relação ao cache.&lt;/p&gt;

&lt;h3 id=&#34;sitemaps-mapa-do-site&#34;&gt;Sitemaps (mapa do site)&lt;/h3&gt;

&lt;p&gt;Para os mecanismos de busca, um sitemap ajuda nas buscas de páginas, pois ele relaciona as URL existentes no seu site. Leia esse &lt;a href=&#34;http://tableless.com.br/seo-sitemaps&#34; title=&#34;Artigo SEO Sitemaps Tableless&#34;&gt;artigo&lt;/a&gt; e veja o porquê do uso de sitemaps.&lt;/p&gt;

&lt;p&gt;O WordPress tem um plug-in que gera um sitemap já otimizado para mecanismos de busca.&lt;/p&gt;

&lt;p&gt;Use o &lt;a href=&#34;http://wordpress.org/extend/plugins/google-sitemap-generator/&#34; title=&#34;Plug-in Google SiteMap Generator&#34;&gt;Google SiteMap Generator&lt;/a&gt; e não tenha possíveis problemas para este assunto.&lt;/p&gt;

&lt;h3 id=&#34;crie-um-bom-meta-robôs&#34;&gt;Crie um bom Meta Robôs&lt;/h3&gt;

&lt;p&gt;É importante você ter um robots.txt na raiz do seu site, que é um arquivo funciona como filtro para os Crawlers e os robôs dos mecanismos de busca, permitindo ou não acesso a páginas do seu site.&lt;/p&gt;

&lt;p&gt;Crie um arquivo em txt, chamado robots.txt com o seguinte código:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;html&amp;#8221;]&lt;/p&gt;

&lt;p&gt;User-agent: *&lt;/p&gt;

&lt;p&gt;Disallow: /cgi-bin&lt;/p&gt;

&lt;p&gt;Disallow: /wp-admin&lt;/p&gt;

&lt;p&gt;Disallow: /wp-includes&lt;/p&gt;

&lt;p&gt;Disallow: /wp-content/plugins&lt;/p&gt;

&lt;p&gt;Disallow: /wp-content/cache&lt;/p&gt;

&lt;p&gt;Disallow: /wp-content/themes&lt;/p&gt;

&lt;p&gt;Disallow: /trackback&lt;/p&gt;

&lt;p&gt;Disallow: /feed&lt;/p&gt;

&lt;p&gt;Disallow: /comments&lt;/p&gt;

&lt;p&gt;Disallow: /category/*/*&lt;/p&gt;

&lt;p&gt;Disallow: */trackback&lt;/p&gt;

&lt;p&gt;Disallow: */feed&lt;/p&gt;

&lt;p&gt;Disallow: */comments&lt;/p&gt;

&lt;p&gt;Disallow: /*?*&lt;/p&gt;

&lt;p&gt;Disallow: /*?&lt;/p&gt;

&lt;p&gt;Allow: /wp-content/uploads&lt;/p&gt;

&lt;p&gt;# Google Image&lt;/p&gt;

&lt;p&gt;User-agent: Googlebot-Image&lt;/p&gt;

&lt;p&gt;Disallow:&lt;/p&gt;

&lt;p&gt;Allow: /*&lt;/p&gt;

&lt;p&gt;# Google AdSense&lt;/p&gt;

&lt;p&gt;User-agent: Mediapartners-Google*&lt;/p&gt;

&lt;p&gt;Disallow:&lt;/p&gt;

&lt;p&gt;Allow: /*&lt;/p&gt;

&lt;p&gt;# digg mirror&lt;/p&gt;

&lt;p&gt;User-agent: duggmirror&lt;/p&gt;

&lt;p&gt;Disallow: /&lt;/p&gt;

&lt;p&gt;Sitemap: &lt;a href=&#34;http://www.seusite.com.br/sitemap.xml&#34;&gt;http://www.seusite.com.br/sitemap.xml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;p&gt;Envie para o servidor e ponha na raiz do seu site.&lt;/p&gt;

&lt;p&gt;E no header.php do seu tema, adicione o código:&lt;/p&gt;

&lt;p&gt;[cce lang=&amp;#8221;php&amp;#8221;]&lt;/p&gt;

&lt;p&gt;&amp;lt;?php&lt;/p&gt;

&lt;p&gt;if(is_single() || is_page() || is_category() || is_home()) {&lt;/p&gt;

&lt;p&gt;echo &amp;#8216;&lt;meta name=&amp;#8221;robots&amp;#8221; content=&amp;#8221;all,noodp&amp;#8221; /&gt;&amp;#8217;;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;else if(is_archive()) {&lt;/p&gt;

&lt;p&gt;echo &amp;#8216;&lt;meta name=&amp;#8221;robots&amp;#8221; content=&amp;#8221;noarchive,noodp&amp;#8221; /&gt;&amp;#8217;;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;else if(is_search() || is_404()) {&lt;/p&gt;

&lt;p&gt;echo &amp;#8216;&lt;meta name=&amp;#8221;robots&amp;#8221; content=&amp;#8221;noindex,noarchive&amp;#8221; /&gt;&amp;#8217;;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;?&amp;gt;&lt;/p&gt;

&lt;p&gt;[/cce]&lt;/p&gt;

&lt;h3 id=&#34;faça-um-bom-conteúdo&#34;&gt;Faça um bom conteúdo&lt;/h3&gt;

&lt;p&gt;Não adianta ter um site todo otimizado para os mecanismos e eles não terem o que buscar de conteúdo no seu site. Fazer um bom conteúdo é essencial para qualquer indexação de artigo, página, textos ect.&lt;/p&gt;

&lt;p&gt;Também não se esqueça de trabalhar com as redes sociais, pois maior quantidade de links gerados para o seu site, maior relevância ele terá.&lt;/p&gt;

&lt;p&gt;Seja sempre objetivo e claro na suas publicações, tenho certeza que terá um bom resultado. Vale ressaltar que o Google está punindo quem copia conteúdo, muito cuidado.&lt;/p&gt;

&lt;p&gt;Caso tenha futuras dúvidas, o WordPress oferece no seu codex um &lt;a href=&#34;http://codex.wordpress.org/Search_Engine_Optimization_for_WordPress&#34; title=&#34;Guia para otimização de SEO WordPress&#34;&gt;guia para otimização de SEO&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Anatomia de um plugin jQuery</title>
      <link>https://tableless.github.io/hugo-public/anatomia-de-um-plugin-jquery/</link>
      <pubDate>Tue, 14 Sep 2010 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/anatomia-de-um-plugin-jquery/</guid>
      <description>

&lt;p&gt;Um dos grandes trunfos do jQuery é a sua vasta gama de plugins. Praticamente qualquer efeito, ação ou manipulação que você consiga imaginar já deve possuir um plugin. Caso contrário, quem sabe você mesmo não desenvolve um?&lt;/p&gt;

&lt;p&gt;Neste artigo, você confere técnicas de como criar o seu próprio plugin. Vamos ver dois exemplos. O primeiro plugin adiciona classes ao primeiro e último ítem de uma lista, tabela, div etc. e o segundo simula a busca por textos do navegador Safari (aquele highlight bacana, como um marcador de textos, no termo procurado).&lt;/p&gt;

&lt;p&gt;Vale lembrar ainda a importáncia de conhecer pelo menos um pouco de JavaScript antes de começar a trabalhar a fundo com jQuery.&lt;/p&gt;

&lt;h4 id=&#34;o-que-é-e-como-funciona-um-plugin-jquery&#34;&gt;O que é e como funciona um plugin jQuery?&lt;/h4&gt;

&lt;p&gt;Existem dois tipos de plugins: as funções e os métodos públicos. A função é anexada diretamente ao objeto jQuery e fica sem acesso a qualquer atributo/elemento encadeado.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;jQuery.titulo = function(campeonato) {
         if($(&#39;div#flamengo&#39;).html()) {
             $(&#39;div#flamengo&#39;).append(campeonato);
         } else {
             alert(campeonato);
         }
     };&lt;/pre&gt;

&lt;p&gt;A função criada acima recebe um parâmetro &lt;strong&gt;campeonato&lt;/strong&gt; e busca a existência de uma div com o id &amp;#8220;flamengo&amp;#8221; (o método &lt;strong&gt;.html()&lt;/strong&gt; retorna null quando o elemento não está presente, logo é uma ótima maneira de validar sua existência). Se encontrar a div, ele adiciona o parâmetro passado ao seu conteúdo. Caso não encontre, nossa função utiliza o bom e velho &lt;strong&gt;alert()&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Para ser executada, a função titulo precisaria ser chamada assim:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$.titulo(&#39;Mundial 81&#39;);&lt;/pre&gt;

&lt;p&gt;O tipo de plugin acima deve ser desenvolvido apenas quando o mesmo for um utilitário, ou seja, que não necessite herdar propriedades do seletor. Um bom exemplo é o método isArray da API do jQuery.&lt;/p&gt;

&lt;p&gt;Já plugins desenvolvidos como método público herdam toda a cadeia de propriedades e elementos disponíveis. Isso porque ele é chamado diretamente em um seletor jQuery. Dentro desse método, o termo &lt;strong&gt;this&lt;/strong&gt; representa o objeto jQuery selecionado. É dessa forma que, provavelmente, você vai desenvolver a maioria dos seus plugins e é assim também que vamos desenvolver nossos plugins nesse tutorial.&lt;/p&gt;

&lt;p&gt;Como ficaria nossa função titulo transformada em um método público do jQuery?&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;jQuery.fn.titulo = function(campeonato){
        this.append(campeonato);
        return this;
     };&lt;/pre&gt;

&lt;p&gt;A nova versão do plugin seria executada da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;#flamengo&#39;).titulo(&#39;Libertadores 2011&#39;);&lt;/pre&gt;

&lt;p&gt;Muito parecido com os plugins de jQuery que você já implementou em seus sites, certo? Note que utilizamos o nome jQuery por extenso. Poderíamos ter utilizado seu apelido: $.fn.titulo = function([&amp;#8230;]. No entanto, quando você precisar do jQuery no modo &lt;strong&gt;no conflict&lt;/strong&gt; (com outros frameworks), é importante utilizar o nome por extenso para o plugin funcionar corretamente. Outra observação importante é nunca esquecer o ponto e vírgula ao final da função, senão o plugin não funciona quando o código for compactado. E, por último, é interessante que seu plugin sempre retorne o objeto jQuery (this), possibilitando assim o encadeamento com outros métodos.&lt;/p&gt;

&lt;p&gt;O problema em utilizar a palavra jQuery e não o apelido ($) é que você precisaria utilizar sempre a palavra dentro do seu método para referenciar o framework. Para resolver isso, vamos utilizar uma função anônima, recurso muito legal do JavaScript, encapsulando nosso plugin. A função anônima recebe como parâmetro o objeto jQuery. Dentro dela, uma outra função engloba o plugin &amp;#8220;convertendo&amp;#8221; o objeto para seu apelido normal. O cifrão ($), nesse caso, pode ser qualquer apelido que você queira trabalhar dentro do seu plugin.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;(function($) {
        // $ é o jQuery no escopo do plugin
        // Poderia ser qualquer apelido
        $.fn.titulo= function(campeonato){
            this.append(campeonato);
            return this;
         };
     })(jQuery);&lt;/pre&gt;

&lt;p&gt;Acima temos um modelo quase ideal para nossos plugins (ainda faltam as opções, veremos mais adiante).&lt;/p&gt;

&lt;p&gt;Agora que vimos a estrutura básica, vamos estabelecer algumas metas para nossos plugins:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Reutilizável:&lt;/strong&gt; o principal objetivo de um plugin é que ele venha a ser utilizado por mais de um projeto, mais de uma pessoa. Não adianta desenvolver um plugin muito específico;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leve &amp;amp; rápido:&lt;/strong&gt; tamanho é sempre documento no caso de JavaScript e arquivos web em geral. Aqui quanto menor, melhor. O plugin também deve ser otimizado para trabalhar com 1 ou 100 elementos;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexível:&lt;/strong&gt; fácil de adaptar, com diversas opções. Tenha isso em mente quando for desenvolver um plugin. Evite utilizar IDs de elementos, nomes, classes e cores fixas.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;meu-primeiro-plugin-jquery-fila&#34;&gt;Meu primeiro plugin: jquery.fila()&lt;/h4&gt;

&lt;p&gt;Não existe melhor maneira para aprender do que na prática, vamos então desenvolver nosso primeiro plugin. Para todo elemento que possua &amp;#8220;filhos&amp;#8221;, por exemplo uma lista ou uma tabela, o plugin vai adicionar uma classe ao primeiro e ao último ítem. Nosso plugin vai receber como opções os nomes das classes a serem adicionadas.&lt;/p&gt;

&lt;p&gt;Vamos chamar nosso plugin de fila (FIrst-LAst). Ele terá um conjunto de opções básicas e, utilizando a função jQuery .extend, sobreescreverá o conjunto com opções passadas na chamada do plugin. As classes &amp;#8216;first&amp;#8217; e &amp;#8216;last&amp;#8217; serão adicionadas caso o plugin seja executado sem nenhum parâmetro.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;(function($){
    $.fn.fila = function(opcoes) {

     // opções padrão
     var defaults = {
         first: &#39;first&#39;,
         last: &#39;last&#39;
     };

     opcoes = $.extend(defaults, opcoes);

    };
})(jQuery);&lt;/pre&gt;

&lt;p&gt;Agora só precisamos varrer o seletor em busca de elementos que possuam &amp;#8220;filhos&amp;#8221;. Quando existir uma classe definida nas opções, o plugin adicionará a mesma aos elementos encontrados. Note que estamos utilizando os seletores &amp;#8216;:first-child&amp;#8217; e &amp;#8216;:last-child&amp;#8217; para buscar o primeiro e o último filho e adicionar as classes especificadas nas opções.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;return this.each(function(){
         if(opcoes.first) $(this).find(&#39;:first-child&#39;).addClass(opcoes.first);
         if(opcoes.last) $(this).find(&#39;:last-child&#39;).addClass(opcoes.last);
     });&lt;/pre&gt;

&lt;h5 id=&#34;jquery-fila-js&#34;&gt;jQuery.fila.js&lt;/h5&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;(function($){
    $.fn.fila = function(opcoes) {

     // opções padrão
     var defaults = {
         first: &#39;first&#39;,
         last: &#39;last&#39;
     };

     opcoes = $.extend(defaults, opcoes);

     return this.each(function(){
         if(opcoes.first) $(this).find(&#39;:first-child&#39;).addClass(opcoes.first);
         if(opcoes.last) $(this).find(&#39;:last-child&#39;).addClass(opcoes.last);
     });

    };
})(jQuery);&lt;/pre&gt;

&lt;p&gt;Exemplos de uso do plugin:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// define ambas as classes
     $(&#39;ul&#39;).fila({
        first: &#39;primeiro&#39;,
        last: &#39;ultimo&#39;
     });

     // opções padrão
     $(&#39;#resultado tbody&#39;).fila();

     // marca apenas o último filho
     $(&#39;div&#39;).fila({
        first: null,
        last: &#39;omega&#39;
     });&lt;/pre&gt;

&lt;h4 id=&#34;marcando-textos-com-estilo&#34;&gt;Marcando textos com estilo&lt;/h4&gt;

&lt;p&gt;Nosso segundo plugin de exemplo vai fazer o seguinte: pesquisar por um termo em um texto e destacar os resultados. Começamos com um pouco de CSS, que vai servir para a nossa marcação:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;span.marcaTexto {
        position: relative;
        z-index: 180!important;
        -moz-box-shadow: 0 0 1em #889;
        -webkit-box-shadow: 0 0 1em #888;
        box-shadow: 0 0 1em #889;
        padding: 4px;
    }&lt;/pre&gt;

&lt;p&gt;A ideia é adicionar o texto ao span marcaTexto, que também será o nome do plugin, mas você poderá utilizar a classe que quiser (essa opção estará presente na configuração). Uma das diferenças desse plugin em relação ao primeiro exemplo é que vamos aceitar tanto uma palavra como um conjunto de opções, dessa forma a chamada pode ser feita só com o termo a ser pesquisado ou com todas as opções disponíveis.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// opções padrão
     var defaults = {
         termo: &#39;&#39;,
         corTexto: &#39;#000&#39;,
         corFundo: &#39;#ffff00&#39;,
         classe: &#39;marcaTexto&#39;
     };

     // se o parâmetro passado for um array, carrega as opções
     if( $.isArray( opcoes ) )
     {
         opcoes = $.extend(defaults, opcoes);
     }
     // caso seja string, o usuário passou apenas o termo a ser marcado
     else
     {
         defaults.termo = opcoes;
         opcoes = defaults;
     }&lt;/pre&gt;

&lt;p&gt;Utilzamos a função jQuery.isArray para identificar se o parâmetro passado é um array ou uma string e assim definimos como tratar as opções. Além do termo a ser pesquisado, o plugin também pode receber as cores do texto e do fundo do span, além da classe CSS que define a estrutura básica da marcação.&lt;/p&gt;

&lt;p&gt;Uma das dificuldades deste plugin é tratar tags HTML. Pra não complicar muito o exemplo, vamos simplesmente remover qualquer tag presente no texto utilizando a função text(). Para a pesquisa, um pouquinho de expressões regulares &amp;#8211; precisamos verificar se o termo a ser pesquisado existe no seletor. Caso exista, o plugin entra em ação e marca o texto com o span e suas opções definidas anteriormente.&lt;/p&gt;

&lt;h5 id=&#34;jquery-marcatexto-js&#34;&gt;jquery.marcaTexto.js&lt;/h5&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;(function($){
    $.fn.marcaTexto = function(opcoes) {
     // opções padrão
     var defaults = {
         termo: &#39;&#39;,
         corTexto: &#39;#000&#39;,
         corFundo: &#39;#ffff00&#39;,
         classe: &#39;marcaTexto&#39;
     };

     // se o parâmetro passado for um array, carrega as opções
     if( $.isArray( opcoes ) )
     {
         opcoes = $.extend(defaults, opcoes);
     }
     // caso seja string, o usuário passou apenas o termo a ser marcado
     else
     {
         defaults.termo = opcoes;
         opcoes = defaults;
     }

     // varre o seletor passado
     return this.each(function(){
         // armazena o texto do elemento
         var content = $(this).text();
         // pesquisa por termo no texto
         var re = new RegExp( opcoes.termo, &#39;i&#39; );
         var result = content.match( re );
         // caso tenha encontrado ocorrências do texto...
         if( result )
         {
             // busca novamente, só que agora adicionando a marcação ao(s) termo(s)
             re = new RegExp( opcoes.termo, &#39;gi&#39; );
             content = content.replace( re, &#39;&amp;lt;span class=&#34;&#39; + opcoes.classe + &#39;&#34; style=&#34;color: &#39; + opcoes.cortexto + &#39;;background-color: &#39; + opcoes.corfundo + &#39;&#34;&amp;gt;&#39; + opcoes.termo + &#39;&amp;lt;/span&amp;gt;&#39;);
             // altera o HTML do elemento original
             $(this).html( content );
         }
     });

    };
})(jQuery);&lt;/pre&gt;

&lt;p&gt;Esse plugin tem diversas &amp;#8220;falhas&amp;#8221; que vão ficar de dever de casa. Por exemplo, atualmente ele ignora maiúsculas e minúsculas. Poderíamos ter uma opção definindo que tipo de busca utilizar, case sensitive ou insenstive. Outra falha é que ele busca qualquer elemento, mesmo um que não tenha conteúdo. Para esses casos, como um table, ele deveria buscar o conteúdo em seus filhos. E, conforme mencionado anteriormente, é necessário fazer com que o plugin preserve as tags HTML encontradas no texto.&lt;/p&gt;

&lt;h4 id=&#34;compartilhe-seus-plugins&#34;&gt;Compartilhe seus plugins!&lt;/h4&gt;

&lt;p&gt;No início pode ser um pouco difícil saber identificar o que é transformado em um plugin e o que continua como um simples trecho de código. O que eu costumo fazer, até para praticar, é olhar elementos em interfaces de aplicativos: filtros, pesquisas, animações, botões. Aplicativos desktop são uma ótima inspiração para o desenvolvimento de plugins jQuery.&lt;/p&gt;

&lt;p&gt;Espero que esse tutorial tenha explicado bem a arte de desenvolver plugins para jQuery e espero ainda mais que vocês possam criar e compartilhar novos plugins, a comunidade web brasileira precisa disso.&lt;/p&gt;

&lt;p&gt;E, não esqueça: se você já tiver desenvolvido um plugin, deixe o link nos comentários.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2010/09/plugins.zip&#34;&gt;Download dos plugins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.github.com/exemplos/anatomia-plugin-jquery/fila.html&#34;&gt;Exemplo online: jquery.fila&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tableless.github.com/exemplos/anatomia-plugin-jquery/&#34;&gt;Exemplo online: jquery.marcaTexto&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>