<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on Tableless</title>
    <link>http://tableless.com.br/tags/go/index.xml</link>
    <description>Recent content in Go on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="http://tableless.com.br/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Por que utilizar Go/Golang no seu backend?</title>
      <link>http://tableless.com.br/por-que-utilizar-gogolang-no-seu-backend/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/por-que-utilizar-gogolang-no-seu-backend/</guid>
      <description>

&lt;p&gt;O tempo passa e quando você é viciado no que faz, no meu caso, codar, a busca por se aprimorar ou descobrir novas maneiras de resolver os problemas da sua área nunca param, assim sendo, um belo dia, cheguei até o &lt;strong&gt;Go&lt;/strong&gt; e desde então não parei mais de aprender sobre a linguagem. A ideia é a cada semana fazer um post sobre, iniciando agora com uma simples introdução e sugestões de artigos para se animar.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;http://synflood.at/tmp/golang-slides/images/gophercolor.png&#34; alt=&#34;Imagem do gopher&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;o-que--gogolang&#34;&gt;O que é Go/Golang?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Go&lt;/strong&gt; ou &lt;strong&gt;Golang&lt;/strong&gt; &amp;#8211; termo que facilita buscas no google &amp;#8211; é uma linguagem &lt;em&gt;open source&lt;/em&gt; criada em 2009 pelo &lt;strong&gt;Google&lt;/strong&gt;, mais especificamente por caras como &lt;em&gt;Rob Pike&lt;/em&gt; e &lt;em&gt;Ken Thompson&lt;/em&gt;. Caso você não conheça, são engenheiros renomados, que tiveram grande influência na história da computação e em projetos &lt;em&gt;open source&lt;/em&gt; de grande escala, pra citar um bem &amp;#8220;simples&amp;#8221;: &lt;strong&gt;Unix&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Só por esta constatação, você já poderia largar tudo e seguir os passos deles cegamente, afinal, Rob e Ken provavelmente não estariam trabalhando em algo meia boca. Brincadeiras à parte, a Go foi criada com objetivos simples, dentre os principais, ter a rapidez do C, mas ser um pouco mais legível e/ou fácil de programar. Inclusive, nos meus primeiros passos com a linguagem, pude sentir exatemente isso. &lt;a href=&#34;https://www.youtube.com/watch?v=FTl0tl9BGdc&#34; target=&#34;_blank&#34;&gt;Aqui&lt;/a&gt; tem um vídeo bem massa do Rob dizendo o porquê você deve aprender Go.&lt;/p&gt;

&lt;h3 id=&#34;por-que-eu-usaria-go&#34;&gt;Por que eu usaria Go?&lt;/h3&gt;

&lt;p&gt;Acima, eu disse algumas vantagens de utilizar a linguagem, porém, a lista é bem mais vasta. Tentarei compilar os pontos que mais me chamam atenção e que possivelmente seriam casos de uso para você utilizá-la:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Go é incrivelmente ‘leve’ em termos de uso de memória. Existe &lt;a href=&#34;http://www.iron.io/how-we-went-from-30-servers-to-2-go/&#34; target=&#34;_blank&#34;&gt;um caso conhecido&lt;/a&gt; de uma companhia que rodava um serviço em Ruby utilizando 50 servidores e foram para 2 com Go.&lt;/li&gt;
&lt;li&gt;Concorrência é um dos pontos fortes da linguagem, se você precisar sobrecarregar um backend com diversos processamentos simultâneos, as &lt;code&gt;goroutines&lt;/code&gt; e &lt;code&gt;channels&lt;/code&gt; &lt;a href=&#34;https://matt.aimonetti.net/posts/2012/11/27/real-life-concurrency-in-go/&#34; target=&#34;_blank&#34;&gt;vão te ajudar bastante&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Compila muito rápido.&lt;/li&gt;
&lt;li&gt;Tem &lt;em&gt;garbage collector&lt;/em&gt;, você não precisa se preocupar tanto com memória como nos seus dias de C.&lt;/li&gt;
&lt;li&gt;É fortemente tipada. (eu pelo menos acho isso bom, phpeiros)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;quem-est-usando-go&#34;&gt;Quem está usando Go?&lt;/h3&gt;

&lt;p&gt;Existe uma infinidade de empresas que ao descobrirem os poderes mágicos de Go, foram migrando seus serviços/backend. Abaixo algumas grandes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Uber &amp;#8211; &lt;a href=&#34;https://eng.uber.com/go-geofence/&#34; target=&#34;_blank&#34;&gt;How we built uber engineering’s highest query per second service using Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Docker &amp;#8211; &lt;a href=&#34;http://pt.slideshare.net/jpetazzo/docker-and-go-why-did-we-decide-to-write-docker-in-go&#34; target=&#34;_blank&#34;&gt;Why did we decide to write Docker in Go?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Dropbox &amp;#8211; &lt;a href=&#34;https://blogs.dropbox.com/tech/2014/07/open-sourcing-our-go-libraries/&#34; target=&#34;_blank&#34;&gt;Open sourcing our Go libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OpenShift &amp;#8211; &lt;a href=&#34;https://blog.gopheracademy.com/birthday-bash-2014/openshift-3-old-dogs-new-tricks/&#34; target=&#34;_blank&#34;&gt;OpenShift3 and Go &amp;#8211; Teaching Old Dogs New Tricks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Twitter &amp;#8211; &lt;a href=&#34;https://blog.twitter.com/2015/handling-five-billion-sessions-a-day-in-real-time&#34; target=&#34;_blank&#34;&gt;Handling five billion sessions a day – in real time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enfim, existem muito mais empresas que se importam e/ou tem necessidade de melhorar a performance de seus serviços e grande parte delas estão olhando para Go e outras linguagens com poderes maiores do que as ‘enterprise languages’ que vemos há anos por aí nas grandes empresas do país.&lt;/p&gt;

&lt;p&gt;Espero que o post tenha sido informativo e inspirador para você descobrir mais sobre a linguagem Go.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Iniciando com o Docker: Criando suas próprias imagens</title>
      <link>http://tableless.com.br/iniciando-com-o-docker-criando-suas-proprias-imagens/</link>
      <pubDate>Thu, 28 Apr 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/iniciando-com-o-docker-criando-suas-proprias-imagens/</guid>
      <description>

&lt;p&gt;No artigo &lt;a href=&#34;http://tableless.com.br/iniciando-com-o-docker-dicas-praticas-para-comecar-usar-agora-mesmo/&#34; target=&#34;_blank&#34;&gt;anterior&lt;/a&gt;, eu descrevi alguns comandos básicos e como iniciar com o pé direito no mundo do &lt;strong&gt;Docker&lt;/strong&gt;, trazendo de forma direta alguns conceitos que com o passar do tempo se tornaram fundamentais no meu fluxo de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Hoje eu quero partir um pouco mais para o lado prático da coisa, vamos construir uma imagem para encapsular uma pequena aplicação em &lt;strong&gt;GO&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;primeiros-passos&#34;&gt;Primeiros passos&lt;/h2&gt;

&lt;p&gt;O arquivo de manifesto do Docker é o Dockerfile, nele você coloca as instruções de como você quer que sua imagem seja construída. Você pode na construção da imagem setar outro arquivo com o parâmetro -f.&lt;/p&gt;

&lt;p&gt;Abaixo temos um exemplo de Dockerfile, esse é um exemplo de um app em go já compilado para ubuntu então eu só preciso copiar o arquivo executável elasticpush para dentro do docker:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;FROM debian:jessie
RUN mkdir /app
ENV ACCESS_TOKEN abc
ENV SECRET_TOKEN xyz
COPY ./bin/elasticpush /app/elasticpush
ENTRYPOINT [“/app/elasticpush”]
&lt;/pre&gt;

&lt;p&gt;Detalhando os comandos utilizados:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FROM&lt;/strong&gt;: Este é o comando mais importante, pois ele especifica a imagem base para a construção de uma nova. Na maioria das vezes a imagem especificada vai ser uma distribuição linux, se essa imagem não for encontrada na máquina local, o docker tentará buscar em algum repository. Caso queira, por exemplo, fazer a build do seu app em GO dentro do container, você vai precisar de uma imagem que tenha o GO instalado e configurado. Outra forma também seria criar diversas instruções com o comando &lt;em&gt;RUN&lt;/em&gt; para fazer essa instalação.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RUN&lt;/strong&gt;: Esse comando serve para executar outros comandos que a versão do sistema operacional permite. Por exemplo, se for debian vc pode instalar pacotes com apt-get, se for CentOS você pode utilizar o yum para pegar as dependências que seu serviço precisa para rodar. Com o RUN você também pode criar arquivos, pastas, enfim acho que deu pra entender que ele executa os mesmo comando do que você executaria na sua máquina, logo você consegue fazer praticamente tudo, e deixar a sequência de comandos versionada aqui dentro.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ENV&lt;/strong&gt;: Serve para você setar variáveis de ambiente, você pode tanto deixar essas variáveis setadas de forma fixa dentro do Dockerfile quanto passá-las dinamicamente na hora que você instanciar o container. Para passar essas variáveis de ambiente na instanciação do container basta usar o parâmetro -e.&lt;/p&gt;

&lt;p&gt;Exemplo: _docker run -e ACCESS&lt;em&gt;TOKEN=abcd [nome da imagem]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;COPY&lt;/strong&gt;: O COPY serve para você poder copiar arquivos e pastas para dentro da imagem do Docker, nesse exemplo eu copiei o arquivo elasticpush que estava dentro da pasta bin na minha máquina local para dentro da pasta /app na imagem do docker.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;: Com esse parâmetro você pode setar se quer que algo seja executado na hora da instanciação do container. Então, quando você der um &lt;em&gt;docker run&lt;/em&gt; nessa imagem, ela já vai instanciar e executar o programa que está no caminho que você colocar entre colchetes. No nosso caso queremos que essa imagem execute nossa aplicação do Elasticpush, o mesmo vale para quaisquer outros serviços como Redis, Elasticsearch, Nodejs, etc&amp;#8230;&lt;/p&gt;

&lt;h2 id=&#34;build-8211-construíndo-a-imagem&#34;&gt;Build &amp;#8211; Construíndo a imagem&lt;/h2&gt;

&lt;p&gt;A essa altura provavelmente você já tem o Docker instalado na sua máquina, caso contrário ensinamos a fazer isso nesse &lt;a href=&#34;http://elasticpush.com/blog/iniciando-com-o-docker-dicas-praticas-para-comecar-a-usar-agora-mesmo/&#34; target=&#34;_blank&#34;&gt;artigo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Para construir a imagem você precisa executar o seguinte comando, na mesma pasta que está o &lt;strong&gt;Dockerfile&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;em&gt;sudo docker build -t app/elasticpush .&lt;/em&gt;&lt;/pre&gt;

&lt;p&gt;Eu escolhi que o nome da minha imagem fosse app/elasticpush, mas isso fica a seu critério, escolha o nome que melhor se adéque ao seu serviço.&lt;/p&gt;

&lt;p&gt;Executado o comando, se tudo correr bem terá uma saída semelhante a essa:&lt;/p&gt;

&lt;pre class=&#34;lang-bash&#34;&gt;Sending build context to Docker daemon 45.03 MB
 Sending build context to Docker daemon
 Step 0 : FROM debian:jessie
 — &amp;gt; a582cd499e0f
 Step 1 : RUN mkdir /app
 — &amp;gt; Using cache
 — &amp;gt; 3763257cc26e
 Step 2 : COPY ./bin/elasticpush /app/elasticpush
 — &amp;gt; cc4b56f3fd8e
 Removing intermediate container 0bb2091ca437
 Step 3 : ENTRYPOINT /app/elasticpush
 —&amp;gt; Running in ad99734cd065
 — &amp;gt; 3ffec68d5499
 Removing intermediate container ad99734cd065
 Successfully built 3ffec68d5499
 &lt;/pre&gt;

&lt;p&gt;Agora você já tem uma imagem construída. Execute o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo docker images&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A imagem com a tag que você escolheu vai estar listada. A partir dessa imagem você pode iniciar o container com o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo docker run -d [nome da imagem]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Observe que utilizei o parâmetro -d que serve para jogar em segundo plano a inicialização do container, o que é opcional. Após isso será entregue um token que identifica o container, tipo esse:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;19895b08f19d7a4436afa1cb8af8f815939000d5468c7db10c4498317fd81cc3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para navegar dentro do container utilize o seguinte comando:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo docker exec -it 19895b08f19d7a4436afa1cb8af8f815939000d5468c7db10c4498317fd81cc3 bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Com isso você estará dentro do container para caso precise fazer alguma coisa específica. Para sair é só digitar &lt;strong&gt;exit&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Bom pessoal, por enquanto é isso, uma dica que dou é tentar criar imagens mais complexas do que a que eu exemplifiquei, caso tenham alguma dúvida é só deixar um comentário.&lt;/p&gt;

&lt;p&gt;Até a próxima!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>