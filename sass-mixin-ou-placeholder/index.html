
<!DOCTYPE html>
<html lang="pt-br" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <base href="https://tableless.github.io/hugo-public/">
  <title>Tableless</title>
  <link rel="canonical" href="https://tableless.github.io/hugo-public/sass-mixin-ou-placeholder/">
  <link href="" rel="alternate" type="application/rss+xml" title="Tableless" />
  <link rel="stylesheet" href="https://tableless.github.io/hugo-public/css/style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/styles/default.min.css">

</head>
<body>


  <header id="tb-header">
    <a href="https://tableless.github.io/hugo-public/" class="tb-logo"><img src="images/logo.svg"></a>

    

    <nav id="tb-menu">
      <ul>

        
          
              
            <li>
              <a href="/hugo-public/categories/html">
                  
                  HTML
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/css/">
                  
                  CSS
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/javascript/">
                  
                  JavaScript
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/back-end/">
                  
                  Back-end
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/wordpress/">
                  
                  WordPress
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/acessibilidade/">
                  
                  Acessibilidade
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/design/">
                  
                  Design
              </a>
          
            </li>
          
              
            <li>
              <a href="/hugo-public/categories/t%C3%A9cnicas-e-pr%C3%A1ticas/">
                  
                  Na prÃ¡tica
              </a>
          
            </li>
          

      </ul>
    </nav>

  </header>

  <header class="tb-post-header">
    <h1 class="tb-hero-title"><a href="/hugo-public/sass-mixin-ou-placeholder/">SASS: Mixin ou Placeholder?</a></h1>
  <p class="tb-hero-p">
    
    VocÃª utiliza prÃ©-processadores de CSS? Sabe a diferenÃ§a entre um mixin e um placeholder? Entenda a diferenÃ§a entre os dois e saiba quando utilizÃ¡-los.
    
  </p>
      <span class="tb-author">por <a href="/hugo-public/author/raphael-fabeni">Raphael Fabeni</a></span>


  </header>


<section class="tb-post">

  <section class="tb-post-content">
    <article class="tb-post-article">
      

<p>Se Ã© um tema que sempre vejo a respeito da utilizaÃ§Ã£o ou nÃ£o, Ã© sobre o uso de prÃ© processadores CSS. Alguns <em>devs</em> que costumo seguir e ler os artigos, e que pra mim sÃ£o algumas das nossas referÃªncias, apontam as suas consideraÃ§Ãµes sobre o tema. O Miller Medeiros, em um <a href="http://blog.millermedeiros.com/the-problem-with-css-pre-processors/">post</a> mostra alguns pontos negativos na utilizaÃ§Ã£o de prÃ© processadores. O Jean Carlos Emer em um outro <a href="http://tableless.com.br/css-steroids/" title="CSS on steroids">post</a> mostra as reais vantagens de se utilizar um prÃ©-processador. O Diego Eis, em um outro <a href="http://tableless.com.br/pre-processadores-usar-ou-nao-usar/" title="PrÃ© processadores: usar ou nÃ£o usar?">post</a> faz uma conclusÃ£o muito boa sobre a utilizaÃ§Ã£o ou nÃ£o:</p>

<blockquote>
<p>PrÃ© processadores podem ajudar como tambÃ©m podem maltratar bastante. Basta um escorregÃ£o para que seu projeto vire um inferno. &#8211; Diego Eis</p>
</blockquote>

<p>A utilizaÃ§Ã£o ou nÃ£o de um prÃ© processador fica a seu critÃ©rio mas, se vocÃª jÃ¡ utiliza nos seus projetos ou estÃ¡ pensando em usar, vocÃª sabe o que sÃ£o um <strong>placeholder</strong> e um <strong>mixin</strong>? Se sim, sabe qual a principal diferenÃ§a entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um <a href="http://www.sitepoint.com/sass-mixin-placeholder/">artigo</a> do <a href="https://twitter.com/HugoGiraudel" title="Perfil do twitter do desenvolvedor Hugo Giraudel">Hugo Giraudel</a>, um dev front-end francÃªs, no <a href="http://www.sitepoint.com/" title="Link do website SitePoint">SitePoint</a> que trata exatamente sobre esse assunto.</p>

<p>â€”</p>

<p>Quando comecei a trabalhar com SASS cerca de um ano e meio atrÃ¡s, uma coisa que me levou tempo para entender foi a diferenÃ§a entre <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins">incluir um mixin</a></em> e <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders">estender um placeholder</a></em>. Na verdade, atÃ© mesmo a noÃ§Ã£o de <em>placeholder</em> era uma espÃ©cie de magia negra vodu naquela Ã©poca.</p>

<p>Se vocÃª estiver em uma situaÃ§Ã£o semelhante, nÃ£o se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um <em>mixin</em>, e quando usar um <em>placeholder do SASS</em>. VocÃª vai entender que ambos tem diferentes finalidades e nÃ£o devem ser confundidas.</p>

<p><em>Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro prÃ©-processador CSS, seja Stylus, LESS, ou outro que vocÃª venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteÃºdo deste artigo para a ferramenta de sua escolha</em>.</p>

<p>Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos <strong>placeholder e mixins do SASS</strong>, entÃ£o vamos fazer isso jÃ¡.</p>

<h2 id="entendendo-o-mixin">Entendendo o mixin</h2>

<p>Um mixin Ã© uma diretiva que permite que vocÃª defina vÃ¡rias regras com diversos argumentos. Pense nisso como uma funÃ§Ã£o que irÃ¡ retornar conteÃºdo CSS ao invÃ©s de um valor. Aqui estÃ¡ a definiÃ§Ã£o de <em>mixin</em> da <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">referÃªncia do SASS</a>:</p>

<blockquote cite="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">
  <p>
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes nÃ£o semÃ¢nticas como <i>.float-left</i>. Mixins podem tambÃ©m conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem atÃ© mesmo possuÃ­rem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  </p>
</blockquote>

<p>Agora que cobrimos a terminologia, vamos dizer que vocÃª encontra algumas declaraÃ§Ãµes que sÃ£o repetidas vÃ¡rias vezes ao longo da sua folha de estilos. VocÃª que estÃ¡ familiarizado com o conceito de DRY (<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">Don&#8217;t Repeat Yourself</a>), sabe que a repetiÃ§Ã£o de cÃ³digo Ã© ruim. Para corrigir isso, vocÃª pode escrever um mixin para todas aquelas declaraÃ§Ãµes repetidas:</p>

<pre class="lang-scss">@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
</pre>

<p><em>Nota: Se vocÃª nÃ£o passar um argumento para um mixin, vocÃª pode omitir os parÃªnteses. Na verdade, vocÃª pode atÃ© omiti-los na definiÃ§Ã£o do <code>@mixin</code></em>.</p>

<p>Com este mixin recÃ©m-criado, vocÃª nÃ£o precisa repetir aquelas trÃªs linhas de cÃ³digo cada vez que precisar centralizar um elemento; vocÃª simplesmente inclui o mixin. Muito prÃ¡tico, nÃ£o Ã©?!</p>

<p>Algumas vezes vocÃª vai querer um mixin para construir o que vocÃª chamaria de <em>shorthand</em> para algumas propriedades. Por exemplo, largura e altura. VocÃª nÃ£o estÃ¡ cansado de escrever as duas linhas vÃ¡rias e vÃ¡rias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!</p>

<pre class="lang-scss">@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
</pre>

<p>Muito simples, nÃ£o Ã©? Note como deixamos o parÃ¢metro <code>$height</code> ser opcional e, por padrÃ£o assumir o mesmo valor do parÃ¢metro <code>$width</code> na assinatura do mixin. Agora, sempre que vocÃª precisar definir as dimensÃµes para um elemento, vocÃª pode simplesmente fazer isso:</p>

<pre class="lang-scss">.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
</pre>

<p><em>Nota: Um outro bom exemplo de mixin seria <a href="http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/">este aqui</a> que eu fiz para evitar de escrever as posiÃ§Ãµes <code>top</code>, <code>left</code>, <code>right</code> e <code>bottom</code> toda vez que quiser utilizar um sistema de posicionamento diferente do estÃ¡tico.</em></p>

<h2 id="conhecendo-seu-placeholder">Conhecendo seu Placeholder</h2>

<p>Placeholders sÃ£o um tipo de coisa estranha. Eles sÃ£o classes que nÃ£o sÃ£o retornadas quando o seu SCSS Ã© compilado. VocÃª deve entÃ£o pensar: <em>&#8220;Qual Ã© o sentido disso?&#8221;</em>. Na verdade, o ponto seria minÃ­mo senÃ£o fosse a expressÃ£o <code>@extend</code>. Mas vamos por partes. Essa Ã© a forma que vocÃª escreve um placeholder:</p>

<pre class="lang-scss">%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
</pre>

<p><em>Nota do editor: Como um placeholder, um mixin Ã© igualmente inÃºtil, a menos que seja referenciado, assim essa seÃ§Ã£o nÃ£o estÃ¡ dizendo que eles sÃ£o diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareÃ§a similar com um bloco de declaraÃ§Ã£o CSS, nÃ£o serÃ¡ gerado por conta prÃ³pria.</em></p>

<p>Basicamente vocÃª escreve exatamente como uma classe <code>CSS</code> exceto pelo sÃ­mbolo % ao invÃ©s do ponto. AlÃ©m disso, segue as mesmas <a href="http://www.w3.org/TR/html401/types.html#type-cdata">regras de nomenclatura</a> das classes.</p>

<p>Agora, se vocÃª tentar compilar seu SCSS, vocÃª nÃ£o vai ver esse pedaÃ§o de cÃ³digo no arquivo gerado. Como eu disse: <strong>placeholders nÃ£o sÃ£o compilados</strong>.</p>

<p>EntÃ£o, por agora, esse placeholder Ã© totalmente inÃºtil. VocÃª nÃ£o consegue fazer qualquer uso dele a nÃ£o ser que vocÃª veja o <code>@extend</code>. Um <code>@extend</code> tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usÃ¡-lo:</p>

<pre class="lang-scss">.container {
  @extend %center;
}
</pre>

<p>Ao fazer isso, o arquivo SASS vai pegar o conteÃºdo do placeholder <code>%center</code> e aplicÃ¡-lo no <code>.container</code> (mesmo que isso nÃ£o aconteÃ§a exatamente assim &#8211; mas isso nÃ£o Ã© importante agora). Como eu disse, vocÃª tambÃ©m pode <em>estender</em> seletores CSS jÃ¡ existentes (alÃ©m de placeholders SCSS) dessa maneira:</p>

<pre class="lang-scss">.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
</pre>

<p>Esse Ã© um caso muito comum para o uso do <code>@extend</code>. Nesse caso, pedimos para a classe <code>.table-zebra</code> se comportar exatamente como a classe <code>.table</code> e entÃ£o adicionamos as regras especÃ­ficas da classe <code>.table-zebra</code>. <em>Estender</em> seletores Ã© bastante conveniente quando vocÃª desenvolve seu site ou aplicaÃ§Ã£o em componentes modulares.</p>

<h2 id="qual-utilizar">Qual utilizar?</h2>

<p>EntÃ£o, a pergunta permanece: o que vocÃª deve usar? Bem, como tudo em nossa Ã¡rea: <strong>depende</strong>. Depende do contexto e, em uma outra anÃ¡lise, do que vocÃª estÃ¡ querendo fazer.</p>

<p>O melhor conselho seria: se vocÃª precisa de variÃ¡veis, utilize o mixin. Caso contrÃ¡rio, use o placeholder. HÃ¡ duas razÃµes para isso:</p>

<ul>
<li>Primeiro, vocÃª nÃ£o pode usar variÃ¡veis em um placeholder. Na verdade, atÃ© pode, mas vocÃª nÃ£o consegue <em>passar</em> uma variÃ¡vel em um placeholder para gerar um conteÃºdo especÃ­fico de CSS, como vocÃª faria em um mixin.</li>
<li>Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando vocÃª os utiliza sem variÃ¡veis contextuais. Simplificando: o SASS vai duplicar a saÃ­da de um mixin toda vez que vocÃª o utilizÃ¡-lo, resultando nÃ£o apenas em CSS duplicado, mas tambÃ©m em uma folha de estilos maior.</li>
</ul>

<p>Considere o primeiro exemplo desse artigo:</p>

<pre class="lang-scss">@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
</pre>

<p>O CSS compilado seria esse:</p>

<pre class="lang-css">.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Observou o CSS duplicado? Ele nÃ£o Ã© tÃ£o prejudicial se forem apenas trÃªs linhas duplicadas, mas se vocÃª tiver muitos mixins que sÃ£o usados vÃ¡rias vezes em um projeto, essas trÃªs linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, sÃ³ que dessa vez utilizando o placeholder?</p>

<pre class="lang-scss">%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
</pre>

<p>Agora, esse Ã© o CSS gerado:</p>

<pre class="lang-css">.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Muito melhor! A compilaÃ§Ã£o leva vantagem <a href="http://reference.sitepoint.com/css/selectorgrouping">agrupando seletores</a>, sem nenhum estilo repetido. Assim, sempre que vocÃª quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas nÃ£o mudarÃ£o, Ã© uma boa idÃ©ia <em>estender</em> um placeholder. Isso resultarÃ¡ em um cÃ³digo CSS compilado muito mais limpo.</p>

<p>Por outro lado, se vocÃª precisa escrever as mesmas propriedades em vÃ¡rios lugares mas com valores diferentes (tamanho, cores, etc), um mixin Ã© o melhor caminho a seguir. Agora se vocÃª possui ambos, um grupo de valores fixos e outro de valores variÃ¡veis, vocÃª deve tentar usar uma combinaÃ§Ã£o dos dois.</p>

<pre class="lang-scss">%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
</pre>

<p>Neste caso, o mixin estÃ¡ <em>estendendo</em> o placeholder para os valores fixos em vez de jogÃ¡-los diretamente em seu corpo. Isso gera um CSS mais limpo:</p>

<pre class="lang-css">a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
</pre>

<h2 id="conclusÃ£o">ConclusÃ£o</h2>

<p>Ã‰ isso. Espero ter deixado claro nÃ£o sÃ³ o que sÃ£o mixins e placeholders, mas tambÃ©m quando vocÃª deve usÃ¡-los e qual os efeitos sobre o CSS compilado.</p>

<p>Se vocÃª tiver alguma coisa a acrescentar sobre suas experiÃªncias com essas <em>features</em> dos prÃ©-processadores de CSS, sinta-se livre para compartilhar nos comentÃ¡rios.</p>

<p>â€”</p>

<p>Texto traduzido e adaptado do [Se Ã© um tema que sempre vejo a respeito da utilizaÃ§Ã£o ou nÃ£o, Ã© sobre o uso de prÃ© processadores CSS. Alguns <em>devs</em> que costumo seguir e ler os artigos, e que pra mim sÃ£o algumas das nossas referÃªncias, apontam as suas consideraÃ§Ãµes sobre o tema. O Miller Medeiros, em um <a href="http://blog.millermedeiros.com/the-problem-with-css-pre-processors/">post</a> mostra alguns pontos negativos na utilizaÃ§Ã£o de prÃ© processadores. O Jean Carlos Emer em um outro <a href="http://tableless.com.br/css-steroids/" title="CSS on steroids">post</a> mostra as reais vantagens de se utilizar um prÃ©-processador. O Diego Eis, em um outro <a href="http://tableless.com.br/pre-processadores-usar-ou-nao-usar/" title="PrÃ© processadores: usar ou nÃ£o usar?">post</a> faz uma conclusÃ£o muito boa sobre a utilizaÃ§Ã£o ou nÃ£o:</p>

<blockquote>
<p>PrÃ© processadores podem ajudar como tambÃ©m podem maltratar bastante. Basta um escorregÃ£o para que seu projeto vire um inferno. &#8211; Diego Eis</p>
</blockquote>

<p>A utilizaÃ§Ã£o ou nÃ£o de um prÃ© processador fica a seu critÃ©rio mas, se vocÃª jÃ¡ utiliza nos seus projetos ou estÃ¡ pensando em usar, vocÃª sabe o que sÃ£o um <strong>placeholder</strong> e um <strong>mixin</strong>? Se sim, sabe qual a principal diferenÃ§a entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um <a href="http://www.sitepoint.com/sass-mixin-placeholder/">artigo</a> do <a href="https://twitter.com/HugoGiraudel" title="Perfil do twitter do desenvolvedor Hugo Giraudel">Hugo Giraudel</a>, um dev front-end francÃªs, no <a href="http://www.sitepoint.com/" title="Link do website SitePoint">SitePoint</a> que trata exatamente sobre esse assunto.</p>

<p>â€”</p>

<p>Quando comecei a trabalhar com SASS cerca de um ano e meio atrÃ¡s, uma coisa que me levou tempo para entender foi a diferenÃ§a entre <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins">incluir um mixin</a></em> e <em><a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders">estender um placeholder</a></em>. Na verdade, atÃ© mesmo a noÃ§Ã£o de <em>placeholder</em> era uma espÃ©cie de magia negra vodu naquela Ã©poca.</p>

<p>Se vocÃª estiver em uma situaÃ§Ã£o semelhante, nÃ£o se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um <em>mixin</em>, e quando usar um <em>placeholder do SASS</em>. VocÃª vai entender que ambos tem diferentes finalidades e nÃ£o devem ser confundidas.</p>

<p><em>Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro prÃ©-processador CSS, seja Stylus, LESS, ou outro que vocÃª venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteÃºdo deste artigo para a ferramenta de sua escolha</em>.</p>

<p>Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos <strong>placeholder e mixins do SASS</strong>, entÃ£o vamos fazer isso jÃ¡.</p>

<h2 id="entendendo-o-mixin-1">Entendendo o mixin</h2>

<p>Um mixin Ã© uma diretiva que permite que vocÃª defina vÃ¡rias regras com diversos argumentos. Pense nisso como uma funÃ§Ã£o que irÃ¡ retornar conteÃºdo CSS ao invÃ©s de um valor. Aqui estÃ¡ a definiÃ§Ã£o de <em>mixin</em> da <a href="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">referÃªncia do SASS</a>:</p>

<blockquote cite="http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content">
  <p>
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes nÃ£o semÃ¢nticas como <i>.float-left</i>. Mixins podem tambÃ©m conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem atÃ© mesmo possuÃ­rem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  </p>
</blockquote>

<p>Agora que cobrimos a terminologia, vamos dizer que vocÃª encontra algumas declaraÃ§Ãµes que sÃ£o repetidas vÃ¡rias vezes ao longo da sua folha de estilos. VocÃª que estÃ¡ familiarizado com o conceito de DRY (<a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">Don&#8217;t Repeat Yourself</a>), sabe que a repetiÃ§Ã£o de cÃ³digo Ã© ruim. Para corrigir isso, vocÃª pode escrever um mixin para todas aquelas declaraÃ§Ãµes repetidas:</p>

<pre class="lang-scss">@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
</pre>

<p><em>Nota: Se vocÃª nÃ£o passar um argumento para um mixin, vocÃª pode omitir os parÃªnteses. Na verdade, vocÃª pode atÃ© omiti-los na definiÃ§Ã£o do <code>@mixin</code></em>.</p>

<p>Com este mixin recÃ©m-criado, vocÃª nÃ£o precisa repetir aquelas trÃªs linhas de cÃ³digo cada vez que precisar centralizar um elemento; vocÃª simplesmente inclui o mixin. Muito prÃ¡tico, nÃ£o Ã©?!</p>

<p>Algumas vezes vocÃª vai querer um mixin para construir o que vocÃª chamaria de <em>shorthand</em> para algumas propriedades. Por exemplo, largura e altura. VocÃª nÃ£o estÃ¡ cansado de escrever as duas linhas vÃ¡rias e vÃ¡rias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!</p>

<pre class="lang-scss">@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
</pre>

<p>Muito simples, nÃ£o Ã©? Note como deixamos o parÃ¢metro <code>$height</code> ser opcional e, por padrÃ£o assumir o mesmo valor do parÃ¢metro <code>$width</code> na assinatura do mixin. Agora, sempre que vocÃª precisar definir as dimensÃµes para um elemento, vocÃª pode simplesmente fazer isso:</p>

<pre class="lang-scss">.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
</pre>

<p><em>Nota: Um outro bom exemplo de mixin seria <a href="http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/">este aqui</a> que eu fiz para evitar de escrever as posiÃ§Ãµes <code>top</code>, <code>left</code>, <code>right</code> e <code>bottom</code> toda vez que quiser utilizar um sistema de posicionamento diferente do estÃ¡tico.</em></p>

<h2 id="conhecendo-seu-placeholder-1">Conhecendo seu Placeholder</h2>

<p>Placeholders sÃ£o um tipo de coisa estranha. Eles sÃ£o classes que nÃ£o sÃ£o retornadas quando o seu SCSS Ã© compilado. VocÃª deve entÃ£o pensar: <em>&#8220;Qual Ã© o sentido disso?&#8221;</em>. Na verdade, o ponto seria minÃ­mo senÃ£o fosse a expressÃ£o <code>@extend</code>. Mas vamos por partes. Essa Ã© a forma que vocÃª escreve um placeholder:</p>

<pre class="lang-scss">%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
</pre>

<p><em>Nota do editor: Como um placeholder, um mixin Ã© igualmente inÃºtil, a menos que seja referenciado, assim essa seÃ§Ã£o nÃ£o estÃ¡ dizendo que eles sÃ£o diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareÃ§a similar com um bloco de declaraÃ§Ã£o CSS, nÃ£o serÃ¡ gerado por conta prÃ³pria.</em></p>

<p>Basicamente vocÃª escreve exatamente como uma classe <code>CSS</code> exceto pelo sÃ­mbolo % ao invÃ©s do ponto. AlÃ©m disso, segue as mesmas <a href="http://www.w3.org/TR/html401/types.html#type-cdata">regras de nomenclatura</a> das classes.</p>

<p>Agora, se vocÃª tentar compilar seu SCSS, vocÃª nÃ£o vai ver esse pedaÃ§o de cÃ³digo no arquivo gerado. Como eu disse: <strong>placeholders nÃ£o sÃ£o compilados</strong>.</p>

<p>EntÃ£o, por agora, esse placeholder Ã© totalmente inÃºtil. VocÃª nÃ£o consegue fazer qualquer uso dele a nÃ£o ser que vocÃª veja o <code>@extend</code>. Um <code>@extend</code> tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usÃ¡-lo:</p>

<pre class="lang-scss">.container {
  @extend %center;
}
</pre>

<p>Ao fazer isso, o arquivo SASS vai pegar o conteÃºdo do placeholder <code>%center</code> e aplicÃ¡-lo no <code>.container</code> (mesmo que isso nÃ£o aconteÃ§a exatamente assim &#8211; mas isso nÃ£o Ã© importante agora). Como eu disse, vocÃª tambÃ©m pode <em>estender</em> seletores CSS jÃ¡ existentes (alÃ©m de placeholders SCSS) dessa maneira:</p>

<pre class="lang-scss">.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
</pre>

<p>Esse Ã© um caso muito comum para o uso do <code>@extend</code>. Nesse caso, pedimos para a classe <code>.table-zebra</code> se comportar exatamente como a classe <code>.table</code> e entÃ£o adicionamos as regras especÃ­ficas da classe <code>.table-zebra</code>. <em>Estender</em> seletores Ã© bastante conveniente quando vocÃª desenvolve seu site ou aplicaÃ§Ã£o em componentes modulares.</p>

<h2 id="qual-utilizar-1">Qual utilizar?</h2>

<p>EntÃ£o, a pergunta permanece: o que vocÃª deve usar? Bem, como tudo em nossa Ã¡rea: <strong>depende</strong>. Depende do contexto e, em uma outra anÃ¡lise, do que vocÃª estÃ¡ querendo fazer.</p>

<p>O melhor conselho seria: se vocÃª precisa de variÃ¡veis, utilize o mixin. Caso contrÃ¡rio, use o placeholder. HÃ¡ duas razÃµes para isso:</p>

<ul>
<li>Primeiro, vocÃª nÃ£o pode usar variÃ¡veis em um placeholder. Na verdade, atÃ© pode, mas vocÃª nÃ£o consegue <em>passar</em> uma variÃ¡vel em um placeholder para gerar um conteÃºdo especÃ­fico de CSS, como vocÃª faria em um mixin.</li>
<li>Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando vocÃª os utiliza sem variÃ¡veis contextuais. Simplificando: o SASS vai duplicar a saÃ­da de um mixin toda vez que vocÃª o utilizÃ¡-lo, resultando nÃ£o apenas em CSS duplicado, mas tambÃ©m em uma folha de estilos maior.</li>
</ul>

<p>Considere o primeiro exemplo desse artigo:</p>

<pre class="lang-scss">@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
</pre>

<p>O CSS compilado seria esse:</p>

<pre class="lang-css">.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Observou o CSS duplicado? Ele nÃ£o Ã© tÃ£o prejudicial se forem apenas trÃªs linhas duplicadas, mas se vocÃª tiver muitos mixins que sÃ£o usados vÃ¡rias vezes em um projeto, essas trÃªs linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, sÃ³ que dessa vez utilizando o placeholder?</p>

<pre class="lang-scss">%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
</pre>

<p>Agora, esse Ã© o CSS gerado:</p>

<pre class="lang-css">.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
</pre>

<p>Muito melhor! A compilaÃ§Ã£o leva vantagem <a href="http://reference.sitepoint.com/css/selectorgrouping">agrupando seletores</a>, sem nenhum estilo repetido. Assim, sempre que vocÃª quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas nÃ£o mudarÃ£o, Ã© uma boa idÃ©ia <em>estender</em> um placeholder. Isso resultarÃ¡ em um cÃ³digo CSS compilado muito mais limpo.</p>

<p>Por outro lado, se vocÃª precisa escrever as mesmas propriedades em vÃ¡rios lugares mas com valores diferentes (tamanho, cores, etc), um mixin Ã© o melhor caminho a seguir. Agora se vocÃª possui ambos, um grupo de valores fixos e outro de valores variÃ¡veis, vocÃª deve tentar usar uma combinaÃ§Ã£o dos dois.</p>

<pre class="lang-scss">%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
</pre>

<p>Neste caso, o mixin estÃ¡ <em>estendendo</em> o placeholder para os valores fixos em vez de jogÃ¡-los diretamente em seu corpo. Isso gera um CSS mais limpo:</p>

<pre class="lang-css">a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
</pre>

<h2 id="conclusÃ£o-1">ConclusÃ£o</h2>

<p>Ã‰ isso. Espero ter deixado claro nÃ£o sÃ³ o que sÃ£o mixins e placeholders, mas tambÃ©m quando vocÃª deve usÃ¡-los e qual os efeitos sobre o CSS compilado.</p>

<p>Se vocÃª tiver alguma coisa a acrescentar sobre suas experiÃªncias com essas <em>features</em> dos prÃ©-processadores de CSS, sinta-se livre para compartilhar nos comentÃ¡rios.</p>

<p>â€”</p>

<p>Texto traduzido e adaptado do]<a href="http://www.sitepoint.com/sass-mixin-placeholder/">4</a> escrito pelo <a href="https://twitter.com/HugoGiraudel" title="Perfil do twitter">Hugo Giraudel</a> em 30 de janeiro de 2014.</p>

<p>TraduÃ§Ã£o autorizada pelo <a href="http://www.sitepoint.com/">SitePoint</a>.</p>

<p>Qualquer erro ou sugestÃ£o de melhoria na traduÃ§Ã£o, Ã© bem vinda! ğŸ™‚</p>

    </article>

<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = '';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
  </section>


  <aside class="tb-aside">
    Banner
  </aside>

</section>


<footer id="tb-footer">
    <div class="tb-container">
    <ul class="tb-social-links">
        <li><a href="http://facebook.com/tablelessbr">Facebook</a></li>
        <li><a href="http://twitter.com/tableless">Twitter</a></li>
        <li><a href="http://tableless.com.br/feed">RSS</a></li>
        <li><a href="http://medium.com/tableless">Medium</a></li>
    </ul>
    <nav class="tb-footer-nav">
        <a href="">Contato</a>
        <a href="">Anuncie</a>
        <a href="">Seja um Autor</a>
        <a href="">Fazemos cÃ³digo front-end</a>
    </nav>

    <p class="tb-for-community">
        Escrito pela e para a comunidade web brasileira. <a href="">Ajude</a>.
    </p>
    </div>
</footer>
<script
  src="https://code.jquery.com/jquery-3.2.1.min.js"
  integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
  crossorigin="anonymous"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/highlight.min.js"></script>
<script>
$(document).ready(function() {
  $('pre').each(function(i, block) {
    hljs.highlightBlock(block);
  });
})</script>


</body>
</html>

