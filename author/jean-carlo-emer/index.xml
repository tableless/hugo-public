<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jean Carlo Emer on Tableless</title>
    <link>https://tableless.github.io/hugo-public/author/jean-carlo-emer/index.xml</link>
    <description>Recent content in Jean Carlo Emer on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/author/jean-carlo-emer/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Fluxo de execução assíncrono em JavaScript – Generators e Async Functions</title>
      <link>https://tableless.github.io/hugo-public/fluxo-de-execucao-assincrono-em-javascript-generators-e-async-functions/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/fluxo-de-execucao-assincrono-em-javascript-generators-e-async-functions/</guid>
      <description>

&lt;p&gt;Os últimos artigos tratam de &lt;a href=&#34;http://tableless.com.br/fluxo-de-execucao-assincrono-em-javascript-callbacks&#34;&gt;Callbacks&lt;/a&gt; e &lt;a href=&#34;http://tableless.com.br/fluxo-de-execucao-assincrono-em-javascript-promises&#34;&gt;Promises&lt;/a&gt;, corre conferir ou relembrar antes de prosseguirmos. Promises são abstrações muito importantes na evolução de escrita de código assíncrono. Tanto isto é verdade, que as técnicas e conceitos que veremos neste artigo são todos apoiados em &lt;em&gt;promises&lt;/em&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function mountUserComponent() {
  return get(&#39;profile.json&#39;).then(function (response) {
    return new UserComponent(response);
  }, function onRejected() {
    // falha na requisição Ajax
  });
}
&lt;/pre&gt;

&lt;p&gt;A intenção a partir daqui é eliminar muito desta necessidade de declarar &lt;em&gt;callbacks&lt;/em&gt; de sucesso e falha para recuperar o resultado de uma promessa. Por enquanto, deixaremos de lado os Generators, que são mais complicados de serem compreendidos neste contexto de uso, e partiremos direto para as Async Functions.&lt;/p&gt;

&lt;h2 id=&#34;async-functions&#34;&gt;Async Functions&lt;/h2&gt;

&lt;p&gt;As Async Functions são o fruto de algumas experimentações com Generators e execução de código assíncrono. As &lt;a href=&#34;http://tc39.github.io/ecmascript-asyncawait&#34;&gt;Async Functions&lt;/a&gt; devem fazer parte da especificação ES2016 e permitem a escrita de códigos poderosos como este a seguir.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function mountUserComponent() {
  let profile = await get(&#39;profile.json&#39;);
  return new UserComponent(profile);
}
&lt;/pre&gt;

&lt;p&gt;O uso de Async Functions como o nome já sugere, exige a declaração de uma função que encapsule as chamadas assíncronas. Note o &lt;code&gt;async&lt;/code&gt; precedendo a declaração da função no exemplo. A chamada Ajax será disparada e a variável &lt;code&gt;profile&lt;/code&gt; irá receber os dados retornados. O papel do &lt;code&gt;await&lt;/code&gt; é interromper a execução do código a espera que a promessa resulte em sucesso. Nossa promessa é constituída pela requisição Ajax e portanto a próxima linha será executada apenas depois do retorno dos dados.&lt;/p&gt;

&lt;p&gt;O resultado da execução de uma Async Function, por sua vez, é uma &lt;em&gt;promise&lt;/em&gt;. Este resultado será o valor ao lado direito do &lt;code&gt;return&lt;/code&gt;. Porém, caso alguma das promessas passadas para &lt;code&gt;await&lt;/code&gt; falhar, esta promessa é que será retornada:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;mountUserComponent().then(function(component) {
   // resultado final da execução da async function
}).catch(function(error) {
  // falha na requisição Ajax
});
&lt;/pre&gt;

&lt;p&gt;Note que as chamadas de &lt;code&gt;await&lt;/code&gt; que resultam em uma promessa rejeitada são transformadas em uma exceção. As exceções também podem ser tratadas internamente na função conforme o código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function mountUserComponent() {
  try {
    let profile = await get(&#39;profile.json&#39;);
    return new UserComponent(profile);
  } catch (error) {
      // falha na requisição Ajax
  }
}
&lt;/pre&gt;

&lt;p&gt;Agora que os conceitos básicos foram apresentados, vamos conferir como alcançar as mesmas funcionalidades utilizando Generators. Outras construções e conceitos avançados serão abordados a partir do tópico &lt;strong&gt;trabalhando com paralelismo&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;generators-e-código-assíncrono&#34;&gt;Generators e código assíncrono&lt;/h2&gt;

&lt;p&gt;Os Generators permitem escrever um algoritmo interativo através de uma função que armazena estado. Sob um ponto de vista mais prático, Generators são utilizados para construir uma coleção de dados sob demanda.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function* infiniteLoopGenerator() {
    let i = 0;
    while (true) {
        yield i++;
    }
}
&lt;/pre&gt;

&lt;p&gt;O código acima representa uma sequência infinita de números. A cada chamada de &lt;code&gt;yield&lt;/code&gt; a execução da função é interrompida permitindo que um valor seja retornado. A intenção aqui não é apresentar todos os conceitos e modos de uso dos Generators, mais detalhes sobre seu funcionamento podem ser encontrados neste &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators&#34;&gt;artigo da MDN sobre Iterators e Generators&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Com um pouco de imaginação, podemos observar a semelhança entre o &lt;code&gt;yield&lt;/code&gt; e &lt;code&gt;await&lt;/code&gt;: ambos interrompem a execução do nosso código. O resultado de portar nosso código para utilizar Generators seria o seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function* mountUserComponentGenerator() {
  let profile = yield get(&#39;profile.json&#39;);
  return new UserComponent(profile);
}
&lt;/pre&gt;

&lt;p&gt;A diferença aqui é que precisaríamos pegar as &lt;em&gt;promises&lt;/em&gt; produzidas pelo &lt;code&gt;yield&lt;/code&gt;, esperar que fossem resolvidas e então passar seu valor de retorno para o Generator:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;let userComponentGenerator = mountUserComponentGenerator();
userComponentGenerator.next().value.then(function(profile) {
    return userComponentGenerator.next(profile).value;
}).then(function(component) {
    // aqui teríamos o componente pronto
});
&lt;/pre&gt;

&lt;p&gt;Apesar do &lt;code&gt;mountUserComponent&lt;/code&gt; ter um código elegante, como você pode ver, sua execução é um tanto complicada. Por causa disto, surgiram bibliotecas como &lt;a href=&#34;https://github.com/tj/co&#34;&gt;Co&lt;/a&gt; e &lt;a href=&#34;http://bluebirdjs.com/docs/api/promise.coroutine.html&#34;&gt;bluebird coroutine&lt;/a&gt; para fazer este trabalho sujo. Abaixo o mesmo &lt;code&gt;mountUserComponentGenerator&lt;/code&gt; sendo executado utilizando Co:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;co(mountUserComponentGenerator).then(function(component) {
    // aqui teríamos o componente pronto
});
&lt;/pre&gt;

&lt;p&gt;O comportamento de um Generator invocado pelo Co é o mesmo de uma Async Function. Mas apesar de serem equivalentes, o uso de Async Functions é mais adequado para nossas intenções de escrita de código assíncrono. Os próximos exemplos seguirão com o uso de Async Functions mesmo sendo possíveis e facilmente portáveis para utilizarem Generators com Co.&lt;/p&gt;

&lt;h2 id=&#34;trabalhando-com-paralelismo&#34;&gt;Trabalhando com paralelismo&lt;/h2&gt;

&lt;p&gt;Conforme vimos nos artigos anteriores, paralelismo é um dos principais recursos que queremos explorar quando escrevemos código assíncrono.&lt;/p&gt;

&lt;p&gt;Vamos considerar que nossa requisição de &lt;code&gt;profile.json&lt;/code&gt;, necessária para montar o componente de usuário, precisa ser acompanhada de uma requisição por &lt;code&gt;avatar.json&lt;/code&gt;. O componente só pode ser montado depois de conseguidas as informações de perfil e &lt;em&gt;avatar&lt;/em&gt; do usuário.&lt;/p&gt;

&lt;p&gt;A mudança parece simples, mas o código que utiliza puramente &lt;em&gt;promises&lt;/em&gt; precisará ser totalmente reescrito:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function mountUserComponent() {
  return Promise.all([
    get(&#39;profile.json&#39;),
    get(&#39;avatar.json&#39;)
  ]).then(function (responses) {
    profile = responses[0];
    avatar = responses[1];
    new UserComponent(profile, avatar);

  }, function onRejected() {
    // falha em alguma requisição Ajax
  });
}
&lt;/pre&gt;

&lt;p&gt;Ao contrário do código acima, o código utilizando Async Functions irá sofrer poucas alterações:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function mountUserComponent() {
  try {
    let profile = get(&#39;profile.json&#39;);
    let avatar = get(&#39;avatar.json&#39;);
    return new UserComponent(await profile, await avatar);
  } catch (error) {
    // falha em alguma requisição Ajax
  }
}
&lt;/pre&gt;

&lt;p&gt;Vale notar que deslocamos as chamadas de &lt;code&gt;await&lt;/code&gt; para o momento em que o componente precisasse ser instanciado. Se tivéssemos mantido o &lt;code&gt;await&lt;/code&gt; junto ao &lt;code&gt;get(&#39;profile.json&#39;)&lt;/code&gt;, a execução seria interrompida até o retorno da requisição. A requisição pelo &lt;em&gt;avatar&lt;/em&gt; não seria então executada paralelamente.&lt;/p&gt;

&lt;p&gt;Uma boa prática é postergar as chamadas de &lt;code&gt;await&lt;/code&gt; para quando o resultado é estritamente necessário. Adotando esta prática, nosso código que faz uso apenas do &lt;code&gt;profile.json&lt;/code&gt; ficaria da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function mountUserComponent() {
  try {
    let profile = get(&#39;profile.json&#39;);
    return new UserComponent(await profile);
  } catch (error) {
      // falha na requisição Ajax
  }
}
&lt;/pre&gt;

&lt;h2 id=&#34;execução-assíncrona&#34;&gt;Execução assíncrona&lt;/h2&gt;

&lt;p&gt;Apoiando nosso estudo em um pouco de formalismo, a expressão de &lt;em&gt;await&lt;/em&gt; é composta por &lt;code&gt;await&lt;/code&gt; e mais outra expressão: &lt;code&gt;await expression&lt;/code&gt;. Até agora, vimos apenas exemplos onde &lt;code&gt;expression&lt;/code&gt; são &lt;em&gt;promises&lt;/em&gt;, mas outros valores também podem ser utilizados:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function notSoAsyncAlert() {
  alert(await &#39;O await pode receber qualquer tipo de valor&#39;);
}
&lt;/pre&gt;

&lt;p&gt;Esta característica favorece a escrita de um código mais flexível. Mas lembre-se que as &lt;em&gt;promises&lt;/em&gt; são valores que representam resultados ainda não alcançados. O &lt;code&gt;await&lt;/code&gt; irá transformar esta mensagem em uma &lt;em&gt;promise&lt;/em&gt; resolvida e isto tem implicações.&lt;/p&gt;

&lt;p&gt;As &lt;em&gt;callbacks&lt;/em&gt; passadas para uma &lt;em&gt;promise&lt;/em&gt; são executadas em um próximo fluxo e não no mesmo fluxo em que são definidas. Algumas postagens sobre &lt;a href=&#34;http://thanpol.as/javascript/promises-a-performance-hits-you-should-be-aware-of&#34;&gt;performance de &lt;em&gt;promises&lt;/em&gt;&lt;/a&gt; e &lt;a href=&#34;http://blog.millermedeiros.com/promise-nexttick&#34;&gt;comparações com nextTick&lt;/a&gt; podem auxiliar a compreender melhor a problemática.&lt;/p&gt;

&lt;p&gt;Voltando a nosso exemplo, graças ao &lt;code&gt;await&lt;/code&gt;, o &lt;code&gt;alert&lt;/code&gt; será executado apenas em um próximo fluxo de execução o que garante um atraso ínfimo. Isto caracteriza nosso código como assíncrono e garante que o funcionamento seja o mesmo quando no futuro, por exemplo, a mensagem a ser impressa for o resultado de uma chamada Ajax.&lt;/p&gt;

&lt;h2 id=&#34;encadeando-awaits&#34;&gt;Encadeando awaits&lt;/h2&gt;

&lt;p&gt;Um dos recursos mais inteligentes das &lt;em&gt;promises&lt;/em&gt; é a capacidade de encadear &lt;em&gt;callbacks&lt;/em&gt;. Esta mesma funcionalidade pode ser alcançada com o uso de Async Functions. O código a seguir carrega arquivos de artigos e os transforma em um &lt;em&gt;blog&lt;/em&gt;:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;async function blogGenerator() {
  let files = getPostFiles(&#39;./posts&#39;);
  let index = generateIndex(await files);
  let posts = generatePosts(await files);

  return {
      index: await index,   
     posts: await posts
  };
}
&lt;/pre&gt;

&lt;p&gt;O encadeamento fica pouco evidente, mas a execução de &lt;code&gt;generateIndex&lt;/code&gt; está restrita ao término do resgate dos arquivos de postagens. Ao fim, a função só termina quando páginas de postagem e listagem terminarem de serem geradas.&lt;/p&gt;

&lt;p&gt;Quando comparadas com o encadeamento de &lt;em&gt;promises&lt;/em&gt; utilizando &lt;code&gt;then&lt;/code&gt;, as Async Functions resultam em um código mais simples e elegantes.&lt;/p&gt;

&lt;h2 id=&#34;conclusões&#34;&gt;Conclusões&lt;/h2&gt;

&lt;p&gt;Utilizar Generators e Async Functions para escrita de código assíncrono são práticas recentes. O &lt;a href=&#34;http://kangax.github.io/compat-table/es6/#generators&#34;&gt;suporte a Generators&lt;/a&gt; ainda é restrito a poucos navegadores e as &lt;a href=&#34;http://kangax.github.io/compat-table/es7/#test-async_functions&#34;&gt;Async Functions não possuem nenhum suporte&lt;/a&gt; até o momento desta postagem. Porém, o uso de transpiladores é a cada dia mais comum, as funcionalidades apresentadas neste artigo podem ser utilizadas em seus projetos com o &lt;a href=&#34;http://stackoverflow.com/a/28709165&#34;&gt;auxílio do Babel&lt;/a&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Por hoje é só, pessoal. Compartilhem nos comentários suas experiências e aprendizados com esta série de artigos e até a próxima!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fluxo de execução assíncrono em JavaScript – Promises</title>
      <link>https://tableless.github.io/hugo-public/fluxo-de-execucao-assincrono-em-javascript-promises/</link>
      <pubDate>Fri, 07 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/fluxo-de-execucao-assincrono-em-javascript-promises/</guid>
      <description>

&lt;p&gt;No &lt;a href=&#34;http://tableless.com.br/fluxo-de-execucao-assincrono-em-javascript-callbacks&#34;&gt;primeiro artigo da série&lt;/a&gt; falamos sobre o que é execução assíncrona, quais APIs executam código assincronamente e como se livrar de dores de cabeça quando utilizando &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Uma série de problemas encontradas ao utilizar &lt;em&gt;callbacks&lt;/em&gt; foram explorados junto com suas soluções. Aprendemos a utilizar &lt;em&gt;closures&lt;/em&gt;, contornar o tratamento de excessões, reconhecer o comportamento do &lt;code&gt;this&lt;/code&gt; e evitar o Callback Hell. O que veremos a seguir são algumas das reais limitações das &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;limitações-das-callbacks&#34;&gt;Limitações das Callbacks&lt;/h2&gt;

&lt;p&gt;Apenas uma &lt;em&gt;callback&lt;/em&gt; pode ser associada a um determinado evento do &lt;em&gt;loop&lt;/em&gt; interno de eventos do JavaScript.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var xmlhttp = new XMLHttpRequest()
xmlhttp.open(&#39;GET&#39;, &#39;http://url.com&#39;, true)
xmlhttp.onreadystatechange = function callback() {}
xmlhttp.send()
&lt;/pre&gt;

&lt;p&gt;Veja acima o exemplo de uma chamada tradicional Ajax que só aceita uma única &lt;em&gt;callback&lt;/em&gt; para lidar com o retorno do servidor. As funções mais antigas da API do DOM enfrentavam este problema para lidar com eventos: &lt;code&gt;document.getElementById(&#39;bla&#39;).onclick = callback&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Algumas APIs suavizam este problema ao modelar suas interações através de uma interface orientada a eventos. Desta maneira, um único evento da API pode ter mais de uma &lt;em&gt;callback&lt;/em&gt; a ser executada no futuro. Cada &lt;em&gt;callback&lt;/em&gt; associada a um evento da API será registrada no &lt;em&gt;loop&lt;/em&gt; de eventos do JavaScript.&lt;/p&gt;

&lt;p&gt;Fazemos isto com frequência utilizando jQuery para associar &lt;em&gt;callbacks&lt;/em&gt; a eventos do DOM. Cada linha do código abaixo pode muito bem estar distribuída entre módulos da sua aplicação:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;element.on(&#39;click&#39;, callback1)
element.on(&#39;click&#39;, callback2)
element.on(&#39;click&#39;, callback3)
&lt;/pre&gt;

&lt;p&gt;Porém, para os casos da API não suportar o modelo de eventos, atribuir múltiplas &lt;em&gt;callbacks&lt;/em&gt; resulta em um alto acoplamento. Como exemplo, observe o código abaixo que não pode ser facilmente distribuído em diferentes módulos da aplicação:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;xmlhttp.onreadystatechange = function callback() {
  callback1()
  callback2()
  callback3()
}
&lt;/pre&gt;

&lt;p&gt;Outro ponto que já deve ter notado é que sempre nos referimos a &lt;em&gt;callbacks&lt;/em&gt; como porções de código a serem executadas em um tempo conveniente &lt;strong&gt;no futuro&lt;/strong&gt;. Isto porque o modelo de &lt;em&gt;callbacks&lt;/em&gt; não possui memória. Sempre que o fluxo de execução associado a &lt;em&gt;callback&lt;/em&gt; achar oporturno, esta será executada.&lt;/p&gt;

&lt;p&gt;Observe o caso em que é preciso esperar que o documento esteja carregado para executar um determinado código. O DOM expõe o evento &lt;code&gt;DOMContentLoaded&lt;/code&gt; que indica justamente o instante em que o documento está totalmente carregado. Mas este evento ocorre uma única vez.&lt;/p&gt;

&lt;p&gt;Os módulos da aplicação que dependem do carregamento do documento devem ser definidos antes deste evento disparar, ou nunca serão executados. Com o domínio de técnicas que temos até aqui, conseguimos contornar este problema de uma maneira grosseira. Teremos apenas que garantir que o código a seguir seja executado antes do documento estar completamente carregado. Sua função é indicar através da variável &lt;code&gt;isReady&lt;/code&gt; se o documento está carregado:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;window.isReady = false
document.addEventListener(&#39;DOMContentLoaded&#39;, function (){ 
  window.isReady = true
})
&lt;/pre&gt;

&lt;p&gt;E então, nos módulos da aplicação, teremos que implementar uma lógica baseada na variável &lt;code&gt;isReady&lt;/code&gt;. É preciso conferir se o documento está carregado e caso contrário, atribuir uma &lt;em&gt;callback&lt;/em&gt; ao evento de carregamento:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;if (isReady) {
  callback1()
} else {
  document.addEventListener(&#39;DOMContentLoaded&#39;, callback1)
}
&lt;/pre&gt;

&lt;p&gt;As limitações e dificuldades já estão claras até aqui, mas podemos adicionar um tanto mais de complexidade. Podemos supor que estes mesmos módulos que dependem de o documento estar completo, também dependem da resposta de uma requisição assíncrona que retorna o perfil do usuário. Além da variável &lt;code&gt;isReady&lt;/code&gt; teríamos mais outra, digamos &lt;code&gt;isProfileLoaded&lt;/code&gt; para controlar os diferentes carregamentos.&lt;/p&gt;

&lt;p&gt;Em resumo: &lt;strong&gt;algumas APIs aceitam uma única &lt;em&gt;callback&lt;/em&gt;, &lt;em&gt;callbacks&lt;/em&gt; não matém memória e são difíceis de coordenar quando temos fluxos assíncronos executando em paralelo&lt;/strong&gt;. Conheceremos a seguir as &lt;em&gt;promises&lt;/em&gt; que prometem (sic) solucionar todos estes problemas.&lt;/p&gt;

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Uma promessa representa o possível resultado de uma operação assíncrona. Alguns exemplos serão mais fáceis para esclarecer como as promessas funcionam. Vamos assumir que a função &lt;code&gt;get&lt;/code&gt; retorna uma &lt;em&gt;promise&lt;/em&gt; de uma requisição Ajax.&lt;/p&gt;

&lt;p&gt;O código a seguir irá requisitar o perfil de um usuário:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;var profile = get(&#39;profile.json&#39;)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Através da função &lt;code&gt;then&lt;/code&gt; é possível atribuir duas &lt;em&gt;callbacks&lt;/em&gt; a uma promessa. A primeira das &lt;em&gt;callbacks&lt;/em&gt; será executada quando tudo ocorrer bem, chamaremos estas de &lt;strong&gt;callbacks de sucesso&lt;/strong&gt;. A segunda delas é executada em caso de erro, chamaremos de &lt;strong&gt;callbacks de falha&lt;/strong&gt;. Podemos utilzar nossa &lt;em&gt;promise&lt;/em&gt; &lt;code&gt;get&lt;/code&gt; da maneira seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;profile.then(function (response) {
  // requisição Ajax executada com sucesso,
  // perfil do usuário retornado
}, function onRejected() {
  // falha na requisição Ajax
});
&lt;/pre&gt;

&lt;p&gt;As promessas são valores que podemos passar para os diferentes módulos da nossa aplicação. &lt;strong&gt;Além disto, as promessas possuem memória&lt;/strong&gt;. Mesmo depois de a requisição por &lt;code&gt;profile.json&lt;/code&gt; completar, podemos adicionar novas &lt;em&gt;callbacks&lt;/em&gt; através do &lt;code&gt;then&lt;/code&gt;. Promessas aceitam múltiplas &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var profile = get(&#39;profile.json&#39;)

var basket = new Basket(profile)
var toolbar = new Toolbar(profile)

function Basket(profile) {
  profile.then(this.setup, this.error)
}

// ...
&lt;/pre&gt;

&lt;h2 id=&#34;criando-promises&#34;&gt;Criando Promises&lt;/h2&gt;

&lt;p&gt;Uma parcela importante para compreender o funcionamento das &lt;em&gt;promises&lt;/em&gt; é exercitar sua criação. O exemplo abaixo cria uma promessa que termina bem em 50% dos casos:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var randomPromise = new Promise(function (fulfill, reject) {
  if (Math.random() &amp;gt; .5) {
    fulfill(&#39;success&#39;)
  } else {
    reject(&#39;fail&#39;)
  }
}
&lt;/pre&gt;

&lt;p&gt;As funções &lt;code&gt;fulfill&lt;/code&gt; e &lt;code&gt;reject&lt;/code&gt; permitem resolver (terminar bem) ou rejeitar a promessa. Aumentado o nível de detalhes: ao chamar &lt;code&gt;fulfill&lt;/code&gt;, as &lt;em&gt;callbacks&lt;/em&gt; de sucesso atribuídas a promessa através do &lt;code&gt;then&lt;/code&gt; são executadas; para o caso de &lt;code&gt;reject&lt;/code&gt; ser disparado, as &lt;em&gt;callbacks&lt;/em&gt; de falha é que serão executadas. &lt;strong&gt;Os valores passados para &lt;code&gt;fulfill&lt;/code&gt; e &lt;code&gt;reject&lt;/code&gt; ficam memorizados na promessa&lt;/strong&gt; e são sempre passados para as &lt;em&gt;callbacks&lt;/em&gt; de sucesso e falha respectivamente.&lt;/p&gt;

&lt;p&gt;Existem dois atalhos para criação de promessas. São as funções &lt;code&gt;Promise.resolve&lt;/code&gt; e &lt;code&gt;Promise.reject&lt;/code&gt;. Estas funções criam uma promessa resolvida ou rejeitada respectivamente. O código abaixo irá imprimir &amp;#8220;salve&amp;#8221; em um diálogo de alerta:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;Promise.resolve(&#39;salve&#39;).then(function (message) { 
  alert(message)
})
&lt;/pre&gt;

&lt;p&gt;Como último exercício, vamos escrever a função &lt;code&gt;get&lt;/code&gt; que fomos apresentados anteriormente:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function get(url) {
  return new Promise(function (fulfill, reject) {
    var req = new XMLHttpRequest()
    req.open(&#39;GET&#39;, url)

    req.onload = function () {
      if (req.status == 200) {
        fulfill(req.response)
      } else {
        reject(Error(req.statusText))
      }
    }

    req.send()
  })
}
&lt;/pre&gt;

&lt;p&gt;A promessa instanciada no interior da função, como deve ser, encapsula uma operação assíncrona. A requisição Ajax é disparada pela promessa. O resultado da requisição resolve ou rejeita a promessa no interior da &lt;em&gt;callback&lt;/em&gt; de &lt;code&gt;onload&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Vale lembrar que as funções Ajax da jQuery já retornam promessas. A função &lt;code&gt;get&lt;/code&gt; que acabamos de criar é equivalente a função &lt;code&gt;$.get&lt;/code&gt; da jQuery.&lt;/p&gt;

&lt;h2 id=&#34;encadeando-promises&#34;&gt;Encadeando Promises&lt;/h2&gt;

&lt;p&gt;Encadeamento ou &lt;em&gt;chaining&lt;/em&gt; é bastante comum no universo JavaScript desde a popularização da jQuery. Usando promessas, é possível chamar um &lt;code&gt;then&lt;/code&gt; após outro conforme abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;parser.start()
  .then(getFiles)
  .then(generateIndex)
  .then(generatePosts)
&lt;/pre&gt;

&lt;p&gt;Cada função passada para o &lt;code&gt;then&lt;/code&gt; pode retornar um valor ou mesmo uma promessa. Aquilo que for retornado será passado para o próximo &lt;code&gt;then&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Voltando a nosso exemplo, para o caso de &lt;code&gt;getFiles&lt;/code&gt; disparar uma requisição assíncrona e retornar uma &lt;em&gt;promise&lt;/em&gt;, o &lt;code&gt;generateIndex&lt;/code&gt; será chamado apenas quando esta promessa for resolvida. O &lt;code&gt;generateIndex&lt;/code&gt; poderá então processar os arquivos e retorná-los. Na sequência, a função &lt;code&gt;generatePosts&lt;/code&gt; irá receber os mesmos arquivos e fará seu trabalho.&lt;/p&gt;

&lt;p&gt;Um detalhe do funcionamento deve ajudar no entendimento. Uma nova promessa é criada a cada chamada de &lt;code&gt;then&lt;/code&gt; com o valor retornado pela sua &lt;em&gt;callback&lt;/em&gt; de sucesso ou falha. Esta nova promessa é que será utilizada pelo próximo &lt;code&gt;then&lt;/code&gt; do encadeamento. Para o caso da &lt;em&gt;callback&lt;/em&gt; não retornar um valor promessa, a função &lt;code&gt;Promise.resolve&lt;/code&gt; será chamada.&lt;/p&gt;

&lt;p&gt;Graças a este comportamento, a rejeição é tratada de um jeito bem poderoso em meio a um encadeamento. Sempre que a promessa é rejeitada, a primeira &lt;em&gt;callback&lt;/em&gt; de falha do encadeamento é chamada. &lt;strong&gt;Esta &lt;em&gt;callback&lt;/em&gt; terá como missão tratar a falha&lt;/strong&gt;. O valor retornado pela &lt;em&gt;callback&lt;/em&gt; de falha irá &lt;strong&gt;disparar as próximas &lt;em&gt;callbacks&lt;/em&gt; de sucesso do encadeamento a não ser que esta retorne uma promessa rejeitada&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O código a seguir irá imprimir o erro &amp;#8220;Oops&amp;#8221; e a mensagem &amp;#8220;Tudo certo&amp;#8221; no &lt;em&gt;console&lt;/em&gt; do navegador. Nele usaremos o &lt;code&gt;catch(callback)&lt;/code&gt; que é equivalente a &lt;code&gt;then(null, callback)&lt;/code&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;Promise.resolve(&#39;Yep&#39;)
  .then(function(data) {
     return Promise.reject(&#39;Oops&#39;)
  }, function (error) {
    // nada de errado com a promise Yep
  })  
  .catch(function (error) {
    console.error(error)
    // o erro é tratado por esta primeira callback de falha
    return &#39;Tudo certo&#39;
  })
  .then(function (message) {
    // o valor retornado pela callback de falha é transformado
    // em uma promessa resolvida
    console.log(message)
  })
&lt;/pre&gt;

&lt;h2 id=&#34;tratando-excessões&#34;&gt;Tratando Excessões&lt;/h2&gt;

&lt;p&gt;No primeiro artigo conhecemos o quanto excessões podem ser uma dor de cabeça quando utilizamos &lt;em&gt;callbacks&lt;/em&gt;. As promessas possuem um mecanismo muito mais inteligente e fácil para lidar com excessões.&lt;/p&gt;

&lt;p&gt;Sempre que uma &lt;em&gt;callback&lt;/em&gt; de sucesso ou falha disparar uma excessão, uma promessa de rejeição é criada. A função de &lt;em&gt;parser&lt;/em&gt; de JSON, por exemplo, dispara uma excessão quando recebe um JSON inválido. O código a seguir abre uma janela de diálogo informando que há algo de errado com o JSON passado:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;Promise.resolve(&#39;oops&#39;)
  .then(function (data) { 
    JSON.parse(data) 
  })
  .catch(function (err) { 
    alert(err.message) 
  })
&lt;/pre&gt;

&lt;p&gt;Até aqui, vimos que promessas possuem memória e aceitam mais de uma &lt;em&gt;callback&lt;/em&gt;. Por serem valores, &lt;em&gt;promises&lt;/em&gt; podem ser facilmente passadas para os módulos da nossa aplicação. Vimos também que promessas possuem um mecanismo poderoso para contornar falhas e excessões. O único tópico que falta é lidar com paralelismo.&lt;/p&gt;

&lt;h2 id=&#34;trabalhando-com-paralelismo&#34;&gt;Trabalhando com paralelismo&lt;/h2&gt;

&lt;p&gt;O paralelismo acontece sempre que utilizamos simultaneamente recursos computacionais com o objetivo de reduzir o tempo necessário para resolver um determinado problema. O navegador faz isto a todo tempo quando, por exemplo, requisita diversas imagens para o servidor.&lt;/p&gt;

&lt;p&gt;Quando falávamos das limitações das &lt;em&gt;callbacks&lt;/em&gt;, apresentamos o problema de um módulo da aplicação que precisava esperar o documento estar carregado e também ter os dados do perfil de usuário carregados via Ajax. Podemos tratar estas duas tarefas como operações assíncronas paralelas.&lt;/p&gt;

&lt;p&gt;O primeiro passo é criar uma promessa que deve resolver quando o documento estiver carregado. Esta promessa é equivalente a variável &lt;code&gt;isReady&lt;/code&gt; que criamos no início do arquivo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var documentReady = new Promise(function (fulfill) {
  document.addEventListener(&#39;DOMContentLoaded&#39;, fulfill)
})
&lt;/pre&gt;

&lt;p&gt;Note que, assim como o código do da variável &lt;code&gt;isReady&lt;/code&gt;, este código deve ser adicionado ao documento antes que o evento &lt;code&gt;DOMContentLoaded&lt;/code&gt; seja disparado. A &lt;a href=&#34;https://github.com/jquery/jquery/blob/842958e7aecd0d75a7ee9e2aaec83457701aa2f3/src/core/ready.js&#34;&gt;promessa retornada pela jQuery&lt;/a&gt; através de &lt;code&gt;$.ready.promise()&lt;/code&gt; tem comportamento semelhante porém é bem mais robusta. Usaremos esta e a função &lt;code&gt;$.get&lt;/code&gt; da jQuery para carregar as informações do usuário.&lt;/p&gt;

&lt;p&gt;Tudo o que precisamos é a função &lt;code&gt;Promise.all&lt;/code&gt; que permite esperar que duas ou mais promessas estejam resolvidas. A &lt;em&gt;callback&lt;/em&gt; de sucesso do &lt;code&gt;then&lt;/code&gt; a seguir será chamada com a lista de resultados retornados pelas promessas:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var profile = $.get(&#39;profile.json&#39;)
var ready = $.ready.promise()

Promise.all([
  profile,
  ready
])
  .then(function (results) {
    var profileData = results[0]
    /* podemos disparar o comportamento do 
       módulo a partir daqui */
  }, function (result) {
    // recebe o resultado da primeira promessa que falhar
  })
&lt;/pre&gt;

&lt;p&gt;Outra função interessante é a &lt;code&gt;Promise.race&lt;/code&gt;. Como você deve imaginar, esta função tem uso semelhante à anterior com a diferença que as &lt;em&gt;callbacks&lt;/em&gt; de sucesso são chamadas assim que a primeira promessa for resolvida. Funções como esta podem ser bem interessantes para definir &lt;em&gt;timeout&lt;/em&gt; para outras tarefas.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;As promessas são um conceito um tanto antigo e existem diversas implementações. No universo JavaScript, existe uma discussão sobre qual o padrão mais adequado. O padrão &lt;a href=&#34;https://promisesaplus.com&#34;&gt;Promises/A+&lt;/a&gt; é o mais aceito e muitas &lt;a href=&#34;http://blog.jquery.com/2015/07/13/jquery-3-0-and-jquery-compat-3-0-alpha-versions-released&#34;&gt;bibliotecas tem feito esforço para ficarem compatíveis a ele&lt;/a&gt;. Os exemplos mostrados aqui seguem este padrão.&lt;/p&gt;

&lt;p&gt;Promessas também possuem seus pontos contra, &lt;a href=&#34;http://sealedabstract.com/code/broken-promises&#34;&gt;alguns artigos alertam&lt;/a&gt;, por exemplo, para o fato de que memorizar todos os resultados pode pesar bastante na memória ocupada pela aplicação.&lt;/p&gt;

&lt;p&gt;Todos os fatores devem ser considerados quando optamos por utilizar uma determinada tecnologia. Mesmo assim, espero que os exemplos que vimos aqui o tenham convencido de que promessas são um recurso a mais para escrever aplicações melhores.&lt;/p&gt;

&lt;p&gt;Os problemas enfrentados quando utilizamos puramente &lt;em&gt;callbacks&lt;/em&gt; estão intimamente ligados com o fato de tentarmos soluções baseadas em controle de fluxo ao invés de dependências entre valores. &lt;em&gt;Promises&lt;/em&gt; são ótimas aliadas nesta briga, lembre-se que: &lt;strong&gt;programação funcional é sobre trabalhar com valores e não com funções&lt;/strong&gt;.&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  ***
&lt;/p&gt;

&lt;p&gt;Ufa, esta leitura deve ter sido um tanto pesada. Alguns conceitos não são nada fáceis, tentei deixá-los o mais claro possível e apoiados por exemplos.&lt;/p&gt;

&lt;p&gt;O próximo e último artigo da série irá tratar de &lt;em&gt;generators&lt;/em&gt; e como estes podem ser utilizados em conjunto com as promessas. Veremos também algumas propostas futuras para lidar com execução de código assíncrono no JavaScript.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fluxo de execução assíncrono em JavaScript – Callbacks</title>
      <link>https://tableless.github.io/hugo-public/fluxo-de-execucao-assincrono-em-javascript-callbacks/</link>
      <pubDate>Mon, 27 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/fluxo-de-execucao-assincrono-em-javascript-callbacks/</guid>
      <description>

&lt;p&gt;O fluxo de execução de um programa é determinado pela ordem em que suas instruções são executadas. Tradicionalmente a execução é sequencial e segue a ordem em que as instruções aparecem no código fonte do programa.&lt;/p&gt;

&lt;p&gt;Existem instruções especiais que podem guiar o fluxo de execução, seja pela imposição de uma decisão, repetição ou pulo. No JavaScript, temos como exemplo &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;try catch&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, dentre outros (como &lt;code&gt;break&lt;/code&gt; e &lt;code&gt;continue&lt;/code&gt; que podem ser usados de um &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label#Using_a_labeled_continue_with_for_loops&#34;&gt;jeito peculiar&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Como a maioria das linguagens de programação, o JavaScript foi projetado para funcionar com um único fluxo de execução. Apenas uma instrução do seu código será processada em um determinado instante. No ambiente do navegador, seu código JavaScript ainda terá que disputar vaga com o &lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&#34;&gt;&lt;em&gt;rendering&lt;/em&gt;&lt;/a&gt; (&lt;em&gt;layout&lt;/em&gt; e &lt;em&gt;paint&lt;/em&gt;) da página. &lt;strong&gt;Isto significa que o navegador não conseguirá posicionar ou desenhar um elemento na tela ao mesmo tempo que executa JavaScript e vice-versa&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;fluxos-assíncronos&#34;&gt;Fluxos assíncronos&lt;/h2&gt;

&lt;p&gt;Mesmo que projetado para ter um único fluxo de execução, algumas tarefas do seu programa JavaScript poderão ser executadas sem interferir em nada o fluxo principal de execução de código. Essas tarefas são conhecidas como fluxos assíncronos. &lt;strong&gt;Você pode disparar uma série dessas tarefas sem precisar esperar que cada uma se complete para prosseguir&lt;/strong&gt;. Nos computadores atuais, que possuem mais de um núcleo de processamento, algumas tarefas do escopo do seu programa poderão inclusive ser executadas no mesmo instante do seu código.&lt;/p&gt;

&lt;p&gt;Isso pode parecer um pouco complicado e um exemplo pode ajudar. Toda vez que você dispara uma &lt;a href=&#34;https://en.wikipedia.org/wiki/Ajax_(programming&#34;&gt;requisição Ajax&lt;/a&gt;, a comunicação com o servidor e o recebimento dos dados ocorre em paralelo a execução de outras linhas do seu programa. &lt;strong&gt;Quando tudo estiver pronto, você será avisado no mesmo fluxo de execução que disparou a requisição, e então poderá usar sua resposta&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Os navegadores possuem uma série de APIs e funções que executam em fluxos assíncronos. Abaixo a lista das mais relevantes:&lt;/p&gt;

&lt;h3 id=&#34;timers&#34;&gt;Timers&lt;/h3&gt;

&lt;p&gt;As funções &lt;code&gt;setTimeout&lt;/code&gt; e &lt;code&gt;setInterval&lt;/code&gt; criam contadores que irão avisar seu programa que determinado período de tempo se passou de forma assíncrona.&lt;/p&gt;

&lt;h3 id=&#34;comunicação-com-servidor&#34;&gt;Comunicação com servidor&lt;/h3&gt;

&lt;p&gt;As APIs para comunicação Ajax e outras que implementam os vários &lt;a href=&#34;https://speakerdeck.com/jcemer/protocolos-de-comunicacao-que-fazem-parte-da-web&#34;&gt;protocolos de comunicação que fazem parte da Web&lt;/a&gt; são assíncronas.  Web Sockets e Server Sent Events criam conexões permanentes com o servidor no navegador, retornando dados ao longo do tempo para nosso código.&lt;/p&gt;

&lt;h3 id=&#34;eventos-do-dom&#34;&gt;Eventos do DOM&lt;/h3&gt;

&lt;p&gt;Através dos eventos do DOM é possível perceber interações do usuário e monitorar mudanças de estado do documento. Como o usuário pode reagir a qualquer instante, o tratamento obrigatoriamente precisa se dar de forma assíncrona. Não é viável bloquear o fluxo de execução principal a espera de um clique.&lt;/p&gt;

&lt;h3 id=&#34;mensagens&#34;&gt;Mensagens&lt;/h3&gt;

&lt;p&gt;A função &lt;code&gt;window.postMessage&lt;/code&gt; e o tratador de evento de recebimento de mensagem, permitem, respectivamente, enviar e receber mensagens de forma assíncrona entre diferentes páginas (ou &lt;em&gt;iframes&lt;/em&gt;) abertas no navegador.&lt;/p&gt;

&lt;h3 id=&#34;mutation-observers&#34;&gt;Mutation Observers&lt;/h3&gt;

&lt;p&gt;Os Mutation Observers permitem assistir a mudanças no documento. Através destes, é possível ser avisado a cada alteração de atributo, criação, remoção ou alteração de elementos da página. Seu comportamento e justificativa de existência é a mesma dos eventos do DOM.&lt;/p&gt;

&lt;h2 id=&#34;callbacks-e-closures&#34;&gt;Callbacks e closures&lt;/h2&gt;

&lt;p&gt;As chamadas de função que executam em um fluxo assíncrono fazem uso de &lt;em&gt;callbacks&lt;/em&gt;. &lt;em&gt;Callbacks&lt;/em&gt; são porções de código que serão executados no futuro, em um tempo conveniente.&lt;/p&gt;

&lt;p&gt;O JavaScript interage com os fluxos assíncronos através de troca de mensagens. Sempre que uma tarefa assíncrona entra em ação, a &lt;em&gt;callback&lt;/em&gt; é registrada e fica a espera de uma mensagem para ser executada. &lt;strong&gt;Existe então um loop de eventos que aguarda por mensagens&lt;/strong&gt; emitidas por &lt;em&gt;timers&lt;/em&gt;, requisições, eventos do DOM e outras chamadas assíncronas.&lt;/p&gt;

&lt;p&gt;As mensagens, quando recebidas, são mantidas em uma fila e disparam a execução da &lt;em&gt;callback&lt;/em&gt;, uma por vez. É importante notar que duas &lt;em&gt;callbacks&lt;/em&gt; não são disparadas no mesmo instante. Existe um único fluxo de execução JavaScript nos navegadores e as &lt;em&gt;callbacks&lt;/em&gt; são executadas nele também.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tudo é executado em paralelo, exceto o seu código &amp;#8211; Mikito Takada&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As &lt;em&gt;callbacks&lt;/em&gt; &lt;strong&gt;possuem acesso às variáveis do escopo em que foram definidas&lt;/strong&gt;, por isto são chamadas &lt;em&gt;closures&lt;/em&gt;. Apesar disto, &lt;em&gt;callbacks&lt;/em&gt; não são executadas no mesmo escopo em que definidas.&lt;/p&gt;

&lt;h2 id=&#34;quebrando-o-fluxo-de-execução&#34;&gt;Quebrando o fluxo de execução&lt;/h2&gt;

&lt;p&gt;Quando escrevemos código para adicionar interatividade a uma página, existem algumas situações que pode ser interessante que o fluxo de execução não seja contínuo. Como vimos anteriormente, a execução de nosso código é compartilhada com o &lt;em&gt;rendering&lt;/em&gt; da página. Qualquer execução que tome um pouco mais de tempo, irá bloquear a interface e transmitir uma impressão de lentidão para o usuário.&lt;/p&gt;

&lt;p&gt;Um artifício que pode ser usado para permitir que o &lt;em&gt;rendering&lt;/em&gt; não seja prejudicado é quebrar a execução de uma tarefa em fatias. Para isto, será preciso dividir a tarefa em &lt;em&gt;callbacks&lt;/em&gt; e fazer uso de recursos que criem fluxos assíncronos. A mais simples das funções que conhecemos já pode ajudar: &lt;code&gt;setTimeout(callback, 0)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A cada chamada de &lt;code&gt;setTimeout&lt;/code&gt; um fluxo assíncrono será criado para gerenciar um temporizador. Assim que as demais instruções forem executadas, o fluxo principal será interrompido. O navegador poderá então utilizar seus recursos para fazer tarefas relacionadas ao &lt;em&gt;rendering&lt;/em&gt;, garantindo assim uma interface fluída para o usuário. Quando tais tarefas terminarem, o temporizador de zero segundos já deverá ter disparado uma mensagem a ser atendida pelo &lt;em&gt;loop&lt;/em&gt; de eventos do JavaScript. A &lt;em&gt;callback&lt;/em&gt; será disparada.&lt;/p&gt;

&lt;p&gt;Usar &lt;code&gt;setTimout&lt;/code&gt;, apesar de ser um truque baixo, irá funcionar bem para tarefas simples. Porém, existe uma limitação em sua especificação. Sempre que &lt;em&gt;callbacks&lt;/em&gt; disparadas por um temporizador criarem outro temporizador, este terá tempo mínimo de 4 milissegundos. Existe uma &lt;a href=&#34;https://github.com/YuzuJS/setImmediate&#34;&gt;especificação em andamento para definir a função &lt;code&gt;setImmediate&lt;/code&gt;&lt;/a&gt;. E para jogos e animações, melhor mesmo é usar a &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&#34;&gt;função &lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; que cria um novo fluxo de execução logo após o &lt;em&gt;rendering&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;problemas-das-callbacks&#34;&gt;Problemas das callbacks&lt;/h2&gt;

&lt;p&gt;O único mecanismo que o JavaScript oferece para gerenciar fluxos de execução assíncronos são as &lt;em&gt;callbacks&lt;/em&gt;. É provável que no futuro tenhamos os &lt;a href=&#34;http://www.2ality.com/2015/03/no-promises.html&#34;&gt;Generators&lt;/a&gt; e &lt;a href=&#34;http://jakearchibald.com/2014/es7-async-functions/&#34;&gt;Async Functions&lt;/a&gt;. Mas por enquanto todas as APIs recebem apenas &lt;em&gt;callbacks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O problema é que alguns códigos que utilizam &lt;em&gt;callbacks&lt;/em&gt; são frequentemente mal compreendidos. O código abaixo, apesar de parecer, não irá mostrar um contador regressivo para o usuário. Como já mencionado, o que as &lt;em&gt;closures&lt;/em&gt; enxergam são variáveis e não valores.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i=0; i&amp;lt;4; i++) {
    setTimeout(function () {
        alert(4-i)
    }, i*100)  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A solução para o código acima é utilizar o &lt;code&gt;.bind&lt;/code&gt; para armazenar os diferentes valores de &lt;code&gt;i&lt;/code&gt;. Uma solução melhor ainda é reescrever este algoritmo seguindo um estilo mais funcional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Array.apply(null, Array(4)).forEach(function (undef, index) {
    setTimeout(function () {
        alert(4-index)
    }, index*100)  
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outra confusão comum envolve excessões. Observe o código a seguir e tente prever seu comportamento:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
    setTimeout(function () {
        throw &amp;quot;Exception&amp;quot;
    }, 100)
}
catch (e) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A exceção emitida pela &lt;em&gt;callback&lt;/em&gt; não será coletada e explodirá direto para o usuário. A &lt;em&gt;callback&lt;/em&gt;, quando executada, não estará mais sendo assistida pelo bloco de tratamento de exceção. Um novo bloco de tratamento deve ser criado no interior da função.&lt;/p&gt;

&lt;p&gt;O valor que o &lt;code&gt;this&lt;/code&gt; irá representar no interior da &lt;em&gt;callback&lt;/em&gt; algumas vezes gera dúvidas. Esqueça! Geralmente é uma má ideia utilizar o &lt;code&gt;this&lt;/code&gt; nestes casos. Se for preciso, é bom recorrer ao &lt;code&gt;.bind&lt;/code&gt; da &lt;em&gt;callback&lt;/em&gt; com o valor que se espera que o &lt;code&gt;this&lt;/code&gt; represente. Logo será possível utilizar também &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&#34;&gt;Arrow Functions&lt;/a&gt; para contornar este problema.&lt;/p&gt;

&lt;p&gt;Por fim, há desenvolvedores que argumentam contra &lt;em&gt;callbacks&lt;/em&gt; pelo uso destas resultar em um código confuso e com alto acoplamento. O site &lt;a href=&#34;http://callbackhell.com&#34;&gt;Callback Hell&lt;/a&gt; ensina de forma prática como evitar o temido &lt;em&gt;callback hell&lt;/em&gt; (sic).&lt;/p&gt;

&lt;p&gt;Apesar de todos estes problemas e confusões, as &lt;em&gt;callbacks&lt;/em&gt; são simples e poderosas.&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  ***
&lt;/p&gt;

&lt;p&gt;Espero que tenha aproveitado a leitura. &lt;span style=&#34;text-decoration: line-through;&#34;&gt;No próximo artigo da série, veremos algumas limitações reais das &lt;em&gt;callbacks&lt;/em&gt;. Seremos apresentados às &lt;em&gt;promises&lt;/em&gt;, que irão garantir uma escrita de código melhor em determinadas circunstâncias. Até lá.&lt;/span&gt; &lt;a href=&#34;http://tableless.com.br/fluxo-de-execucao-assincrono-em-javascript-promises/&#34;&gt;O próximo artigo da série que fala sobre _promises _já saiu&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OOCSS, SMACSS, BEM, DRY CSS: afinal, como escrever CSS?</title>
      <link>https://tableless.github.io/hugo-public/oocss-smacss-bem-dry-css-afinal-como-escrever-css/</link>
      <pubDate>Mon, 23 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/oocss-smacss-bem-dry-css-afinal-como-escrever-css/</guid>
      <description>

&lt;p&gt;Já sabemos que se tratando de CSS, apesar da escrita ser muito simples, há uma série de armadilhas. Começamos não utilizando &lt;code&gt;!important&lt;/code&gt; ou &lt;code&gt;tags&lt;/code&gt; para estilização, &lt;a href=&#34;http://josh.github.io/css-explain&#34;&gt;considerando o peso dos seletores&lt;/a&gt; e adotando um &lt;em&gt;code standard&lt;/em&gt;. Mas ainda não damos tanta atenção para a arquitetura que está intimamente ligada a futuros conflitos. Um conflito de CSS é fruto de código mal escrito que cancela regras ou as aplicada em porções inadequadas do &lt;em&gt;layout&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Saiba que não se trata de aprender algumas técnicas a mais, antes que alguém deixe um dos muito comentários infelizes que figuram em outros textos do assunto, trata-se essencialmente de reconhecer soluções para um problema pertinente e comum. &lt;strong&gt;É preciso pensar como organizar nosso código CSS&lt;/strong&gt;. Melhor ainda, devemos planejar qual será a &lt;strong&gt;o estilo de arquitetura&lt;/strong&gt; da nossa folha de estilo.&lt;/p&gt;

&lt;h2 id=&#34;conceitos-básicos&#34;&gt;Conceitos básicos&lt;/h2&gt;

&lt;p&gt;A experiência nos mostra aquilo que Phil Karlton já dizia: uma das tarefas mais árduas da computação é a de nomear coisas. E isto é o que fazemos o tempo todo quando escrevemos CSS, definir quais serão nossos seletores. Esta tarefa envolve organização, padronização, planejar reutilização e uma série de outras disciplinas.&lt;/p&gt;

&lt;p&gt;Um ponto pertinente é compreendermos o significado de semântica, que define a relação entre símbolos e seu significado, neste contexto. Nicolas Gallagher escreveu um texto sensacional sobre &lt;a href=&#34;http://nicolasgallagher.com/about-html-semantics-front-end-architecture&#34;&gt;semântica no HTML e sua não relação com semântica da arquitetura do front-end&lt;/a&gt;. A semântica das &lt;em&gt;tags&lt;/em&gt; do HTML e Microdata está muito bem definida nas especificações e deve ser respeitada. Através dela é possível para humanos e máquinas melhor interpretar as informações contidas em um documento.&lt;/p&gt;

&lt;p&gt;Por outro lado, ao contrário daquilo que muitos pensam, não há nenhuma semântica a ser seguida quando atribuímos classes a um elemento. &lt;strong&gt;Não existe classe não semântica&lt;/strong&gt;, já que seu significado deve ser estabelecido em cada projeto.&lt;/p&gt;

&lt;h2 id=&#34;object-oriented-css&#34;&gt;Object Oriented CSS&lt;/h2&gt;

&lt;p&gt;O conteúdo de um website geralmente é bem específico em cada uma das páginas. É pouco comum que o mesmo conteúdo se manifeste em diferentes seções de um projeto. Portanto, &lt;strong&gt;classes nomeadas com base no conteúdo são bastante difíceis de serem reusadas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Segundo o OOCSS, um &lt;em&gt;objeto de CSS&lt;/em&gt; é todo &lt;strong&gt;padrão visual&lt;/strong&gt; que pode se repetir no projeto e é identificado através de uma classe. O estilo enfatiza a separação de propriedades de estrutura e de &lt;em&gt;skin&lt;/em&gt;. Propriedades como &lt;code&gt;background&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt; e &lt;code&gt;border&lt;/code&gt;, quando fizerem parte da identidade visual do projeto, são consideras parte do &lt;em&gt;skin&lt;/em&gt; e devem ser agrupadas em classes próprias. Observe a classe de &lt;em&gt;skin&lt;/em&gt; &lt;code&gt;anchor-icon&lt;/code&gt;, que define um &lt;code&gt;background&lt;/code&gt;, utilizada juntamente com duas classes de estrutura: &lt;code&gt;&amp;lt;button class=&amp;quot;button anchor-icon&amp;quot;&amp;gt;Abrir&amp;lt;/button&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;a class=&amp;quot;link anchor-icon&amp;quot;&amp;gt;Tableless&amp;lt;/a&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O uso dos objetos ao longo do projeto não deve causar surpresas, o que significa que sua localização não deve interferir na sua apresentação. Isto significa não utilizar &lt;em&gt;nesting&lt;/em&gt; de seletores. Caso sejam necessárias variações, objetos podem estender outros diretamente no HTML: &lt;code&gt;&amp;lt;div class=&amp;quot;graph graph-big&amp;quot;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Classes como &lt;code&gt;.wrapper&lt;/code&gt;, &lt;code&gt;.image-replacement&lt;/code&gt; e &lt;code&gt;.clearfix&lt;/code&gt; aparecem em alguns exemplos que aplicam este sistema. O argumento é que se tratam de classes de estrutura com um padrão que pode ser reusado. Um exemplo: &lt;code&gt;&amp;lt;div class=&amp;quot;graph graph-big clearfix wrapper&amp;quot;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O maior ensinamento é o de utilizar classes baseadas na aparência ao invés de conteúdo ou até mesmo funcionalidade, que até pouco eu acreditava ser o ideal. Apesar dos demais conceitos serem interessantes, a documentação é vaga e não há um padrão de nomenclatura que diferencie classes de estruturação e de &lt;em&gt;skins&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;smacss&#34;&gt;SMACSS&lt;/h2&gt;

&lt;p&gt;O sistema estabelece e é bastante baseado em cinco categorias de regras de CSS: &lt;em&gt;base&lt;/em&gt;, &lt;em&gt;layout&lt;/em&gt;, &lt;em&gt;module&lt;/em&gt;, &lt;em&gt;state&lt;/em&gt; e a pouco importante &lt;em&gt;theme&lt;/em&gt;. As regras de &lt;em&gt;base&lt;/em&gt; são as do tipo que não utilizam seletores com classes ou ids, as encontramos em um &lt;em&gt;CSS Reset&lt;/em&gt; ou &lt;em&gt;normalize.css&lt;/em&gt;. O sistema alerta sobre a &lt;a href=&#34;http://stackoverflow.com/a/8357635&#34;&gt;agressividade dos &lt;em&gt;CSS Resets&lt;/em&gt;&lt;/a&gt; mas não alerta sobre as regras deste tipo definidas no próprio projeto, ainda mais quando aplicadas a &lt;em&gt;divs&lt;/em&gt;, &lt;em&gt;spans&lt;/em&gt; ou &lt;em&gt;headings&lt;/em&gt;. &lt;strong&gt;Regras cujos seletores não utilizam classes são globais e qualquer decisão tomada neste nível irá perpetuar por todo o projeto, cuidado&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As categorias de &lt;em&gt;layout&lt;/em&gt; e &lt;em&gt;module&lt;/em&gt; são bastante semelhantes. Pense no &lt;em&gt;layout&lt;/em&gt; como elementos agregadores e geralmente únicos como &lt;em&gt;header&lt;/em&gt;, &lt;em&gt;footer&lt;/em&gt; e &lt;em&gt;sidebar&lt;/em&gt;. O sistema propõe que regras de &lt;em&gt;layout&lt;/em&gt; tenham ids ou classes com o prefixo &lt;code&gt;.l-&lt;/code&gt; como seletores.&lt;/p&gt;

&lt;p&gt;As regras da categoria &lt;em&gt;module&lt;/em&gt; englobam os demais componentes da página. O sistema não encoraja o uso de elementos nos seletores, preferindo &lt;code&gt;.box .title&lt;/code&gt; ao invés de &lt;code&gt;.box h2&lt;/code&gt;. Ainda, o seletores como &lt;code&gt;.box-title&lt;/code&gt; são defendidos para facilitar a leitura do HTML.&lt;/p&gt;

&lt;p&gt;Assim como o OOCSS, o sistema repudia regras do tipo &lt;code&gt;#sidebar .media&lt;/code&gt; onde a localização do elemento passa a ser relevante para sua apresentação. O SMACSS reforça que seja adicionada uma classe para abrigar as variações. O elemento da &lt;em&gt;sidebar&lt;/em&gt; passa a ter a classe do módulo e também a do sub-módulo: &lt;code&gt;&amp;lt;div class=&amp;quot;media media-sidebar&amp;quot;&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A categoria de &lt;em&gt;state&lt;/em&gt; engloba regras responsáveis por gerenciar estado de componentes enquanto o usuário estiver navegando. Regras desta categorias são as únicas que podem e talvez precisem utilizar &lt;code&gt;!important&lt;/code&gt;. O padrão indica que as classes possuam o prefixo &lt;code&gt;.is-&lt;/code&gt;. Com certeza, algum dos seus projetos já precisou de uma classe como &lt;code&gt;.is-active&lt;/code&gt;, &lt;code&gt;.is-collapsed&lt;/code&gt; ou &lt;code&gt;is-current&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O SMACSS é mais uma série de tutoriais de como escrever um bom código que propriamente um sistema de CSS. Contra os padrões, &lt;strong&gt;não concordo com qualquer aparição de #id em folhas de estilos&lt;/strong&gt; por ir contra os preceitos de reuso. O atributo id na realidade serve mais como um destino de navegação, por isto a necessidade de ser único. Considero um pouco estranho também o prefixo &lt;code&gt;l-&lt;/code&gt; para as classes de &lt;em&gt;layout&lt;/em&gt;, o que me atreve a desconsiderar totalmente a categoria e a gerir suas regras como se pertencessem a categoria &lt;em&gt;module&lt;/em&gt;. Não existe necessidade desta distinção nos seletores, apenas separar as regras em um arquivo &lt;code&gt;layout.css&lt;/code&gt; já é suficiente.&lt;/p&gt;

&lt;p&gt;A categoria de &lt;em&gt;state&lt;/em&gt; é a mais interessante, o padrão fica muito conveniente para ser utilizado em código JavaScript. Quando o estado de um componente demanda regras muito específicas, o SMACSS sugere o seletor &lt;code&gt;.is-tab-active&lt;/code&gt;. Desta maneira, o JavaScript perde um tanto da sua modularidade, seletores aninhados como &lt;code&gt;.tab.is-active&lt;/code&gt; podem ser uma melhor jogada.&lt;/p&gt;

&lt;p&gt;Por fim, mesmo sendo &lt;a href=&#34;http://www.smashingmagazine.com/2012/04/20/decoupling-html-from-css&#34;&gt;bastante válido&lt;/a&gt;, o SMACSS não soluciona alguns desafios típicos do &lt;em&gt;design&lt;/em&gt; de componentes de médio porte pois em nenhum momento endereça como nomear adequadamente elementos descendentes.&lt;/p&gt;

&lt;h2 id=&#34;bem&#34;&gt;BEM&lt;/h2&gt;

&lt;p&gt;O BEM &amp;#8211; sigla para &lt;em&gt;block&lt;/em&gt;, &lt;em&gt;element&lt;/em&gt;, &lt;em&gt;modifier&lt;/em&gt; &amp;#8211; é uma metodologia com várias versões cujo o preceito de esclarecer o desenvolvedor mais sobre o &lt;em&gt;markup&lt;/em&gt; através de suas classes. &lt;strong&gt;Este sistema permite escrever sites de maneira rápida, auto-explicativa e com manutenção descomplicada&lt;/strong&gt;. Esqueça seus preconceitos com os caracteres duplos de hifen, eu já deixei o meu de lado, e reflita a seguir o quanto mais de informação a classe &lt;code&gt;.report-graph__bar_size_big&lt;/code&gt; oferece em relação as tradicionais &lt;code&gt;.bar&lt;/code&gt;, &lt;code&gt;.report-graph-bar&lt;/code&gt; ou &lt;code&gt;.graph-bar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O &lt;em&gt;block&lt;/em&gt; é uma entidade independente da aplicação, podendo ser o mais alto nível de abstração (&lt;em&gt;header&lt;/em&gt;, &lt;em&gt;footer&lt;/em&gt;) ou componente (&lt;em&gt;graph&lt;/em&gt;, &lt;em&gt;tabs&lt;/em&gt;). O &lt;em&gt;element&lt;/em&gt; é um descendente dependente de um &lt;em&gt;block&lt;/em&gt; que possui uma certa função. Para permitir nomes compostos e evitar ambiguidades, o padrão estabelece o controverso &lt;code&gt;__&lt;/code&gt; como separador. Desmembrando a classe &lt;code&gt;report-graph__bar&lt;/code&gt;, identificamos &lt;em&gt;bar&lt;/em&gt; como &lt;em&gt;element&lt;/em&gt; e sabemos da existência do elemento pai &lt;em&gt;report-graph&lt;/em&gt;, que é o &lt;em&gt;block&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;O estilo define o &lt;em&gt;modifier&lt;/em&gt; como uma propriedade de um &lt;em&gt;block&lt;/em&gt; ou &lt;em&gt;element&lt;/em&gt; que altera sua aparência. Desta maneira, o &lt;em&gt;block&lt;/em&gt; &lt;code&gt;.menu&lt;/code&gt; poderia ser acrescido da classe &lt;code&gt;.menu_size_big&lt;/code&gt;, note o uso de &lt;code&gt;_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A fim de deixar o padrão um pouco mais claro, veja um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;div class=&amp;quot;report-graph&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;report-graph__bar&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;report-graph__bar report-graph__bar_size_big&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As classes &lt;code&gt;.report-graph&lt;/code&gt;, &lt;code&gt;report-graph__bar&lt;/code&gt; e &lt;code&gt;report-graph__bar_size_big&lt;/code&gt; são, respectivamente, &lt;em&gt;block&lt;/em&gt;, &lt;em&gt;element&lt;/em&gt; e &lt;em&gt;modifier&lt;/em&gt;. Neste ponto você já deve ter refletido e concluído que sim, há muito mais informação numa classes nomeada neste padrão.&lt;/p&gt;

&lt;p&gt;Uma das falhas do estilo é não possuir categorias como as do SMACSS. Segundo o padrão, o estado de um componente deve ser endereçado como um &lt;em&gt;modifier&lt;/em&gt;, não há uma categoria de &lt;em&gt;state&lt;/em&gt;. Conforme citei anteriormente, classes &lt;em&gt;modifier&lt;/em&gt; como &lt;code&gt;.menu__item_state_current&lt;/code&gt; tiram a modularidade do JavaScript fazendo com que o código dependa do componente. Alguns desenvolvedores também podem sentir falta do estilo não versar nada sobre regras aplicadas diretamente a elementos (categoria &lt;em&gt;base&lt;/em&gt; do SMACSS) e boas práticas de CSS.&lt;/p&gt;

&lt;p&gt;O grande trunfo do padrão é mesmo sugerir uma nomenclatura adequada para elementos descendentes. Outro aspecto interessante é o padrão de &lt;a href=&#34;http://bem.info/method/filesystem&#34;&gt;organização de arquivos&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;dry-css&#34;&gt;DRY CSS&lt;/h2&gt;

&lt;p&gt;O princípio consiste em não repetir propriedades com mesmos valores em seu código. De maneira simples, a todo momento que isto for necessário, estas propriedades devem ser agrupadas e endereçadas por vários seletores. O sistema define que o agrupamento seja nomeado através de um primeiro seletor, algo como &lt;code&gt;#MEDIUM-WHITE-BACKGROUND&lt;/code&gt; para um agrupamento de &lt;code&gt;background&lt;/code&gt; e &lt;code&gt;border&lt;/code&gt; brancas. As custas deste primeiro seletor, muitos desenvolvedores confundem que o &lt;em&gt;pattern&lt;/em&gt; sugere que este seletor seja usado no HTML, o que não é verdade.&lt;/p&gt;

&lt;p&gt;A técnica, assim como outros sistemas, sugere que seu código seja pensando em termos de padrões de aparência. O problema está no fato da técnica não sugerir melhor uso das classes de CSS. Segundo o sistema, sempre que a aparência de um elemento mudar, sua classe precisará ser movida para outros agrupamentos nas folhas de estilo. Sistemas como SMACSS e BEM endereçam mudanças de aparência com a criação de um submódulo ou modificador que será adicionado ao HTML evidenciando a alteração e permitindo manter a antiga aparência.&lt;/p&gt;

&lt;p&gt;Não entenda mal, os conceitos por trás do DRY CSS são válidos. Inclusive, já &lt;a href=&#34;http://tableless.com.br/css-steroids&#34;&gt;sugeri uma variação da técnica em conjunto com &lt;em&gt;placeholders&lt;/em&gt; do SASS&lt;/a&gt; para nomear propriedades que definem um elemento da aparência do seu projeto. Os &lt;em&gt;placeholders&lt;/em&gt; carregam os conceitos de DRY CSS e ainda permitem basear sua arquitetura em outros sistemas mais poderosos.&lt;/p&gt;

&lt;h2 id=&#34;afinal-como-escrever-css&#34;&gt;Afinal, como escrever CSS&lt;/h2&gt;

&lt;p&gt;Como você deve ter reparado, todas os sistemas possuem conceitos e abordagens para escrever código melhor e acredito um pouco em cada um deles. Não vai adiantar muito pular para esta conclusão em busca de repostas, os conceitos já foram todos explorados.&lt;/p&gt;

&lt;p&gt;Saiba também que não é por nada que &lt;em&gt;Atomic CSS&lt;/em&gt; não aparece no texto, sem levar em conta a metodologia e apesar das &lt;a href=&#34;http://www.smashingmagazine.com/2013/10/21/challenging-css-best-practices-atomic-approach&#34;&gt;tentativas em convencer&lt;/a&gt;, não enxergo valor em classes como &lt;code&gt;.mt-20&lt;/code&gt; e códigos como o do site &lt;a href=&#34;https://my.yahoo.com&#34;&gt;My Yahoo!&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Voltando ao ponto, por incrível que pareça, o ideal é mesmo misturar os sistemas. Uma boa referência é a &lt;a href=&#34;https://github.com/suitcss/suit/blob/master/doc/naming-conventions.md&#34;&gt;convenção do projeto SUIT CSS&lt;/a&gt;. O projeto convenciona três categorias de classes: utilitárias, componentes e estado; cada uma seguindo um sistema. Classes utilitárias (OCSS) são estruturais, de baixo nível e possuem prefixo &lt;code&gt;.u-&lt;/code&gt;: &lt;code&gt;.u-clearfix&lt;/code&gt;, &lt;code&gt;u-row&lt;/code&gt;, &lt;code&gt;u-span2&lt;/code&gt;. Os componentes definem uma variação de BEM que introduz os sinais &lt;code&gt;--&lt;/code&gt; para designar os &lt;code&gt;modifiers&lt;/code&gt;. Vale a nota que este uso dos hifens é erroneamente atribuído ao BEM, que na realidade define unicamente &lt;em&gt;underscores&lt;/em&gt;. Por fim, o sistema define classes de estado dos componentes seguindo o padrão do SMACSS.&lt;/p&gt;

&lt;p&gt;O projeto &lt;a href=&#34;https://github.com/suitcss&#34;&gt;SUIT CSS&lt;/a&gt;, mantido por ninguém menos que Nicolas Gallagher, criador do normalize.css, é uma fonte incrível para se observar como definir classes seguindo esta mistura mágica de &lt;em&gt;pattenrs&lt;/em&gt;. Um pequeno ponto contra a nomenclatura do projeto é o uso de classes em &lt;code&gt;CamelCase&lt;/code&gt;. Portanto, deixarei logo abaixo uma pequena variação em &lt;code&gt;lowercase&lt;/code&gt; para facilitar o entendimento e servir como um guia simples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Utility */
.u-utility-name {}

/* Component */
.block-name {}
.block-name__element-name {}
.block-name--modifier-name {}

/* State */
.is-global-state {}

/* Component state (scoped to component) */
.block-name.is-state-of-component {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Acima de tudo, é essencial evoluirmos nosso entendimento sobre a importância da busca por um sistema para evitar conflitos de código e facilitar reuso até mesmo entre diferentes projetos. A adoção de um sistema abstrai o raciocínio repetitivo de buscar nomes para as classes e permite escrever CSS com um pouco menos de culpa.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Semântica de variáveis e propriedades personalizadas em CSS</title>
      <link>https://tableless.github.io/hugo-public/semantica-de-variaveis-e-propriedades-personalizadas-em-css/</link>
      <pubDate>Wed, 16 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/semantica-de-variaveis-e-propriedades-personalizadas-em-css/</guid>
      <description>

&lt;h2 id=&#34;pré-processadores&#34;&gt;Pré-processadores&lt;/h2&gt;

&lt;p&gt;Sou defensor do uso de pré-processadores de CSS e tenho alguns &lt;a href=&#34;http://tableless.com.br/css-steroids&#34;&gt;bons argumentos para convencer você&lt;/a&gt;. Um dos benefícios dos pré-processadores é a possibilidade de uso de variáveis para armazenar medidas, cores e outros atributos do &lt;em&gt;layout&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Além de manter seu projeto facilmente configurável e permitir o uso de álgebra, a simples tarefa de dar nome aos atributos força um raciocínio mais apurado. Variações pequenas de medidas e cores, que são resquícios das ferramentas utilizadas para &lt;em&gt;design&lt;/em&gt;, serão mais facilmente identificadas e limadas.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;There are only two hard things in Computer Science: cache invalidation and naming things.&lt;/p&gt;

&lt;p&gt;&amp;#8212; Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A semântica, de maneira geral, descreve o significado dos &lt;em&gt;tokens&lt;/em&gt; da linguagem. Em nosso caso, a semântica descreve quais as transformações que nosso código irá sofrer durante o processamento.&lt;/p&gt;

&lt;p&gt;Diferentes pré-processadores possuem significativas diferenças no comportamento de variáveis. Um aspecto importante é entender qual o comportamento das variáveis em meio a estas transformações a fim de evitar resultados inesperados.&lt;/p&gt;

&lt;h3 id=&#34;introdução&#34;&gt;Introdução&lt;/h3&gt;

&lt;p&gt;Seletores aninhados são a principal influência no comportamento de variáveis em pré-processadores. Variáveis definidas em um nível são visíveis para todos os níveis aninhados mais internamente.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.list {
    $var-red: crimson;
    .list-item {
        color: $var-red;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quando definimos uma variável fora de qualquer seletor, esta será visível em qualquer ponto do código. Chamamos estas variáveis de globais.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$global-red: crimson;
.list-item {
    color: $global-red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sass&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Vejamos a semântica das variáveis no &lt;a href=&#34;http://codepen.io/jcemer/pen/CfvLm&#34;&gt;Sass utilizando um exemplo&lt;/a&gt;. Após definido o valor de uma variável em um seletor, uma nova atribuição em um aninhamento interno terá efeito também nos níveis externos. Este comportamento pode ser um pouco estranho, veja em nosso exemplo como o seletor &lt;code&gt;.just-to-confuse-you&lt;/code&gt; modifica o valor de &lt;code&gt;$orange&lt;/code&gt; afetando inclusive o valor da variável no seletor &lt;code&gt;.is-orange&lt;/code&gt;. O caso da variável global &lt;code&gt;$red&lt;/code&gt; também é curioso, qualquer ponto do código poderá modificar seu valor afetando em todos os seus usos subsequentes indiferente do nível de aninhamento do seletor.&lt;/p&gt;

&lt;p&gt;Caso tenha um bom domínio de JavaScript, uma analogia pode ajudar no seu entendimento. Pense no aninhamento dos seletores como escopos criados por &lt;a href=&#34;http://benalman.com/news/2010/11/immediately-invoked-function-expression&#34;&gt;funções imediatamente invocadas&lt;/a&gt;. A primeira atribuição de valor a uma variável também a declara utilizando &lt;code&gt;var&lt;/code&gt;. As demais atribuições de valor em escopos mais internos não fazem mais uso do &lt;code&gt;var&lt;/code&gt;. Veja, &lt;em&gt;closures&lt;/em&gt; que podem alterar o valor das variáveis dos escopos em que são criadas afetando todos os demais escopos. Variáveis que tem seu primeiro valor atribuído fora de qualquer seletor serão globais, nunca farão uso de &lt;code&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Este comportamento é um tanto estranho e algumas vezes criticado. Um seletor aninhado pode acidentalmente atribuir valor a uma variável global e impactar no restante do projeto. Pensando nisto, as variáveis globais não poderão mais ser alteradas dentro de seletores nas próximas versões do pré-processador. A &lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_CHANGELOG.html#330_7_march_2014&#34;&gt;versão 3.3.0&lt;/a&gt; já inclui a &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;!global&lt;/code&gt;. Nesta versão, já é acusado um &lt;em&gt;warning&lt;/em&gt; se a &lt;em&gt;flag&lt;/em&gt; não for usada ao alterar o valor de uma global dentro de um seletor.&lt;/p&gt;

&lt;p&gt;Vale lembrar que existe também &lt;em&gt;flag&lt;/em&gt; &lt;code&gt;!default&lt;/code&gt; para os casos em que a intenção seja atribuir valor a uma variável apenas se está ainda não tiver recebido algum.&lt;/p&gt;

&lt;h3 id=&#34;less-e-stylus&#34;&gt;LESS e Stylus&lt;/h3&gt;

&lt;p&gt;A semântica de variáveis no LESS e Stylus é um tanto mais previsível. Retomando a nossa analogia com o universo JavaScript, pense como se cada atribuição de valor fosse precedida de uma declaração de variável utilizando &lt;code&gt;var&lt;/code&gt;. O valor do escopo mais externo será ofuscado mas não alterado.&lt;/p&gt;

&lt;p&gt;Voltando aos pré-processadores, um seletor não terá a capacidade de alterar o valor de uma variável global ou definida em um seletor de nível mais externo. Este apenas definirá uma nova variável visível no nível atual e nos níveis mais internos. Mais simples e seguro, porém um tanto menos poderoso que no Sass. Confira o &lt;a href=&#34;http://codepen.io/jcemer/pen/yqLoJ&#34;&gt;exemplo em LESS&lt;/a&gt; (na dúvida, &lt;a href=&#34;http://codepen.io/jcemer/pen/AJzwp&#34;&gt;aqui está em Stylus&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;O LESS não dispõe de nenhuma &lt;em&gt;flag&lt;/em&gt; como &lt;code&gt;!default&lt;/code&gt; e &lt;code&gt;!global&lt;/code&gt;, uma pena.&lt;/p&gt;

&lt;h3 id=&#34;variáveis-e-os-mixins&#34;&gt;Variáveis e os mixins&lt;/h3&gt;

&lt;p&gt;Os &lt;em&gt;mixins&lt;/em&gt; também possuem um papel importante na &lt;a href=&#34;http://codepen.io/jcemer/pen/qBlci&#34;&gt;manipulação de variáveis&lt;/a&gt;, tanto no LESS quanto no Sass, o escopo levado em consideração é aquele em que o &lt;em&gt;mixin&lt;/em&gt; é incluído. Isto é útil para sistemas semânticos de &lt;em&gt;grids&lt;/em&gt; em porcentagem, por exemplo. Confira o código do Bourbon Neat e veja como os &lt;em&gt;mixins&lt;/em&gt; &lt;a href=&#34;https://github.com/thoughtbot/neat/blob/90016226abbdcc4c01cf24ce7346cb4ed2d5291b/app/assets/stylesheets/grid/_row.scss#L3&#34;&gt;utilizam variáveis&lt;/a&gt; para &lt;a href=&#34;https://github.com/thoughtbot/neat/blob/90016226abbdcc4c01cf24ce7346cb4ed2d5291b/app/assets/stylesheets/grid/_span-columns.scss#L8&#34;&gt;compartilhar&lt;/a&gt; valores entre si.&lt;/p&gt;

&lt;p&gt;Curiosamente, os &lt;em&gt;mixins&lt;/em&gt; do Stylus têm acesso as variáveis do seletor em que são incluídos, porém &lt;a href=&#34;http://codepen.io/jcemer/pen/tijCI&#34;&gt;não possuem capacidade de alterar seus valores&lt;/a&gt;. No Stylus, os &lt;em&gt;mixins&lt;/em&gt; constituem um escopo que impossibilita alterar valores de variáveis de escopos externos.&lt;/p&gt;

&lt;p&gt;A semântica de comportamento das variáveis segue a já ilustrada para cada um dos pré-processadores. Portanto, os &lt;em&gt;mixins&lt;/em&gt; de Sass são um tanto mais poderosos e destrutivos por poderem manipular variáveis globais mesmo quando incluídos em um seletor.&lt;/p&gt;

&lt;h2 id=&#34;variáveis-nativas-de-css&#34;&gt;Variáveis nativas de CSS&lt;/h2&gt;

&lt;p&gt;Os pré-processadores de CSS mais populares já tem pouco mais de meia década de existência. Neste tempo, seus benefícios puderam ser comprovados e naturalmente rascunhos de especificações surgiram para incorporar algumas das suas funcionalidades ao CSS.&lt;/p&gt;

&lt;p&gt;O primeiro rascunho de &lt;a href=&#34;http://dev.w3.org/csswg/css-variables&#34;&gt;especificação de variáveis nativas no CSS&lt;/a&gt; data de 2012. Esta especificação é bastante comparada com as variáveis já presentes nos pré-processadores, inclusive por &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables&#34;&gt;fontes renomadas&lt;/a&gt;. Na minha opinião, a comparação é equivocada, &lt;strong&gt;as variáveis nativas possuem uma semântica e uso completamente diferente das que temos nos pré-processadores&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O último rascunho da especificação é intitulado &lt;em&gt;CSS Custom Properties&lt;/em&gt; e isto já nos dá uma boa pista da diferença de comportamento. As variáveis nativas são propriedades &lt;a href=&#34;http://tableless.com.br/efeito-cascata-e-especificidade-do-css&#34;&gt;com característica de herança&lt;/a&gt; igual a &lt;code&gt;color&lt;/code&gt; e &lt;code&gt;font&lt;/code&gt;: seus valores são herdados por padrão pelos filhos do elemento em que são definidas. &lt;strong&gt;Parece simples, mas esta é a grande diferença, o comportamento variáveis nativas é apoiado nos elementos do documento assim como o restante da folha de estilo&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;propriedades-personalizadas&#34;&gt;Propriedades Personalizadas&lt;/h2&gt;

&lt;p&gt;A partir de agora, passaremos a chamar nossas variáveis nativas de propriedades personalizadas a fim de seguir a especificação e expressar melhor seu significado. A propriedade personalizada é aquela cuja definição é precedida de &lt;code&gt;--&lt;/code&gt;. Seus valores podem ser acessados através da função &lt;code&gt;var()&lt;/code&gt;. Vejamos um primeiro exemplo.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.list {
    --red: crimson;
    .list-item {
        color: var(--red);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como você pode imaginar, o conceito de variável global não mais se aplica às propriedades personalizadas. Uma certa confusão pode ser causada ao analisar trechos de código como este abaixo que inclusive fazem parte da especificação.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:root {
--red: crimson;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Não há nenhuma relação com variáveis globais. O &lt;code&gt;:root&lt;/code&gt; trata-se de um seletor da especificação &lt;em&gt;level&lt;/em&gt; 3 que referencia o mais externos dos elementos do documento. Na prática, este seletor pode ser substituído pelo seletor &lt;code&gt;html&lt;/code&gt;. Uma das razões da criação do &lt;code&gt;:root&lt;/code&gt; é a de que folhas de estilo podem ser utilizadas em documentos no formato SVG e XML, o que não vem muito ao caso.&lt;/p&gt;

&lt;h3 id=&#34;componentes&#34;&gt;Componentes&lt;/h3&gt;

&lt;p&gt;O ponto forte das propriedades personalizadas está enraizado justamente na herança. Um dos assuntos mais mencionados nos últimos tempos no desenvolvimento &lt;em&gt;front-end&lt;/em&gt; são os componentes. São nos componentes que as propriedades personalizadas ganham destaque.&lt;/p&gt;

&lt;p&gt;A melhor maneira de provar as vantagens de uma tecnologia é resolvendo um problema real. Tenho em memória um problema que enfrentei em uma plataforma de ensino. Nesta plataforma de ensino, haviam cerca de dez disciplinas, cada uma identificada com uma cor. Os componentes da plataforma ganhavam a caracterização de uma das disciplinas e as cores da disciplina eram utilizadas em diferentes propriedades como &lt;code&gt;background&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt;, &lt;code&gt;box-shadow&lt;/code&gt; e &lt;code&gt;border-color&lt;/code&gt; em elementos distintos do componente. Não existe uma maneira sensata de solucionar um problema como este, a solução é duplicar bastante código. As propriedades personalizadas nos permitem resolver de uma maneira incrível, vejam o exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* Component lesson */
.lesson {
    color: grey;
    border: 1px solid var(--discipline-color);
}
.lesson-title {
    color: var(--discipline-color);
}
.lesson-grade {
    background: var(--discipline-color);
}

/* Disciplines */
.discipline-mathematics {
    --discipline-color: blue;
}

.discipline-portuguese {
    --discipline-color: red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Este exemplo pode ser aplicado muito facilmente ao HTML dos componentes, basta adicionarmos uma das classes de disciplina a cada um deles: &lt;code&gt;&amp;lt;div class=&amp;quot;lesson discipline-mathematics&amp;quot;&amp;gt;&lt;/code&gt;. Veja o &lt;a href=&#34;http://codepen.io/jcemer/pen/uwntB&#34;&gt;exemplo em funcionamento&lt;/a&gt; (apenas Firefox Nightly).&lt;/p&gt;

&lt;h2 id=&#34;palavras-finais&#34;&gt;Palavras finais&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;As propriedades personalizadas não substituem as variáveis dos pré-processadores&lt;/strong&gt;. As variáveis dos pré-processadores continuarão cumprindo sua função de abstrair aspectos de &lt;em&gt;layout&lt;/em&gt; descomplicando sua organização de código. As propriedades personalizadas deverão, por sua vez, facilitar a customização de componentes. O ideal é aprendermos a utilizar estes dois recursos em conjunto.&lt;/p&gt;

&lt;p&gt;A especificação de &lt;em&gt;CSS Custom Properties&lt;/em&gt; ainda está em rascunho e só está implementada por enquanto no Firefox Nightly. Apesar de ainda precisarmos esperar um pouco para utilizar em produção, é importante já raciocinarmos quais os problemas que as propriedades solucionam. Lembre-se que as variáveis de pré-processadores já estão por ai há um bom tempo e não tem porque deixar de usá-las.&lt;/p&gt;

&lt;p&gt;Espero que este texto o tenha ajudado a entender a diferente semântica das variáveis em cada um dos pré-processadores e diferenciado o suficiente das propriedades personalizadas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Acelere o carregamento de suas páginas</title>
      <link>https://tableless.github.io/hugo-public/acelere-o-carregamento-de-suas-paginas/</link>
      <pubDate>Tue, 25 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/acelere-o-carregamento-de-suas-paginas/</guid>
      <description>

&lt;p&gt;Muita coisa já foi escrita sobre este assunto, originalmente em português temos o renomado guia &lt;a href=&#34;http://browserdiet.com/pt&#34;&gt;Como perder peso no browser&lt;/a&gt; cujos autores são feras e a série intitulada &lt;a href=&#34;http://tableless.com.br/performance-frontend-parte1&#34;&gt;Performance front-end&lt;/a&gt; aqui mesmo no Tableless. As iniciativas gringas são muitas com destaque ao &lt;a href=&#34;http://developer.yahoo.com/yslow&#34;&gt;YSlow&lt;/a&gt; e às &lt;a href=&#34;http://developer.yahoo.com/performance/rules.html&#34;&gt;práticas do Yahoo! para melhorar performance&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Neste ponto, se ainda continua nesta leitura, você deve estar se perguntando se existe alguma técnica que não é coberta por alguma destas referências. Há sim. Porém já deixo o aviso, o que veremos a seguir não substitui outras técnicas voltadas a ganho de performance, assim como muitas outras, é apenas uma técnica complementar.&lt;/p&gt;

&lt;h2 id=&#34;carregamento-especulativo&#34;&gt;Carregamento especulativo&lt;/h2&gt;

&lt;p&gt;Uma tentativa de acelerar o carregamento já foi vendida no Brasil como uma funcionalidade incrível creditada a discadores de internet. Sim, discadores. Os pacotes de &lt;em&gt;software&lt;/em&gt; incluíam um navegador especial. A função deste era identificar os &lt;em&gt;hiperlinks&lt;/em&gt; já no carregamento da página e requisitar por eles sem que o usuário tomasse conhecimento. Assim, quando o usuário seguisse algum &lt;em&gt;hiperlink&lt;/em&gt;, o seu conteúdo já estava disponível.&lt;/p&gt;

&lt;p&gt;O resultado desta técnica é um tanto desastroso por duas perspectivas. Muito do conteúdo requisitado nunca era utilizado desperdiçando banda de internet e processamento do cliente e servidor. E em segundo, porque já naquele tempo as páginas &lt;a href=&#34;http://tableless.com.br/o-grande-desencontro-http-com-o-html&#34;&gt;faziam mal uso de &lt;em&gt;hiperlinks&lt;/em&gt;&lt;/a&gt; para operar manipulação e exclusão de recursos.&lt;/p&gt;

&lt;p&gt;Esta técnica já não é mais utilizada, provando que requisitar mais do que se precisa não é uma solução inteligente.&lt;/p&gt;

&lt;h2 id=&#34;carregando-apenas-conteúdo&#34;&gt;Carregando apenas conteúdo&lt;/h2&gt;

&lt;p&gt;Nas aplicações tradicionais, o carregamento de JavaScript e CSS, nossos &lt;em&gt;assets&lt;/em&gt;, despendem &lt;strong&gt;até metade do tempo&lt;/strong&gt; total de carregamento da página. Se considerarmos que, para tirar proveito do &lt;em&gt;cache&lt;/em&gt;, estes &lt;em&gt;assets&lt;/em&gt; serão os mesmos em diferentes páginas. O próximo passo é reaproveitar uma única página durante a navegação.&lt;/p&gt;

&lt;p&gt;A técnica consiste em alterar o comportamento padrão dos &lt;em&gt;hyperlinks&lt;/em&gt; fazendo com que o endereço indicado no atributo &lt;code&gt;href&lt;/code&gt; seja requisitado assincronamente. O resultado da requisição é analisado e apenas o conteúdo de interesse é substituído. O principal ganho de performance se deve ao fato das folhas de estilo e &lt;em&gt;scripts&lt;/em&gt; não serem requisitados durante a navegação.&lt;/p&gt;

&lt;h3 id=&#34;bibliotecas&#34;&gt;Bibliotecas&lt;/h3&gt;

&lt;h4 id=&#34;jquery-pjax&#34;&gt;jQuery PJAX&lt;/h4&gt;

&lt;p&gt;Criada por um dos fundadores do GitHub, a biblioteca &lt;a href=&#34;https://github.com/defunkt/jquery-pjax&#34;&gt;PJAX&lt;/a&gt; implementa a técnica utilizando jQuery. Para testar seu funcionamento, basta navegar por um repositório no próprio GitHub.&lt;/p&gt;

&lt;p&gt;A biblioteca permite indicar quais &lt;em&gt;hyperlinks&lt;/em&gt; terão seu comportamento modificado e qual o &lt;em&gt;container&lt;/em&gt; que deve ser utilizado para depositar o conteúdo retornado pela requisição. O conteúdo retornado pela requisição deve ser tratado no &lt;em&gt;back-end&lt;/em&gt; para retornar estritamente o que precisa ser depositado no &lt;em&gt;container&lt;/em&gt;. Isto é possível graças a um cabeçalho adicionado a requisição que garante sua identificação no &lt;em&gt;back-end&lt;/em&gt;. Mesmo que a intenção seja substituir o &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;, é aconselhado remover o &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; mantendo apenas a &lt;em&gt;tag&lt;/em&gt; &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;. Isto garante um ganho de performance ainda mais significativo.&lt;/p&gt;

&lt;h4 id=&#34;turbolinks&#34;&gt;Turbolinks&lt;/h4&gt;

&lt;p&gt;O Turbolinks é um misto de biblioteca JavaScript e código &lt;em&gt;back-end&lt;/em&gt; que implementa a  técnica de carregamento de conteúdo no Ruby on Rails sem depender de jQuery. A &lt;em&gt;gem&lt;/em&gt;, como são chamados os pacotes de Ruby, é padrão a partir da versão 4.0 do &lt;em&gt;framework&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A biblioteca foi desenvolvida pela 37Signals para ser utilizada na versão &lt;em&gt;mobile&lt;/em&gt; do seu principal produto, o Campfire. O que atesta que a técnica é praticável em dispositivos móveis modernos.&lt;/p&gt;

&lt;p&gt;Diferente da biblioteca PJAX, o Turbolinks não permite que seja configurado o &lt;em&gt;container&lt;/em&gt; de destino do conteúdo, todo o conteúdo do &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; é substituído. Por causa disto, a aplicação não precisa sofrer nenhuma modificação no seu _back-end_ para utilizar a &lt;em&gt;gem&lt;/em&gt;: o conteúdo esperado é o mesmo de uma requisição tradicional de página. Como veremos a seguir, os desafios para se utilizar o Turbolinks e mesmo a PJAX, residem no &lt;em&gt;front-end&lt;/em&gt; da aplicação&lt;/p&gt;

&lt;h3 id=&#34;como-a-técnica-é-possível&#34;&gt;Como a técnica é possível&lt;/h3&gt;

&lt;p&gt;Requisições assíncronas já são usadas frequentemente e enfrentam praticamente nenhum problema de suporte. Nos primórdios, &lt;em&gt;iframes&lt;/em&gt; e API de &lt;code&gt;ActiveXObject&lt;/code&gt; eram usados para possibilitar este tipo de requisição. Atualmente, grande parte dos navegadores suportam a API de &lt;code&gt;XMLHttpRequest&lt;/code&gt; apesar da &lt;a href=&#34;http://www.w3.org/TR/XMLHttpRequest&#34;&gt;especificação estar em rascunho desde 2006&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Note que a técnica é fundamentalmente calcada na mudança da barra de endereço sem que resulte no carregamento de uma nova página. A barra de endereço está intimamente ligada com a seção de histórico onde os navegadores armazenam as páginas acessadas. Antigamente, este histórico podia apenas ser retrocedido e avançado através da interface JavaScript &lt;code&gt;window.history&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Uma nova especificação, associada com o &lt;a href=&#34;http://www.w3.org/TR/2011/WD-html5-20110113/history.html&#34;&gt;HTML5&lt;/a&gt;, permite manipular o histórico e consequentemente a barra de endereço. Como se trata de uma funcionalidade nova, seu &lt;a href=&#34;http://caniuse.com/#feat=history&#34;&gt;suporte é restrito a navegadores modernos&lt;/a&gt;. As bibliotecas PJAX e Turbolinks fazem uma &lt;strong&gt;detecção da funcionalidade&lt;/strong&gt; e operam no modelo de navegação tradicional caso esta não esteja disponível.&lt;/p&gt;

&lt;p&gt;A nova API de &lt;em&gt;history&lt;/em&gt; permite adicionar novas entradas com a função &lt;code&gt;window.history.pushState&lt;/code&gt;. A função recebe os parâmetros &lt;code&gt;data&lt;/code&gt; e &lt;code&gt;title&lt;/code&gt;, utilizados para referenciar esta entrada no histórico. O último parâmetro &lt;code&gt;url&lt;/code&gt; se trata do endereço a ser mostrado na barra de endereço. A API também define um evento &lt;code&gt;popstate&lt;/code&gt; que permite identificar quando o usuário navega por entradas adicionadas ao histórico. Vejamos o funcionamento com um exemplo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;window.addEventListener(&#39;popstate&#39;, function(event) {
  console.log(event.state);
}, false

window.history.pushState({ tableless: &#39;sample&#39; }, &#39;Fake Post&#39;, &#39;http://tableless.com.br/fake-post&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como já observamos, a execução da função &lt;code&gt;pushState&lt;/code&gt; irá adicionar uma entrada no histórico de navegação e alterar a barra de endereço para &lt;em&gt;&lt;a href=&#34;http://tableless.com.br/fake-post&#34;&gt;http://tableless.com.br/fake-post&lt;/a&gt;&lt;/em&gt;. Na ocasião de o usuário retroceder o histórico de navegação, a barra de endereço será alterada para seu endereço inicial e o evento &lt;code&gt;popstate&lt;/code&gt; será disparado. O valor da propriedade &lt;code&gt;state&lt;/code&gt; do evento é aquele definido pelo parâmetro &lt;code&gt;data&lt;/code&gt; na chamada de &lt;code&gt;pushState&lt;/code&gt;. O &lt;em&gt;console&lt;/em&gt; será preenchido com &lt;code&gt;Object {tableless: &amp;quot;sample&amp;quot;}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Dependendo da implementação da API no navegador, o evento &lt;code&gt;popstate&lt;/code&gt; será disparado logo no carregamento da página. Neste caso, o &lt;em&gt;console&lt;/em&gt; será preenchido com &lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;dicas-importantes&#34;&gt;Dicas importantes&lt;/h3&gt;

&lt;p&gt;Fazendo uso das bibliotecas, seu projeto ser tornará uma aplicação que carrega suas páginas assincronamente. Um pré requisito para o que discutiremos a seguir é compreender o comportamento dos &lt;em&gt;scripts&lt;/em&gt;. Sempre que um &lt;em&gt;script&lt;/em&gt; não é disponibilizado no documento, a única maneira de executá-lo é através da API do DOM. Nestes casos, o seu carregamento será assíncrono e sua execução é condicionada ao término do &lt;em&gt;download&lt;/em&gt;. Note, &lt;strong&gt;não há garantia de ordem de execução quando temos mais de um script&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;jquery-pjax-1&#34;&gt;jQuery PJAX&lt;/h4&gt;

&lt;p&gt;A biblioteca analisa o conteúdo retornado pela requisição a procura de &lt;em&gt;scripts&lt;/em&gt;. Caso o arquivo indicado pelo &lt;code&gt;src&lt;/code&gt; ainda não faça parte da aplicação, o &lt;em&gt;script&lt;/em&gt; é adicionado ao &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;. &lt;strong&gt;Apenas estes serão executados sem garantia de ordem&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O ideal é incluir os &lt;em&gt;scripts&lt;/em&gt; no &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; e assistir aos eventos &lt;code&gt;pjax:start&lt;/code&gt; e &lt;code&gt;pjax:end&lt;/code&gt;, disparados imediatamente antes e depois de alterar o conteúdo,  para atribuir e remover comportamentos. Entenda que a biblioteca mantém em &lt;em&gt;cache&lt;/em&gt; todos os conteúdos requisitados para agilizar a navegação pelo histórico. Isto matém ativos os comportamentos atribuídos. O impacto é ainda maior se o conteúdo assiste a eventos do &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; ou outros objetos globais. A remoção dos comportamentos passa a ser de extrema importância para evitar &lt;em&gt;memory leaks&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&#34;turbolinks-1&#34;&gt;Turbolinks&lt;/h4&gt;

&lt;p&gt;A biblioteca &lt;strong&gt;executa todos os &lt;em&gt;scripts&lt;/em&gt; contidos no &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;&lt;/strong&gt; sem garantia de ordem. Um dos problemas mais comuns se dá quando a biblioteca é ativada em aplicações que seguem a boa prática de inserir os &lt;em&gt;scripts&lt;/em&gt; antes do &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;. Os &lt;em&gt;scripts&lt;/em&gt; que tenham alguma dependência, &lt;em&gt;plugins&lt;/em&gt; jQuery, por exemplo, passam a depender da sorte para funcionar. A solução é mover os &lt;em&gt;scripts&lt;/em&gt; para o &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; ou marcar aqueles que não devem ser executados com o atributo &lt;code&gt;data-turbolinks-eval&lt;/code&gt; igual a &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Uma prática comum quando posicionamos &lt;em&gt;scripts&lt;/em&gt; no &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; é acessar o DOM utilizando funções como &lt;code&gt;jQuery.ready &lt;/code&gt;para garantir que já esteja acessível. O maior impacto no uso do Turbolinks é que eventos de &lt;em&gt;load&lt;/em&gt; não serão mais disparados durante a navegação, &lt;code&gt;jQuery.ready &lt;/code&gt;não irá funcionar. A biblioteca dispara os eventos &lt;code&gt;page:receive&lt;/code&gt; e &lt;code&gt;page:load&lt;/code&gt; antes e depois de alterar o conteúdo. Os comportamentos precisam ser atribuídos com base nestes eventos.&lt;/p&gt;

&lt;p&gt;A biblioteca ainda permite que os &lt;em&gt;assets&lt;/em&gt; que contenham o atributo &lt;code&gt;data-turbolinks-track&lt;/code&gt; sejam analisados a cada requisição. Caso uma mudanças seja identificada, a página é completamente recarregada.&lt;/p&gt;

&lt;p&gt;Assim como a PJAX, o Turbolinks também implementa uma estratégia de &lt;em&gt;cache&lt;/em&gt;. O conteúdo, quando trazido imediatamente do &lt;em&gt;cache&lt;/em&gt;, dispara o evento &lt;code&gt;page:restore&lt;/code&gt;. Em seguida, para atualizar o conteúdo, a requisição é refeita. Todas as mudanças de conteúdo, que sempre serão duas nestes casos, são seguidas dos eventos &lt;code&gt;page:change&lt;/code&gt; e &lt;code&gt;page:update&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Gerenciar todos estes eventos pode ser complicado, ainda mais se já estiver acostumado a utilizar &lt;code&gt;jQuery.ready&lt;/code&gt;. A solução é adotar o &lt;em&gt;plugin&lt;/em&gt; &lt;a href=&#34;https://github.com/kossnocorp/jquery.turbolinks&#34;&gt;jQuery Turbolinks&lt;/a&gt;. Mas não se esqueça, a mesma dica de remoção dos comportamentos mencionada na seção a respeito da PJAX são válidas aqui para evitar &lt;em&gt;memory leaks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Um último desafio é fazer com que outras bibliotecas JavaScript sejam compatíveis com o Turbolinks. Serviços comuns como Google Analytics e &lt;em&gt;widgets&lt;/em&gt; do Facebook e Twitter podem não funcionar adequadamente. Um projeto muito interessante chamado &lt;a href=&#34;http://reed.github.io/turbolinks-compatibility&#34;&gt;Turbolinks Compatibility&lt;/a&gt; apresenta estratégias para tornar compatível uma série de bibliotecas.&lt;/p&gt;

&lt;h3 id=&#34;futuro-das-bibliotecas&#34;&gt;Futuro das bibliotecas&lt;/h3&gt;

&lt;p&gt;Formulários ainda são um problema, o Turbolinks não endereça este caso de uso e o PJAX apenas o faz de maneira experimental. O agravante é maior quando o formulário inclui envio de arquivos.&lt;/p&gt;

&lt;p&gt;A especificação em rascunho do XMLHttpRequest Level 2 permite o envio de arquivos com informação de progresso através de requisições assíncronas. Esta é uma funcionalidade muito interessante para aplicações que fazem &lt;em&gt;upload&lt;/em&gt; de muitos arquivos em série, por exemplo. O &lt;a href=&#34;http://caniuse.com/xhr2&#34;&gt;suporte da API&lt;/a&gt; já é muito bom em navegadores modernos.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A biblioteca PJAX é uma alternativa muito boa por permitir atualizar seções específicas da página. Ao mesmo tempo, para uma implementação inicial, a biblioteca permite também o carregamento total do conteúdo da página.&lt;/p&gt;

&lt;p&gt;Turbolinks é uma ótima alternativa para implementar a técnica de carregamento de conteúdo em aplicações Ruby on Rails. Se você quiser ir um pouco além, podendo inclusive enviar formulários, a biblioteca &lt;a href=&#34;https://github.com/igor-alexandrov/wiselinks&#34;&gt;Wiselinks&lt;/a&gt; pode ser uma ótima tentativa.&lt;/p&gt;

&lt;h3 id=&#34;evoluindo-ainda-mais-a-sua-aplicação&#34;&gt;Evoluindo ainda mais a sua aplicação&lt;/h3&gt;

&lt;p&gt;Talvez não pareça tão natural, mas o próximo passo é utilizar uma biblioteca como o Backbone.js. Através dela é possível gerenciar cada um dos &lt;em&gt;containers&lt;/em&gt; que podem sofrer atualização de conteúdo através do construtor &lt;code&gt;Backbone.View&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Os endereços serão gerenciados pelo &lt;code&gt;Backbone.Router&lt;/code&gt; que inclusive utiliza &lt;code&gt;window.history.pushState&lt;/code&gt;. Note a semelhança, todas as páginas que o roteador conhece devem ser implementadas no &lt;em&gt;back-end&lt;/em&gt; para quando o usuário acessar o endereço diretamente. O Backbone.js ainda disponibiliza os construtores de &lt;code&gt;Model&lt;/code&gt; e &lt;code&gt;Collection&lt;/code&gt; para gerenciar os dados da sua aplicação.&lt;/p&gt;

&lt;h3 id=&#34;por-fim&#34;&gt;Por fim&lt;/h3&gt;

&lt;p&gt;Os ganhos em rapidez de carregamento podem ser bastante significativos, mas a aplicação precisa ser repensada e adequada. É preciso testar constantemente a aplicação em busca de &lt;em&gt;memory leaks&lt;/em&gt;.  Apenas adicionar uma das bibliotecas de carregamento de conteúdo assíncrono e esperar que tudo funcione não é uma alternativa. Mas não deixe de tentar, o usuário agradece.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Qual a dose certa de JavaScript</title>
      <link>https://tableless.github.io/hugo-public/qual-dose-certa-de-javascript/</link>
      <pubDate>Mon, 03 Feb 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/qual-dose-certa-de-javascript/</guid>
      <description>

&lt;p&gt;Para uma linguagem de programação que começou de maneira tão despretensiosa, o JavaScript ganhou muito espaço. É bem verdade que &lt;a href=&#34;http://en.wikipedia.org/wiki/Comparison_of_web_browsers#JavaScript_support&#34;&gt;alguns navegadores não dão suporte à linguagem&lt;/a&gt;, mas estes possuem propósitos particulares ou estacionaram em alguma era que não esta.&lt;/p&gt;

&lt;p&gt;O navegador Chrome deve muito da sua popularidade pela rapidez com que interpreta JavaScript e a Mozilla há pouco removeu a opção de desabilitar a linguagem no Firefox. Os fabricantes de navegadores bem sabem, querendo ou não, a internet como conhecemos tem o JavaScript como uma de suas principais dependências.&lt;/p&gt;

&lt;p&gt;O dilema é como melhor aplicar e o quanto tornar dependente nossa aplicação de código escrito em JavaScript. Qual a dose certa?&lt;/p&gt;

&lt;h2 id=&#34;manifesto&#34;&gt;Manifesto&lt;/h2&gt;

&lt;p&gt;O &lt;em&gt;The Web Standards Project&lt;/em&gt; fez bastante barulho há algum tempo e trouxe consigo o &lt;a href=&#34;http://www.webstandards.org/action/dstf/manifesto&#34;&gt;Manifesto do JavaScript&lt;/a&gt;. Segundo o texto, &lt;strong&gt;a função do JavaScript é melhorar a usabilidade das páginas através da adição de interatividade&lt;/strong&gt;. O que nos leva a algumas premissas:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Cliente não deve assumir o papel do servidor&lt;/strong&gt;. O JavaScript não deve ter a função de fazer uma série de requisições em Ajax e montar a página toda no front-end.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;O JavaScript deve ser não obstrusivo&lt;/strong&gt;. A experiência do usuário não deve depender do correto funcionamento e suporte de JavaScript. Mesmo que perdendo usabilidade, todas as funcionalidades devem sempre estar disponíveis.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;a-prática&#34;&gt;A prática&lt;/h2&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;O documento de HTML deve ser entregue para o usuário com conteúdo e o carregamento do JavaScript postergado ao máximo: para o fim do &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;. A não ser que você tenha ótimos motivos (por favor, liste nos comentários), reserve a função de gerar o documento para o servidor da sua aplicação. Falando em comentários, saiba até que o carregamento assíncrono deles não é algo a se orgulhar se o motivo for unicamente limitações de infra estrutura. Em defesa a nós bloqueiros, o Disqus tem uma boa pitada de rede social e isto já nos vale como desculpa para seu uso.&lt;/p&gt;

&lt;p&gt;Voltando ao ponto, o &lt;a href=&#34;https://blog.twitter.com/2012/improving-performance-on-twittercom&#34;&gt;Twitter já aprendeu&lt;/a&gt; na própria pele que a performance no front-end está fortemente ligado a quanto do trabalho é deixado para o navegador. Sua infra pode ter várias APIs fantásticas e dignas mas a função de consolidar as informações não é do navegador do usuário.&lt;/p&gt;

&lt;p&gt;Só me deixe esclarecer um detalhe, nada contra bibliotecas e &lt;em&gt;frameworks&lt;/em&gt; JavaScript, eles são bastante úteis e devem entrar em ação assim que todo o conteúdo já tiver sido carregado. Interações mais complexas podem ter sua usabilidade aprimorada drasticamente se realizadas em uma única página com auxílio de JavaScript.&lt;/p&gt;

&lt;h3 id=&#34;javascript-não-obstrusivo&#34;&gt;JavaScript não obstrusivo&lt;/h3&gt;

&lt;p&gt;O assunto não é nenhuma novidade e caso desconheça &lt;a href=&#34;http://dev.opera.com/articles/view/the-seven-rules-of-unobtrusive-javascrip&#34;&gt;The seven rules of unobtrusive JavaScript&lt;/a&gt; é um bom começo. Sejamos práticos e vamos pegar como exemplo âncoras que removem algum registro da sua base de dados. Sem JavaScript, o clique na âncora não vai resultar em uma requisição de &lt;code&gt;DELETE&lt;/code&gt;, mas sim levar para uma representação do registro que obrigatoriamente deve conter um formulário que permita esta ação. Tudo bem se o usuário precisa navegar para outra página e dar alguns cliques a mais, mesmo com perda de usabilidade, a funcionalidade está lá e pode ser alcançada sem dependência de JavaScript. Caso não tenha compreendido o exemplo das âncoras e sua requisição, confira esta &lt;a href=&#34;http://tableless.com.br/o-grande-desencontro-http-com-o-html&#34;&gt;postagem sobre REST&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Escrever seu código de maneira que não seja obstrusivo é possível na maioria das aplicações. Mas e para aplicações de tempo real, por exemplo, como é possível? Algumas funcionalidades podem não ser possíveis sem o devido suporte computacional, não tem jeito. O que nos resta são os paliativos. Uma aplicações de tempo real pode ter uma &lt;em&gt;meta refresh&lt;/em&gt; no &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; ou um botão para atualizar, não é o ideal, mas é o mínimo.&lt;/p&gt;

&lt;p&gt;Mesmo assim, desculpa, mas não acho prático que por criar código exclusivamente não obstrusivo se deixe de fazer jogos e outras aplicações utilizando WebSockets e WebGL. Mas são poucas as aplicações que estão neste seleto grupo. Por fim, os conceitos por trás de JavaScript não obstrusivo são bastante relevantes e respeitá-los ao máximo continua sendo uma boa prática para tornar sua aplicação acessível a qualquer suporte computacional.&lt;/p&gt;

&lt;h3 id=&#34;acessibilidade&#34;&gt;Acessibilidade&lt;/h3&gt;

&lt;p&gt;A acessibilidade pode estar unicamente relacionada com a escrita de JavaScript não obstrusivo: a partir do momento que sua aplicação não depende exclusivamente de JavaScript, o conteúdo estará sempre acessível. Mas garantir  que sua aplicação esteja acessível apenas quando o JavaScript falhar, demorar para carregar (mais sobre este assunto em breve) ou simplesmente não ter o devido suporte, soa como plano B. Que tal então garantir acessibilidade também quando o JavaScript está sendo executado adequadamente?&lt;/p&gt;

&lt;p&gt;A especificação WAI-ARIA permite tornar acessíveis as tão modernas aplicações ricas. Como estamos nos preocupando com aspectos práticos, vamos a este exemplo de &lt;a href=&#34;http://getbootstrap.com/javascript/#modals&#34;&gt;_modal_ do Bootstrap&lt;/a&gt;. Repare como a &lt;em&gt;modal&lt;/em&gt; não é aberta por uma âncora e sim por um botão.  Neste exemplo, seu conteúdo não está em uma página alternativa ou seção do mesmo documento, não há razão para utilizarmos uma âncora. No elemento da &lt;em&gt;modal&lt;/em&gt;, os atributos de &lt;code&gt;role&lt;/code&gt; e &lt;code&gt;aria-hidden&lt;/code&gt; auxiliam a indicar o tipo de conteúdo e se este está disponível. A função do JavaScript aqui, além de mostrar a &lt;em&gt;modal&lt;/em&gt;, é garantir o correto valor para o atributo &lt;code&gt;aria-hidden&lt;/code&gt; e assegurar que o foco seja direcionado para o elemento da &lt;em&gt;modal&lt;/em&gt; assim que ativada.&lt;/p&gt;

&lt;p&gt;Coleções de componentes de interfaces como a jQuery UI são razoavelmente acessíveis. O calcanhar de Aquiles parece residir nas famosas _tabs._ Inclusive, existem alguns &lt;em&gt;forks&lt;/em&gt; deste _widget_ da jQuery UI tentando atingir melhores níveis de acessibilidade por manter o histórico de navegação, indicar o foco adequadamente e possibilitar melhor navegação através do teclado. Utilizar os atributos WAI-ARIA corretos nem sempre é o bastante.&lt;/p&gt;

&lt;h4 id=&#34;conteúdo-que-pode-sofrer-atualização&#34;&gt;Conteúdo que pode sofrer atualização&lt;/h4&gt;

&lt;p&gt;A especificação de boas práticas de uso de WAI-ARIA nos deixa ainda um recurso pouco comentado e, na minha opinião, de vital importância em uma aplicação rica. São atributos com a função de permitir que a aplicação seja cortês com o usuário: o atributo &lt;code&gt;aria-live&lt;/code&gt;, por exemplo, permite indicar se modificações no conteúdo do elemento devem ser notificadas ao usuário.&lt;/p&gt;

&lt;p&gt;Utilizando novamente o exemplo dos comentários, veja quanto é relevante indicar de forma acessível que novos comentários estão disponíveis. Sempre contamos com o estímulo visual que pode, por diversos motivos, não ser notado pelo usuário. Faz todo sentido em aplicações com algum tipo de comportamento assíncrono poder &lt;a href=&#34;http://www.w3.org/WAI/PF/aria-practices/#liveprops&#34;&gt;indicar quais regiões podem sofrer atualizações&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;modularização&#34;&gt;Modularização&lt;/h3&gt;

&lt;p&gt;Já escrevi por aqui que &lt;a href=&#34;http://tableless.com.br/modularizacao-em-javascript&#34;&gt;modularização nos permite reduzir a complexidade, separar interesses e manter o código de maneira simples&lt;/a&gt;. Mas ainda, digamos que sua aplicação esteja com uma grande quantidade de código a ser baixada. Caso seu código seja modularizado seguindo AMD, pacotes de módulos podem ser carregados sob demanda.&lt;/p&gt;

&lt;p&gt;Pensando em uma &lt;em&gt;single page app&lt;/em&gt; de e-mail, nem sempre que utilizar a aplicação o usuário pode querer escrever mensagens ou gerenciar as configurações. Não há necessidade em fazer o &lt;em&gt;download&lt;/em&gt; e processamento de uma grande quantidade de código responsável por funcionalidades que são de uso esporádico na sua aplicação. Algumas heurísticas interessantes podem ser utilizadas para condicionar o carregamento dos pacotes sem onerar o usuário com o mal visto &amp;#8220;carregando&amp;#8221;. Por exemplo: o usuário leu mais de duas mensagens, é provável que queira escrever alguma; o usuário aproximou o &lt;em&gt;mouse&lt;/em&gt; do botão de configurações, a ação pode estar sendo considerada.&lt;/p&gt;

&lt;h3 id=&#34;versione-o-seu-produto&#34;&gt;Versione o seu produto&lt;/h3&gt;

&lt;p&gt;Claro que a web é de todos e estamos aprendendo a possibilitar que diferentes suportes computacionais possam partilhar de um mesmo documento. Mas sejamos honestos, aplicações ricas, a despeito de todos os seus esforços, podem, por culpa da banda de internet ou capacidade de processamento, ter uma experiência miserável em alguns dispositivos.&lt;/p&gt;

&lt;p&gt;Caso não haja saída e os muitos recursos sejam o diferencial do seu produto, uma versão &lt;em&gt;fit&lt;/em&gt; da sua aplicação com uso limitado de JavaScript pode ser a solução. O Gmail já segue esta estratégia há muito tempo e até o momento não me parece uma má jogada. Nunca esqueça que o essencial é garantir uma experiência adequada para o usuário.&lt;/p&gt;

&lt;p&gt;Note ainda que esta prática não entra em desacordo com a premissa de escrever JavaScript não obstrusivo. Pelo contrário, o que estamos oferecendo é um fluxo alternativo onde as funcionalidades principais do produto estão disponíveis mesmo que com uma usabilidade mais pobre. Uma versão alternativa da aplicação pode ainda se valer da modularização do seu código e se você for bem esperto, irá reaproveitar muita coisa.&lt;/p&gt;

&lt;h2 id=&#34;palavras-finais&#34;&gt;Palavras finais&lt;/h2&gt;

&lt;p&gt;Levando em conta qualquer aplicação, saiba que é difícil avaliar pela quantidade de linhas o quão adequado é um código JavaScript. Se você compreendeu bem os exemplos e conceitos do texto, vai notar que não há nenhuma relação entre a dose certa e esta outra medida.&lt;/p&gt;

&lt;p&gt;Em uma única sentença, a &lt;strong&gt;dose certa de JavaScript é aquela em que a experiência do usuário é glorificada&lt;/strong&gt;. Isto vai depender muito dos objetivos da sua aplicação e na maneira que você escreve código. Tudo isto irá afetar a acessibilidade, usabilidade e performance.&lt;/p&gt;

&lt;p&gt;Aprenda a pensar e planejar a sua aplicação como um todo, apenas JavaScript não será sua salvação nem sua completa derrota. Saiba que as vezes a acessibilidade só pode ser alcançada com a ajuda de alguns atributos no HTML. O segredo é estudar alternativas, experimentar soluções e mensurar resultados.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>O grande desencontro do HTTP com o HTML</title>
      <link>https://tableless.github.io/hugo-public/o-grande-desencontro-http-com-o-html/</link>
      <pubDate>Mon, 06 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/o-grande-desencontro-http-com-o-html/</guid>
      <description>

&lt;p&gt;O texto irá contar a evolução e desencontro de duas tecnologias. O importante aqui é apresentar a você uma série de conceitos e raciocínios ligados à linguagem de marcação e ao protocolo de marcação mais famosos dos nossos tempos. Vê se não banca o curioso, nada de descer até o fim do texto para conhecer o desfecho desta trama.&lt;/p&gt;

&lt;h2 id=&#34;prólogo&#34;&gt;Prólogo&lt;/h2&gt;

&lt;h3 id=&#34;hypertext-transfer-protocol-http&#34;&gt;Hypertext Transfer Protocol (HTTP)&lt;/h3&gt;

&lt;p&gt;O HTTP é um protocolo de comunicação para distribuição de objetos de hipermídia referenciados por uma URL. Este é o principal dos protocolos da Internet e com certeza, como desenvolvedores, é o que devemos melhor conhecer. A função do protocolo é bastante simples: realizar requisições e receber respostas entre um cliente e servidor.&lt;/p&gt;

&lt;p&gt;A transmissão de informações entre um emissor e um receptor caracteriza uma comunicação. E da mesma forma que uma comunicação interpessoal, a cordialidade é essencial. O protocolo HTTP estabelece um cabeçalho para suas requisições e respostas. O cabeçalho de uma mensagem são informações complementares que são de uso do cliente e servidor. Através das informações passadas pelo cabeçalho, que são de uso exclusivo do servidor e navegador, é possível informar em uma requisição a preferência de idiomas, as codificações e os formatos de conteúdo para uma resposta. O cabeçalho da resposta, por sua vez, contém o &lt;a href=&#34;http://httpstatus.es&#34;&gt;código de status&lt;/a&gt;, codificação, formato do conteúdo e tempo de expiração da página.&lt;/p&gt;

&lt;h4 id=&#34;métodos-de-requisição&#34;&gt;Métodos de requisição&lt;/h4&gt;

&lt;p&gt;O protocolo HTTP foi criado no projeto World Wide Web e designado para operar essencialmente com documentos de hipertexto. Nesta época, havia somente o método GET para requisitar as páginas, mas isto foi antes de qualquer especificação do protocolo.&lt;/p&gt;

&lt;p&gt;O HTTP 1.1, que constitui a especificação consolidada mais recente, possui alguns outros métodos que são informados no cabeçalho da requisição. Os principais métodos que você deve conhecer são:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;: desde sempre, solicita um objeto para o servidor. Em tempo, objetos são qualquer entidade que o servidor conheça e que o cliente esteja interessando em manipular.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PUT&lt;/strong&gt;: escreve um objeto no servidor de maneira a respeitar a propriedade da &lt;a href=&#34;http://pt.wikipedia.org/wiki/Idempot%C3%AAncia&#34;&gt;idempotência&lt;/a&gt;. Em linhas gerais, este tipo de requisição pode ser chamada mais de uma vez e o resultado no servidor será o mesmo. Geralmente estas requisições carregam consigo um identificador único para o objeto e portanto são mais usadas para alterá-lo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;: escreve um objeto no servidor sem respeitar a propriedade da idempotência. Requisições deste tipo, quando repetidas, podem gerar resultados diferentes no servidor. O uso comum é para a criação de objetos no servidor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DELETE&lt;/strong&gt;: remove um objeto no servidor.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;representational-state-transfer-rest&#34;&gt;Representational State Transfer (REST)&lt;/h3&gt;

&lt;p&gt;Graças a ubiquidade alcançada pelos navegadores, aplicações apoiadas na internet são cada vez mais comuns. REST é um estilo de arquitetura que define como aplicações devem utilizar o protocolo HTTP e URLs para representar recursos.&lt;/p&gt;

&lt;p&gt;O estilo estabelece que o conceito de &lt;strong&gt;recurso&lt;/strong&gt; é tudo aquilo no servidor que pode ser nomeado, tal como documentos ou imagens. Cada recurso deve possuir um identificador único, ou seja, uma &lt;strong&gt;URL&lt;/strong&gt;. Por exemplo, uma aplicação para gerenciar produtos pode identificar um recurso de produto através da URL &lt;code&gt;products/59&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O cliente, através dos &lt;strong&gt;métodos de requisição do HTTP&lt;/strong&gt;, efetua ações em um recurso. Considerando a mesma aplicação, requisições com método &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt; e &lt;code&gt;DELETE&lt;/code&gt; para a URL &lt;code&gt;products/59&lt;/code&gt; irão mostrar, alterar e excluir o produto, respectivamente. Note, uma única URL para três diferentes ações.&lt;/p&gt;

&lt;p&gt;O último conceito relacionado a REST é o de &lt;strong&gt;representação&lt;/strong&gt;. O cliente sempre irá transferir uma representação de um recurso. Informações passadas pelo cabeçalho da requisição ou acrescentadas ao fim da URL podem informar qual o formato da representação que se espera de um recurso. Desta forma, o mesmo recurso pode ser transferido na forma de HTML, JSON e até mesmo XML.&lt;/p&gt;

&lt;p&gt;O Ruby on Rails, &lt;em&gt;framework&lt;/em&gt; bastante usado para desenvolver aplicações &lt;em&gt;web&lt;/em&gt;, prove uma série de funcionalidades para auxiliar o uso de REST. Para compreender melhor o assunto, basta conferir &lt;a href=&#34;http://guides.rubyonrails.org/routing.html#crud-verbs-and-actions&#34;&gt;o guia de rotas&lt;/a&gt; do Ruby on Rails, que documenta como definir URLs e ações de &lt;em&gt;controller&lt;/em&gt; com base em recursos.&lt;/p&gt;

&lt;p&gt;A bibliografia a respeito de REST é vasta. A última dica sobre o assunto é conferir a tradução de um texto que é muito bom e engraçado: &lt;a href=&#34;http://distopico.wordpress.com/traducao-de-how-i-explained-rest-to-my-wife&#34;&gt;Como eu expliquei REST para a minha esposa&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;hypertext-markup-language-html&#34;&gt;Hypertext Markup Language (HTML)&lt;/h3&gt;

&lt;p&gt;O desenvolvimento do HTML foi concomitante ao do HTTP, sua função é marcar os documentos do projeto World Wide Web. Você já está careca de saber que o HTML é um conjunto de &lt;em&gt;tags&lt;/em&gt; que estruturam e garantem semântica ao documento.&lt;/p&gt;

&lt;h2 id=&#34;capítulo-1-a-evolução-das-especificações&#34;&gt;Capítulo 1: A evolução das especificações&lt;/h2&gt;

&lt;p&gt;No início, o navegador tinha como função ser a interface para uma grande biblioteca distribuída. O protocolo HTTP, antes mesmo da sua especificação, tinha apenas um método GET. Não havia a intenção de se alterar as informações armazenadas em um servidor. A primeira especificação do HTTP já era mais ambiciosa e definia uma série de &lt;a href=&#34;http://www.w3.org/Protocols/HTTP/Methods.html&#34;&gt;métodos de requisições&lt;/a&gt;. Com estes métodos, já era possível deixar explícito que uma alteração seria realizada no servidor.&lt;/p&gt;

&lt;p&gt;Criada logo após a especificação do HTTP, a &lt;a href=&#34;http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt&#34;&gt;primeira especificação do HTML&lt;/a&gt; era um pouco menos ambiciosa. Tente imaginar, a especificação não continha formulários. Mesmo assim, os métodos de requisição do HTTP não foram deixados de fora. As âncoras aceitavam um atributo &lt;code&gt;methods&lt;/code&gt; para indicar quais métodos poderiam ser usados ao requisitar determinado objeto. Poucos navegadores deram suporte ao atributo, o qual nunca chamou muita a atenção e na especificação atual já está obsoleto.&lt;/p&gt;

&lt;p&gt;Manter o HTML com o único propósito de marcar conteúdo já não era a estratégia quando definida a segunda especificação da linguagem. A especificação eleva o HTML 2.0 a um &lt;em&gt;Internet Media Type&lt;/em&gt;. Isto significa que os usuários podem não apenas navegar e interagir com documentos, mas também preencher e submeter formulários.&lt;/p&gt;

&lt;p&gt;Além de um atributo &lt;code&gt;action&lt;/code&gt; com a URL de destino, os formulários aceitam um atributo &lt;code&gt;method&lt;/code&gt; que suporta os valores &lt;code&gt;GET&lt;/code&gt; ou &lt;code&gt;POST&lt;/code&gt; como método da requisição de envio. O uso de &lt;code&gt;POST&lt;/code&gt;, segundo a especificação, é restrito a operações que modifiquem a base de dados ou assinem algum serviço.&lt;/p&gt;

&lt;h2 id=&#34;capítulo-2-o-desencontro&#34;&gt;Capítulo 2: O desencontro&lt;/h2&gt;

&lt;p&gt;No estado atual da especificação, o HTML suporta âncoras que realizam requisições com o método &lt;code&gt;GET&lt;/code&gt; e formulários que são enviados com método &lt;code&gt;GET&lt;/code&gt; ou &lt;code&gt;POST&lt;/code&gt;. Qualquer outro recurso, tais como imagens, folhas de estilo e &lt;em&gt;scripts&lt;/em&gt;, são requisitados com o método &lt;code&gt;GET&lt;/code&gt;. &lt;strong&gt;O HTML não possui nenhum recurso para o uso dos métodos &lt;code&gt;PUT&lt;/code&gt; e &lt;code&gt;DELETE&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O resultado é que não existe uma maneira de utilizar uma API REST unicamente através de HTML. Em outras palavras, uma página pode apenas acessar e criar novos recursos. Não é possível excluir ou alterar recursos utilizando REST e toda a sorte dos métodos de requisição do HTTP.&lt;/p&gt;

&lt;p&gt;As discussões a respeito desta falha de compatibilidade são antigas. Existem várias propostas de soluções. A mais notável, chamada &lt;a href=&#34;http://cameronjones.github.io/form-http-extensions/index.html#form-method-attribute&#34;&gt;HTML Form HTTP Extensions&lt;/a&gt;, acrescenta um atributo &lt;code&gt;method&lt;/code&gt; ao formulário que aceita a maioria dos métodos do HTTP 1.1. Desta maneira, é possível disparar uma requisição com método &lt;code&gt;DELETE&lt;/code&gt; através de um formulário. A proposta, que é um rascunho não oficial e não possui suporte em nenhum navegador, inclui também artifícios para adicionar informações ao cabeçalho da requisição.&lt;/p&gt;

&lt;h2 id=&#34;capítulo-3-alternativas&#34;&gt;Capítulo 3: Alternativas&lt;/h2&gt;

&lt;p&gt;Antes de falar das alternativas, é importante nos voltarmos para o JavaScript. A API &lt;code&gt;XMLHttpRequest&lt;/code&gt; permite o uso de todos os métodos além de manipular outros dados do cabeçalho da requisição:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request = new XMLHttpRequest();
request.open(&#39;DELETE&#39;, &#39;products/59&#39;);

request.setRequestHeader(&#39;X-Requested-With&#39;, &#39;XMLHttpRequest&#39;);
request.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;É importante destacar que poder disparar requisições com diferentes métodos apenas através de JavaScript não é o bastante. Em especial, requisições deste tipo são assíncronas, não sendo sempre o que precisamos.&lt;/p&gt;

&lt;h3 id=&#34;formulários&#34;&gt;Formulários&lt;/h3&gt;

&lt;p&gt;Apesar do Ruby on Rails se tratar de um framework para desenvolver aplicações web para navegadores, o estilo REST é suportado e evangelizado em toda a documentação do framework.&lt;/p&gt;

&lt;p&gt;Enquanto as especificações não evoluem, os formulários parecem ser a melhor alternativa para disparar diferentes métodos. O Ruby on Rails tem como dependência o &lt;a href=&#34;http://rack.github.io&#34;&gt;Rack&lt;/a&gt;, que é uma interface para desenvolver aplicações em Ruby. O Rack permite que o formulário com método &lt;code&gt;POST&lt;/code&gt; possa informar um novo método através de um campo &lt;code&gt;_method&lt;/code&gt;. Isto não afeta diretamente o método da requisição, apenas faz com que o Ruby on Rails interprete a requisição de maneira diferente. O formulário a seguir seria atendido por uma rota de &lt;code&gt;DELETE&lt;/code&gt; de &lt;code&gt;products/59&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;products/59&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;hidden&amp;quot; name=&amp;quot;_method&amp;quot; value=&amp;quot;delete&amp;quot;&amp;gt;
    &amp;lt;button&amp;gt;Deletar produto&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caso esteja utilizando Ruby on Rails, não é recomendado possuir códigos como este nas suas &lt;code&gt;views&lt;/code&gt;. Ao invés disto, utilize &lt;a href=&#34;http://guides.rubyonrails.org/form_helpers.html&#34;&gt;Form Helpers&lt;/a&gt;, os quais já se encarregam de escrever este e outros campos necessários para o correto funcionamento do framework.&lt;/p&gt;

&lt;p&gt;Tratando-se de outras linguagens, diferentes frameworks &lt;em&gt;full-stack&lt;/em&gt; também endereçam esta solução. O Laravel, escrito em PHP, &lt;a href=&#34;http://laravel.com/docs/html#opening-a-form&#34;&gt;também suporta um campo &lt;code&gt;hidden&lt;/code&gt; de nome &lt;code&gt;_method&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A flexibilidade e vantagem desta solução é poder ter as mesmas rotas e ações para manipular um recurso através de formulários HTML e requisições JavaScript. Graças ao REST, as diferentes ações podem transferir uma representação do recurso em HTML ou JSON para requisições oriundas de formulários e &lt;code&gt;XMLHttpRequest&lt;/code&gt;, respectivamente.&lt;/p&gt;

&lt;h3 id=&#34;âncoras&#34;&gt;Âncoras&lt;/h3&gt;

&lt;p&gt;Segunda a especificação, os &lt;em&gt;links&lt;/em&gt; são conexões entre dois recursos. Em especial, as âncoras permitem que o usuário navegue através de um documento ou acesse outro recurso seguindo determinada URL. Os &lt;em&gt;links&lt;/em&gt;, que incluem &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;, sempre requisitam recursos através do método &lt;code&gt;GET&lt;/code&gt; e portanto &lt;strong&gt;não devem causar efeito colateral no servidor&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;removendo-registros&#34;&gt;Removendo registros&lt;/h4&gt;

&lt;p&gt;Em áreas administrativas, é bastante comum termos registros em tabelas com uma âncora de excluir. E está errado por vários motivos: não é por navegar para uma página que registros devem ser excluídos. Lembre-se que nos tempos em que conexão banda larga era rara, aceleradores praticavam acesso a todas as âncoras para agilizar a navegação. Assim, tudo seria excluído. O mínimo a se dizer é que cada um destes botões devem estar envoltos em um formulário &lt;code&gt;POST&lt;/code&gt;, até mesmo se sua aplicação não respeitar REST.&lt;/p&gt;

&lt;p&gt;Um argumento que pode surgir contra esta prática é a mudança dos elementos no HTML, por trocarmos um único &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; por um formulário que tem um &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; não tão fácil de estilizar. Se você estiver utilizando REST, existe uma alternativa que é apoiada em JavaScript: continuar usando &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; que quando clicado criará e enviará um formulário. O Ruby on Rails faz exatamente isto com o auxílio do &lt;code&gt;jquery_ujs&lt;/code&gt; incluso na gem &lt;a href=&#34;https://github.com/rails/jquery-rails&#34;&gt;jquery-rails&lt;/a&gt; quando encontra uma âncora com &lt;code&gt;data-method&lt;/code&gt; igual a esta:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;products/59&amp;quot; data-method=&amp;quot;delete&amp;quot; rel=&amp;quot;nofollow&amp;quot;&amp;gt;Remover&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;O atributo &lt;code&gt;rel&lt;/code&gt; com valor &lt;code&gt;nofollow&lt;/code&gt; serve para que esta âncora não seja deliberadamente seguida. Repetindo uma recomendação, caso esteja no Rails, utilize o &lt;em&gt;helper&lt;/em&gt; &lt;code&gt;link_to&lt;/code&gt; ao invés de escrever diretamente o código acima.&lt;/p&gt;

&lt;p&gt;Um detalhe importante é que através desta abordagem, caso o comportamento do JavaScript seja impedido, o usuário terá apenas acesso a uma representação do recurso. O mesmo acontece para o caso de o usuário copiar esta URL e acessar pela barra de navegação. Nestes casos, uma requisição &lt;code&gt;GET&lt;/code&gt; é disparada e não haverá exclusão do recurso. A questão aqui é que a representação do recurso, ou seja, a página que é exibida ao acessar &lt;code&gt;products/59&lt;/code&gt; através de &lt;code&gt;GET&lt;/code&gt;, deve conter um formulário que permita excluir o produto. Este artifício muitas vezes é deixado de lado e a exclusão dos registros fica condiciona a JavaScript.&lt;/p&gt;

&lt;h2 id=&#34;nota-do-autor&#34;&gt;Nota do autor&lt;/h2&gt;

&lt;p&gt;O conceito de REST é muito interessante e espero que logo possamos utilizar nativamente no HTML. Seria genial e com certeza é necessária uma evolução da especificação neste aspecto. Cá entre nós, evoluções deste tipo são muito mais úteis que mudar a semântica de &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; e afins.&lt;/p&gt;

&lt;p&gt;Antes de mais nada, não se esqueça que &lt;strong&gt;acessar um &lt;em&gt;link&lt;/em&gt; não pode causar nenhum efeito colateral na sua aplicação&lt;/strong&gt;. Use e abuse de formulários. Mais ainda, faça que o &lt;em&gt;back-end&lt;/em&gt; da sua aplicação utilize REST. Escolha um bom &lt;em&gt;framework&lt;/em&gt; e vá em frente.&lt;/p&gt;

&lt;p&gt;Desculpe pelo texto ter ficado extenso e talvez um tanto pesado. Espero que tenha gostado e que aproveite estas dicas para escrever aplicações melhores.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Modularização em JavaScript</title>
      <link>https://tableless.github.io/hugo-public/modularizacao-em-javascript/</link>
      <pubDate>Mon, 09 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/modularizacao-em-javascript/</guid>
      <description>

&lt;p&gt;Modularização implica na divisão das funcionalidades de um código em partes distintas. Os módulos compõe peças que podem ser adicionadas e removidas quando necessário, vejam: &lt;strong&gt;reuso de código&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Os frutos do &lt;strong&gt;encapsulamento&lt;/strong&gt; alcançado com a modularização são a &lt;strong&gt;redução da complexidade&lt;/strong&gt;, &lt;strong&gt;separação de interesses&lt;/strong&gt; e &lt;strong&gt;manutenção descomplicada&lt;/strong&gt;. Ainda, a definição de cada módulo força o programador a determinar quais os limites e responsabilidades de cada porção do código.&lt;/p&gt;

&lt;p&gt;Acredito que estes argumentos já justificam a adoção de um sistema de módulos para seu código. Assumindo que estamos escrevendo código segundo a &lt;a href=&#34;http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf&#34;&gt;especificação ECMAScript 5&lt;/a&gt;, tudo começa por uma das palavras grifadas no início do texto: encapsulamento.&lt;/p&gt;

&lt;h2 id=&#34;encapsulamento-em-javascript&#34;&gt;Encapsulamento em JavaScript&lt;/h2&gt;

&lt;p&gt;Todo programador que se depara com um código, por menos complexo que seja, precisará entender o conceito de escopo. O &lt;a href=&#34;http://msdn.microsoft.com/pt-br/library/ie/bzt2dkta(v=vs.94).aspx&#34;&gt;escopo de uma variável&lt;/a&gt; ou função no JavaScript são as linhas de código em que estas são acessíveis.&lt;/p&gt;

&lt;p&gt;Encapsulamento é um dos fundamentos da programação orientada a objetos tradicional. Considerando que não temos classes no JavaScript e se entendermos encapsulamento como uma forma de restringir acesso à informação, concluímos que a definição de escopo é o caminho para alcança-lo.&lt;/p&gt;

&lt;p&gt;O JavaScript possui um escopo global, que quando em navegadores é &lt;code&gt;window&lt;/code&gt;, e aqueles criados a partir da &lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FFunctions_and_function_scope&#34;&gt;execução de uma função&lt;/a&gt;. A maneira mais fácil de alcançar encapsulamento é utilizando uma função anônima invocada imediatamente após sua definição:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;(function () {
    var hideFromOutside = true;
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Por favor, saiba que este &lt;em&gt;pattern&lt;/em&gt; chama-se &lt;a href=&#34;http://benalman.com/news/2010/11/immediately-invoked-function-expression&#34;&gt;Immediately-Invoked Function Expression (IIFE)&lt;/a&gt; e que os parênteses iniciais servem para que a instrução seja reconhecida como uma expressão.&lt;/p&gt;

&lt;h2 id=&#34;módulos&#34;&gt;Módulos&lt;/h2&gt;

&lt;p&gt;Mencionado já há mais de 10 anos, o mais simples dos padrões de escrita de módulos em JavaScript é o &lt;em&gt;module pattern&lt;/em&gt;. O padrão consiste de uma IIFE que retorna um objeto com valores e funções, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;var counter = (function () {
  var current = 0;
  return {
    name: &#34;counter&#34;,
    next: function () {
      return current + 1;
    },
    isFirst: function () {
      return current == 0;
    }
  };
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;revealing-module-pattern&#34;&gt;Revealing Module Pattern&lt;/h3&gt;

&lt;p&gt;O &lt;a href=&#34;http://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript&#34;&gt;module pattern possui muitas variações&lt;/a&gt;, uma delas é o &lt;em&gt;revealing module pattern&lt;/em&gt;. Neste padrão, todas as funções e valores do módulo são &lt;strong&gt;acessíveis no escopo local&lt;/strong&gt; e apenas referências são retornadas na forma de objeto.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;var counter = (function () {
  var current = 0;
  function next() {
    return current + 1;
  }
  function isFirst() {
    return current == 0;
  }

  return {
    next: next,
    isFirst: isFirst
  };
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apesar de mencionado no &lt;a href=&#34;http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world&#34;&gt;artigo que define o padrão&lt;/a&gt;, o ideal é retornar apenas referências a funções, &lt;a href=&#34;http://jsfiddle.net/J4Rkd/1&#34;&gt;retornar outros valores pode dar dor de cabeça&lt;/a&gt;. &lt;em&gt;Revealing module pattern&lt;/em&gt; é bastante interessante pela garantia de acesso descomplicado sem a necessidade de uso do &lt;code&gt;this&lt;/code&gt;, por exemplo. A propósito, este conceito será útil para a construção de módulos melhores em outros padrões.&lt;/p&gt;

&lt;h3 id=&#34;namespace&#34;&gt;Namespace&lt;/h3&gt;

&lt;p&gt;Os padrões que vimos até então poluem o escopo global da aplicação com a definição de uma série de variáveis. Uma solução é a criação de um &lt;em&gt;namespace&lt;/em&gt; de uso específico para os módulos.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;window.App = {
  modules: {}
};

App.modules.counter = (function () {
  /* ... */
})();

App.modules.slider = (function () {
  /* ... */
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;módulos-robustos&#34;&gt;Módulos robustos&lt;/h2&gt;

&lt;p&gt;É natural que módulos dependam uns dos outros. Uma característica importante de um sistema de módulos robusto é a possibilidade de &lt;strong&gt;indicar quais são as dependências&lt;/strong&gt; de um determinado módulo e traçar uma estratégia de carregamento caso esta não esteja disponível.&lt;/p&gt;

&lt;h3 id=&#34;asyncronous-module-definition-amd&#34;&gt;Asyncronous Module Definition (AMD)&lt;/h3&gt;

&lt;p&gt;Módulos AMD podem ser requisitados, definidos e utilizados a medida que necessários. Nosso contador, se reescrito em AMD, ficaria da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;define(&#39;counter&#39;, function () {
  var current = 0;
  function next() {
    return current + 1;
  }
  function isFirst() {
    return current == 0;
  }
  return {
    next: next,
    isFirst: isFirst
  };
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Diferente de outros sistemas de módulos, as dependências de cada módulo AMD são indicadas na sua própria definição. Isto significa que as dependências não precisam estar prontas para o uso assim que o módulo seja definido, estas podem ser carregadas assincronamente condicionando a execução do módulo.&lt;/p&gt;

&lt;p&gt;O trecho de código a seguir define um módulo com duas dependências:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;define(
  [
    &#39;dep1&#39;,
    &#39;dep2&#39;
  ], 

  function (dep1, dep2) {
    /* ... */
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caso tenha achado estranho, saiba que a definição do módulo geralmente utiliza uma formatação de espaços bastante específica para facilitar a leitura e entendimento das dependências.&lt;/p&gt;

&lt;p&gt;Em meio ao trecho de código, caso não tenha notado, não definimos o identificador deste módulo. Os módulos podem (e devem) ser definidos um em cada arquivo e, nestes casos, o nome do arquivo torna-se o identificador.&lt;/p&gt;

&lt;h4 id=&#34;requisitando-módulos&#34;&gt;Requisitando módulos&lt;/h4&gt;

&lt;p&gt;Toda aplicação terá um trecho principal de código que irá requisitar os módulos e fazer o &lt;em&gt;bootstrap&lt;/em&gt; da aplicação. O &lt;code&gt;require&lt;/code&gt; (sim, a semântica é lógica) não exige identificação e atende ao requisito, veja a seguir:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;&lt;code&gt;require(
  [
    &#39;slider&#39;,
    &#39;counter&#39;,
    &#39;inputMask&#39;
  ], 

  function (slider, counter, inputMask) {
     /* ... */
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Uma boa prática é criar uma interface comum para iniciar o comportamento de cada um dos módulos. Existem diferentes preferências, particularmente utilizo uma função &lt;code&gt;init&lt;/code&gt;. Desta forma, o corpo de código do &lt;code&gt;require&lt;/code&gt; conteria algo como &lt;code&gt;slider.init()&lt;/code&gt; e &lt;code&gt;counter.init()&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;carregando-os-módulos&#34;&gt;Carregando os módulos&lt;/h4&gt;

&lt;p&gt;Módulos AMD podem ser utilizados em qualquer navegador, porém sua definição não é suportada nativamente. O que significa que precisamos de uma biblioteca que provenha as tais funções &lt;code&gt;define&lt;/code&gt; e &lt;code&gt;require&lt;/code&gt;. O mais popular &lt;code&gt;loader&lt;/code&gt; de AMD é o &lt;a href=&#34;http://requirejs.org&#34;&gt;require.js&lt;/a&gt;. Desculpe decepcionar, mas &lt;a href=&#34;http://requirejs.org/docs/start.html#get&#34;&gt;sua configuração&lt;/a&gt; não está no escopo deste texto.&lt;/p&gt;

&lt;h4 id=&#34;empacotando-os-módulos&#34;&gt;Empacotando os módulos&lt;/h4&gt;

&lt;p&gt;Um dos principais argumentos contra o uso de AMD é a demora para o carregamento de todos os módulos e suas dependências. &lt;strong&gt;Apesar de possível, o carregamento assíncrono de cada um dos módulos é sumariamente não recomendado&lt;/strong&gt; levando em conta os &lt;a href=&#34;https://speakerdeck.com/jcemer/protocolos-de-comunicacao&#34;&gt;protocolos de rede&lt;/a&gt; que utilizamos atualmente.&lt;/p&gt;

&lt;p&gt;Existem ferramentas como o &lt;a href=&#34;https://github.com/jrburke/r.js&#34;&gt;r.js&lt;/a&gt; que tem a função de empacotar os módulos e entregar um único arquivo para donwload no client-side. O r.js depende de Node.js e introduz uma etapa de análise e concatenação dos arquivos.&lt;/p&gt;

&lt;p&gt;Caso já possua um &lt;a href=&#34;http://tableless.com.br/workflow-para-cuidar-dos-seus-assets&#34;&gt;workflow para cuidar do seus assets&lt;/a&gt;, concatenar os arquivos e utilizar o &lt;a href=&#34;https://github.com/jrburke/almond&#34;&gt;almond&lt;/a&gt; pode ser uma solução bem mais simples. O único detalhe é que você precisará atribuir um identificador para cada módulo. Mesmo que os módulos estejam definidos cada um em um arquivo, lembre-se que a biblioteca entrará em ação apenas após a concatenação.&lt;/p&gt;

&lt;h4 id=&#34;motivação-para-o-uso&#34;&gt;Motivação para o uso&lt;/h4&gt;

&lt;p&gt;Os módulos AMD já são utilizados nos mais famosos projetos escritos em JavaScript, basta acessar os repositórios: &lt;a href=&#34;https://github.com/jquery/jquery/blob/master/src/core.js&#34;&gt;jQuery&lt;/a&gt;, &lt;a href=&#34;https://github.com/flightjs/flight/blob/master/lib/index.js&#34;&gt;Flight&lt;/a&gt;, &lt;a href=&#34;https://github.com/lodash/lodash-amd/blob/master/compat/main.js&#34;&gt;Lo-Dash&lt;/a&gt;, &lt;a href=&#34;https://github.com/mout/mout/blob/master/src/index.js&#34;&gt;Mout&lt;/a&gt;; e muitos outros.&lt;/p&gt;

&lt;p&gt;A definição permite ainda definir plugins para estender o comportamento de carregamento dos módulos e carregar outros conteúdos que não sejam unicamente JavaScript.&lt;/p&gt;

&lt;h2 id=&#34;o-futuro&#34;&gt;O futuro&lt;/h2&gt;

&lt;p&gt;A especificação ECMAScript 6 já possui um rascunho de uma nova &lt;a href=&#34;http://wiki.ecmascript.org/doku.php?id=harmony:modules&#34;&gt;definição de módulos&lt;/a&gt;. Os assim chamados &lt;em&gt;ES6 modules&lt;/em&gt; são baseados em um sistema de módulos robusto da especificação CommonJS.&lt;/p&gt;

&lt;h3 id=&#34;commonjs-modules&#34;&gt;CommonJS modules&lt;/h3&gt;

&lt;p&gt;Os módulos CJS se tornaram bastante populares por serem a base do padrão adotado pelo &lt;a href=&#34;http://nodejs.org/api/modules.html&#34;&gt;Node.js&lt;/a&gt;. O principal impedimento para seu uso atualmente é o não suporte a este padrão nos navegadores. Existem ferramentas para viabilizar o seu uso em navegadores, inclusive módulos &lt;a href=&#34;http://requirejs.org/docs/api.html#cjsmodule&#34;&gt;AMD podem internamente utilizar a sintaxe proposta&lt;/a&gt; pela especificação de CommonJS.&lt;/p&gt;

&lt;h3 id=&#34;es6-modules&#34;&gt;ES6 modules&lt;/h3&gt;

&lt;p&gt;O sistema de módulos ES6 combina os dois melhores sistemas de módulos existentes. A definição dos módulos se parece muito com CJS e as mesmas características assíncronas da AMD são endereçadas pela especificação de um &lt;a href=&#34;http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders&#34;&gt;&lt;em&gt;loader&lt;/em&gt; nativo&lt;/a&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[ES6 modules] permitirão a definição de dependências sem uso de &lt;em&gt;callbacks&lt;/em&gt; (como em CJS) mas serão assíncronos (como AMD). &amp;#8211; David Herman&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;considerações-finais&#34;&gt;Considerações finais&lt;/h2&gt;

&lt;p&gt;Um sistema de módulos adequado é a saída para manter a sanidade do seu código JavaScript. A despeito das inúmeras soluções, saiba que a escolha de um sistema já padronizado garante o uso de uma solução otimizada para este problema comum.&lt;/p&gt;

&lt;p&gt;Se me permite um conselho: &lt;strong&gt;prefira sempre um sistema de módulos robusto&lt;/strong&gt;, é difícil prever o quão complexa uma aplicação poderá se tornar. Em outras palavras, escolha entre: AMD, &lt;em&gt;CommonJS modules&lt;/em&gt; utilizando ferramentas como &lt;a href=&#34;http://browserify.org&#34;&gt;Browserify&lt;/a&gt; e até mesmo (por sua conta e risco) &lt;em&gt;ES6 modules&lt;/em&gt; com &lt;a href=&#34;https://github.com/ModuleLoader/es6-module-loader&#34;&gt;ES6 Module Loader&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS on steroids</title>
      <link>https://tableless.github.io/hugo-public/css-steroids/</link>
      <pubDate>Tue, 12 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/css-steroids/</guid>
      <description>

&lt;p&gt;Os pré-processadores de CSS têm a função de adicionar funcionalidades não nativas às folhas de estilo. Estes açúcares sintáticos, como são chamados, estabelecem uma nova linguagem cujo código precisa ser processado para se tornar CSS e então ser interpretado por qualquer navegador.&lt;/p&gt;

&lt;p&gt;Cá entre nós, pré-processadores não são nenhuma novidade, o mais antigo deles surgiu em 2007. O que talvez não seja conhecido por muita gente, inclusive por aqueles que já utilizam um pré-processador, são quais os problemas que eles se propõe a solucionar. Mas estudar pré-processadores como uma linguagem que abrange variáveis, regras aninhadas e &lt;em&gt;helpers&lt;/em&gt;, maneira como muitos textos e tutoriais apresentam, é leviano demais. Que tal se formos apresentados a folhas de estilos comuns, identificando o que nelas pode ser considerado problemático, e como podemos tornar estes códigos melhores inserindo uma etapa de pré-processamento?&lt;/p&gt;

&lt;h2 id=&#34;medidas&#34;&gt;Medidas&lt;/h2&gt;

&lt;p&gt;Medidas são elementos bastante importantes na definição de um layout. Mesmo layouts responsivos, que são menos engessados, possuem algumas delas seja na forma de percentual ou mesmo de pixel.&lt;/p&gt;

&lt;p&gt;Abaixo um típico código de layout desktop:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {       
  width: 960px;
}

.header {
  width: 940px;
}

.speaker-list {
  width: 480px;
}&lt;/pre&gt;

&lt;p&gt;A uma primeira vista, estas medidas parecem não ter uma relação. &lt;strong&gt;A tarefa de identificar a relação entre as medidas necessita de raciocínio&lt;/strong&gt; &lt;strong&gt;(um pouco) mais apurado&lt;/strong&gt;. Assim, identificamos o primeiro e mais importante conceito que pode tornar nosso código melhor: devemos evitar ao máximo que seja preciso raciocinar para compreender relações entre medidas, por exemplo.&lt;/p&gt;

&lt;p&gt;Voltando ao código de layout desktop, suas medidas podem ser relacionadas da seguinte maneira: os 940px representam a largura total menos um respiro de 20px e os 480px são simplesmente a metade da largura total.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The ratio of time spent reading (code) versus writing is well over 10 to 1 &amp;#8230; (therefore) making it easy to read makes it easier to write.&lt;cite&gt;&amp;#8211; Robert C. Martin&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Reescrevendo o código em uma linguagem que será pré-processada podemos utilizar variáveis e tornar estas relações óbvias para futuros codificadores que irão manter o projeto e até para nós mesmos que estamos tendo contato com ele neste momento. Confere o resultado:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$site-width: 960px;
$site-gap: 20px;

body {
  width: $site-width;
}

.header {
  width: $site-width - $site-gap;
}

.speaker-list {
  width: $site-width / 2;
}&lt;/pre&gt;

&lt;h2 id=&#34;cores&#34;&gt;Cores&lt;/h2&gt;

&lt;p&gt;As cores no CSS são definidas através de um modelo aditivo por ser este comumente utilizado em monitores. Tradicionalmente, definimos as cores no formato RGB hexadecimal.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.about {
  background: #3F4955;
}

.contact a:hover {
  color: #3F4956;
}

.speaker-list {
  border: 1px solid #3F4955;
}&lt;/pre&gt;

&lt;p&gt;A não ser que você seja um exímio conhecedor do formato, é relativamente incomum você identificar qual a aparência da cor com base nestas numerações que indicam os níveis de vermelho, verde e azul.&lt;/p&gt;

&lt;p&gt;O mais natural é &lt;a href=&#34;http://www.w3.org/TR/css3-color/#svg-color&#34;&gt;atribuir nome às cores&lt;/a&gt;. Desta forma, evitamos que seja novamente &lt;strong&gt;necessário raciocínio extra&lt;/strong&gt; para identificar quais as cores com base na sua numeração. Além disto, evitamos que erros de digitação passem desapercebidos. Se você mal reparou, a segunda cor está com uma variação diferente em nosso código, típico fruto da falta de atenção ao digitar ou definição errada nos arquivos do layout.&lt;/p&gt;

&lt;p&gt;Claro, a grande maioria das cores não possuem nomes, teremos que nomea-las por nós mesmos. Indo um pouco além, o ideal ainda é adicionalmente definir nomes para as cores em uma semântica que faça sentido para o projeto. É papel do designer fornecer as informações que nos levariam a um código que, utilizando variáveis suportadas pelos pré-processadores, se parece com o seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$grey-color: #3F4955;
$main-color: $grey-color;

body {
  color: $main-color;
}

.about {
  background: $main-color;
}

.contact a:hover {
  color: $main-color;
}

.speaker-list {
  border: 1px solid $main-color;
}&lt;/pre&gt;

&lt;p&gt;Acho que não é preciso comentar o quão mais fácil de entender este código acabou de ser tornar.&lt;/p&gt;

&lt;h3 id=&#34;variações-de-cores&#34;&gt;Variações de cores&lt;/h3&gt;

&lt;p&gt;Layouts geralmente utilizam diferentes variações de uma mesma cor apenas escurecendo, clareando, adicionando um canal de transparência ou mexendo na saturação.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
  color: #3F4955;
}

.slider {
  color: #293038;
}

.carousel {
  background: rgba(63, 73, 85, 0.8);
}&lt;/pre&gt;

&lt;p&gt;O código acima possui apenas cores cinza azuladas. Acho difícil que tenha reparado, mas a cor base é a primeira, a segunda é apenas uma variação mais escura e a última tem apenas o canal de transparência definido. Eu sei, não é evidente, ao menos para mim não é.&lt;/p&gt;

&lt;p&gt;Os pré-processadores possuem funções específicas para manipular cores. Com elas, podemos &lt;strong&gt;nos preocupar menos&lt;/strong&gt; com as variações das cores enquanto escrevemos nosso código, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$grey-color: #3F4955;
$grey-dark-color: darken($grey-color, 10);
$transparent-grey-color: rgba($grey-color, .8);

body {
  color: $grey-color;
}

.slider {
  color: $grey-dark-color;
}

.carousel {
  background: $transparent-grey-color;
}&lt;/pre&gt;

&lt;h2 id=&#34;vendor-prefixes&#34;&gt;Vendor prefixes&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Vendor prefixes&lt;/em&gt; possuem implicações fora do escopo deste texto. Mas em linhas gerais, saiba que são a maneira que os fabricantes adicionam suporte para funcionalidades de maneira experimental. O mais importante: estas funcionalidades podem não fazer parte de uma especificação ou fazerem parte de uma especificação ainda não finalizada, cuidado.&lt;/p&gt;

&lt;p&gt;_Designeres_ como o Bernard, &lt;a href=&#34;http://tableless.com.br/como-usar-gradient-no-css-de-forma-consciente&#34;&gt;são grandes amantes de gradiente&lt;/a&gt;. Não nego, quando bem aplicados em um layout fazem toda a diferença. O problema é definir todos os malditos prefixos. Vejamos, em um site como o &lt;a href=&#34;//www.colorzilla.com/gradient-editor&#34;&gt;Ultimate CSS Gradient Generator&lt;/a&gt;, o resultado de um gradiente linear simples é o seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.slider {
  background: #1e5799; /* Old browsers */
  background: -moz-linear-gradient(left, #1e5799 0%, #7db9e8 100%); /* FF3.6+ */
  background: -webkit-gradient(linear, left top, right top, color-stop(0%,#1e5799), color-stop(100%,#7db9e8)); /* Chrome,Safari4+ */
  background: -webkit-linear-gradient(left, #1e5799 0%,#7db9e8 100%); /* Chrome10+,Safari5.1+ */
  background: -o-linear-gradient(left, #1e5799 0%,#7db9e8 100%); /* Opera 11.10+ */
  background: -ms-linear-gradient(left, #1e5799 0%,#7db9e8 100%); /* IE10+ */
  background: linear-gradient(to right, #1e5799 0%,#7db9e8 100%); /* W3C */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=&#39;#1e5799&#39;, endColorstr=&#39;#7db9e8&#39;,GradientType=1 ); /* IE6-9 */
}&lt;/pre&gt;

&lt;p&gt;Sério, acho complicado demais dar manutenção em código como este. Para poupar este trabalho árduo e, digamos, de resultado duvidoso, os pré-processadores possuem bibliotecas como: &lt;a href=&#34;http://compass-style.org&#34;&gt;Compass&lt;/a&gt;, &lt;a href=&#34;http://visionmedia.github.io/nib&#34;&gt;Nib&lt;/a&gt; e &lt;a href=&#34;http://bourbon.io&#34;&gt;Bourbon&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Com o &lt;a href=&#34;http://compass-style.org/reference/compass/css3/images&#34;&gt;Compass, é possível declarar o background&lt;/a&gt; facilmente e ainda configurar quais navegadores serão suportados:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$blue-color: #1E5799;
$light-blue-color: #7DB9E8;

.slider {
  @include background(
    linear-gradient($blue-color, $light-blue-color)
  );
}&lt;/pre&gt;

&lt;p&gt;As bibliotecas dão suporte a muitas outras funcionalidades e nunca se esqueça que ainda é possível definir seus próprios &lt;em&gt;mixins&lt;/em&gt;, veremos a utilidade na sequência.&lt;/p&gt;

&lt;h2 id=&#34;agrupando-regras&#34;&gt;Agrupando regras&lt;/h2&gt;

&lt;p&gt;Talvez você esteja seguindo a risca uma metodologia como &lt;a href=&#34;http://bem.info/method&#34;&gt;BEM&lt;/a&gt; e esta seção então não fará tanto sentido. Em todos os outros casos, é  comum utilizar uma classe para determinar um escopo e passar a estilizar outros elementos descendentes levando em conta esta classe. Sim, estamos falando dos tais componentes e outras abstrações mais simples também.&lt;/p&gt;

&lt;p&gt;Todas as regras que estilizam um componente são então escritas próximas uma das outras. O que não garante que por falta de atenção seja inserido no futuro um código sem relação alguma em meio as minhas regras que definem um componente. Alguns desenvolvedores então, por clareza e de modo a evitar futuros deslizes, costumam indentar as regras dos elementos descendentes para deixar mais óbvia a relação entre as regras. Sei não, acho estranho.&lt;/p&gt;

&lt;p&gt;Pré-processadores permitem que as regras sejam declaradas umas dentro das outras fazendo com que os seletores sejam somados no resultado final. Muito &lt;strong&gt;mais simples de ler e manter a organização do código&lt;/strong&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;.slider {
  p {
    margin-bottom: 1em;
  }
  a {
    font-weight: bold;
    &amp;:hover {
      background: $color-secondary;
    }
  }
}&lt;/pre&gt;

&lt;h3 id=&#34;cuidado-com-os-seletores&#34;&gt;Cuidado com os seletores&lt;/h3&gt;

&lt;p&gt;Um erro comum inspirado pela possibilidade de se escrever código com regras dentro uma das outras é a escrita de toda a árvore de elementos do HTML no CSS. Propriedades aplicadas a seletores como: html body section p a:hover estão longe de ser uma boa prática.&lt;/p&gt;

&lt;p&gt;É muito importante sempre ter em mente qual o código gerado pelo pré-processador. &lt;strong&gt;Utilizar um pré-processador não substitui o uso de boas práticas de escrita de CSS&lt;/strong&gt;. Na dúvida, &lt;a href=&#34;//josh.github.io/css-explain&#34;&gt;teste o peso dos seletores gerados neste serviço&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;reaproveitando-regras&#34;&gt;Reaproveitando regras&lt;/h2&gt;

&lt;p&gt;Os frameworks de CSS tem se tornado cada vez mais populares. Uma característica importante a se notar é que todo framework evita a redundância de código CSS criando diversas classes com semântica de aparência para que sejam incluídas no documento: button-large e text-right, por exemplo.&lt;/p&gt;

&lt;p&gt;Alguns projetos são ideais para serem desenvolvidos utilizando um framework. Outros estão bem distantes disto sendo que suas classes então devem respeitar a semântica do seu conteúdo ou função. Nestes projetos, sempre acontece de os elementos possuírem igual aparência mas diferente função ou conteúdo, como ilustrado abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.address {
  width: 200em;
  height: 300em;
  background: #666;
  color: white;
}

.profile {
  width: 200em;
  height: 300em;
  background: #666;
  color: white;
  font-size: 20em;
}&lt;/pre&gt;

&lt;p&gt;De maneira a evitar estas repetições, os pré-processadores permitem estender outras regras e acabam por &lt;strong&gt;agrupar seus seletores sem repetir as propriedades&lt;/strong&gt;. Assim, é possível escrever o código do .profile apenas como uma extensão de .address mais esta última propriedade que altera o tamanho da fonte.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.address {
  width: $box-width;
  height: $box-height;
  background: $box-color;
  color: white;
}

.profile {
  @extend .address;
  font-size: 20em;
}&lt;/pre&gt;

&lt;p&gt;Legal, mas a semântica disto é um pouco estranha. Por que estamos fazendo endereço estender perfil, qual a relação entre eles? Alguns pré-processadores acrescentam um seletor especial chamado &lt;em&gt;placeholder&lt;/em&gt;. Sua função é unicamente ser estendido por outras regras, o &lt;em&gt;placeholder&lt;/em&gt; não é impresso diretamente no resultado final.&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;%box {
  width: $box-width;
  height: $box-height;
  background: $box-color;
  color: white;
}

.address {
  @extend %box;
}

.profile {
  @extend %box;
  font-size: 20em;
}&lt;/pre&gt;

&lt;h2 id=&#34;helpers&#34;&gt;Helpers&lt;/h2&gt;

&lt;p&gt;Novamente, vou deixar vocês com o código parcial de uma folha de estilo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.profile {
  position: relative;
  width: 100px;
  background: red;
}
.profile:before {
  content: &#34;&#34;;
  position: absolute;
  width: 0;
  height: 0;
  border: 7px solid transparent;
  left: 50%;
  margin-left: -7px;
  top: -13px;
  border-bottom: 7px red solid;
}&lt;/pre&gt;

&lt;p&gt;Agora, a pergunta: o que este código representa? Não sei, não faço a menor ideia, até mesmo para mim que o escrevi, em uma primeira análise, é difícil identificar. A dica aqui é: &lt;strong&gt;dê nome a todo conjunto de propriedades que definem um elemento da aparência do seu projeto&lt;/strong&gt;, placeholders são ideais para isto.&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;%arrow-top {
  position: relative;
  &amp;:before {
    content: &#34;&#34;;
    position: absolute;
    width: 0; height: 0;
    border: 7px solid transparent;
    left: 50%;
    margin-left: -7px;
    top: -13px;
    border-bottom: 7px red solid;
  }
}

.profile {
  width: 100px;
  background: red; 
  @extend %arrow-top;
}&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Name everything you can. &lt;cite&gt;&amp;#8211; Martin Odersky&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para o caso de utilizarmos diferentes cores de setas, podemos ainda definir um &lt;em&gt;mixin&lt;/em&gt; exclusivo para nos auxiliar nesta tarefa, confere:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@mixin arrow-top-color($color) {
  &amp;:before {
    border-bottom-color: $color;
  }
}

.profile {
  width: 100px;
  background: blue; 
  @extend %arrow-top;
  @include arrow-top-color(blue);
}&lt;/pre&gt;

&lt;p&gt;Os &lt;em&gt;helpers&lt;/em&gt; são bastante úteis. Saber quando usar &lt;em&gt;mixins&lt;/em&gt; ou &lt;em&gt;placeholders&lt;/em&gt; é simples: os &lt;em&gt;mixins&lt;/em&gt; são para quando é preciso passar algum parâmetro, como, em nosso caso, a cor.&lt;/p&gt;

&lt;p&gt;Um outro exemplo bem interessante é o do site do &lt;a href=&#34;http://frontinpoa.com.br&#34;&gt;Front in Poa&lt;/a&gt;. Para ele, &lt;a href=&#34;https://gist.github.com/jcemer/7130218&#34;&gt;criei uma série de &lt;em&gt;helpers&lt;/em&gt;&lt;/a&gt; para representar as linhas que são renderizadas através de gradientes radiais.&lt;/p&gt;

&lt;h2 id=&#34;concluindo&#34;&gt;Concluindo&lt;/h2&gt;

&lt;p&gt;Espero que estes exemplos o tenham convencido a considerar o uso de um pré-processador. E para você que já utiliza, espero que os conceitos abram um pouco mais sua mente e o façam escrever folhas de estilo cada vez melhores.&lt;/p&gt;

&lt;p&gt;A respeito da escolha do pré-processador, saiba que os mais populares são &lt;a href=&#34;http://sass-lang.com&#34;&gt;Sass&lt;/a&gt;, &lt;a href=&#34;http://learnboost.github.io/stylus/&#34;&gt;Stylus&lt;/a&gt; e &lt;a href=&#34;http://lesscss.org/&#34;&gt;Less&lt;/a&gt;. Não se esqueça de sempre levar em consideração a preferência e habilidades da sua equipe para auxiliar na tarefa de escolha. Vou apenas bancar o intrometido e deixar uma dica: o Less não possui suporte a &lt;em&gt;placeholders&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Workflow para cuidar dos seus assets</title>
      <link>https://tableless.github.io/hugo-public/workflow-para-cuidar-dos-seus-assets/</link>
      <pubDate>Thu, 31 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/workflow-para-cuidar-dos-seus-assets/</guid>
      <description>

&lt;p&gt;No desenvolvimento web, o termo assets é utilizado para designar tudo o que complementa o conteúdo dos websites. Em outras palavras, assets são nossos recursos de folhas de estilo, scripts, fontes e imagens.&lt;/p&gt;

&lt;p&gt;Em uma primeira análise, os assets parecem algo simples de se gerenciar. Porém, o que passa muitas vezes por desapercebido é que a falta de alguns cuidados podem impactar significativamente na performance do projeto notada pelo usuário.&lt;/p&gt;

&lt;p&gt;Apesar dos sintomas da baixa performance serem muito mais notados no front-end, uma estratégia adequada de gerência deve iniciar já no back-end das aplicações. Muito por isto, programadores Ruby criaram a biblioteca Sprockets que tem como função compilar e servir assets da melhor maneira possível. Seu principal uso se dá através do Asset Pipeline, parte integrante do framework de desenvolvimento Ruby on Rails.&lt;/p&gt;

&lt;p&gt;O que segue é uma análise detalhada das principais funcionalidades do workflow do Asset Pipeline destacando quais os impactos positivos que são refletidos para os projetos que o utilizam.&lt;/p&gt;

&lt;h2 id=&#34;asset-pipeline&#34;&gt;Asset Pipeline&lt;/h2&gt;

&lt;p&gt;As principais funcionalidades do framework são: pré-compilar, concatenar, minificar e ajudar para que o navegador faça o cache dos arquivos adequadamente.&lt;/p&gt;

&lt;h3 id=&#34;pré-compilação&#34;&gt;Pré-compilação&lt;/h3&gt;

&lt;p&gt;Linguagens como &lt;a href=&#34;http://tableless.com.br/javascript-com-cafe&#34;&gt;CoffeeScript&lt;/a&gt; e &lt;a href=&#34;http://tableless.com.br/sass-um-outro-metodo-de-escrever-css&#34;&gt;Sass&lt;/a&gt; têm se tornado cada vez mais maduras e utilizadas no processo de desenvolvimento. Este texto não tem o caráter de defender quais os benefícios de uso de cada uma delas. Mas é importante que, se você optar ou precisar utilizar alguma delas, seu workflow suporte o seu uso.&lt;/p&gt;

&lt;p&gt;O Asset Pipeline e outros frameworks similares provêm uma maneira bastante simples de indicar por quais linguagens e engines o arquivo precisa ser avaliado. Eles fazem isto através da extensão do arquivo. Assim, é só nomear o arquivo com a extensão &lt;code&gt;.coffee&lt;/code&gt; para indicar que seu conteúdo está escrito em CoffeeScript.&lt;/p&gt;

&lt;p&gt;Mais do que indicar uma linguagem, é possível fazer com que um mesmo arquivo seja avaliado por mais de uma liguagem ou engine através do uso de outros indicadores no nome do arquivo. Um arquivo de nome &lt;code&gt;main.js.coffee.erb&lt;/code&gt;, seria avaliado pela engine de template Erb e posteriormente interpretado como CoffeeScript. Nestes casos, o resultado de cada avaliação, que são iniciadas pela extensão mais a direita, é então utilizado como insumo para a próxima avaliação.&lt;/p&gt;

&lt;h3 id=&#34;concatenação&#34;&gt;Concatenação&lt;/h3&gt;

&lt;p&gt;Apesar de folhas de estilo e código JavaScript ainda não possuírem construções nativas de módulos, a simples tarefa de separação do código em diferentes arquivos já garante maior legibilidade e facilidade de manutenção.&lt;/p&gt;

&lt;p&gt;Por outro lado, queremos continuar entregando a menor quantidade possível de assets no front-end da aplicação. Para tal, precisamos concatenar os arquivos. A maneira de concatenar os arquivos de JavaScript no Asset Pipeline é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-javascript linenums&#34;&gt;//= require jquery
//= require jquery.ui
//= require main&lt;/pre&gt;

&lt;p&gt;E para concatenar folhas de estilo:&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-ruby linenums&#34;&gt;/*
*= require normalize 
*= require layout
*= require header
*/&lt;/pre&gt;

&lt;p&gt;Vale lembrar que depois de concatenados os arquivos, a referência da linha em que determinado código foi declarado é perdida, o que pode dificultar o &lt;em&gt;debugging&lt;/em&gt;. O Asset Pipeline, quando em ambiente de desenvolvimento, inclui todos os arquivos no HTML sem concatenar através de diferentes &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; e &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;. Desta forma, é muito mais fácil identificar qual o arquivo e linha de cada diretiva.&lt;/p&gt;

&lt;p&gt;A partir disto, notamos que o workflow que cuida dos assets &lt;strong&gt;precisa necessariamente ter acesso&lt;/strong&gt; à aplicação para poder, como neste caso, flexibilizar o uso de diferentes arquivos com base no ambiente.&lt;/p&gt;

&lt;p&gt;Vale ressaltar que soluções de workflow escritas nos dias atuais podem utilizar &lt;a href=&#34;http://www.html5rocks.com/en/tutorials/developertools/sourcemaps&#34;&gt;Source Maps&lt;/a&gt;, o que também é possível no Asset Pipeline, para chegar a um resultado semelhante.&lt;/p&gt;

&lt;h3 id=&#34;minificação&#34;&gt;Minificação&lt;/h3&gt;

&lt;p&gt;Último passo do seu workflow, minificar os arquivos garante aquela economia esperta da banda larga do usuário. E, assim como na concatenação, você &lt;strong&gt;não&lt;/strong&gt; vai querer que os arquivos estejam minificados em seu ambiente de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Novamente, o Asset Pipeline não minifica seus arquivos quando em ambiente de desenvolvimento. As ferramentas geralmente utilizadas para a tarefa em ambiente de produção são: minificador do Sass para as folhas de estilos e &lt;a href=&#34;https://github.com/mishoo/UglifyJS&#34;&gt;UglifyJS&lt;/a&gt; para JavaScript.&lt;/p&gt;

&lt;h3 id=&#34;cache&#34;&gt;Cache&lt;/h3&gt;

&lt;p&gt;O ponto mais importante relacionado aos assets é a configuração adequada do tempo de expiração de cada arquivo. Porque, no pior dos casos, em decorrência disto o usuário será obrigado a baixar todas as imagens e demais recursos a cada acesso a uma diferente página do seu website.&lt;/p&gt;

&lt;p&gt;Pegando como exemplo a configuração de tempo de expiração dos arquivos do &lt;a href=&#34;https://github.com/h5bp/html5-boilerplate/blob/9518d22de739a1b03bdbfcde2149e1fd994c280a/.htaccess#L445&#34;&gt;HTML5 Boilerplate&lt;/a&gt;, é possível notar que os assets possuem em geral um tempo de expiração de um mês. Grosseiramente, isto significa que o usuário irá baixar determinado arquivo novamente apenas daqui um mês.&lt;/p&gt;

&lt;p&gt;Os benefícios são óbvios, os malefícios talvez nem tanto. Se o projeto sofrer manutenção e aquela imagem importante for alterada, o usuário não necessariamente terá a nova versão. A solução é renomear os arquivos (e não apenas a &lt;a href=&#34;http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring&#34;&gt;querystring&lt;/a&gt;) a cada alteração para que assim o usuário seja obrigado  a baixar a nova versão.&lt;/p&gt;

&lt;p&gt;O Asset Pipeline viabiliza esta estratégia adicionando um código ao nome de todos os arquivos, o &lt;code&gt;main.css&lt;/code&gt; é renomeado para algo como &lt;code&gt;main-dc409308c085b71ae34d793cedb384a1.css&lt;/code&gt;. O código é relacionado ao conteúdo do arquivo, o que significa que se eu alterar qualquer caractere, este código muda e o nome do meu arquivo também.&lt;/p&gt;

&lt;p&gt;Por fim, o Asset Pipeline provê o método &lt;code&gt;asset_path&lt;/code&gt; para que eu possa saber o nome do meu arquivo já com o código. Basta utilizar a pré-compilação, e o arquivo de folha de estilo &lt;code&gt;main.css.erb&lt;/code&gt; será avaliado pela engine de template que irá traduzir &lt;code&gt;&amp;lt;%= asset_path(&#39;logo.png&#39;) %&amp;gt;&lt;/code&gt; para o nome da imagem já com o código.&lt;/p&gt;

&lt;p&gt;Mesmo não sendo um processo tão simples, não existe melhor estratégia na atualidade para garantir que os usuários possam manter arquivos no cache e ao mesmo tempo baixar imediatamente apenas os arquivos que tenham sido alterados em uma manutenção da sua aplicação. Antes que alguém comente, renomear a pasta de todos os assets não garante que apenas os arquivos alterados necessitem ser baixados, todos serão.&lt;/p&gt;

&lt;h2 id=&#34;outros-frameworks&#34;&gt;Outros frameworks&lt;/h2&gt;

&lt;p&gt;Entendi, você achou as funcionalidades do Asset Pipeline fantásticas e compreendeu na teoria e prática a importância de cada uma delas. Mas se a sua aplicação não é escrita em Ruby on Rails, é possível utilizar &lt;a href=&#34;https://github.com/DanielHeath/sprockets-sample&#34;&gt;somente o Sprockets&lt;/a&gt;. De qualquer maneira, você vai precisar de Ruby e perderá alguns recursos.&lt;/p&gt;

&lt;p&gt;Vale ressaltar que qualquer linguagem de back-end pode implementar um workflow igual a este. E com certeza ele deve ser copiado e aprimorado. Já existem inclusive plugins em desenvolvimento para o &lt;a href=&#34;http://tableless.com.br/grunt-voce-deveria-estar-usando&#34;&gt;Grunt&lt;/a&gt;. Quem sabe você não possa colaborar com algum deles.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>