<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Andre Cardoso on Tableless</title>
    <link>https://tableless.github.io/hugo-public/author/andre-cardoso/index.xml</link>
    <description>Recent content in Andre Cardoso on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/author/andre-cardoso/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PHPUnit – persistência e configurações avançadas</title>
      <link>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</link>
      <pubDate>Thu, 08 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-persistencia-e-configuracoes-avancadas/</guid>
      <description>

&lt;p&gt;Neste artigo você verá como utilizar o &lt;a title=&#34;PHPUnit - site oficial&#34; href=&#34;http://phpunit.de/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; para realizar testes com persistência de dados utilizando o &lt;a title=&#34;Projeto Doctrine&#34; href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;Doctrine&lt;/a&gt; um &lt;a title=&#34;O que é um ORM?&#34; href=&#34;http://pt.wikipedia.org/wiki/Mapeamento_objeto-relacional&#34; target=&#34;_blank&#34;&gt;ORM&lt;/a&gt; open-source e como definir configurações avançadas para personalizar sua suíte de testes e gerar relatórios de testes executados bem como cobertura do código de produção.&lt;/p&gt;

&lt;h2 id=&#34;começando&#34;&gt; Começando&lt;/h2&gt;

&lt;p&gt;Para começar o projeto crie um arquivo chamado &lt;em&gt;composer.json&lt;/em&gt;. Nele listaremos todos os pacotes/bibliotecas de terceiros que utilizaremos. Para este post utilizaremos o Doctrine e vários elementos do Zend Framework 2 além de é claro o próprio PHPUnit. Abaixo segue a lista de todas as bibliotecas que serão utilizadas.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;require&#34; : {
    &#34;doctrine/common&#34; : &#34;*&#34;,
    &#34;doctrine/dbal&#34;: &#34;*&#34;,
    &#34;doctrine/orm&#34; : &#34;*&#34;,
    &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;,
    &#34;zendframework/zend-stdlib&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-filter&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-servicemanager&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-crypt&#34;: &#34;2.3.*@dev&#34;,
    &#34;zendframework/zend-math&#34;: &#34;2.3.*@dev&#34;
 }&lt;/pre&gt;

&lt;p&gt;Seguindo as recomendações da &lt;a title=&#34;FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt;, utilizaremos a &lt;a title=&#34;PSR-0&#34; href=&#34;http://www.php-fig.org/psr/psr-0/&#34; target=&#34;_blank&#34;&gt;PSR-0&lt;/a&gt; que trata sobre a forma de carregarmento de classes na aplicação que estamos desenvolvendo. Com isso trabalharemos com namespaces e não precisaremos utilizar require ou include nas classes que utilizaremos. Para que o projeto tenha suas classes carregadas conforme a PSR-0 podemos informar isso no arquivo &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; &#34;autoload&#34; : {
    &#34;psr-0&#34;: {
        &#34;Tableless\\&#34;: &#34;src/&#34;
    }
 }&lt;/pre&gt;

&lt;p&gt;Isto nos diz que o namespace “Tableless” estará presente na pasta &lt;em&gt;src&lt;/em&gt; e para isto se faz necessária a criação da pasta &lt;em&gt;src&lt;/em&gt; e dentro da mesma a pasta &lt;em&gt;Tableless&lt;/em&gt;. Há outra maneira de registrar o namespace através do _boostrap._&lt;em&gt;php&lt;/em&gt; que seria algo como:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt; $load = require __DIR__ . &#39;/vendor/autoload.php&#39;;
 $load-&amp;gt;add(&#39;Tableless&#39;, __DIR__ . &#39;/src&#39;);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p class=&#34;lang-php&#34;&gt;
  O arquivo &lt;em&gt;bootstrap.php &lt;/em&gt;é comumente utilizado para realizar as configurações iniciais em vários frameworks. Basicamente ele inclui o &lt;em&gt;autoload.php&lt;/em&gt; gerado pelo composer e podem ser definidas as mais diversas configurações globais de sua aplicação no mesmo.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isso baixamos o composer utilizando o comando &lt;strong&gt;curl -sS &lt;a href=&#34;https://getcomposer.org/installer&#34;&gt;https://getcomposer.org/installer&lt;/a&gt; | php&lt;/strong&gt; e em seguida instalamos as dependências através do comando &lt;strong&gt;php composer.phar install&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41342&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png&#34; alt=&#34;Instalando composer e dependências&#34; width=&#34;403&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/02-instalando-composer-e-dependencias-403x310.png 403w, uploads/2014/03/02-instalando-composer-e-dependencias-218x168.png 218w, uploads/2014/03/02-instalando-composer-e-dependencias.png 791w&#34; sizes=&#34;(max-width: 403px) 100vw, 403px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Com a instalação das dependências agora temos a nova estrutura contendo uma pasta &lt;em&gt;vendor&lt;/em&gt; contendo todas as bibliotecas de terceiros, um novo arquivo &lt;em&gt;composer.lock&lt;/em&gt; e &lt;em&gt;composer.phar&lt;/em&gt; os quais já foram descritos em outro artigo sobre PHPUnit com composer e que pode ser acessado &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41343&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/03-nova-estrutura-490x310.png&#34; alt=&#34;Nova Estrutura&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/03-nova-estrutura-490x310.png 490w, uploads/2014/03/03-nova-estrutura-265x168.png 265w, uploads/2014/03/03-nova-estrutura-400x252.png 400w, uploads/2014/03/03-nova-estrutura.png 1086w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;próximo-passo&#34;&gt;Próximo passo&lt;/h2&gt;

&lt;p&gt;Agora temos de criar um arquivo que será o pontapé inicial da aplicação, arquivo este comumente nomeado de bootstrap conforme já mencionado anteriormente. Nele são configurados onde se encontram as entidades – que serão explicadas mais a frente deste tutorial, configuração do banco de dados entre outras configurações. Como neste exemplo será utilizado o Doctrine, precisamos configurar o mesmo.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado &lt;em&gt;bootstrap.php&lt;/em&gt; na raiz de seu projeto, o fonte do &lt;em&gt;bootstrap.php&lt;/em&gt; está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
// Carregando o autoload que o composer gerou
require __DIR__ . &#39;/vendor/autoload.php&#39;;
// indicando tudo que usaremos no bootstrap
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\Tools\Setup;
use Doctrine\ORM\Mapping\Driver\AnnotationDriver;
use Doctrine\Common\Annotations\AnnotationReader;
use Doctrine\Common\Annotations\AnnotationRegistry;
/**
* Definindo se é modo desenvolvimento
* 
* Caso true: o cache do Doctrine é realizado em formato de array
* Caso false: o cache é conforme configuração (memcache, APC..)
* 
* Somente trabalharemos aqui com o modo TRUE, cache em array
*/
$config = Setup::createConfiguration( true );
// pasta onde encontram-se nossas entidades
$entitypath = array( __DIR__ . &#39;/src/Tableless/Entity&#39; );
// registrando as entidades
$driver = new AnnotationDriver(new AnnotationReader(), $entitypath);
$config-&gt;setMetadataDriverImpl($driver);
/**
* indicando que trabalharemos com o modo annotations para
* as entidades. Pode ser também via arquivo yaml e xml
* 
*/
AnnotationRegistry::registerFile(__DIR__ 
. &#39;/vendor/doctrine/orm/lib/Doctrine/ORM/Mapping/Driver/DoctrineAnnotations.php&#39;);
// configurando a conexão com o banco de dados
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_mysql&#39;,    
    &#39;user&#39; =&gt; &#39;root&#39;,
    &#39;password&#39; =&gt; &#39;root&#39;,
    &#39;dbname&#39; =&gt; &#39;tableless_tdd&#39;,
);
// E finalmente criando o manipulador de entidades
$entityManager = EntityManager::create($conn, $config);&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Até agora você viu várias vezes a palavra “Entidade” mas o que ela significa? Entidade é um objeto que tem um significado conceitual dentro de um domínio. Em outras palavras, cada entidade no Doctrine é a representação de uma tabela no banco de dados e cada registro é uma instância desta entidade. A entidade não manipula o banco de dados, apenas representa-o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pronto, a nível de produção já temos a configuração, agora criaremos a estrutura e configurações para testes.&lt;/p&gt;

&lt;p&gt;Na raiz de seu projeto crie uma pasta chamada &lt;em&gt;tests&lt;/em&gt;, dentro dela uma pasta chamada &lt;em&gt;src&lt;/em&gt; e dentro da src uma pasta chamada &lt;em&gt;Tableless&lt;/em&gt;. Perceba que o namespace ficará na mesma estrutura do código de produção, desta forma para utilizarmos uma entidade chamada &lt;em&gt;User&lt;/em&gt; por exemplo, usaremos a seguinte declaração: &lt;strong&gt;use Tableless\Entity\User;&lt;/strong&gt;. Para a classe de testes de User se for necessária declarar em algum lugar será desta forma: &lt;strong&gt;use Tableless\Entity\UserTest;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41345&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/04-estrutura-inicial-testes-398x310.png&#34; alt=&#34;Estrutura inicial testes&#34; width=&#34;398&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/04-estrutura-inicial-testes-398x310.png 398w, uploads/2014/03/04-estrutura-inicial-testes-215x168.png 215w, uploads/2014/03/04-estrutura-inicial-testes-400x311.png 400w, uploads/2014/03/04-estrutura-inicial-testes.png 542w&#34; sizes=&#34;(max-width: 398px) 100vw, 398px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a criação das pastas necessárias falta a criação do bootstrap de testes e de um arquivo de configurações de execução do PHPUnit.&lt;/p&gt;

&lt;p&gt;Começando com o bootstrap, o código novamente está comentado explicando porque determinadas coisas estão sendo feitas. Crie o arquivo &lt;em&gt;bootstrap.php&lt;/em&gt; dentro da pasta de testes (&lt;em&gt;tests&lt;/em&gt;).&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&lt;?php
// utilizando o bootstrap de produção
require __DIR__ . &#39;/../bootstrap.php&#39;;
use Doctrine\ORM\EntityManager;
/*
* Sobrescrevendo a conexão com banco de dados.
* 
* Isto faz-se necessário para que ao rodar os testes 
* o banco de produção não sofra alterações
*/
$conn = array(
    &#39;driver&#39; =&gt; &#39;pdo_sqlite&#39;,
    &#39;dbname&#39; =&gt; &#39;:memory:&#39;,
);
return $entityManager = EntityManager::create($conn, $config);
&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;O bootstrap de testes se faz necessário para sobrescrever a conexão com o banco de dados, caso contrário, todos os testes realizariam alterações no banco de dados de produção e isto jamais deve acontecer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Feito isto agora é o momento de criar o arquivo xml de configurações do PHPUnit. Crie um arquivo chamado &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;phpunit.xm&lt;/i&gt;l dentro de sua pasta &lt;i style=&#34;font-family: Arial, sans-serif;line-height: 1.5em&#34;&gt;tests&lt;/i&gt; e adicione o conteúdo abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&amp;gt;
&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;

&amp;lt;!-- Indicando qual é o diretório onde as classes de teste se encontram --&amp;gt;
    &amp;lt;testsuites&amp;gt;
        &amp;lt;testsuite name=&#34;Tableless TDD Test Suite&#34;&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;src/&amp;lt;/directory&amp;gt;
        &amp;lt;/testsuite&amp;gt;
    &amp;lt;/testsuites&amp;gt;

&amp;lt;!-- Adicionando filtros, basicamente whitelist (diretórios que serão executados), 
dentro temos o exclude (diretórios que não serão executados pelos testes) --&amp;gt;

&amp;lt;filter&amp;gt;
    &amp;lt;whitelist&amp;gt;
        &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;../src/&amp;lt;/directory&amp;gt;
        &amp;lt;exclude&amp;gt;
            &amp;lt;directory suffix=&#34;.php&#34;&amp;gt;./vendor/&amp;lt;/directory&amp;gt;
        &amp;lt;/exclude&amp;gt;
    &amp;lt;/whitelist&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;/phpunit&amp;gt;&lt;/pre&gt;

&lt;p&gt;Quase pronto, se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; dentro da raiz do projeto teremos a mensagem de que nenhum teste foi executado como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41346&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/05-nenhum-teste-490x310.png&#34; alt=&#34;Nenhum Teste&#34; width=&#34;490&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/05-nenhum-teste-490x310.png 490w, uploads/2014/03/05-nenhum-teste-265x168.png 265w, uploads/2014/03/05-nenhum-teste-400x253.png 400w, uploads/2014/03/05-nenhum-teste.png 803w&#34; sizes=&#34;(max-width: 490px) 100vw, 490px&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt; Como estamos trabalhando com um arquivo de configurações, para rodarmos o phpunit seguindo as definições do arquivo precisamos utilizar o parâmetro &lt;strong&gt;-c&lt;/strong&gt; seguido do nome do arquivo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Obviamente que nenhum teste ainda foi executado porque não temos nenhuma classe de testes. Vamos começar então. Crie uma pasta &lt;em&gt;Entity&lt;/em&gt; dentro de &lt;em&gt;tests/src&lt;/em&gt;. Dentro desta pasta crie um arquivo chamado &lt;em&gt;UsertTest.php&lt;/em&gt;. A nova estrutura de testes deve estar como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41347&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/06-nova-estrutura-de-testes-379x310.png&#34; alt=&#34;Nova estrutura de testes&#34; width=&#34;379&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/06-nova-estrutura-de-testes-379x310.png 379w, uploads/2014/03/06-nova-estrutura-de-testes-205x168.png 205w, uploads/2014/03/06-nova-estrutura-de-testes-400x326.png 400w, uploads/2014/03/06-nova-estrutura-de-testes.png 695w&#34; sizes=&#34;(max-width: 379px) 100vw, 379px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;UserTest.php&lt;/em&gt; adicione o namespace do mesmo que é Tableless\Entity.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;namespace Tableless\Entity;&lt;/pre&gt;

&lt;p&gt;Agora definimos quais classes utilizaremos para este teste. Como estamos testando a entidade &lt;em&gt;User&lt;/em&gt; precisaremos utilizar o Tableless\Entity\User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;&lt;/pre&gt;

&lt;p&gt;No entanto aí tem um detalhe. A entidade User ainda não existe, mas a criaremos dentro de instantes pois ainda temos uma classe que devemos criar antes mesmo da &lt;em&gt;User&lt;/em&gt;. Ela se chama &lt;em&gt;TestCase&lt;/em&gt; e deve estar no namespace Tableless\Test. Crie em &lt;em&gt;src/Tableless&lt;/em&gt; (não em tests/src/Tableless) uma pasta chamada Test e dentro dela um arquivo chamado &lt;em&gt;TestCase.php&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41348&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/07-criando-test-case-426x310.png&#34; alt=&#34;Criando o TestCase&#34; width=&#34;426&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/07-criando-test-case-426x310.png 426w, uploads/2014/03/07-criando-test-case-230x168.png 230w, uploads/2014/03/07-criando-test-case-400x291.png 400w, uploads/2014/03/07-criando-test-case.png 602w&#34; sizes=&#34;(max-width: 426px) 100vw, 426px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Neste arquivo copie e cole o código abaixo que está comentado para melhor entendimento.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;?php
namespace Tableless\Test;

use Doctrine\ORM\Tools\SchemaTool;
use PHPUnit_Framework_TestCase as PHPUnit;

abstract class TestCase extends PHPUnit
{
    protected $entityManager = null;

    /**
    * Executado antes de cada teste unitário
    */
    public function setup() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Cria a base de dados necessária com suas determinadas tabelas
        $tool-&amp;gt;createSchema($classes);

        parent::setup();
    } 

    /**
    * Executado após a execução de cada um dos testes unitários
    */
    public function tearDown() 
    {
        $entityManager = $this-&amp;gt;getEntityManager(); 
        $tool = new SchemaTool($entityManager);

        //Obtem informações das entidades que encontrar em Tableless\Entity
        $classes = $entityManager-&amp;gt;getMetadataFactory()-&amp;gt;getAllMetadata();

        // Desfaz o banco criado no setUp
        $tool-&amp;gt;dropSchema($classes);

        parent::tearDown();
    }

    /**
    * 
    * @return \Doctrine\ORM\EntityManager
    */
    public function getEntityManager() 
    {
        if (! $this-&amp;gt;entityManager) {
            $this-&amp;gt;entityManager = require __DIR__ . &#39;/../../../tests/bootstrap.php&#39;;
        } 
        return $this-&amp;gt;entityManager; 
    } 
}&lt;/pre&gt;

&lt;p&gt;Pronto, já estamos com tudo o que precisamos para começar escrever os testes. Detalhe que esta configuração foi criada para que fosse possível utilizar e testar a persistência de dados utilizando o Doctrine. Para demais testes em controllers, services, views, forms ou o que mais você desejar esta configuração realizada até o momento permanece podendo ser acrescida de novos elementos, tudo depende da necessidade.&lt;/p&gt;

&lt;h2 id=&#34;criando-o-primeiro-teste&#34;&gt;Criando o primeiro teste&lt;/h2&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt; começaremos a definir nossos testes. Lembre-se que a ideia do TDD é que o teste seja criado antes do código de produção, e assim faremos.&lt;/p&gt;

&lt;p&gt;Pra início de conversa utilizaremos a classe &lt;em&gt;TestCase&lt;/em&gt; previamente criada e a entidade User.&lt;/p&gt;

&lt;pre&gt;use Tableless\Entity\User;
use Tableless\Test\TestCase;&lt;/pre&gt;

&lt;p&gt;A classe de testes atual (UserTest) extende de TestCase e adicionaremos o atributo protegido $entity.&lt;/p&gt;

&lt;pre&gt;class UserTest extends TestCase
{
    protected $entity;
}&lt;/pre&gt;

&lt;p&gt;Assim como a classe TestCase, nossa classe UserTest também possuirá um métdo setUp e um tearDown que servirão para as configurações da mesma. De momento apenas setaremos o valor default do atributo entity no setUp.&lt;/p&gt;

&lt;pre&gt;public function setUp()
{
    $this-&amp;gt;entity = &#39;Tableless\Entity\User&#39;;
};&lt;/pre&gt;

&lt;p&gt;Agora segue o nosso primeiro teste: Novamente há comentários explicando cada ação.&lt;/p&gt;

&lt;pre&gt;public function testIfIsSavingAsExpected()
{
    // Criando os dados necessários para salvar o usuário
    $userData = array(
        &#39;id&#39; =&amp;gt; 1,
        &#39;name&#39; =&amp;gt; &#39;Nome do usuário&#39;,
        &#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;,
        &#39;password&#39; =&amp;gt; &#39;xpto&#39;,
        &#39;profilePic&#39; =&amp;gt; &#39;image.png&#39;
    );
    /* o Id é gerado automaticamente pelo Doctrine, neste caso estou forçando
    * um Id desejado, mas somente para o teste, para o código de produção
    * isto não se faz necessário
    */

    // Instanciando a entidade usuário definindo todos os atributos à ela
    $user = new User( $userData );

    // salvando o usuário no banco de dados
    $this-&amp;gt;getEntityManager()-&amp;gt;persist( $user );
    $this-&amp;gt;getEntityManager()-&amp;gt;flush();

    // Obtendo o usuário salvo
    $registeredUser = $this-&amp;gt;getEntityManager()
            -&amp;gt;getRepository($this-&amp;gt;entity)
            -&amp;gt;findOneBy(array(&#39;email&#39; =&amp;gt; &#39;usuario@dominio.com&#39;));

    // Garantindo que tudo funcionou conforme o esperado
    $this-&amp;gt;assertInstanceOf($this-&amp;gt;entity, $registeredUser);
    $this-&amp;gt;assertEquals($userData[&#39;name&#39;], $registeredUser-&amp;gt;getName());
}&lt;/pre&gt;

&lt;p&gt;Se rodarmos o comando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; da raiz de nosso projeto deveremos ver o seguinte erro: “PHP Fatal error: Class &amp;#8216;Tableless\Entity\User &amp;#8230;&amp;#8217;” isto porque ainda não existe a entidade &lt;em&gt;User&lt;/em&gt; pois realizamos o primeiro passo do TDD, o “Red”. Em seguida realizaremos o passo “Green” que consiste em criarmos o código que faça o teste passar e por último o passo “Refactor” que é onde faremos algumas melhorias no código. No código exemplo não existirá duplicidade e/ou partes inconsistentes com isso o Refactor realizará apenas algumas pequenas melhorias, nada mais.&lt;/p&gt;

&lt;p&gt;Crie na pasta &lt;em&gt;src&lt;/em&gt; (não em tests/src) uma pasta chamada &lt;em&gt;Entity&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;User.php&lt;/em&gt;. Eis a estrutura da entidade &lt;em&gt;User&lt;/em&gt;. Por ser um arquivo muito extenso, colocarei apenas o link do mesmo que encontra-se no github. &lt;a title=&#34;Tableless\Entity\user&#34; href=&#34;https://gist.github.com/andrebian/11389706&#34; target=&#34;_blank&#34;&gt;Tableless\Entity\User&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Perceba que existem comentários acima de cada um dos atributos da classe. Isto se dá por estarmos utilizando o Annotations do Doctrine para que os mesmos sejam lidos e mapeados no banco de dados. Em outras palavras, o Doctrine lê a anotação e cria a estrutura da tabela conforme as definições nos comentários. Há a possibilidade de realizar tais definições via xml e também via yaml o que não veremos neste tutorial.&lt;/p&gt;

&lt;p&gt;Agora se rodarmos nosso teste novamente o mesmo passará. Ou seja, já temos um código minimamente testado com um início de noção de persistência de dados, veremos uma pequena melhora no código agora e em seguida algumas configurações para a execução dos testes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41349&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/08-primeiro-teste-passando-575x310.png&#34; alt=&#34;Primeiro teste passando&#34; width=&#34;575&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/08-primeiro-teste-passando-575x310.png 575w, uploads/2014/03/08-primeiro-teste-passando-312x168.png 312w, uploads/2014/03/08-primeiro-teste-passando-400x215.png 400w, uploads/2014/03/08-primeiro-teste-passando.png 797w&#34; sizes=&#34;(max-width: 575px) 100vw, 575px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;definindo-hash-para-senha&#34;&gt;Definindo hash para senha&lt;/h2&gt;

&lt;p&gt;Primeiramente no teste adicionaremos uma asserção de que a senha do usuário registrado não é igual a senha que definimos, em string pura. Adicione o trecho de código abaixo em seu teste logo após $this-&amp;gt;assertEquals($userData[&amp;#8216;name&amp;#8217;], $registeredUser-&amp;gt;getName());&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;// verificando se hash de senha funcionou
$this-&amp;gt;assertNotEquals($userData[&#39;password&#39;], $registeredUser-&amp;gt;getPassword());&lt;/pre&gt;

&lt;p&gt;Ao rodarmos o teste o mesmo deve quebrar pois ainda não criamos um hash para a senha, desta forma a senha fornecida está em string pura no banco de dados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41350&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/09-teste-falhando-hash-523x310.png&#34; alt=&#34;Teste falhando hash&#34; width=&#34;523&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/09-teste-falhando-hash-523x310.png 523w, uploads/2014/03/09-teste-falhando-hash-283x168.png 283w, uploads/2014/03/09-teste-falhando-hash-400x237.png 400w, uploads/2014/03/09-teste-falhando-hash.png 800w&#34; sizes=&#34;(max-width: 523px) 100vw, 523px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora, na classe Tableless\Entity\User usaremos as seguintes classes do Zend:&lt;/p&gt;

&lt;pre&gt;use Zend\Math\Rand;
use Zend\Crypt\Key\Derivation\Pbkdf2;&lt;/pre&gt;

&lt;p&gt;em setPassword deixaremos adicionaremos a chamada ao método encryptPassword&lt;/p&gt;

&lt;pre&gt;public function setPassword( $password )
{
    $this-&amp;gt;password = $this-&amp;gt;encryptPassword($password);
    return $this;
}&lt;/pre&gt;

&lt;p&gt;E criaremos o método encryptPassword.&lt;/p&gt;

&lt;pre&gt;public function encryptPassword( $password )
{
   return base64_encode(
    Pbkdf2::calc(&#39;sha256&#39;, $password, $this-&amp;gt;salt, 
            10000, strlen($password*2)));
}&lt;/pre&gt;

&lt;p&gt;Agora rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; o teste passa novamente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41351&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/10-teste-passando-hash-375x310.png&#34; alt=&#34;teste passando hash&#34; width=&#34;375&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/10-teste-passando-hash-375x310.png 375w, uploads/2014/03/10-teste-passando-hash-203x168.png 203w, uploads/2014/03/10-teste-passando-hash-400x330.png 400w, uploads/2014/03/10-teste-passando-hash.png 795w&#34; sizes=&#34;(max-width: 375px) 100vw, 375px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Assim finalizamos o básico da realização de testes utilizando persitência de dados. A partir de agora veremos algumas configurações avançadas que lhe ajudarão muito no feedback dos testes.&lt;/p&gt;

&lt;h2 id=&#34;algumas-configurações-avançadas&#34;&gt;Algumas configurações avançadas&lt;/h2&gt;

&lt;p&gt;Através do arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; podemos definir algumas configurações avançadas para a execução dos testes. Começando pela declaração &lt;phpunit&gt;. Atualmente encontra-se desta forma:&lt;/p&gt;

&lt;pre class=&#34;lang-xml&#34;&gt;&amp;lt;phpunit colors=&#34;true&#34; bootstrap=&#34;bootstrap.php&#34;&amp;gt;&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que utilizaremos um arquivo de bootstrap e dizemos qual arquivo é e também que queremos coloração no output. Caso colors=”true” não estivesse presente nossa visão ficaria desta forma.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41352&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/11-colors-482x310.png&#34; alt=&#34;Colors&#34; width=&#34;482&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/11-colors-482x310.png 482w, uploads/2014/03/11-colors-261x168.png 261w, uploads/2014/03/11-colors-400x257.png 400w, uploads/2014/03/11-colors.png 806w&#34; sizes=&#34;(max-width: 482px) 100vw, 482px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos definir erros e avisos sendo tratados como exceções.&lt;/p&gt;

&lt;pre&gt;&amp;lt;phpunit 
    convertErrorsToExceptions=&#34;true&#34; 
    convertNoticesToExceptions=&#34;true&#34;
    convertWarningsToExceptions=&#34;true&#34;
    colors=&#34;true&#34;
    bootstrap=&#34;bootstrap.php&#34;
&amp;gt;&lt;/pre&gt;

&lt;p&gt;E muitas outras opções. Para conhecer todas as opções de configurações acesse &lt;a title=&#34;Visualizar as configurações do PHPUnit&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/appendixes.configuration.html&#34; target=&#34;_blank&#34;&gt;este link&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Certamente que a configuração a seguir é uma que empolga muitos desenvolvedores, logs e coverage. Com logs e coverage você identifica quais testes passaram, quais tiveram exceções, quais não passaram e o mais legal de tudo, o percentual de cobertura de testes que há em seu código de produção. Basicamente ao rodar um teste unitário, ele cobre uma pequena parte de seu código de produção, habilitando coverage você pode verificar quais linhas estão realmente garantidas por testes e quais você ainda tem de trabalhar mais tempo para garantir um mínimo de cobertura necessário para perfeito funcionamento mas principalmente para garantia de evolução de seu software.&lt;/p&gt;

&lt;p&gt;Para criar logs utilizamos a tag logging no arquivo &lt;em&gt;phpunit.xml&lt;/em&gt; logo após o fechamento da tag &lt;/filter&gt;.&lt;/p&gt;

&lt;pre&gt;&amp;lt;logging&amp;gt;
    &amp;lt;log type=&#34;testdox-text&#34; target=&#34;data/testdox.txt&#34; /&amp;gt;
&amp;lt;/logging&amp;gt;&lt;/pre&gt;

&lt;p&gt;O log acima está gravando em formato de texto um checklist dos testes que existem em todas as classes de teste dentro da suite de testes marcando com x os que foram executados.&lt;/p&gt;

&lt;p&gt;Rodando &lt;strong&gt;./vendor/bin/phpunit -c tests/phpunit.xml&lt;/strong&gt; será criada a pasta &lt;em&gt;tests/data&lt;/em&gt; contento o arquivo &lt;em&gt;testdox.txt&lt;/em&gt; O nome do arquivo é de sua escolha.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41353&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/12-testdox-569x310.png&#34; alt=&#34;Testdox&#34; width=&#34;569&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/12-testdox-569x310.png 569w, uploads/2014/03/12-testdox-308x168.png 308w, uploads/2014/03/12-testdox-400x217.png 400w, uploads/2014/03/12-testdox.png 891w&#34; sizes=&#34;(max-width: 569px) 100vw, 569px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Também é possível gerar o testdox em formato html, basta alterar testdox-text para testdox-html e testdox.txt para testdox.html mas o mais comum é ser utilizado em formato txt mesmo.&lt;/p&gt;

&lt;p&gt;Existe também a possibilidade de habilitar o testdox em tempo de execução. Basta apenas adicionar o parâmetro &amp;#8211;testdox ao rodar os testes. O resultado será como abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --testdox
PHPUnit 3.7.35 by Sebastian Bergmann.
Configuration read from /home/andre/Documents/Posts/tableless/phpunit-persistencia-de-dados-e-configuracoes-avancadas/sources/tests/phpunit.xml
Tableless\Entity\User
  [x] If is saving as expected
Generating code coverage report in HTML format ... done&lt;/pre&gt;

&lt;h2 id=&#34;agrupamento-de-testes&#34;&gt;Agrupamento de testes&lt;/h2&gt;

&lt;p&gt;Por certas vezes necessitamos agrupar testes para que rodemos somente determinada sequência sem que os demais sejam executados. Isto é útil para quando temos de realizar uma pequena alteração e não se faça necessário a execução de todos os testes já criados tornando o feedback mais rápido. Comumente isto é utilizado quando se deseja realizar um ajuste pontual e ao ser finalizado todos os testes são executados novamente.&lt;/p&gt;

&lt;p&gt;O PHPUnit nos permite trabalhar com grupos os quais veremos sua definição a seguir.&lt;/p&gt;

&lt;p&gt;Crie uma pasta chamada &lt;em&gt;Filter&lt;/em&gt; em &lt;em&gt;tests/src/Tableless&lt;/em&gt; e dentro dela um arquivo chamado &lt;em&gt;CurrencyTest.php&lt;/em&gt;. O conteúdo deste arquivo está abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;?php
namespace Tableless\Filter;
use Tableless\Test\TestCase;
/**
* @group Filter
*/
class CurrencyTest extends TestCase 
{
    public function testIfClassExists()
    {
        $this-&amp;gt;assertTrue(class_exists(&#39;Tableless\Filter\Currency&#39;));
    }
}&lt;/pre&gt;

&lt;p&gt;Perceba que antes de ser declarado o nome da classe existe uma anotação @group Filter. É isto que define o grupo ao qual este teste pertence. Faça o mesmo para o teste já existente (tests/src/Tableless/Entity/UserTest.php) anotando-o como @group Entity.&lt;/p&gt;

&lt;pre&gt;...
/**
* @group Entity
*/
class UserTest extends TestCase
...&lt;/pre&gt;

&lt;p&gt;Agora que temos a definição dos grupos podemos rodar nossos testes somente de 1 grupo, de um conjunto de grupos ou de todos os grupos sem distinção. Existem duas formas de rodar os testes por grupos, através de parâmetro informado no momento da execução dos testes ou através do arquivo xml de configurações do PHPUnit, veremos ambas.&lt;/p&gt;

&lt;h3 id=&#34;via-parâmetro&#34;&gt;Via parâmetro&lt;/h3&gt;

&lt;h4 id=&#34;somente-um-grupo&#34;&gt;Somente um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity
&lt;/pre&gt;

&lt;h4 id=&#34;mais-de-um-grupo&#34;&gt;Mais de um grupo&lt;/h4&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml --group Entity,Filter
&lt;/pre&gt;

&lt;p&gt;Para que todos os grupos de testes sejam executados basta que não seja informado o parâmetro &amp;#8211;group.&lt;/p&gt;

&lt;h3 id=&#34;via-arquivo-de-configuração&#34;&gt;Via arquivo de configuração&lt;/h3&gt;

&lt;p&gt;No arquivo tests/phpunit.xml adicione uma tag &lt;groups&gt; e dentro dela liste os grupos desejados.&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;&amp;lt;groups&amp;gt;
    &amp;lt;include&amp;gt;
        &amp;lt;group&amp;gt;Entity&amp;lt;/group&amp;gt;
    &amp;lt;/include&amp;gt;
&amp;lt;/groups&amp;gt;&lt;/pre&gt;

&lt;p&gt;Você deve estar imaginando, se existe uma tag &lt;strong&gt;include &lt;/strong&gt;deve existir uma tag &lt;strong&gt;exclude &lt;/strong&gt;também. Imaginou certo! Dentro de include você adiciona todos os grupos que deseja que sejam executados nos testes já em exclude, todos que NÃO devem ser executados. O excclude é ideal para testes que foram marcados como incompletos ou pulados (skipped).&lt;/p&gt;

&lt;p&gt;Após adicionar as tags referentes aos grupos de testes no arquivo xml de configurações não se faz mais necessário informar o parâmetro  &amp;#8211;group, basta rodar normalmente.&lt;/p&gt;

&lt;pre&gt;$ ./vendor/bin/phpunit -c tests/phpunit.xml&lt;/pre&gt;

&lt;h2 id=&#34;agora-sim-o-mais-legal-de-todos-coverage-em-html&#34;&gt;Agora sim, o mais legal de todos, Coverage em Html!&lt;/h2&gt;

&lt;p&gt;Dentro de &lt;logging&gt; adicione uma nova tag chamada &lt;log&gt; conforme o exemplo abaixo.&lt;/p&gt;

&lt;pre&gt;&amp;lt;log 
    type=&#34;coverage-html&#34; 
    target=&#34;data/coverage&#34; 
    charset=&#34;UTF-8&#34; 
    yui=&#34;true&#34; 
    highlight=&#34;true&#34;
    lowUpperBound=&#34;35&#34;
    highUpperBound=&#34;70&#34; /&amp;gt;&lt;/pre&gt;

&lt;p&gt;Basicamente estamos definindo que o coverage será em formato html, que o considerado baixo coverage será de 35% e um bom coverage se dará a partir de 70%. O highlight serve para destacar as linhas que foram cobertas com verde, não cobertas com vermelho e ignoradas permanecem com a cor padrão. Rode o teste novamente.&lt;/p&gt;

&lt;p&gt;Agora no browser entre em seu localhost na pasta do projeto em que está trabalhando. Em seguida entre na pasta &lt;em&gt;tests&lt;/em&gt;, após isto em &lt;em&gt;data&lt;/em&gt; e por último em coverage. Surpreenda-se!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41354&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/13-coverage-588x223.png&#34; alt=&#34;Coverage&#34; width=&#34;588&#34; height=&#34;223&#34; srcset=&#34;uploads/2014/03/13-coverage-588x223.png 588w, uploads/2014/03/13-coverage-329x125.png 329w, uploads/2014/03/13-coverage-660x251.png 660w, uploads/2014/03/13-coverage-400x152.png 400w, uploads/2014/03/13-coverage.png 1324w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Navegando pelos arquivos você identificará o que já está bom e o que precisa ser mais testado. Neste nosso caso chegar a 100% é muito fácil, basta lermos todos os dados do usuário.&lt;/p&gt;

&lt;p&gt;No arquivo &lt;em&gt;tests/src/Tableless/Entity/UserTest.php&lt;/em&gt;, dentro do único teste que temos adicione os seguintes asserts:&lt;/p&gt;

&lt;pre&gt;$this-&amp;gt;assertEquals(1, $registeredUser-&amp;gt;getId());
$this-&amp;gt;assertEquals(&#39;usuario@dominio.com&#39;, $registeredUser-&amp;gt;getEmail());
$this-&amp;gt;assertNotNull($registeredUser-&amp;gt;getSalt());
$this-&amp;gt;assertEquals(&#39;image.png&#39;, $registeredUser-&amp;gt;getProfilePic());&lt;/pre&gt;

&lt;p&gt;Rode os testes novamente e corra pro abraço!&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41355&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/14-coverage-100-588x237.png&#34; alt=&#34;Coverage 100%&#34; width=&#34;588&#34; height=&#34;237&#34; srcset=&#34;uploads/2014/03/14-coverage-100-588x237.png 588w, uploads/2014/03/14-coverage-100-329x132.png 329w, uploads/2014/03/14-coverage-100-660x266.png 660w, uploads/2014/03/14-coverage-100-400x161.png 400w, uploads/2014/03/14-coverage-100.png 1303w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Lembrando novamente que para entendimento deste tutorial se faz necessário a leitura dos conteúdos anteriores sobre o tema, sendo eles &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar/&#34; title=&#34;TDD, por que usar?&#34;&gt;TDD, por que usar?&lt;/a&gt;  e &lt;a href=&#34;http://tableless.com.br/phpunit-como-iniciar-sem-dores/&#34; title=&#34;PHPUnit, como iniciar sem dores&#34;&gt;PHPUnit, como iniciar sem dores&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;bonus&#34;&gt;Bonus.&lt;/h2&gt;

&lt;p&gt;O que fizemos até o momento foi preparar o ambiente de testes e executá-los mas este ambiente ainda não está totalmente pronto para o código de produção pois precisamos de conexão com um banco de dados além de mais uma configuração do Doctrine para que possamos criar o banco de dados a partir de nossas entidades. Ou seja, lembra daquele processo de criar o banco de dados, definir as tabelas e relacionamentos todos antes do código? Com o Doctrine isto não se faz mais necessário, pode ser feito da forma descrita (e tradicional) mas há outra forma bem legal que é uma mão na roda e que mostrarei agora.&lt;/p&gt;

&lt;p&gt;Primeiramente precisamos criar um arquivo de configuração para o cli (Command Line Interface) do Doctrine. Na pasta raiz de sua aplicação crie um arquivo chamado &lt;em&gt;cli-config.php&lt;/em&gt; e cole o seguinte conteúdo:&lt;/p&gt;

&lt;pre&gt;//cli-config.php
require &#39;bootstrap.php&#39;;

return \Doctrine\ORM\Tools\Console\ConsoleRunner::createHelperSet($entityManager);&lt;/pre&gt;

&lt;div id=&#34;LC3&#34;&gt;
  Após a criação deste arquivo podemos rodar o seguinte comando &lt;b&gt;./vendor/bin/doctrine&lt;/b&gt;
&lt;/div&gt;

&lt;p&gt;Aparecerão várias opções de uso que vão desde checagem de status de conexão, validação das entidades, além de outras funcionalidades. Uma coisa que o doctrine não faz realmente é criar a base de dados pois isto depende de cada base pois Mysql é de um jeito, Postgres é de outro, SQL Server é de outro ainda, então esta tarefa ainda é manual.&lt;/p&gt;

&lt;p&gt;Para fins didáticos criei uma base chamada tableless_tdd no mysql como definido no arquivo bootstrap.php da raiz do projeto. Você pode alterar o nome se quiser, bem como o próprio banco, experimente o Sqlite se quiser.&lt;/p&gt;

&lt;p&gt;Com a base criada rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;. Se estiver tudo ok aparecerá algo como a imagem abaixo. Nela informa que o mapeamento das entidades está correto mas o banco ainda não está sincronizado, para sincronizar rode o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;. Isto lerá todas as entidades contidas em src/Tableless/Entity e criará a estrutura de tabelas a partir delas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:validate-schema&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41356&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/15-doctrine-validate-500x310.png&#34; alt=&#34;Doctrine Validate Schema&#34; width=&#34;500&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/15-doctrine-validate-500x310.png 500w, uploads/2014/03/15-doctrine-validate-271x168.png 271w, uploads/2014/03/15-doctrine-validate-400x247.png 400w, uploads/2014/03/15-doctrine-validate.png 797w&#34; sizes=&#34;(max-width: 500px) 100vw, 500px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:create&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-medium wp-image-41357&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/03/16-doctrine-create-validate-459x310.png&#34; alt=&#34;Doctrine create validate&#34; width=&#34;459&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/03/16-doctrine-create-validate-459x310.png 459w, uploads/2014/03/16-doctrine-create-validate-249x168.png 249w, uploads/2014/03/16-doctrine-create-validate-400x269.png 400w, uploads/2014/03/16-doctrine-create-validate.png 820w&#34; sizes=&#34;(max-width: 459px) 100vw, 459px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Atualmente possuímos somente a entidade User que indica que uma tabela users será criada no banco de dados. Após a finalização da execução do comando anterior seu banco de dados já estará com a nova estrutura. Ao realizar qualquer alteração na entidade User ou mesmo criar novas entidades você precisará rodar o comando &lt;strong&gt;./vendor/bin/doctrine orm:schema-tool:update&lt;/strong&gt; com isso aparecerá uma mensagem informando que já há uma estrutura no banco de dados e lhe pede confirmação sobre o que fazer. Você pode ignorar, ver as alterações ou forçar se tiver certeza do que está fazendo ou mesmo se já visualizou as alterações que serão realizadas e está ciente de que está tudo certo. Basta ler as intruções que o próprio Doctrine fornece que você saberá o que fazer, é muito intuitivo.&lt;/p&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;Agora que você já configurou o Doctrine, já conhece como criar testes unitários resta apenas aperfeiçoar a cada dia. Não existe uma receita, tudo requer empenho e dedicação mas que no final quando você ver aquelas barrinhas verdes mostrando 100% de cobertura se sentirá cada vez mais empolgado e com um código mais estável mas o principal, com um código que pode facilmente evoluir.&lt;/p&gt;

&lt;p&gt;Para baixar o código-fonte gerado neste artigo acesse este link do &lt;a title=&#34;Baixar o código-fonte&#34; href=&#34;https://github.com/andrebian/tdd-persistencia-de-dados&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Composer – um pouco além do básico</title>
      <link>https://tableless.github.io/hugo-public/composer-um-pouco-alem-basico/</link>
      <pubDate>Tue, 01 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/composer-um-pouco-alem-basico/</guid>
      <description>

&lt;p&gt;No post anterior expliquei o que vem a ser o composer, como baixar, criar o arquivo de configurações e instalar pacotes ou bibliotecas. Agora veremos algumas questões um pouco mais avançadas sobre o uso do composer.&lt;/p&gt;

&lt;h2 id=&#34;instalação-global&#34;&gt;Instalação global&lt;/h2&gt;

&lt;p&gt;O composer suporta instalação global para que seja utilizado apenas um &amp;#8220;executável&amp;#8221; para todo e qualquer projeto. Usei o termo executável pois refere-se ao composer.phar, que como explicado no post anterior é uma forma de empacotamento no PHP que transforma a aplicação toda em um único arquivo que é facilmente executável em qualquer local de seu sistema operacional.&lt;/p&gt;

&lt;p&gt;O processo de instalação global do composer se dá das mesmas formas que a instalação já mostrada no post anterior com uma pequena diferença, selecionamos um diretório para manter o composer e quando utilizarmos, utilizamos sempre a partir deste diretório.&lt;/p&gt;

&lt;p&gt;Mãos na massa!&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Todos os exemplos aqui criados foram realizados em ambiente Linux. No Mac OS X é semelhante e no Windows há algumas pequenas diferenças com relação à execução do PHP, com isso sugiro que leia a &lt;a title=&#34;Documentação oficial do composer&#34; href=&#34;https://getcomposer.org/doc/&#34; target=&#34;_blank&#34;&gt;documentação oficial&lt;/a&gt; do composer para maiores detalhes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Instalarei o composer no diretório /opt de meu Linux, você pode selecionar o diretório de sua preferência pois funcionará da mesma forma, desde que você tenha o PHP instalado é claro.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;$ cd /opt &amp;&amp; mkdir composer &amp;&amp; cd composer&lt;/pre&gt;

&lt;p&gt;O comando acima em 3 passos (separados por &lt;strong&gt;&amp;amp;&amp;amp;&lt;/strong&gt;). No passo 1, entro no diretório /opt. No passo 2 crio uma pasta chamada composer e no passo 3 entro na pasta _composer_ recém criada.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Lembrando que você deve possuir permissão de escrita no diretório que pretende instalar o composer globalmente.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agora dentro da pasta /opt/composer basta que baixemos o composer através de uma das opções abaixo:&lt;/p&gt;

&lt;pre&gt;curl -sS https://getcomposer.org/installer | php&lt;/pre&gt;

&lt;p&gt;ou&lt;/p&gt;

&lt;pre&gt;php -r &#34;readfile(&#39;https://getcomposer.org/installer&#39;);&#34; | php&lt;/pre&gt;

&lt;p&gt;Com isso dentro da pasta /opt/composer deve agora existir o arquivo &lt;em&gt;composer.phar&lt;/em&gt;. Os passos descritos até aqui são ilustrados na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/01-download-do-composer.jpg&#34; alt=&#34;Download do composer&#34; width=&#34;1320&#34; height=&#34;621&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ainda dentro de _/opt/composer_ rodamos o comando &lt;strong&gt;php composer.phar&lt;/strong&gt;, é exibido o menu de ajuda do composer indicando que foi instalado corretamente.&lt;/p&gt;

&lt;h3 id=&#34;utilizando-o-composer-global-em-um-projeto&#34;&gt;Utilizando o composer global em um projeto&lt;/h3&gt;

&lt;p&gt;Criamos um projeto qualquer em um diretório de sua escolha. Farei o mesmo em meu Desktop em uma pasta chamada &lt;em&gt;composer-alem-do-basico&lt;/em&gt;. Dentro desta pasta crio um arquivo chamado _composer.json_ adicionando a seguinte estrutura:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;authors&#34;: [
        {
            &#34;name&#34;: &#34;Seu nome&#34;,
            &#34;email&#34;: &#34;seu email&#34;
        }
    ],
    &#34;require&#34;: {
        &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    }
}&lt;/pre&gt;

&lt;p&gt;Perceba que não temos nenhum pacote de terceiro como dependência ainda, somente definimos que a versão mínima do PHP para rodarmos a aplicação é a 5.2.8, deixaremos esta versão por enquanto e adicionaremos em &amp;#8220;require&amp;#8221; o &lt;a title=&#34;ORM Doctrine&#34; href=&#34;http://www.doctrine-project.org/&#34; target=&#34;_blank&#34;&gt;ORM Doctrine&lt;/a&gt;. Não será criado nenhum código utilizando o Doctrine, apenas está sendo incluso por ser um projeto que não possui muitas dependências fazendo a instalação ser mais rápida. Então nosso require agora fica assim:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34; : &#34;2.4.*&#34;
}&lt;/pre&gt;

&lt;p&gt;Note que na versão desejada do Doctrine informei 2.4.*, isto significa que sempre será utilizada a versão mais recente dentro do release 2.4. Caso você queira estar sempre com a mais atual possível basta remover a numeração da versão e adicionar somente &amp;#8220;*&amp;#8221;, desta forma nosso require no _composer.json_ tem esta estrutura:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34; : &#34;*&#34;
}&lt;/pre&gt;

&lt;p&gt;Agora que está configurada nossa primeira dependência do projeto basta que rodemos o comando &lt;strong&gt;php /opt/composer/composer.phar install&lt;/strong&gt;. Atenção ao caminho de onde está sendo rodado o composer, perceba que é a pasta que instalamos ele anteriormente. Com isso não preciso ficar para cada projeto baixando o &lt;em&gt;composer.phar&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/02-instalando-primeiras-dependencias.jpg&#34; alt=&#34;instalação via composer&#34; width=&#34;877&#34; height=&#34;692&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O Doctrine assim como todas as suas dependências são instaladas e temos agora esta estrutura dentro de nosso projeto:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/03-nova-estrutura-vendor.jpg&#34; alt=&#34;Estrutura inicial&#34; width=&#34;791&#34; height=&#34;615&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;qual-a-vantagem-do-composer-com-instalação-global&#34;&gt;Qual a vantagem do composer com instalação global?&lt;/h2&gt;

&lt;p&gt;Apesar de muitos pensarem e economia de espaço isso é irrelevante pois o _composer.phar_ &amp;#8220;pesa&amp;#8221; apenas 1MB aproximadamente. Há a vantagem que o composer sempre estará disponível para qualquer aplicação eliminando possíveis erros de tentar rodar o comando &lt;strong&gt;php composer.phar alguma-coisa&lt;/strong&gt; e o composer.phar não estar presente, ou seja, basicamente a vantagem em possuir uma instalação global é você nunca esquecer de instalá-lo para cada aplicação sua.&lt;/p&gt;

&lt;p&gt;No demais não há vantagens pois para cada aplicação o composer realizará o download de todas suas dependências individualmente para cada aplicação, ou seja, se você possuir 3 aplicações, o &lt;em&gt;composer.phar&lt;/em&gt; será somente 1 (na pasta /opt/composer/composer.phar) no entanto os vendors serão específicos para cada aplicação como mostra a imagem abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/04-dois-projetos-com-vendors-distintos.jpg&#34; alt=&#34;Vendors&#34; width=&#34;792&#34; height=&#34;465&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;errata&#34;&gt;Errata&lt;/h2&gt;

&lt;p&gt;Conforme mencionado em um cometário pelo Marcel dos Santos o correto para a instalação ser de fato global seria que o composer estivesse em &lt;em&gt;/usr/local/bin&lt;/em&gt;. Você pode simplesmente mover o composer.phar que atualmente encontra-se em &lt;em&gt;/opt/composer&lt;/em&gt; para a pasta &lt;em&gt;/usr/local/bin&lt;/em&gt; e para que seja executado basta em seu terminal digitar &lt;strong&gt;composer.phar&lt;/strong&gt; em qualquer ponto do seu sistema operacional.&lt;/p&gt;

&lt;h2 id=&#34;direcionamento-de-vendors&#34;&gt;Direcionamento de vendors&lt;/h2&gt;

&lt;p&gt;Por padrão o composer entende que as bibliotecas de terceiros devem ficar dentro do diretório _vendor_ mas é possível alterar. Pense em uma situação em que você está trabalhando com algum framework que fornece uma estrutura de diferente da estabelecida pelo composer, o CakePHP por exemplo, por padrão neste framework as bibliotecas de terceiros são instaladas em _vendors_ (no plural mesmo).&lt;/p&gt;

&lt;p&gt;Isto é facilmente configurado através do arquivo &lt;em&gt;composer.json&lt;/em&gt;. Decalararei que minhas bibliotecas de terceiros serão acondicionadas em &lt;em&gt;3rdparty&lt;/em&gt; apenas para fins didáticos. Para direcionar os vendors do composer precisamos adicionar a informação de onde nossos vendors serão acondicionados:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;....
&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34;: &#34;*&#34;
},
&#34;config&#34;: {
    &#34;vendor-dir&#34;: &#34;3rdparty&#34;
}
.....&lt;/pre&gt;

&lt;p&gt;Feito isto basta rodar o comando &lt;strong&gt;php /opt/composer/composer.phar install&lt;/strong&gt; caso não tenha instalado ainda ou &lt;strong&gt;php /opt/composer/composer.phar update&lt;/strong&gt; caso já tenha realizado alguma instalação anteriormente.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Caso você execute o update do composer ( &amp;#8230; composer.phar update) e alterou a pasta de vendors, esteja ciente de que a pasta que existia antes permanecerá em sua aplicação e você terá de removê-la manualmente pois o composer perdeu a referência da mesma a partir do momento que você alterou o &amp;#8220;vendor-dir&amp;#8221;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A nova estrutura de nossa aplicação será esta:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/05-nova-estrutura-vendor-path.jpg&#34; alt=&#34;Nova estrutura vendor&#34; width=&#34;809&#34; height=&#34;550&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;direcionando-pacotes&#34;&gt;Direcionando pacotes&lt;/h2&gt;

&lt;p&gt;Cada pacote que você define como uma dependência de sua aplicação possui uma série de configurações e podem conter dependências também que são listadas em seus composer.json. Ou seja, cada pacote possui (comumente) dentro dele um json informando do que eles dependem, se são plugins de algum framework ou CMS entre outras configurações.&lt;/p&gt;

&lt;p&gt;Um bom exemplo de plugins que são instalados em seus diretórios corretos são os plugins do wordpress, desde que você informe que estará utilizando os instaladores do composer &lt;em&gt;&amp;#8220;composer/installers&amp;#8221;: &amp;#8220;*&amp;#8221;&lt;/em&gt;. Caso você não esteja utilizando os instaladores do composer pode simplesmente direcionar cada pacote para onde bem entender.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;....
&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34;: &#34;*&#34;,
    &#34;josegonzalez/cakephp-upload&#34;: &#34;*&#34;
},
&#34;extra&#34; : {
    &#34;installer-paths&#34; : {
        &#34;plugins/Upload&#34; : [&#34;josegonzalez/cakephp-upload&#34;]
    }
},
....&lt;/pre&gt;

&lt;p&gt;Mesmo que você esteja utilizando os instaladores ainda sim pode personalizar pacote por pacote onde quer que eles sejam instalados dentro de sua aplicação.&lt;/p&gt;

&lt;p&gt;No novo exemplo do composer estou informando que o plugin de upload do CakePHP será instalado na pasta _plugins/Upload_ ao invés de &lt;em&gt;app/Plugin/Upload&lt;/em&gt; como seria instalado pelo CakePHPInstaller do composer.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/06-pacote-em-diretorio-personalizado.jpg&#34; alt=&#34;pacote em diretorio personalizado&#34; width=&#34;795&#34; height=&#34;456&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Como você pode ver, é possível personalizar a instalação cada pacote com simples configuração através de nosso arquivo &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;require-ou-require-dev&#34;&gt;Require ou require-dev?&lt;/h2&gt;

&lt;p&gt;O composer trabalha basicamente com dois tipos de dependências, os _require _que são os estritamente necessários para o funcionamento da aplicação e os _require-dev_ que são dependências utilizadas em ambiente de desenvolvimento, são elas ferramentas como PHPUnit, ferramentas de log, entre outras. No exemplo abaixo informamos que para nossa aplicação utilizaremos o ORM Doctrine e para o ambiente de desenvolvimento somente utilizaremos o PHPUnit.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;require&#34;: {
    &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
    &#34;doctrine/orm&#34;: &#34;*&#34;,
    &#34;josegonzalez/cakephp-upload&#34;: &#34;*&#34;
},
&#34;require-dev&#34; : {
    &#34;phpunit/phpunit&#34; : &#34;4.0.*&#34;
},&lt;/pre&gt;

&lt;p&gt;Com a configuração distinta podemos instalar no ambiente de produção somente as dependências necessárias para o funcionamento correto da aplicação deixando de lado as dependências de desenvolvimento.&lt;/p&gt;

&lt;p&gt;Como já realizamos a primeira instalação através do composer agora apenas utilizamos o comando &lt;strong&gt;php /opt/composer/composer.phar update&lt;/strong&gt; (se for a instalação global do composer) ou &lt;strong&gt;php composer.phar update&lt;/strong&gt; (se o composer.phar foi baixado na raiz de sua aplicação). Com este comando todos os pacotes serão instalados.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/07-atualizando-dev.jpg&#34; alt=&#34;Atualização dev&#34; width=&#34;834&#34; height=&#34;615&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a atualização (que baixará muitos pacotes) a nova estrutura de nosso projeto é a seguinte.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/08-estrutura-com-dev.jpg&#34; alt=&#34;Nova estrutura com Dev&#34; width=&#34;960&#34; height=&#34;672&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pensemos agora que estamos no ambiente de produção ou homologação onde não se faz necessário o PHPUnit. Não é necessária a remoção do mesmo no arquivo *composer.json* e sim rodarmos o comando &lt;strong&gt;php composer.phar update &amp;#8211;no-dev&lt;/strong&gt; e o resultado será como na imagem abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/09-update-sem-dev.jpg&#34; alt=&#34;Update sem Dev&#34; width=&#34;955&#34; height=&#34;499&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note apenas que na imagem acima eu rodei o update em meu ambiente de desenvolvimento apenas excluindo os pacotes de modo &lt;em&gt;dev&lt;/em&gt; para ilustrar o funcionamento. Na imagem também é possível perceber que o PHPUnit e suas dependências que já estavam instalados foram removidos por não serem mais necessários em modo produção. Na imagem abaixo está a nova estrutura de nossa aplicação.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/06-pacote-em-diretorio-personalizado.jpg&#34; alt=&#34;Pacote personalizado&#34; width=&#34;795&#34; height=&#34;456&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;definição-de-autoload&#34;&gt;Definição de Autoload&lt;/h2&gt;

&lt;p&gt;Para quem não conhece existe a &lt;a title=&#34;FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; (Framework Interop Group) que visa sugerir padrões de desenvolvimento através de suas PSRs. Atualmente são 4 recomendações sendo a primeira delas (&lt;a title=&#34;Conheça a PSR-0&#34; href=&#34;http://www.php-fig.org/psr/psr-0/&#34; target=&#34;_blank&#34;&gt;PSR-0&lt;/a&gt;) a que trata de como o carregamento de sua aplicação deve ocorrer. Basicamente é a informação de onde será definido o namespace de sua aplicação.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;&#34;autoload&#34; : {
    &#34;psr-0&#34;: {
         &#34;Tableless\\&#34;: &#34;src/&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;Note que foi definido o namespace _Tableless_ indicando que o mesmo está dentro da pasta &lt;em&gt;src&lt;/em&gt;. O nome da pasta pode ser outro qualquer e não somente &lt;em&gt;src&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com isso a nova estrutura de nossa aplicação é esta&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/21-namespace.jpg&#34; alt=&#34;Nova estrutura com namespace&#34; width=&#34;958&#34; height=&#34;596&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para utilizar todo o projeto entitulado como Tableless neste exemplo basta informá-lo onde o mesmo se faça necessário:&lt;/p&gt;

&lt;pre class=&#34;lang-php&#34;&gt;use Tableless;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;criando-um-pacote-do-composer&#34;&gt;Criando um pacote do composer&lt;/h2&gt;

&lt;p&gt;Pra finalizar criaremos um pacote do composer. Primeiramente você precisa ter uma conta no &lt;a title=&#34;Ir ao Github&#34; href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt; ou &lt;a title=&#34;Ir ao bitbucket&#34; href=&#34;https://bitbucket.org/&#34; target=&#34;_blank&#34;&gt;bitbucket&lt;/a&gt; (trabalharemos apenas com versionamento em git). Também será necessária uma conta no &lt;a title=&#34;Ir ao Packegist&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;Packagist&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tendo os requisitos atendidos agora deve ser criado um repositório no github, se você não sabe criar ou não utilizou o github ainda leia &lt;a title=&#34;Criando repositório no Github&#34; href=&#34;https://help.github.com/articles/create-a-repo&#34; target=&#34;_blank&#34;&gt;este tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Feito isto é hora de clonar o repositório em uma pasta de sua preferência, utilize o comando &lt;strong&gt;git clone git@github.com:username/repo-name.git&lt;/strong&gt; no meu caso é: git clone git@github.com:andrebian/exemplo-composer-tableless.git. Na imagem abaixo é possível ver o git realizando o clone e a estrutura inicial do projeto que contém além dos arquivos do git somente o arquivo README.md que foi criado juntamente com a criação do repositório no github.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/10-clonando-novo-projeto.jpg&#34; alt=&#34;Clonando novo projeto&#34; width=&#34;874&#34; height=&#34;451&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora temos de criar nosso arquivo _composer.json_ para que sejam adicionadas as informações de nosso novo pacote. Sua estrutura é a seguinte.&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;name&#34;: &#34;andrebian/exemplo-composer-tableless&#34;,
    &#34;description&#34;: &#34;Este pacote foi criado apenas para complementar o post no Tableless&#34;,
    &#34;authors&#34;: [ 
        {
            &#34;name&#34;: &#34;Andre Cardoso&#34;,
            &#34;email&#34;: &#34;andrecardosodev@gmail.com&#34;
        }
    ],
    &#34;require&#34;: {
         &#34;php&#34;: &#34;&amp;gt;=5.3.17&#34;,
         &#34;kevinlebrun/slug.php&#34;: &#34;1.*&#34;
    }
 }&lt;/pre&gt;

&lt;p&gt;A chave &amp;#8220;name&amp;#8221; deve possuir o vendor (seu username) e o slug do nome  do projeto.&lt;/p&gt;

&lt;p&gt;Note que adicionei uma dependência ao meu projeto, com isso mesmo se o pacote slug.php não estiver setado no composer que engloba toda a aplicação será instalado porque eu informei que meu pacote precisa dele para funcionar corretamente.&lt;/p&gt;

&lt;p&gt;Feito isto basta que as alterações realizadas sejam enviadas ao github e podemos prosseguir com a criação do pacote no packagist. Não vou explicar o funcionamento do git (commit, pull, push e outros) pois o foco deste post é o composer. Se você ainda não conhece o git sujiro a leitura de &lt;a href=&#34;http://tableless.com.br/iniciando-no-git-parte-1/&#34; title=&#34;Iniciando no git parte 1&#34;&gt;Iniciando no git&lt;/a&gt; que foi escrito pelo Diego Eis e está divido em duas partes que lhe mostram conceitos e utilização do mesmo. A imagem abaixo mostra o repositório no github já com a nova estrutura contendo o &lt;em&gt;composer.json&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/11-projeto-no-github.jpg&#34; alt=&#34;Configurações&#34; width=&#34;1088&#34; height=&#34;641&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora que já temos nosso repositório no github basta criarmos nosso pacote no packagist. Acessando &lt;a href=&#34;https://packagist.org/&#34;&gt;https://packagist.org/&lt;/a&gt; e estando logado clique em &amp;#8220;Submit package&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/12-submit-package.jpg&#34; alt=&#34;Enviar pacote&#34; width=&#34;1068&#34; height=&#34;457&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Informe a URL em que o mesmo se encontra, neste caso &lt;a href=&#34;https://github.com/andrebian/exemplo-composer-tableless&#34;&gt;https://github.com/andrebian/exemplo-composer-tableless&lt;/a&gt; e clique em Check&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/13-package-url.jpg&#34; alt=&#34;Check&#34; width=&#34;954&#34; height=&#34;551&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após a verificação e confirmação de que está tudo ok basta clicar em Submit&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/14-confirm-submit.jpg&#34; alt=&#34;Confirm&#34; width=&#34;927&#34; height=&#34;557&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Na imagem seguinte você pode ver que o pacote foi criado com sucesso e já está disponível para ser adicionado como dependência em qualquer projeto que você desejar.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/15-package-created.jpg&#34; alt=&#34;Created&#34; width=&#34;1150&#34; height=&#34;556&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note apenas que há uma chamada de atenção ali informando que o pacote não é atualizável automaticamente, vamos corrigir isto agora.&lt;/p&gt;

&lt;p&gt;Acessando sua conta no github navegue pelos seus repositórios até encontrar o desejado e entre em suas configurações.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/16-settings.jpg&#34; alt=&#34;Settings&#34; width=&#34;1138&#34; height=&#34;664&#34; /&gt;&lt;/p&gt;

&lt;p&gt;À esquerda há um menu com algumas opções, clique em &lt;strong&gt;Webhooks &amp;amp; Services&lt;/strong&gt; e em seguida em configurar serviços.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/17-webhooks.jpg&#34; alt=&#34;Service&#34; width=&#34;1115&#34; height=&#34;572&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Role a tela até localizar o serviço &lt;strong&gt;Packagist&lt;/strong&gt; e clique no mesmo. Uma nova tela será aberta solicitando os dados de sua conta. Forneça &amp;#8220;user&amp;#8221; e &amp;#8220;token&amp;#8221;, o &amp;#8220;domain&amp;#8221; é opcional, em seguida marque a opção &amp;#8220;Active&amp;#8221; e clique em Update Settings.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/18-packagist-token.jpg&#34; alt=&#34;Token&#34; width=&#34;781&#34; height=&#34;599&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para obter o token, vá até sua conta no Packagist e clique em &amp;#8220;Show API Token&amp;#8221;.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/19-show-api-token.jpg&#34; alt=&#34;Show API Token&#34; width=&#34;922&#34; height=&#34;591&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Após confirmado o user e token nas configurações de webhooks do github, acesse novamente Webhooks &amp;amp; Services, vá novamente até Packagist e perceba que agora existe um botão de teste para confirmar que o serviço foi habilitado com sucesso, clique sobre o mesmo e certifique-se de que uma mensagem de sucesso foi retornarda.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/20-confirm-service.jpg&#34; alt=&#34;Confirm service&#34; width=&#34;1129&#34; height=&#34;662&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Quase lá, agora falta somente acessarmos nosso pacote no composer para certificar que a mensagem de que o mesmo não é atualizado automaticamente não aparece mais.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter&#34; src=&#34;https://raw.githubusercontent.com/andrebian/posts/master/tableless/composer-um-pouco-alem-do-basico/images/20-success.jpg&#34; alt=&#34;Success&#34; width=&#34;920&#34; height=&#34;547&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Prontinho! Tudo funcionando perfeitamente. Agora sempre que você der um push no github o pacote do composer é atualizado automaticamente.&lt;/p&gt;

&lt;h2 id=&#34;concluindo&#34;&gt;Concluindo&lt;/h2&gt;

&lt;p&gt;Como você pode ver o composer é muito versátil, pode (e deve preferencialmente) ser utilizado em todo e qualquer projeto em PHP. Obviamente que existem configurações mais avançadas no entanto elas não vem ao caso neste momento por serem muito específicas de cada projeto/pacote. A ideia deste post era fornecer um pouco mais de informações sobre a utilização do composer que foi iniciada no post anterior &lt;a href=&#34;http://tableless.com.br/composer-para-iniciantes/&#34; title=&#34;Composer para iniciantes&#34;&gt;Composer para iniciantes&lt;/a&gt; para maiores informações a documentação oficial sempre será a melhor fonte.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Composer para iniciantes</title>
      <link>https://tableless.github.io/hugo-public/composer-para-iniciantes/</link>
      <pubDate>Tue, 18 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/composer-para-iniciantes/</guid>
      <description>

&lt;p&gt;&lt;a title=&#34;Ir para a homepage do Composer&#34; href=&#34;https://getcomposer.org/&#34; target=&#34;_blank&#34;&gt;Composer&lt;/a&gt; é uma ferramenta para gerenciamento de dependências para o PHP que vem ganhando espaço e se tornando cada vez mais indispensável. Com algumas poucas linhas de configurações você define todas as bibliotecas de terceiros ou mesmo suas que deseja/precisa utilizar em seu projeto, o composer encarrega-se de baixá-las e criar um autoloader deixando-as prontas para uso.&lt;/p&gt;

&lt;p&gt;Para muitos o composer ainda é um mistério então o intuito deste post é mostrar ao usuário que ainda não conhece como baixar, configurar e utilizar o composer de forma básica.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;do-que-preciso&#34;&gt;Do que preciso?&lt;/h2&gt;

&lt;p&gt;Basicamente precisará do PHP em sua versão a partir da 5.3.2.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Os exemplos criados neste post serão baseados em ambiente Linux, em sua maioria funcionará da mesma forma no Mac OS X mas para o Windows recomendo que leia a documentação oficial. O conceito é o mesmo nos três Sistemas Operacionais no entanto no Windows há algumas mínimas diferenças.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;como-começo&#34;&gt;Como começo?&lt;/h2&gt;

&lt;p&gt;Primeiramente você precisa realizar o download do phar do composer. O &lt;a title=&#34;Descubra o que é um arquivo Phar&#34; href=&#34;https://php.net/manual/pt_BR/book.phar.php&#34; target=&#34;_blank&#34;&gt;phar&lt;/a&gt; é um empacotamento de uma aplicação e é utilizado para fornecer bibliotecas e ferramentas nas quais o desenvolvedor não tem de se preocupar com sua estrutura. Em outras palavras, é pegar e usar.&lt;/p&gt;

&lt;p&gt;Para que você obtenha o composer há duas maneiras distintas. Através da biblioteca &lt;a title=&#34;Descubra o que é cURL&#34; href=&#34;http://en.wikipedia.org/wiki/CURL&#34; target=&#34;_blank&#34;&gt;cURL&lt;/a&gt; e através do próprio PHP. Basta selecionar uma das opções abaixo e executar em seu terminal.&lt;/p&gt;

&lt;p&gt;Instalando via cURL:&lt;/p&gt;

&lt;p&gt;curl -sS &lt;a href=&#34;https://getcomposer.org/installer&#34;&gt;https://getcomposer.org/installer&lt;/a&gt; | php&lt;/p&gt;

&lt;p&gt;Instalando via PHP:&lt;/p&gt;

&lt;p&gt;php -r &amp;#8220;readfile(&amp;#8216;&lt;a href=&#34;https://getcomposer.org/installer&amp;amp;#8217;);&amp;amp;#8221&#34;&gt;https://getcomposer.org/installer&amp;amp;#8217;);&amp;amp;#8221&lt;/a&gt;; | php&lt;/p&gt;

&lt;p&gt;Existem outras maneiras de instalar, na verdade são configurações mais avançadas de instalação que não serão abordadas aqui por se tratar de ser um conteudo voltado à iniciantes.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;qual-o-próximo-passo&#34;&gt;Qual o próximo passo?&lt;/h2&gt;

&lt;p&gt;Antes de você sair querendo fazer as coisas acontecerem precisamos passar alguns conceitos básicos.&lt;/p&gt;

&lt;p&gt;O composer facilita o gerenciamento de dependências em seus projetos, com isso houve a necessidade de uma padronização para a interoperabilidade entre os mais diversos frameworks PHP do mercado. Mas detalhe que o composer não limita-se à uso somente em frameworks, você pode tranquilamente utilizá-lo em seus projetos com PHP puro desde que siga as recomendações da &lt;a title=&#34;Descubra o que é FIG&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; (Framework Interoperability Group).&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;o-arquivo-de-configurações&#34;&gt;O arquivo de configurações&lt;/h2&gt;

&lt;p&gt;Agora que você já tem uma noção do que é o composer está na hora de botar a mão na massa.&lt;/p&gt;

&lt;p&gt;Primeiramente crie um arquivo chamado &lt;em&gt;composer.json&lt;/em&gt;. Este arquivo possuirá as configurações de dependências de sua aplicação em formato &lt;a title=&#34;Veja mais sobre a estrutura de um arquivo Json&#34; href=&#34;http://json.org/json-pt.html&#34; target=&#34;_blank&#34;&gt;Json&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Abaixo segue um esqueleto básico do _composer.json_ – o arquivo em que as dependências serão descritas, em seguida o mesmo será esclarescido.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-json&#34;&gt;{
    &#34;name&#34;: &#34;Nome do projeto&#34;,
    &#34;description&#34;: &#34;Breve descrição do que a aplicação se propoe a fazer&#34;,
    &#34;authors&#34;: [
        {
            &#34;name&#34;: &#34;Seu nome&#34;,
            &#34;email&#34;: &#34;seu-email@seu-dominio.com&#34;
        }
    ],
    &#34;require&#34;: {
        &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;O “name” é o nome de sua aplicação. Esta marcação é opcional mas recomendada.&lt;/p&gt;

&lt;p&gt;O “description” é uma breve descrição do que sua aplicação se propõe a fazer. Também opcional.&lt;/p&gt;

&lt;p&gt;Em “authors” aparecem os créditos de desenvolvedores que contribuiram com o projeto.&lt;/p&gt;

&lt;p&gt;O “require” basicamente deixa claro quais são as dependências de sua aplicação. Neste caso se a versão do PHP for abaixo da 5.2.8 simplesmente uma mensagem de erro será lançada ao instalar as dependências lhe informando que não é possível prosseguir por nem todos os requisitos estarem satisfeitos.&lt;/p&gt;

&lt;p&gt;Como você pode ver acima este é o esqueleto de uma aplicação muito básica, sem configurações avançadas e sem indicação de nenhuma biblioteca de terceiro.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;ok-mas-e-agora&#34;&gt;Ok, mas e agora?&lt;/h2&gt;

&lt;p&gt;Agora que você já tem o esqueleto de seu composer configurado em sua aplicação falta incluir alguns pacotes. O composer utiliza como seu repositório o &lt;a title=&#34;Pacotes do composer&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;Packagist&lt;/a&gt; onde qualquer desenvolvedor pode criar seus próprios pacotes e disponibilizá-los para a comunidade semelhante o &lt;a title=&#34;Ir ao Github&#34; href=&#34;https://github.com/&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;. O Packagist lhe fornece o total de instalações dos pacotes por dia, mês e o total. O mais legal é que estas estatísticas são fiéis, ou seja, se alguém remover um pacote do seu _composer.json_ o total de instalações é reduzido. Com esta informação restam contagens apenas aplicações que realmente estão utilizando determinado pacote.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;um-pequeno-exemplo&#34;&gt;Um pequeno exemplo.&lt;/h2&gt;

&lt;p&gt;Para fins didáticos mostrarei aqui a utilização de uma biblioteca para slug criada por &lt;a title=&#34;Perfil de Kevin Le Brun no Github&#34; href=&#34;https://github.com/kevinlebrun&#34; target=&#34;_blank&#34;&gt;Kevin Le Brun&lt;/a&gt;, o &lt;a title=&#34;Slug PHP no Github&#34; href=&#34;https://github.com/kevinlebrun/slug.php&#34; target=&#34;_blank&#34;&gt;slug.php&lt;/a&gt;. Na seção em que são definidos os requerimentos (require) no arquivo _composer.json _basta adicionar logo abaixo da linha que define que o necessita do PHP o nome do pacote desejado e a sua versão. Neste caso o pacote é &amp;#8220;kevinlebrun/slug.php&amp;#8221; e a versão é &amp;#8220;1.*&amp;#8221;. Com isso a nova estrutura do composer.json é:&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-json&#34;&gt;...
&#34;require&#34;: {
        &#34;php&#34;: &#34;&amp;gt;=5.2.8&#34;,
        &#34;kevinlebrun/slug.php&#34;: &#34;1.*&#34;
}
...&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Muito bem, agora está tudo pronto para que você veja o composer em ação. Na pasta raíz de sua aplicação (que é a mesma que o _composer.json_ e o _composer.phar_ se encontram) rode o comando &lt;strong&gt;php composer.phar install&lt;/strong&gt;. Este comando fará o composer ler as configurações setadas no arquivo json e instalar todas as bibliotecas/pacotes necessários para a sua aplicação e também estas mesmas bibliotecas que possuírem dependências terão as mesmas resolvidas. Pense no composer mais ou menos como o apt-get do Linux debian-like. Nele, ao instalar um pacote qualquer todas suas dependências são resolvidas automaticamente.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-large wp-image-41193&#34; alt=&#34;Estruturdo composer e instalação&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/estrutura-e-instalacao-660x292.png&#34; width=&#34;660&#34; height=&#34;292&#34; srcset=&#34;uploads/2014/02/estrutura-e-instalacao-660x292.png 660w, uploads/2014/02/estrutura-e-instalacao-329x146.png 329w, uploads/2014/02/estrutura-e-instalacao-588x261.png 588w, uploads/2014/02/estrutura-e-instalacao-400x177.png 400w, uploads/2014/02/estrutura-e-instalacao.png 1275w&#34; sizes=&#34;(max-width: 660px) 100vw, 660px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Perceba que na pasta em que encontra-se sua aplicação agora existem a pasta &lt;em&gt;vendor&lt;/em&gt;, um arquivo _composer.phar_ (que já encontrava-se ali), um arquivo _composer.json_ (que já encontrava-se ali) e um arquivo _composer.lock_ – que é o arquivo gerado automaticamente após a instalação com sucesso.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-41194&#34; alt=&#34;Estrutura de arquivos após a instalação via composer&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/estrutura-arquivos.png&#34; width=&#34;682&#34; height=&#34;333&#34; srcset=&#34;uploads/2014/02/estrutura-arquivos.png 682w, uploads/2014/02/estrutura-arquivos-329x160.png 329w, uploads/2014/02/estrutura-arquivos-588x287.png 588w, uploads/2014/02/estrutura-arquivos-634x310.png 634w, uploads/2014/02/estrutura-arquivos-400x195.png 400w&#34; sizes=&#34;(max-width: 682px) 100vw, 682px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;o-próximo-passo-mais-um&#34;&gt;O próximo passo (mais um)&lt;/h2&gt;

&lt;p&gt;Agora já temos tudo. O composer gerenciando as dependências, as dependências definidas em nosso arquivo composer.json, e uma pasta contendo todas as dependências necessárias juntamente com o autoloader do composer que encarrega-se de registar todos os namespaces dos arquivos baixados na pasta &lt;em&gt;vendor&lt;/em&gt;. Com isso basta utilizarmos.&lt;/p&gt;

&lt;p&gt;Crie um arquivo chamado index.php e inclua o autoloader do composer conforme o exemplo abaixo.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-php&#34;&gt;&amp;lt;?php
header(&#39;Content-Type: text/html; charset=utf-8&#39;);

require &#39;vendor/autoload.php&#39;;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Importante que esteja definido que o conteúdo será exibido utilizando a codificação UTF-8 pois problemas podem ocorrer no tratamento de caracteres especiais como acentuações.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Com isso em mãos, basta apenas utlizarmos nosso slug.php.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-php&#34;&gt;$slugifier = new \Slug\Slugifier();

// Definindo tratamento de caracteres com acentuação
$slugifier-&amp;gt;setTransliterate(true); 

$frase = &#39;Frase com acentuação para teste de criação de slug&#39;;

$slug = $slugifier-&amp;gt;slugify($frase);

echo &#39;&amp;lt;b&amp;gt;Frase natural: &amp;lt;/b&amp;gt;&#39; . $frase . &#34;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&#34;;
echo &#39;&amp;lt;b&amp;gt;Frase com aplicação de slug: &amp;lt;/b&amp;gt;&#39; . $slug . &#34;&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;&#34;;&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Perfeito, agora basta exibir no seu browser ou mesmo via terminal.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-41196&#34; alt=&#34;Slug rodando no terminal&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/slug-terminal.png&#34; width=&#34;816&#34; height=&#34;424&#34; srcset=&#34;uploads/2014/02/slug-terminal.png 816w, uploads/2014/02/slug-terminal-323x168.png 323w, uploads/2014/02/slug-terminal-588x305.png 588w, uploads/2014/02/slug-terminal-596x310.png 596w, uploads/2014/02/slug-terminal-400x207.png 400w&#34; sizes=&#34;(max-width: 816px) 100vw, 816px&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Acessando nosso localhost através de um browser o resultado será este&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;aligncenter size-full wp-image-41195&#34; alt=&#34;Slug rodando no navegador&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/02/slug-browser.png&#34; width=&#34;621&#34; height=&#34;353&#34; srcset=&#34;uploads/2014/02/slug-browser.png 621w, uploads/2014/02/slug-browser-295x168.png 295w, uploads/2014/02/slug-browser-545x310.png 545w, uploads/2014/02/slug-browser-400x227.png 400w&#34; sizes=&#34;(max-width: 621px) 100vw, 621px&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;complementando&#34;&gt;Complementando&lt;/h2&gt;

&lt;p&gt;O comando &lt;strong&gt;php composer.phar install&lt;/strong&gt; é utilizado somente uma vez em seu repositório. Para qualquer alteração do _composer.json_ que caracteriza-se como uma nova dependência ou remoção de uma existente deve ser utilizado o comando &lt;strong&gt;php composer.phar update&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;O composer ainda possui um self-update em que baixa a sua última versão. Normalmente ao rodar qualquer comando você verá uma mensagem dizendo que a sua versão do composer precisa ser atualizada. Para isto basta o comando &lt;strong&gt;php composer.phar self-update&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;O composer está se tornando a cada dia mais utilizado entre desenvolvedores e vale muito a pena se aprofundar no assunto.&lt;/p&gt;

&lt;p&gt;O código-fonte deste exemplo está no github para eventuais consultas &lt;a title=&#34;Código-fonte do projeto criado para este post&#34; href=&#34;https://github.com/andrebian/posts/blob/master/tableless/tableless-composer-para-iniciantes/sources/sources.zip&#34; target=&#34;_blank&#34;&gt;neste link&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHPUnit, como iniciar sem dores</title>
      <link>https://tableless.github.io/hugo-public/phpunit-como-iniciar-sem-dores/</link>
      <pubDate>Tue, 07 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/phpunit-como-iniciar-sem-dores/</guid>
      <description>

&lt;p&gt;Como já mencionei em um artigo anterior, o &lt;a title=&#34;Ir ao repositório do PHPUnit&#34; href=&#34;https://github.com/sebastianbergmann/phpunit/&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt; é um framework de testes unitários para a linguagem PHP. Ele provê um ecossistema para a execução de testes de forma automatizada.&lt;/p&gt;

&lt;p&gt;Neste artigo veremos a sua instalação utilizando o gerenciador de pacotes &lt;a title=&#34;Ir à página oficial do Composer&#34; href=&#34;http://getcomposer.org/&#34; target=&#34;_blank&#34;&gt;composer&lt;/a&gt;, configuração e estrutura de pastas e alguns testes simples sem persistência de dados.&lt;/p&gt;

&lt;h2 id=&#34;instalando-o-phpunit&#34;&gt;Instalando o PHPUnit&lt;/h2&gt;

&lt;p&gt;Para iniciar a instalação do PHPUnit precisamos primeiramente de um diretório que será nosso diretório de trabalho neste exemplo. Após criado o diretório é necessário criar um arquivo chamado &lt;a title=&#34;Ir ao modelo do arquivo composer.json&#34; href=&#34;http://getcomposer.org/doc/04-schema.md&#34; target=&#34;_blank&#34;&gt;&lt;i&gt;composer&lt;/i&gt;&lt;i&gt;.json&lt;/i&gt;&lt;/a&gt; para que seja definida a necessidade do PHP Unit no projeto. O arquivo _composer_&lt;em&gt;.json&lt;/em&gt; é responsável por declarar todas as bibliotecas que serão necessárias para o projeto em questão, em suma todas soluções de terceiros, incluindo suas soluções genéricas que encontrem-se no &lt;a title=&#34;Ir ao Packagist, repositório do composer&#34; href=&#34;https://packagist.org/&#34; target=&#34;_blank&#34;&gt;repositório do composer&lt;/a&gt; serão gerenciadas conforme a especificação do arquivo &lt;em&gt;composer.json.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;O arquivo para este artigo deverá conter o seguinte conteúdo:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;require-dev&#34;: {
        &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;Isto quer dizer que estamos registrando como uma dependência de nosso projeto o PHPUnit em sua versão 3.7 sempre solicitando a última atualização. Para que sempre seja utilizada a última versão do PHPUnit basta remover a sequência &amp;#8220;3.7.*&amp;#8221; por simplesmente &amp;#8220;*&amp;#8221;. O mesmo é possível com qualquer biblioteca gerenciada pelo composer.&lt;/p&gt;

&lt;p&gt;Agora já estão prontas as declarações de nossas dependências basta baixar o gerenciador de dependência &lt;a title=&#34;Baixar o composer&#34; href=&#34;http://getcomposer.org/download/&#34; target=&#34;_blank&#34;&gt;composer&lt;/a&gt; e rodar o comando&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;php composer.phar install.&lt;/pre&gt;

&lt;p&gt;Isto irá de maneira automática baixar todas as dependências que foram especificadas no arquivo composer.json, e neste exemplo trata-se apenas do PHPUnit no entanto o próprio PHP Unit requer algumas bibliotecas de terceiros então outras bibliotecas estarão disponíveis além do mesmo dentro da pasta &lt;em&gt;vendor&lt;/em&gt; que será criada.&lt;/p&gt;

&lt;div id=&#34;attachment_40041&#34; style=&#34;width: 407px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40041 &#34; alt=&#34;PHPUnit - Instalação a partir do composer&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/01-composer-install-397x310.png&#34; width=&#34;397&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/01-composer-install-397x310.png 397w, uploads/2013/12/01-composer-install-215x168.png 215w, uploads/2013/12/01-composer-install.png 881w&#34; sizes=&#34;(max-width: 397px) 100vw, 397px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Instalação a partir do composer
  &lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;attachment_40049&#34; style=&#34;width: 394px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40049 &#34; alt=&#34;PHPUnit - Estrutura de pastas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/02-estrutura-pastas-384x310.png&#34; width=&#34;384&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/02-estrutura-pastas-384x310.png 384w, uploads/2013/12/02-estrutura-pastas-208x168.png 208w, uploads/2013/12/02-estrutura-pastas.png 784w&#34; sizes=&#34;(max-width: 384px) 100vw, 384px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Estrutura de pastas
  &lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;Existe uma convenção de padrões definidos pela &lt;a title=&#34;Ir à página do Framework Interop Group&#34; href=&#34;http://www.php-fig.org/&#34; target=&#34;_blank&#34;&gt;FIG&lt;/a&gt; chamada &lt;a title=&#34;Ver todas as PSRs&#34; href=&#34;https://github.com/php-fig/fig-standards/tree/master/accepted&#34; target=&#34;_blank&#34;&gt;PSR (Proposal Standards Recommendation)&lt;/a&gt;. Para facilitar será utilizada a definição do Autoloader para o exemplo que está descrito na PSR-0. Após a correta instalação via composer devem ser criadas os diretórios &lt;em&gt;src&lt;/em&gt; e dentro dele &lt;em&gt;Application&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Com a definição do Autoloader a nova estrutura do composer é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-json&#34;&gt;{
    &#34;autoload&#34;: {
        &#34;psr-0&#34;: {&#34;Application\\&#34;: &#34;src/&#34;}
    },
    &#34;require-dev&#34;: {
        &#34;phpunit/phpunit&#34;: &#34;3.7.*&#34;
    }
}&lt;/pre&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;No arquivo composer.json agora é dito que o autoloader deve reconhecer o namespace &amp;#8220;Application&amp;#8221; que encontra-se dentro do diretorio &lt;em&gt;src&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div id=&#34;attachment_40044&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40044 &#34; alt=&#34;PHPUnit - Nova estrutura de pastas&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/4-nova-estrutura-pastas-588x303.png&#34; width=&#34;588&#34; height=&#34;303&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Nova estrutura de pastas
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;iniciando-com-um-simples-teste&#34;&gt;Iniciando com um simples teste&lt;/h2&gt;

&lt;p&gt;Como o PHPUnit já está instalado corretamente no projeto agora vem a parte legal que é criar pequenos testes (unitários, obviamente) e colocar em prática o vermelho-verde-refatora já mencionado no meu post anterior &lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar&#34; title=&#34;Ler mais sobre TDD&#34;&gt;TDD, por que usar?&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Primeiramente deve ser criada a pasta &lt;em&gt;tests&lt;/em&gt; que servirá para acomodar todos os casos de teste a serem executados.&lt;/p&gt;

&lt;p&gt;Começando com um teste simples, e na verdade este artigo somente mostrará o uso simplificado pois a finalidade do mesmo é apenas mostrar o caminho das pedras, como começar, instalar, configurar e rodar os primeiros testes. A partir daí cabe à necessidade de cada desenvolvedor.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Aqui será criado um arquivo PHPNativeElements onde serão testados algumas funções nativas do PHP e seus comportamentos. Obviamente que este caso de teste calha somente em modo didático pois tais testes e classe testada terá muito mais de uma única responsabilidade, é somente em caráter demonstrativo.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Criado o arquivo _PHPNativeElementsTest.php_ dentro do diretório tests, siga o exemplo abaixo.&lt;/p&gt;

&lt;div id=&#34;attachment_40045&#34; style=&#34;width: 383px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40045  &#34; alt=&#34;PHPUnit - Estrutura inicial do primeiro teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/5-estrutura-primeiro-teste-373x310.png&#34; width=&#34;373&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/5-estrutura-primeiro-teste-373x310.png 373w, uploads/2013/12/5-estrutura-primeiro-teste-202x168.png 202w, uploads/2013/12/5-estrutura-primeiro-teste.png 738w&#34; sizes=&#34;(max-width: 373px) 100vw, 373px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Estrutura inicial do primeiro teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt; Para que seja reconhecido como um teste o arquivo deve conter a sufixo Test.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;executando-de-forma-simples&#34;&gt;Executando de forma simples&lt;/h2&gt;

&lt;p&gt;Como o PHPUnit foi instalado a partir do composer, é a partir da estrutura montada pelo mesmo que este será executado digitando no terminal&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;./vendor/bin/phpunit&lt;/pre&gt;

&lt;p&gt;Com isto uma tela de ajuda deve aparecer com todas as opções disponíveis para a utilização do PHPUnit. Seguem as definições do comando que será executado neste primeiro momento.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #000080&#34;&gt;./vendor/bin/phpunit&lt;/span&gt; &lt;span style=&#34;color: #333333&#34;&gt;&amp;#8211;colors&lt;/span&gt; &lt;span style=&#34;color: #008000&#34;&gt;&amp;#8211;debug&lt;/span&gt; &lt;span style=&#34;color: #800000&#34;&gt;tests/PHPNativeElements &lt;/span&gt;onde:&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #000080&#34;&gt;./vendor/bin/phpunit&lt;/span&gt;: o próprio executável do PHPUnit&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #333333&#34;&gt;&amp;#8211;colors&lt;/span&gt;: habilita coloração ( assim podemos ver os estágios vermelho-verde de forma mais simples)&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #008000&#34;&gt;&amp;#8211;debug&lt;/span&gt;: habilita o modo debug para detalhamento das ações que estão sendo tomadas durante os testes – Esta ação serve como ótima documentação como já mencionado em meu artigo anterior.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;color: #800000&#34;&gt;tests/PHPNativeElements&lt;/span&gt;: o nome da classe de testes a ser testada.&lt;/p&gt;

&lt;p&gt;Ao rodarmos o comando acima a mensagem resultante deverá ser a de que não há testes disponíveis na classe testada.&lt;/p&gt;

&lt;div id=&#34;attachment_40050&#34; style=&#34;width: 484px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40050  &#34; alt=&#34;PHPUnit - Falta de testes&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/6-falta-de-testes-474x310.png&#34; width=&#34;474&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/6-falta-de-testes-474x310.png 474w, uploads/2013/12/6-falta-de-testes-256x168.png 256w, uploads/2013/12/6-falta-de-testes.png 881w&#34; sizes=&#34;(max-width: 474px) 100vw, 474px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Informação de que ainda não há testes
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;fazendo-o-primeiro-teste-passar&#34;&gt;Fazendo o primeiro teste passar&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;O TDD define que o desenvolvimento deve ser orientado a testes, com isso, criaremos primeiramente a expectativa na nossa classe de testes e em seguida a implementação no código de produção.&lt;/p&gt;

&lt;p&gt;Após o método &lt;em&gt;tearDown&lt;/em&gt; que já encontra-se na classe &lt;em&gt;PHPNativeElementsTest&lt;/em&gt; crie um método chamado &lt;em&gt;testOperacaoMatematica&lt;/em&gt;. Assim como a classe de teste possui uma convenção com os métodos também é necessário especificar qual trata-se de um teste a partir do prefixo &lt;em&gt;test.&lt;/em&gt; Por este motivo nosso primeiro caso de teste se chamar testOperacaoMatematica. Caso não contenha o prefixo test e, não sendo os métodos setUp e tearDown, o PHPUnit simplesmente não executa o método.&lt;/p&gt;

&lt;p&gt;Como estamos utilizando o Autoloader, em nossa classe de teste usaremos o namespace &amp;#8220;_Application_&lt;em&gt;NativeElements\Math&amp;#8221;&lt;/em&gt; para carregar a nossa classe que será testada a partir da classe de testes. Como atributo de nossa classe de teste adicionaremos &amp;#8220;$math&amp;#8221; e nele instanciaremos a classe _Application_&lt;em&gt;NativeElements\Math&lt;/em&gt; dentro do método &lt;em&gt;setUp&lt;/em&gt;.&lt;/p&gt;

&lt;div id=&#34;attachment_40052&#34; style=&#34;width: 434px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40052 &#34; alt=&#34;PHPUnit - Nova estrutura da classe de teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/7-nova-estrutura-classe-de-testes1-424x310.png&#34; width=&#34;424&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/7-nova-estrutura-classe-de-testes1-424x310.png 424w, uploads/2013/12/7-nova-estrutura-classe-de-testes1-230x168.png 230w, uploads/2013/12/7-nova-estrutura-classe-de-testes1.png 804w&#34; sizes=&#34;(max-width: 424px) 100vw, 424px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Nova estrutura da classe de teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Ao rodarmos novamente o PHPUnit o teste simplesmente quebra. Isto porque a classe&lt;/p&gt;

&lt;p&gt;_Application_&lt;em&gt;NativeElements\Math&lt;/em&gt; ainda não existe. Este é o próximo passo, o código que fará o testes passar.&lt;/p&gt;

&lt;div id=&#34;attachment_40053&#34; style=&#34;width: 498px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40053 &#34; alt=&#34;PHPUnit - Quebra do teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/8-quebra-do-teste-488x310.png&#34; width=&#34;488&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/8-quebra-do-teste-488x310.png 488w, uploads/2013/12/8-quebra-do-teste-264x168.png 264w, uploads/2013/12/8-quebra-do-teste.png 875w&#34; sizes=&#34;(max-width: 488px) 100vw, 488px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Quebra do teste por não existir a classe testada
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Criamos o arquivo&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Math.php&lt;/em&gt; dentro do diretório &lt;em&gt;Application/NativeElements&lt;/em&gt; e no mesmo a classe &lt;em&gt;Math&lt;/em&gt; definindo como namespace &lt;em&gt;Application\NativeElements&lt;/em&gt;. Por hora nenhum método é criado nesta nova classe.&lt;/p&gt;

&lt;div id=&#34;attachment_40056&#34; style=&#34;width: 514px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40056 &#34; alt=&#34;PHPUnit - Classe de produção, nela os problemas criados nos testes serão solucionados&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/9-class-504x310.png&#34; width=&#34;504&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/9-class-504x310.png 504w, uploads/2013/12/9-class-273x168.png 273w, uploads/2013/12/9-class.png 955w&#34; sizes=&#34;(max-width: 504px) 100vw, 504px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Classe de produção, nela os problemas criados nos testes serão solucionados
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Rodando nosso teste novamente ele quebra mais uma vez. Agora o que está faltando é o método testado (&lt;/p&gt;

&lt;p&gt;&lt;em&gt;sum&lt;/em&gt; ).&lt;/p&gt;

&lt;div id=&#34;attachment_40057&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40057 &#34; alt=&#34;PHPUnit - Faltando método sum&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/10-method-missing-588x289.png&#34; width=&#34;588&#34; height=&#34;289&#34; srcset=&#34;uploads/2013/12/10-method-missing-588x289.png 588w, uploads/2013/12/10-method-missing-329x162.png 329w, uploads/2013/12/10-method-missing-628x310.png 628w, uploads/2013/12/10-method-missing.png 880w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Faltando método sum
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Ao criar o método sum e sua lógica estando correta o teste atual passará, então passamos do estágio vermelho para o estágio verde. Como este exemplo é uma simples operação matemática muito provavelmente não será necessária uma refatoração. No entanto sendo um lógica mais complexa o ideal é que sempre comece testando pequenos passos, que são chamados de baby steps ou passos de bebê. Ao se deparar com uma situação complexa em que o resultado depende de N variáveis, trata-se sempre o meio mais simples e os testes passando passa-se a procurar solucionar uma nova condição para o resultado.&lt;/p&gt;

&lt;div id=&#34;attachment_40058&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40058 &#34; alt=&#34;PHPUnit - Método com a lógica necessária e primeiro teste passando&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/11-pass-588x262.png&#34; width=&#34;588&#34; height=&#34;262&#34; srcset=&#34;uploads/2013/12/11-pass-588x262.png 588w, uploads/2013/12/11-pass-329x146.png 329w, uploads/2013/12/11-pass-660x294.png 660w, uploads/2013/12/11-pass.png 1364w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Método com a lógica necessária e primeiro teste passando
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Agora basta adicionar os asserts para as demais operações matemáticas.&lt;/p&gt;

&lt;div id=&#34;attachment_40059&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40059 &#34; alt=&#34;PHPUnit - Outros métodos de operações matemáticas simples&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/12-other-methods-588x272.png&#34; width=&#34;588&#34; height=&#34;272&#34; srcset=&#34;uploads/2013/12/12-other-methods-588x272.png 588w, uploads/2013/12/12-other-methods-329x152.png 329w, uploads/2013/12/12-other-methods-660x305.png 660w, uploads/2013/12/12-other-methods.png 1358w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Outros métodos de operações matemáticas simples
  &lt;/p&gt;
&lt;/div&gt;

&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;

&lt;blockquote&gt;
&lt;p&gt;Como pode ser percebido, como terceiro parâmetro do assert foi adicionada uma mensagem opcional, isso para que ao dar erro da asserção tal mensagem seja exibida, conforme a imagem seguinte.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div id=&#34;attachment_40060&#34; style=&#34;width: 507px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40060 &#34; alt=&#34;PHPUnit - Mensagem de erro de asserção&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/13-message-497x310.png&#34; width=&#34;497&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/13-message-497x310.png 497w, uploads/2013/12/13-message-269x168.png 269w, uploads/2013/12/13-message.png 809w&#34; sizes=&#34;(max-width: 497px) 100vw, 497px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Mensagem de erro de asserção
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2 id=&#34;refatorando&#34;&gt;Refatorando&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Agora voltando ao código originado na classe&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Math&lt;/em&gt;, dá pra perceber que há muita repetição pois todos os métodos recebem dois valores e retornam uma operação correspondente. Como utilizando TDD temos segurança em desenvolver, podemos tranquilamente remover tais repetições criando uma interface onde é previamente definida a operação a ser realizada e retorna o resultado desta operação. Obviamente com esta atitude o teste também sofrerá alterações e isso é algo comum pois uma aplicação está sempre evoluindo.&lt;/p&gt;

&lt;p&gt;Frenta à necessidade de refatoração novamente começamos a partir do teste e ele fica como na imagem a seguir:&lt;/p&gt;

&lt;div id=&#34;attachment_40061&#34; style=&#34;width: 498px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40061 &#34; alt=&#34;PHPUnit - Alterações na classe de teste&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/14-test-refactor-488x310.png&#34; width=&#34;488&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/14-test-refactor-488x310.png 488w, uploads/2013/12/14-test-refactor-264x168.png 264w, uploads/2013/12/14-test-refactor.png 899w&#34; sizes=&#34;(max-width: 488px) 100vw, 488px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Alterações na classe de teste
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Com a refatoração nossa classe Math é modificada e criada uma interface:&lt;/p&gt;

&lt;div id=&#34;attachment_40063&#34; style=&#34;width: 598px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40063 &#34; alt=&#34;PHPUnit - refatoração da classe Math&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/15-refactor-588x284.png&#34; width=&#34;588&#34; height=&#34;284&#34; srcset=&#34;uploads/2013/12/15-refactor-588x284.png 588w, uploads/2013/12/15-refactor-329x159.png 329w, uploads/2013/12/15-refactor-640x310.png 640w, uploads/2013/12/15-refactor.png 1354w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Refatoração da classe Math
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;E agora rodando novamente o teste após a refatoração, simplesmente continuamos com tudo verde, ou seja, alteramos muito a forma de implementação de uma classe e ela continua executando seu papel como deve.&lt;/p&gt;

&lt;div id=&#34;attachment_40064&#34; style=&#34;width: 587px&#34; class=&#34;wp-caption aligncenter&#34;&gt;
  &lt;img class=&#34;size-medium wp-image-40064 &#34; alt=&#34;PHPUnit - Teste passando após refatoração&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2013/12/16-refactor-pass-577x310.png&#34; width=&#34;577&#34; height=&#34;310&#34; srcset=&#34;uploads/2013/12/16-refactor-pass-577x310.png 577w, uploads/2013/12/16-refactor-pass-313x168.png 313w, uploads/2013/12/16-refactor-pass.png 818w&#34; sizes=&#34;(max-width: 577px) 100vw, 577px&#34; /&gt;
  
  &lt;p class=&#34;wp-caption-text&#34;&gt;
    Teste passando após refatoração
  &lt;/p&gt;
&lt;/div&gt;

&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;

&lt;blockquote&gt;
&lt;p&gt;Este é apenas um exemplo didático de refatoração, mas mesmo com ele dá pra perceber como houve a anulação de código repetido e para um futura manutenção basta que mexa-se em um local somente para que surta efeitos à todas as operações matemáticas.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;finalizando&#34;&gt;Finalizando&lt;/h2&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Neste artigo foi abordado apenas a instalação do PHPUnit e a execução de um teste muito simples. Para testes mais avançados serão criados novos artigos sempre em sequência para que o estudo de desenvolvimento orientado a testes siga um fluxo sadio. Já fora criado um artigo explicando os por ques de se utilizar e não se utilizar TDD que encontra-se neste&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/tdd-por-que-usar&#34; title=&#34;Ler mais sobre TDD&#34;&gt;link&lt;/a&gt; e é o primeiro artigo da sequência.&lt;/p&gt;

&lt;p&gt;&lt;!-- P { margin-bottom: 0.08in; }A:link {  } --&gt;Os próximos artigos seguirão a sequência abaixo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configurações avançadas – Apenas uma breve abordagem de como realizar configurações avançadas na execução do PHPUnit gerando reports como coverage.&lt;/li&gt;
&lt;li&gt;Persistência – Será utilizado o ORM Doctrine para complementarmos o projeto&lt;/li&gt;
&lt;li&gt;Mockery – Utilizando objetos simulados para atender certos comportamentos&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Você pode baixar o código-fonte dos exemplos apresentados aqui no &lt;a title=&#34;Ir para o repositório de exemplos desenvolvidos neste artigo&#34; href=&#34;https://github.com/andrebian/phpunit-como-iniciar-sem-dores&#34; target=&#34;_blank&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TDD, por que usar?</title>
      <link>https://tableless.github.io/hugo-public/tdd-por-que-usar/</link>
      <pubDate>Tue, 17 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/tdd-por-que-usar/</guid>
      <description>

&lt;p&gt;TDD é o desenvolvimento de software orientado a testes, ou em inglês, &lt;a title=&#34;Test Driven Development&#34; href=&#34;http://pt.wikipedia.org/wiki/Test_Driven_Development&#34; target=&#34;_blank&#34;&gt;Test Driven Development&lt;/a&gt;. Mas mais do que simplesmente testar seu código, TDD é uma filosofia, uma cultura. Neste artigo você conhecerá um pouco sobre sua motivação e também saberá os fatores que contribuem e dificultam sua prática.&lt;/p&gt;

&lt;h2 id=&#34;por-que-muitos-não-praticam&#34;&gt;Por que muitos não praticam?&lt;/h2&gt;

&lt;p&gt;Muitos fatores contribuem para que inúmeros programadores deixem de utilizar TDD logo no início. Alguns deles são:&lt;/p&gt;

&lt;h3 id=&#34;dificuldade-em-começar&#34;&gt;Dificuldade em começar&lt;/h3&gt;

&lt;p&gt;Apesar de uma extensa e clara documentação, iniciar o desenvolvimento orientado a testes pode ser um trabalho árduo para muitos pelo simples fato de que geralmente muitos iniciantes tentam praticá-lo em código já existente. Este definitivamente não é o caminho. A principal característica do desenvolvimento orientado a testes é que ele seja orientado a testes. Em outras palavras o código que realizará sua lógica deve ser criado somente após a criação do teste e isso torna-se algo de difícil aceitação pois ainda não se tem nada e já se faz necessário testar.&lt;/p&gt;

&lt;h3 id=&#34;curva-de-apendizado&#34;&gt;Curva de apendizado&lt;/h3&gt;

&lt;p&gt;Complementando o item anterior, este é outro motivo que faz programadores desistirem do desenvolvimento orientado a testes. Como qualquer nova tecnologia, para a pratica de TDD leva-se um bom tempo dependendo disponibilidade e principalmente da vontade do programador.&lt;/p&gt;

&lt;p&gt;Tempo&lt;/p&gt;

&lt;p&gt;Engana-se quem pensa que produzirá mais código pelo simples fato de utilizar TDD. O TDD na verdade chega a desacelerar a produção de código. Quando falo em produção de código, me refiro à quantidade de linhas escritas. Mas nisso tudo há vantagens e elas serão descritas mais a frente.&lt;/p&gt;

&lt;h3 id=&#34;cultura&#34;&gt;Cultura&lt;/h3&gt;

&lt;p&gt;Muito fala-se de TDD no Brasil, mas ao questionarmos programadores de diversas empresas muitos apresentam os motivos citados acima para não utilizá-lo. Existem sim muitas empresas e programadores que levam a prática a sério e a evangelizam justamente por conhecerem as vantagens que o TDD nos traz.&lt;/p&gt;

&lt;h2 id=&#34;nem-tudo-é-tão-ruim&#34;&gt;Nem tudo é tão ruim&lt;/h2&gt;

&lt;p&gt;Vistos alguns pontos que dificultam programadores a aderirem ao TDD, listamos agora alguns benefícios que esta prática nos fornece.&lt;/p&gt;

&lt;h3 id=&#34;qualidade-do-código&#34;&gt;Qualidade do código&lt;/h3&gt;

&lt;p&gt;Um dos principais ensinamentos, senão o principal, do TDD é que se algo não é possível de ser testado então foi desenvolvido de forma errada. Parece um pouco drástico mas não é. Em pouco tempo utilizando testes o programador percebe mudanças relevantes em sua forma de programar. Em suma o uso de TDD ajuda o programador a elaborar um código com cada vez mais qualidade criando objetos concisos e com menos dependências.&lt;/p&gt;

&lt;h3 id=&#34;raciocínio&#34;&gt;Raciocínio&lt;/h3&gt;

&lt;p&gt;Para que o código torne-se mais conciso, tenha menos acoplamentos e dependências o programador deve forçar seu raciocínio a níveis elevados. É muito difícil criar algo que realmente tenha um bom design. Utilizando TDD o programador praticamente obriga-se a olhar seu código de outra forma normalmente jamais vista antes. Aí é que está a parte legal da coisa toda.&lt;/p&gt;

&lt;h3 id=&#34;segurança&#34;&gt;Segurança&lt;/h3&gt;

&lt;p&gt;Ponto importantíssimo para qualquer software nos dias de hoje. Mas não se engane, não estou falando de segurança da informação e sim de segurança ao desenvolver. Pense em uma situação em que o programador tenha um código que desenvolvera ha cerca de um ano. Como normalmente vivemos em um mundo com inúmeros softwares desenvolvidos ao longo de cada ano, torna-se muito difícil lembrar de tudo a respeito de um que merece nossa atenção em determinado momento. Normalmente deve-se realizar um trabalho bastante cauteloso para nova implementação em um software que encontra-se em produção. Toda e qualquer alteração deve ser minunciosamente testada e garantida que não afetará demais módulos do software. Fazer isto manualmente é realmente complicado pois até então não sabe-se (ou lembra-se) ao certo quem afeta quem no sistema. Com a prática de TDD cada pequeno passo do software está devidamente testado. Ou seja, com este cenário o programador pode realizar qualquer alteração sem medo e sem culpa.&lt;/p&gt;

&lt;p&gt;Como cada pequeno passo tomado pelo sistema está testado ao qualquer módulo ou funcionalidade sofrer alteração, com poucos segundos descobre-se se houveram quebras e o melhor de tudo, onde foram essas quebras. Com isso em mãos a correção das quebras torna-se uma tarefa simples sem frustrar o cliente e o usuário.&lt;/p&gt;

&lt;h3 id=&#34;trabalho-em-equipe&#34;&gt;Trabalho em equipe&lt;/h3&gt;

&lt;p&gt;Por prover mais segurança o trabalho em equipe torna-se muito mais proveitoso eliminando discussões e dúvidas desnecessárias. Ao entrar no desenvolvimento do projeto o novo desenvolvedor tem apenas o trabalho de entender qual task deve ser realizada e ler os testes das features já desenvolvidas. Ao rodar os testes pela primeira vez o programador descobre se está no caminho de ter um entregável mais rapidamente e com segurança. Existem empresas em que um novo programador tem entregáveis logo no primeiro dia de trabalho. Sem testes normalmente haveria um período de adaptação para prévio entendimento do que há no sistema no momento de seu ingresso ao time de desenvolvimento.&lt;/p&gt;

&lt;h3 id=&#34;documentação&#34;&gt;Documentação&lt;/h3&gt;

&lt;p&gt;Ao criar testes descritivos estes servem como uma excelente documentação para o software. Quando qualquer programador for rodar os testes, basta habilitar o modo verbose que uma “história” é contada eliminando o árduo trabalho de documentar um software onde nos meios tradicionais tende a defasar-se. O problema é que a documentação tradicional raramente segue o mesmo ritmo do desenvolvimento. Com os testes unitários a “documentação” é gerada antes mesmo da nova feature ser implementada e permanece fiel a qualquer alteração.&lt;/p&gt;

&lt;h2 id=&#34;o-que-resume-se-disto-tudo&#34;&gt;O que resume-se disto tudo?&lt;/h2&gt;

&lt;p&gt;Até aqui temos os pontos negativos e positivos do desenvolvimento orientado a testes. Agora vamos aprender um pouco sobre o que é TDD.&lt;/p&gt;

&lt;p&gt;O TDD (Test Driven Development) baseia-se em três passos, vermelho-verde-refatora. O vermelho é a escrita do primeiro teste antes mesmo da lógica existir. O verde é o ponto em que a lógica para que o teste previamente criado passe. Esta lógica deve ser desenvolvida da forma mais simples possível eliminando complexidades desnecessárias fazendo com que a evolução do código ocorra de forma segura. O refatora é a melhoria do código. Neste ponto são removidas duplicações, múltiplas responsabilidades e o código fica cada vez mais próximo de sua versão final.&lt;/p&gt;

&lt;p&gt;Para que o processo vermelho-verde-refatora seja de fato implementado, utiliza-se baby steps ou passos de bebê. Esta técnica consiste em realizar um pequeno passo de cada vez, se uma lógica é complexa de ser desenvolvida ela é dividida em muitas pequenas partes que evoluem até sua solução final. Obviamente que esta técnica é aplicável preferencialmente em processos complexos que dependem de muitas variáveis. Para processos simples nem sempre é a mais indicada.&lt;/p&gt;

&lt;p&gt;Os testes devem ser unitários. Isto implica em um teste automatizado certificar-se de apenas uma funcionalidade do código utilizando para isso quantos asserts forem necessários. Por serem testes automatizados são fácil e rapidamente executados eliminando testes manuais que encarecem o software em vários aspectos. Devido à dinâmica de tais testes é possível vincular o software com ferramentas de integração contínua como Jenkins reduzindo ainda mais o custo (tempo de desenvolvimento) do mesmo.&lt;/p&gt;

&lt;p&gt;Concluindo&lt;/p&gt;

&lt;p&gt;Como ficou claro a prática do desenvolvimento orientado a testes pode ser penosa para quem está começando mas muito satisfatória para quem já a tem como parte de seu dia a dia. Ao utilizar TDD o programador “perde” em linhas de código por hora mas ganha horas, dias, quem sabe até semanas na prevenção de novos erros e correção dos que ocorrem durante a implementação de uma nova feature. Detalhe que o método TDD parte do princípio que o teste sempre deve ser implementado antes do código de produção.&lt;/p&gt;

&lt;p&gt;Em suma tudo vai depender to porte do projeto em que se está trabalhando, da cultura da empresa e da vontade de programadores mas sabe-se que quem utiliza TDD reconhece suas vantagens.&lt;/p&gt;

&lt;p&gt;Agora que você já tem uma noção do que é TDD, suas vantagens e desvantagens, sugiro a ler sobre &lt;a title=&#34;xUnit - Framework de testes unitários&#34; href=&#34;http://www.martinfowler.com/bliki/Xunit.html&#34; target=&#34;_blank&#34;&gt;xUnit&lt;/a&gt;. O xUnit é um framework de testes disponível para várias linguagens de programação. Em PHP temos o &lt;a title=&#34;PHPUnit - Framework de testes unitários para PHP&#34; href=&#34;http://phpunit.de/manual/3.7/pt_br/automating-tests.html&#34; target=&#34;_blank&#34;&gt;PHPUnit&lt;/a&gt;, em java o &lt;a title=&#34;jUnit - Framework de testes unitários para Java&#34; href=&#34;http://junit.org/&#34; target=&#34;_blank&#34;&gt;jUnit&lt;/a&gt; e demais linguagens possuem seus frameworks que tem a mesma finalidade, criar um ecossistema para que o programador desenvolva orientando-se a testes.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>