<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bruno Ruiz on Tableless</title>
    <link>http://tableless.com.br/author/bruno-ruiz/index.xml</link>
    <description>Recent content in Bruno Ruiz on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="http://tableless.com.br/author/bruno-ruiz/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Workflow Front-end</title>
      <link>http://tableless.com.br/workflow-front-end/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/workflow-front-end/</guid>
      <description>

&lt;p&gt;O desenvolvimento em html, javascript e CSS é uma forma mágica de se construir um mundo novo a cada linha de código. Os mágicos do front-end precisam de cartolas para que retirem seus coelhos. Essas cartolas e varinhas mágicas devem ser escolhidas a dedo, para que a mágica aconteça de forma suave e agradável à plateia.&lt;/p&gt;

&lt;p&gt;Cada mágico tem sua técnica, portanto o objetivo não é estabelecer um padrão imutável, mas estabelecer diretrizes que possam servir de auxílio a qualquer ilusionista. Vamos entender magia.&lt;/p&gt;

&lt;h2 id=&#34;baralho&#34;&gt;Baralho&lt;/h2&gt;

&lt;p&gt;Todo mágico possui um baralho. Com ele é possível fazer um número imenso de ilusões. Tão versátil quanto um baralho, deve ser o editor de texto a ser usado pelo desenvolvedor.&lt;/p&gt;

&lt;p&gt;Vamos falar de dois editores: Edge Code e Sublime Text.&lt;/p&gt;

&lt;p&gt;O Edge Code tem como objetivo permitir o foco no trabalho, para isso ele tem uma interface propositalmente simples. Uma mágica que adoro nele é poder editar conteúdo de um arquivo por meio de outro com base em uma relação específica – ou seja, tenho no arquivo html uma marcação que faz referência a uma classe CSS, clicando com o botão direito nessa classe e selecionando quick edit podemos editar o CSS do arquivo externo com base no arquivo html. Esse baralho tem muito mais mágicas.&lt;/p&gt;

&lt;p&gt;O Sublime Text tem tantos recursos que possibilitam uma produtividade imensa. Quando você acessa &lt;a href=&#34;http://www.sublimetext.com/&#34;&gt;http://www.sublimetext.com/&lt;/a&gt;, nota-se o foco em mostrar o quão produtivo o Sublime Text é. Uma mágica de produtividade é a possibilidade de selecionar um texto que se repete em um arquivo html por meio da tecla de atalho Ctrl+d e alterar todos ao mesmo tempo. Adoro isso.&lt;/p&gt;

&lt;h2 id=&#34;cartola&#34;&gt;Cartola&lt;/h2&gt;

&lt;p&gt;O NodeJS permite que mágicas que eram feitas somente no palco – navegador –, possam ser feitas atrás das cortinas – servidor. No entanto essas mágicas são cada vez mais complexas, gerando uma dependência de recursos que necessitariam de outra ferramenta mágica para gerenciá-las.&lt;/p&gt;

&lt;p&gt;Essa outra ferramenta mágica é nossa cartola. Dela tiramos tudo que é necessário para fazermos o show. Duas cartolas não podem deixar de serem conhecidas: NPM e Bower.&lt;/p&gt;

&lt;p&gt;O NPM é o que todo gerenciador de dependências precisa ser: instalador de pacotes, gerenciador de versão e gerenciador de dependências.&lt;/p&gt;

&lt;p&gt;O Bower é o que o NPM é, mas para componentes front-end.&lt;/p&gt;

&lt;p&gt;Se este é o cenário, então é bom termos duas cartolas, cada uma fazendo seu tipo de mágica: NPM no desenvolvimento com Grunt, Gulp, JSHint, etc; e Bower para componentes front-end.&lt;/p&gt;

&lt;h2 id=&#34;assistentes&#34;&gt;Assistentes&lt;/h2&gt;

&lt;p&gt;Assistentes de palco são vitais no contexto de muitas mágicas. Além de distrair quem vê o espetáculo, elas embelezam o ambiente. Elas são o CSS da ilusão.&lt;/p&gt;

&lt;p&gt;Frameworks de estilo podem agilizar muito um trabalho, porque muitas das preocupações iniciais do projeto, podem ser deixadas de lado pela adoção de um padrão, que já respondeu a todas elas. Nossas assistentes de palco são: Bootstrap e Pure.&lt;/p&gt;

&lt;p&gt;Bootstrap é de longe a ferramenta mais popular para atribuição de estilo aos projetos. Pontos positivos: variedade de componentes, utilizado por grandes empresas que contribuem com o projeto e boa documentação. Ele é a assistente que sabe como as mágicas são feitas.&lt;/p&gt;

&lt;p&gt;Pure tem como objetivo fornecer estilo totalmente independente de qualquer javascript e de uma maneira muito leve. É uma assistente magrinha que faz seu trabalho bem feito.&lt;/p&gt;

&lt;p&gt;É inquestionável que a aparência faz muita diferença.&lt;/p&gt;

&lt;h2 id=&#34;caixas-e-lâminas&#34;&gt;Caixas e lâminas&lt;/h2&gt;

&lt;p&gt;Na mágica da mulher cortada ao meio, uma mulher entra numa caixa e o mágico enfia uma lâmina no meio da caixa, e ela é separada em duas partes. As mãos, a cabeça e os pés continuam se mexendo. Quando uso pré-processadores CSS me sinto separado um corpo ao meio, mas ao mesmo tempo confiando que ele irá unir as partes e no final teremos um corpo inteiro.&lt;/p&gt;

&lt;p&gt;É claro que escrever CSS puro gerará menos código que o uso errôneo de mixins em SASS. Mas devemos medir a relação de custo e benefício em relação a produtividade (após a curva de aprendizagem ser superada) e qualidade do nosso código, para podermos escolher aquilo que é melhor para o projeto &amp;#8211; espetáculo. Nossas caixas e lâminas para separarem corpos podem ser: LESS e SASS.&lt;/p&gt;

&lt;p&gt;As características da LESS que devem ser sempre destacadas são, em sua maioria, comuns aos pré-processadores. Mas devem ser ditas aqui:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Variáveis: valores que são usados em vários lugares podem ser reutilizados por todo o estilo do projeto, e quando uma alteração for necessária, poderá ser feita com muita facilidade.&lt;/li&gt;
&lt;li&gt;Mixins: servem ao mesmo propósito das variáveis – a reutilização –, mas sendo usadas para classes completas. Podendo incluir uma classe dentro de outra classe, como se fosse uma propriedade.&lt;/li&gt;
&lt;li&gt;Aninhamento: a possibilidade de aninhar seletores dentro de outros seletores é um truque que me encanta muito. Porque ele criará os seletores longos por conta própria e você ficará com o trabalho de apenas construir a hierarquia a seletores por meio de aninhamento.&lt;/li&gt;
&lt;li&gt;Operações: executar operações com propriedades e cores por meio do CSS é tão fora de cogitação que se torna muito surpreendente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SASS faz tudo isso descrito acima, e faz antes de o LESS ter feito. Mas a consideração que deve ser feita é: LESS tem uma sintaxe mais simples, que leva a uma curva de aprendizagem menor, e quando essa curva atinge uma boa inclinação, ela é mais produtiva.&lt;/p&gt;

&lt;h2 id=&#34;automatização&#34;&gt;Automatização&lt;/h2&gt;

&lt;p&gt;Muitas coisas precisam ser feitas, que não necessariamente são observadas, mas tem valor. Isso se aplica a tudo na vida. Montar o palco para o espetáculo, preparar e limpar as ferramentas, checar se tudo está apto para funcionamento, etc. Concatenar arquivos, minificar código, realizar o deploy, etc.&lt;/p&gt;

&lt;p&gt;Estas tarefas podem continuar a serem feitas, mas sem o trabalho que normalmente se tem para as suas execuções. A ferramenta a ser usada neste caso é o Grunt.&lt;/p&gt;

&lt;p&gt;Com o Grunt você pode automatizar tarefas para serem executadas via linha de comando. Basta ter o NodeJS e configurar as tarefas a serem automatizadas.&lt;/p&gt;

&lt;h2 id=&#34;qualidade&#34;&gt;Qualidade&lt;/h2&gt;

&lt;p&gt;Uma mágica bem feita pode ser repetida diversas vezes, e ainda causará boas impressões. Isso se deve a qualidade com que a mágica foi feita. Existe a melhor maneira de executá-la, e quando isso é feito, tudo flui muito bem. Escrever códigos javascript e css com qualidade &amp;#8211; o que inclui boas práticas de sintaxe e construção – é um desafio, porque escrever sem boas práticas também funciona.&lt;/p&gt;

&lt;p&gt;Para verificar a qualidade do nosso código temos: JSLint, JSHint e CSSLint.&lt;/p&gt;

&lt;p&gt;JSLint realiza uma busca com foco em erros de sintaxe e erros estruturais.&lt;/p&gt;

&lt;p&gt;JSHint é um fork do JSLint com uma melhoria que permite customizações, ele permite flexibilidade.&lt;/p&gt;

&lt;p&gt;CSSLint tem o objetivo de verificar além da sintaxe a performance do CSS.&lt;/p&gt;

&lt;h2 id=&#34;enfim&#34;&gt;Enfim&lt;/h2&gt;

&lt;p&gt;Cada mágico tem um conjunto de mágicas que são apresentadas. Mas todos tem o mesmo objetivo: encantar. Todo desenvolvedor precisa encantar a todos para ter seu trabalho reconhecido. Essas ferramentas, e muitas outras, podem fazer a diferença. Então faça a diferença.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns em JavaScript – Observer</title>
      <link>http://tableless.com.br/design-patterns-em-javascript-observer/</link>
      <pubDate>Fri, 19 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/design-patterns-em-javascript-observer/</guid>
      <description>

&lt;h2 id=&#34;o-que-é-design-patterns&#34;&gt;O que é Design Patterns?&lt;/h2&gt;

&lt;p&gt;Desenvolver um software é se deparar constantemente com problemas. Esses problemas surgem em diversas situações e em grande quantidade. Em termos simples: nos deparamos várias vezes com um mesmo problema em diversas situações em momentos diferentes no mesmo projeto.&lt;/p&gt;

&lt;p&gt;Se os problemas são sempre os mesmos as soluções se repetem. Mas é muito comum darmos as mesmos soluções aos mesmos problemas de formas diferentes; isto porque não padronizamos soluções para problemas que sempre estamos resolvendo.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Padronizar soluções é a melhor forma de resolver problemas durante o desenvolvimento de softwares.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em linguagens orientadas a objetos temos a disposição uma série de padrões que auxiliar na criação de objetos, na forma como eles se relacionam e nos comportamentos que eles podem adotar. Em JavaScript não é diferente. Nós podemos implementar padrões com o objetivos de auxiliar o processo de desenvolvimentos nestes aspectos.&lt;/p&gt;

&lt;p&gt;Vamos falar um pouco sobre um padrão de estrutura JavaScript chamada Observer.&lt;/p&gt;

&lt;h2 id=&#34;o-que-é-o-design-pattern-observer&#34;&gt;O que é o Design Pattern Observer?&lt;/h2&gt;

&lt;p&gt;Um Observer é um padrão que possibilita a um objeto observar o estado de outro objeto, sendo notificado quando ele muda de estado. Portando, existem dois papéis neste padrão de desenvolvimento: o observador e o observado. No entanto, esta relação pode ter múltiplos objetos observadores e múltiplos observados. Uma característica deste padrão, que o torna poderoso, é o &lt;strong&gt;acoplamento fraco&lt;/strong&gt;; o objeto observado e o observador podem ter seu acoplamento desfeito em tempo de execução a qualquer momento.&lt;/p&gt;

&lt;h2 id=&#34;implementando-o-design-pattern-observer&#34;&gt;Implementando o Design Pattern Observer?&lt;/h2&gt;

&lt;p&gt;Vamos à pratica do padrão! Nós criaremos um objeto que será responsável por gerenciar o relacionamento entre os objetos observados e observadores.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var observador&lt;/pre&gt;

&lt;p&gt;O objeto &lt;code&gt;observador&lt;/code&gt; terá quatro métodos: o primeiro método é responsável pela assinatura dos objetos observadores à objetos observados. Estes são adicionados a uma lista de objetos inscritos, conforme podemos ver abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;observador = {
    adicionaInscricao: function(callback){
                 this.inscritos[this.inscritos.length] = callback;
               }
   }
&lt;/pre&gt;

&lt;p&gt;O segundo método remove a inscrição de objeto na estrutura de um observer. Esta  possibilidade torna possível, não somente a adição, mas também a remoção de uma inscrição em tempo de execução.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;observador = {
    adicionaInscricao: function(callback){
                 this.inscritos[this.inscritos.length] = callback;
               },
   removeInscricao: function(callback){
                 for (var i = 0; i &amp;lt; this.inscritos.length; i++) {
                     if (this.inscritos[i] === callback) {
                          delete(this.inscritos[i]);
                        }
                   }
              }
        }
&lt;/pre&gt;

&lt;p&gt;Devemos ter uma forma pela qual a execução dos métodos dos objetos observados possam passar pelo observador. Somente assim os objetos inscritos poderão ser avisados da execução para a qual eles estão inscritos.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;observador = {
    adicionaInscricao: function(callback){
                 this.inscritos[this.inscritos.length] = callback;
               },
   removeInscricao: function(callback){
                 for (var i = 0; i &amp;lt; this.inscritos.length; i++) {
                     if (this.inscritos[i] === callback) {
                          delete(this.inscritos[i]);
                        }
                   }
              },

    publica:function (oque) {
              for (var i = 0; i &amp;lt; this.inscritos.length; i++) {
                            if (typeof this.inscritos[i] === &#39;function&#39;) {
                                            this.inscriots[i](oque);
                             }
                        }
                 }
          }&lt;/pre&gt;

&lt;p&gt;Fazer de um objeto um observado deve  ser uma atribuição da estrutura do  nosso observador. Para isto temos o método fazObservado abaixo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;observador = {
    adicionaInscricao: function(callback){
                 this.inscritos[this.inscritos.length] = callback;
               },
   removeInscricao: function(callback){
                 for (var i = 0; i &amp;lt; this.inscritos.length; i++) {
                     if (this.inscritos[i] === callback) {
                          delete(this.inscritos[i]);
                        }
                   }
              },

    publica:function (oque) {
              for (var i = 0; i &amp;lt; this.inscritos.length; i++) {
                            if (typeof this.inscritos[i] === &#39;function&#39;) {
                                            this.inscritos[i](oque);
                             }
                        }
                 },
   fazObservado:function (o) { 
              for (var i in this) {
                  o[i] = this[i];
                  o.inscritos= [];
               }
            }
    };&lt;/pre&gt;

&lt;h2 id=&#34;como-usar-o-design-pattern-observer&#34;&gt;Como usar o Design Pattern Observer?&lt;/h2&gt;

&lt;p&gt;Ter a estrutura de observer disponibilizada em seu projeto possiblita uma orgnanização em todas as estapdas do desenvolvimento. Para termos uma idéia disto vejamos como utilizar a estrutura do observer.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var observado = {
        executa:function(){
             var conteudo = &#39;Executado em: &#39; + new Date();
                 this.publica(conteudo);
          }
   };

   observador.fazObservado(observado);

var observaObservado = {
      verifica:function(oque){
           console.log(&#34;Observou &#34;+oque)
           }
     };

    observado.adicionaInscricao(observaObservado.verifica);
    observado.executa();
&lt;/pre&gt;

&lt;p&gt;Sempre que implementamos um padrão de desenvolvimento, ganhamos produtividade, agilidade e organização. Portanto, implemente padrões e seja feliz!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>File API – Trabalhando com Arquivos Locais Usando Javascript</title>
      <link>http://tableless.com.br/file-api-trabalhando-com-arquivos-locais-usando-javascript/</link>
      <pubDate>Tue, 08 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/file-api-trabalhando-com-arquivos-locais-usando-javascript/</guid>
      <description>

&lt;p&gt;A atividade exercida localmente para a leitura de arquivos fornecidos pelo cliente na web sempre foi a de selecionar o arquivo e enviá-los ao servidor para que este possa, de alguma forma, fazer a leitura e retornar os dados de leitura para o cliente. Esta é a prática usual. Mas o HTML5 veio com suas API para desmistificar o usual.&lt;/p&gt;

&lt;p&gt;A File API desmitifica a prática de enviar um arquivo para o servidor para que ele possa ser lido. Sim, você pode ler arquivos no navegador, usando a capacidade processamento do cliente, e liberando seu servidor para executar atividades que somente ele possa executar.&lt;/p&gt;

&lt;p&gt;Mas, afinal, como funciona esta tal de File API? Bem, ela provê um padrão para executar as seguintes atividades:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Selecionar arquivos ou uma lista de arquivos;&lt;/li&gt;
&lt;li&gt;Ler alguns atributos dos arquivos selecionados, e;&lt;/li&gt;
&lt;li&gt;Ler o conteúdo dos arquivos selecionados.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bem, mas você pode estar imaginando que agora é possível criar uma aplicação que irá, ao ser carregado no navegador, fazer a leitura de arquivos do usuário  fazendo aquilo para o qual foi construído. Infelizmente não, mas felizmente no que se diz respeito a segurança. Você só poderá manipular arquivos locais que o usuário prover acesso conscientemente, única e exclusivamente por este meio.&lt;/p&gt;

&lt;h3 id=&#34;selecionar-arquivos-e-ler-seus-atributos&#34;&gt;Selecionar Arquivos e Ler Seus Atributos&lt;/h3&gt;

&lt;p&gt;Para selecionarmos um arquivo podemos criar um elemento &lt;em&gt;input&lt;/em&gt; com a propriedade &lt;em&gt;type&lt;/em&gt; igual a _file. _Com isto o usuário poderá escolher o arquivo que será selecionado. Vamos exibir os atributos do arquivo selecionado em um parágrafo.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt; &amp;lt;input id=&#34;inputFile&#34; type=&#34;file&#34;&amp;gt;
 &amp;lt;p id=&#34;atributos&#34;&amp;gt;&amp;lt;/p&amp;gt;&lt;/pre&gt;

&lt;p&gt;Agora que podemos selecionar o arquivo, vamos pegar alguns atributos. É possível pegar os  seguintes atributos do arquivo selecionado: nome, tipo de arquivo e tamanho do arquivo. Como fazer isto? Veja abaixo:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;function pegarArquivo(arquivoSelecionado) {
    if(arquivoSelecionado.files){
       var file = arquivoSelecionado.files[0];
       document.getElementById(&#39;atributos&#39;).innerHTML =
                             &#39;  nome do arquivo: &#39;+file.name +
                             &#39;;  tipo do arquivo: &#39;+file.type +
                             &#39;;  tamanho do arquivo: &#39;+file.size + &#39; bytes&#39;
                   }   
                                          }&lt;/pre&gt;

&lt;p&gt;O que estamos fazendo acima é pegar o arquivo selecionado no elemento &lt;em&gt;input&lt;/em&gt;, verificar se tem algum arquivo selecionado e pegar os atributos de nome, tipo e  tamanho do arquivo no índice zero. Em seguida estes são exibidos no parágrafo com o &lt;em&gt;id&lt;/em&gt; atributos.&lt;/p&gt;

&lt;p&gt;É claro que pegar as propriedades de um arquivo pode ser útil para muitas atividades. Mas o que mais impressiona na File API é possibilidade de leitura do conteúdo de arquivos. Vamos ver como isto é possível?&lt;/p&gt;

&lt;h3 id=&#34;filereader&#34;&gt;FileReader&lt;/h3&gt;

&lt;p&gt;É possível ler arquivos na memória do cliente por meio de uma interface da File API chamada FileReader. A FileReader fornece métodos, atributos e eventos que permitem a leitura de arquivos de forma assíncrona.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;input id=&#34;inputImage&#34; type=&#34;file&#34; onchange=&#34;pegaArquivo(this.files)&#34;&amp;gt;
&amp;lt;div id=&#34;imgLocal&#34;&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;Os elementos acima possibilitam a seleção de uma imagem para carregamento no navegador. Posteriormente as imagens serão exibidas na &lt;em&gt;div&lt;/em&gt; mostrada acima.&lt;/p&gt;

&lt;p&gt;O script para carregar a imagem selecionada e exibi-la para o usuário, utiliza o método onload do objeto FileReader , conforme mostra o código abaixo:&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;function pegaArquivo(files){
    var imgLoca = document.getElementById(&#39;imgLocal&#39;)
    var file = files[0];
    var img = document.createElement(&#34;img&#34;);
        img.file = file;

        imgLocal.appendChild(img)

    var reader = new FileReader();
        reader.onload = (function(aImg) {return function(e) {aImg.src = e.target.result;};})(img);
        reader.readAsDataURL(file);
}&lt;/pre&gt;

&lt;p&gt;Primeiro, nós lemos os atributos de um arquivo, agora nós carregamos um arquivo de imagem. Mas na verdade o que eu quero mostrar para vocês é a capacidade de leitura de um arquivo csv. Um arquivo do tipo csv pode conter dados, que quando carregados, possibilita a geração de tabelas, gráficos e todas as formas de exibição de dados possíveis. Novamente digo que isto poderia ser feito pelo servidor, mas não queremos consumir ciclos do servidor desnecessariamente.&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;input type=&#34;file&#34; id=&#34;inputCSV&#34; onchange=&#34;pegaCSV(this)&#34;&amp;gt;
&amp;lt;div id=&#34;CSVsaida&#34;&amp;gt;&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;Acima nós criamos uma tag input com type file para carregarmos o nosso arquivo csv. No evento onchage estamos executando uma função que irá fazer a mágica para nós. Em seguida temo uma tag onde serão exibidos os dados do csv após carregado.&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;var leitorDeCSV = new FileReader()
window.onload = function init() {
    leitorDeCSV.onload = leCSV;
}&lt;/pre&gt;

&lt;p&gt;Acima nós criamos uma variável do tipo FileReader logo na sequência atribuímos a função leCSV ao evento de onload. Sendo assim, no momento em que o arquivo csv for carregado ele disparará a função leCSV.&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;function pegaCSV(inputFile) {
     var file = inputFile.files[0];
     leitorDeCSV.readAsText(file);
}&lt;/pre&gt;

&lt;p&gt;Agora nós contruímos a função que será executada para selecionar o arquivo csv.&lt;/p&gt;

&lt;pre class=&#34;javascript&#34;&gt;function leCSV(evt) {

  var fileArr = evt.target.result.split(&#39;\n&#39;);
  var strDiv = &#39;&amp;lt;table&amp;gt;&#39;;

  for (var i=0; i&amp;lt;fileArr.length; i++) {
       strDiv += &#39;&amp;lt;tr&amp;gt;&#39;;
       var fileLine = fileArr[i].split(&#39;,&#39;);
           for (var j=0; j&amp;lt;fileLine.length; j++) {
                strDiv += &#39;&amp;lt;td&amp;gt;&#39;+fileLine[j].trim()+&#39;&amp;lt;/td&amp;gt;&#39;;
      }
      strDiv += &#39;&amp;lt;/tr&amp;gt;&#39;;
  }

      strDiv += &#39;&amp;lt;/table&amp;gt;&#39;;
      var CSVsaida = document.getElementById(&#39;CSVsaida&#39;);
      CSVsaida.innerHTML = strDiv;
}&lt;/pre&gt;

&lt;p&gt;Quando o evento de onload for disparado ele executará a função acima, nela o arquivo csv lido será usado para contruir tabelas com suas linhas e colunas e o resultado final será inserido na tag CSVsaida.&lt;/p&gt;

&lt;p&gt;Com este &lt;a title=&#34;CSV File API&#34; href=&#34;http://jsfiddle.net/bruiz/273dC/3/embedded/result/&#34; target=&#34;_blank&#34;&gt;EXEMPLO&lt;/a&gt;, não temos dúvidas do poder deste padrão web. De fato poderemos simplificar muito o trabalho de leitura de arquivos. Agora fica por sua curiosidade e necessidade explorar a File API.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;line-height: 1.5em&#34;&gt;Bons estudos e bom trabalho!&lt;/span&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Web Storage  – HTML5</title>
      <link>http://tableless.com.br/web-storage-html5/</link>
      <pubDate>Tue, 28 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/web-storage-html5/</guid>
      <description>

&lt;h2 id=&#34;cookies-8211-o-passado&#34;&gt;Cookies &amp;#8211; o passado&lt;/h2&gt;

&lt;p&gt;Para entendermos a vantagem obtida na utilização do WebStorage vamos compreender como uma aplicação trabalha(va) com cookies.&lt;/p&gt;

&lt;p&gt;Os cookies são inseridos no cabeçalho HTTP, sendo assim, sua performance pode ser comprometida. E estando as informações no cabeçalho HTTP, podemos nos perguntar: o quão protegidas elas estão?&lt;/p&gt;

&lt;p&gt;Outro desafio que se apresenta ao se trabalhar cookies é a capacidade de armazenamento: 4kB por cookies vezes no máximo 20 cookies é igual a capacidade de 80 kB. Essa restrição de capacidade por si só já é um problema, mas ela acarreta outro dificuldade, o gerenciamento destes cookies.&lt;/p&gt;

&lt;p&gt;Pense que em uma aplicação que real seria muito útil armazenar mais do que 80 kB, para fazer isso com cookies seria necessário estabelecer um controle de validade dos cookies, essa seria uma maneira muito inteligente de utilizar cookies &amp;#8211; afinal ele precisar estar armazenado somente enquanto for necessário, mas o trabalho para controlar as datas de validade dos cookies seria um trabalho que requisitaria calcular seus tempos de validade, mais código.&lt;/p&gt;

&lt;h2 id=&#34;webstorage-8211-o-presente-e-suas-vantagens&#34;&gt;WebStorage &amp;#8211; o presente e suas vantagens.&lt;/h2&gt;

&lt;p&gt;As limitações dos cookies já foram citadas, mas o WebStorage é melhor no itens citados? SIM.&lt;/p&gt;

&lt;p&gt;Vamos ver como o WebStorage é melhor.&lt;/p&gt;

&lt;p&gt;Mas em primeiro lugar vamos falar de segurança.&lt;/p&gt;

&lt;p&gt;Os pares de chave e valor gravados pela WebStorage não podem ser acessados por outros subdomínios. Isso garante que caso você use o WebStorage para gravar dados com sigilo. Isso faz com que ele não corra o risco de ser acessado por outro domínio.&lt;/p&gt;

&lt;p&gt;Sobre a capacidade de armazenamento, temos o suficiente para trabalharmos bem. A API permite armazenamentos entre 2,5 MB até 10 MB. Esse espaço é suficiente para podermos trabalhar com folga, principalmente se compararmos com a capacidade permitida para se trabalhar com os cookies.&lt;/p&gt;

&lt;p&gt;Com este espaço disponível talvez você não precise se preocupar com o controle de validade dos dados. Mas caso você queira controlar o período em que os dados estarão gravados no navegador do usuário, você pode fazer isto. Para tanto, temos que entender o desdobramento do conceito do WebStorage: localStorage e sessionStorage.&lt;/p&gt;

&lt;p&gt;Este último manterá os dados salvos enquanto o navegador estiver aberto. Isso é muito útil, pois nem sempre queremos que os dados estejam sempre disponíveis. Enquanto o localStorage manterá o dado gravado até que ele seja removido diretamente, você poderá fechar o navegador, reiniciar o computador e os dados ainda estarão lá.&lt;/p&gt;

&lt;h2 id=&#34;exemplo&#34;&gt;Exemplo&lt;/h2&gt;

&lt;p&gt;Não há melhor maneira de aprender do que fazendo. Vamos construir uma calculadora em que seja possível salvarmos os valores calculados e visualizá-los ao lado, e sempre que o usuário desejar ver os resultados calculados ele poderá fazer isto, mesmo após ter fechada a sessão. Então vamos ao exemplo.&lt;/p&gt;

&lt;p&gt;Primeiro vamos construir a estrutura do nosso documento html, nele usaremos a biblioteca jquery para facilitar a construção do nosso script. Também teremos uma tag input onde serão apresentados os dígitos clicados, em seguidas temos os botões com os numeros de 0 à 9, com as operações de SOMA, MULTIPLICAÇÃO, DIVISÃO e SUBTRAÇÃO, PARÊNTESES e os botões de SALVAR &amp;#8211; que irá salvar o valor da tag input no localStorage &amp;#8211; ,LISTAR que ira pegar todos os valores listados no localStorage e colocar em uma tabela e o botão APAGAR que deletará todos itens do localStorage, também temos a tabela onde serão colocados os valores encontrados no localStorage :&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;!--Início - Documento .html-- gt;
&amp;lt;html&amp;gt;    
  &amp;lt;head&amp;gt;
    &amp;lt;script src=&#34;http://code.jquery.com/jquery-1.10.2.min.js&#34;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;

    &amp;lt;input id=&#34;inputResult&#34;&amp;gt;&amp;lt;/input&amp;gt;
    &amp;lt;br&amp;gt;

    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;1&#34;&amp;gt;1&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;2&#34;&amp;gt;2&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;3&#34;&amp;gt;3&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;4&#34;&amp;gt;4&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;5&#34;&amp;gt;5&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;

    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;6&#34;&amp;gt;6&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;7&#34;&amp;gt;7&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;8&#34;&amp;gt;8&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;9&#34;&amp;gt;9&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnNumber&#34; value=&#34;0&#34;&amp;gt;0&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;

    &amp;lt;button class=&#34;btnOperacao&#34; value=&#34;+&#34;&amp;gt;+&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnOperacao&#34; value=&#34;-&#34;&amp;gt; - &amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnOperacao&#34; value=&#34;*&#34;&amp;gt; * &amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnOperacao&#34; value=&#34;/&#34;&amp;gt; / &amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnOperacao&#34; value=&#34;(&#34;&amp;gt;(&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;

    &amp;lt;button class=&#34;btnOperacao&#34; value=&#34;)&#34;&amp;gt;)&amp;lt;/button&amp;gt;
    &amp;lt;button class=&#34;btnResult&#34; value=&#34;=&#34;&amp;gt;=&amp;lt;/button&amp;gt;
    &amp;lt;button id=&#34;btnLimpar&#34; class=&#34;btnOperacao&#34; value=&#34;LIMPAR&#34;&amp;gt;LIMPAR&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;button class=&#34;btnSalvar&#34; value=&#34;SALVAR&#34;&amp;gt;SALVAR&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;button class=&#34;btnListar&#34; value=&#34;LISTAR&#34;&amp;gt;LISTAR VALORES&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;button class=&#34;btnApagar&#34; value=&#34;APAGAR&#34;&amp;gt;APAGAR VALORES&amp;lt;/button&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;br&amp;gt;

    &amp;lt;table id=&#34;tableResults&#34; class=&#34;tabela&#34; border=&#34;0&#34;&amp;gt;
            &amp;lt;tr&amp;gt;
                     &amp;lt;td&amp;gt;
      Chave
        &amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;
      Valor
                    &amp;lt;/td&amp;gt;
                 &amp;lt;/tr&amp;gt;

    &amp;lt;/table&amp;gt;
  &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&amp;lt;!--Fim - Documento .html--&amp;gt;&lt;/pre&gt;

&lt;p&gt;Criado o documento acima vamos construir nossa lógica.&lt;/p&gt;

&lt;p&gt;O que queremos primeiramente é pegar o valor clicado nos números e colocá-los no input. Para isso vamos usar o evento clique que será atribuído aos botões dos números por meio da classe btnNumber, e dentro da função atribuída colocaremos o valor clicado mais o valor que ele terá.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;.btnNumber&#39;).click(function(){  
   $(&#39;#inputResult&#39;).val($(&#39;#inputResult&#39;).val()+this.value)
});&lt;/pre&gt;

&lt;p&gt;Agora o que queremos é fazer o mesmo para pegarmos as operações clicadas. A lógica é a mesma, mas adicionaremos uma tratativa para acaso o botão de operação clicado seja o LIMPAR. Se clicar no botão LIMPAR o valor da tag input será esvaziado.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;.btnOperacao&#39;).click(function(){  
  if(this.value != &#39;LIMPAR&#39;){
    $(&#39;#inputResult&#39;).val($(&#39;#inputResult&#39;).val()+this.value)
  }
  else{
    $(&#39;#inputResult&#39;).val(&#39;&#39;)
  }
});&lt;/pre&gt;

&lt;p&gt;Bem, isso é uma calculadora, então temos que calcular. É neste momento onde gosto de expressar o amor ao javascript, basta passarmos a string com a conta montada na tag input para o método eval( ), para que ele execute o cálculo. O código abaixo mostra a atribuição da função e a execução do calculo e em seguida coloca o valor na tag input.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;.btnResult&#39;).click(function(){  
    $(&#39;#inputResult&#39;).val(eval($(&#39;#inputResult&#39;).val()))
});&lt;/pre&gt;

&lt;p&gt;Finalmente vamos ao WebStorage, porque queremos gravar os valores e deixá-los disponíveis. Para gravarmos um valor no localStorage usamos o setItem(chave,valor), sempre gravaremos um par de chave e valor no WebStorage. Sabemos que queremos gravar o valor do resultado, mas a chave vamos deixar nas mãos do usuário. Quando ele clicar em salvar vamos dar ao usuário a opção dar um nome aquele resultado, e este nome será a chave a ser gravada com o valor.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;.btnSalvar&#39;).click(function(){
    var lS = prompt(&#34;De um nome ao resultado para salvar.&#34;,&#34;&#34;);
    localStorage.setItem(lS,$(&#39;#inputResult&#39;).val());
})&lt;/pre&gt;

&lt;p&gt;Temos o botão LISTAR que pegará todos os valores salvos no localStorage e colocará na tabela abaixo da calculadora. Para pegarmos um valor usamos o getitem(chave), para sabermos quantos itens temos no localStorage usamos o localStorage.length e para pegar a chave usamos localStorage.key(index). Utilizando um while varremos localStorage e inserimos os valores na tabela.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;.btnListar&#39;).click(function(){
  var tamanho = localStorage.length;
  var chave = &#39;&#39;;
  var valor = &#39;&#39;;

  if(document.getElementById(&#34;tableResults&#34;).rows.length &amp;gt; 1)  {
    for(var t = document.getElementById(&#34;tableResults&#34;).rows.length; t &amp;gt; 1; t--){
      document.getElementById(&#34;tableResults&#34;).deleteRow(1);
    }
  }

  var numOfCols =  document.getElementById(&#34;tableResults&#34;).rows[document.getElementById(&#34;tableResults&#34;).rows.length-1].cells.length;

  for(var c = 0; c &amp;lt; tamanho;c++){
    chave = localStorage.key(c);
    valor = localStorage.getItem(chave);
    var newRow = document.getElementById(&#34;tableResults&#34;).insertRow(document.getElementById(&#34;tableResults&#34;).rows.length);

    for (var j = 0; j &amp;lt; numOfCols; j++) {
      newCell = newRow.insertCell(j);

      if(j==0){
       newCell.innerHTML = chave.toUpperCase();
     }else if(j == 1){
       newCell.innerHTML = valor;
     }
   }
 }
})&lt;/pre&gt;

&lt;p&gt;A ultima lógica é a de limpar o localStorage com os dados salvos. Usamos o localStorage.clear() para limpar todos os itens. Veja como:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;$(&#39;.btnApagar&#39;).click(function(){
   localStorage.clear()                 
})&lt;/pre&gt;

&lt;p&gt;Estilo é importante, não é o nosso foco, mas é importante, então vamos implementar algum estilo.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;button{
  width:27.5px;
}
.btnListar,.btnSalvar,.btnApagar{
  width:155px;
}
#btnLimpar{
  width:90px; 
}
#inputResult{
  text-align: center;
}
table.tabela tbody tr:nth-child(odd){
  background-color: #E9E9E9;
}&lt;/pre&gt;

&lt;p&gt;Este é o código que temos.Vamos ver como o navegador (Chrome) nos possibilita inspecionar o elemento.&lt;/p&gt;

&lt;p&gt;Execute o documento no navegador e aperte F12. Aparecerá a tela do lado direito aperte a seta à esquerda do Local Storage para visualizar os dados salvos pelo documento em execução. No caso abaixo, ainda não temos nenhum valor salvo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws1.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-40582&#34; alt=&#34;ws1&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws1-588x171.png&#34; width=&#34;588&#34; height=&#34;171&#34; srcset=&#34;uploads/2014/01/ws1-588x171.png 588w, uploads/2014/01/ws1-329x95.png 329w, uploads/2014/01/ws1-660x192.png 660w, uploads/2014/01/ws1.png 970w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Faça qualquer conta.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws2.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-40583&#34; alt=&#34;ws2&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws2-226x310.png&#34; width=&#34;226&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/01/ws2-226x310.png 226w, uploads/2014/01/ws2-122x168.png 122w, uploads/2014/01/ws2.png 262w&#34; sizes=&#34;(max-width: 226px) 100vw, 226px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Agora clique em igual (=) para obter o resultado.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws3.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-40584&#34; alt=&#34;ws3&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws3-237x310.png&#34; width=&#34;237&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/01/ws3-237x310.png 237w, uploads/2014/01/ws3-128x168.png 128w, uploads/2014/01/ws3.png 264w&#34; sizes=&#34;(max-width: 237px) 100vw, 237px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Clicando em salvar, abriremos um prompt para ser digitado o nome do resultado que será utilizado para identificar o valor.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws4.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-40585&#34; alt=&#34;ws4&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws4-588x156.png&#34; width=&#34;588&#34; height=&#34;156&#34; srcset=&#34;uploads/2014/01/ws4-588x156.png 588w, uploads/2014/01/ws4-329x87.png 329w, uploads/2014/01/ws4-660x176.png 660w, uploads/2014/01/ws4.png 944w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Depois de clicar em OK, abra o inspetor de elementos Developer Tools clique no botão de refresh no rodapé e você verá o valor salvo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws5.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-40586&#34; alt=&#34;ws5&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws5-588x162.png&#34; width=&#34;588&#34; height=&#34;162&#34; srcset=&#34;uploads/2014/01/ws5-588x162.png 588w, uploads/2014/01/ws5-329x91.png 329w, uploads/2014/01/ws5-660x182.png 660w, uploads/2014/01/ws5.png 936w&#34; sizes=&#34;(max-width: 588px) 100vw, 588px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Execute mais um calculo e salve seu valor. Agora clique em LISTAR VALORES e assim serão exibidos todos os valores no localStorage.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws6.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-40587&#34; alt=&#34;ws6&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/01/ws6-242x310.png&#34; width=&#34;242&#34; height=&#34;310&#34; srcset=&#34;uploads/2014/01/ws6-242x310.png 242w, uploads/2014/01/ws6-131x168.png 131w, uploads/2014/01/ws6.png 264w&#34; sizes=&#34;(max-width: 242px) 100vw, 242px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Clicando em APAGAR VALORES os dados sumirão e não serão mais visualizados no Developers Tools e não serão listados na tabela.&lt;/p&gt;

&lt;p&gt;Para finalizarmos temos que esclarecer que a maneira de se usar o sessionStorage é a mesma do localStorage. O que deve ficar claro é que ao usar o sessionStorage todos os dados salvos serão perdidos ao se fechar o navegador. O exemplo acima pode ser adaptado ao sessionStorage sem problemas. Veja o exemplo funcionando: &lt;a title=&#34;EXEMPLO&#34; href=&#34;http://jsfiddle.net/bruiz/d5prC/&#34; target=&#34;_blank&#34;&gt;EXEMPLO&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bons estudos e bom trabalho!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>