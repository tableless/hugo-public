<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alex Miranda on Tableless</title>
    <link>https://tableless.github.io/hugo-public/author/alex-miranda/index.xml</link>
    <description>Recent content in Alex Miranda on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/author/alex-miranda/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Uma vis√£o detalhada sobre instancia√ß√£o de variaveis no JavaScript</title>
      <link>https://tableless.github.io/hugo-public/uma-visao-detalhada-sobre-instanciacao-de-variaveis-no-javascript/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/uma-visao-detalhada-sobre-instanciacao-de-variaveis-no-javascript/</guid>
      <description>

&lt;h2 id=&#34;hoisting&#34;&gt;Hoisting&lt;/h2&gt;

&lt;p&gt;Antes de falarmos sobre hoisting √© importante lembrar como funciona escopo em JavaScript. Escopo nada mais √© do que um contexto criado para os valores e express√µes terem sua validade. Em JavaScript o escopo √© criado com a declara√ß√£o de fun√ß√µes. Vamos a um exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// Escopo global
var num = 0; 

// Escopo criado pela fun√ß√£o
function imprimir(){
    var num = 1;
    console.log(num);
}

// Executar a fun√ß√£o e o que tem em seu escopo
imprimir(); // 1

// Imprimindo a vari√°vel do escopo global
console.log(num); // 0
&lt;/pre&gt;

&lt;p&gt;No exemplo acima temos o seguinte: A vari√°vel &amp;#8220;num&amp;#8221; foi declarada com o mesmo nome em 2 lugares diferentes: No escopo global e no escopo criado pela fun√ß√£o imprimir. Por elas estarem em escopos diferentes, n√£o tem problema terem o mesmo nome.&lt;/p&gt;

&lt;p&gt;Mas cuidado! As vari√°veis declaradas sem a palavra reservada &amp;#8220;var&amp;#8221; passam a ser parte do escopo global. Olha s√≥:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// Escopo global
var num = 0;

// Escopo criado para a fun√ß√£o imprimir
function imprimir(){
    num = 1; 
    console.log(num);
}

// Executar a fun√ß√£o e o que tem no escopo
imprimir(); // 1

// Acessando a vari√°vel do escopo global
console.log(num); // 1
&lt;/pre&gt;

&lt;p&gt;Uma das boas praticas em JavaScript √© sempre declarar as vari√°veis com a palavra reservada &amp;#8216;var&amp;#8217; para conter o valor em seu escopo local e manter o escopo global limpo.&lt;/p&gt;

&lt;p&gt;Legal, agora que j√° relembramos o escopo em JavaScript vamos entender o que √© o hoisting.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Hoisting pode ser traduzido como levantar, erguer ou i√ßar.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Esse comportamento na linguagem JavaScript vale para fun√ß√µes e vari√°veis. Vamos falar primeiro sobre o hoisting de vari√°veis. Quando declaramos uma vari√°vel em JavaScript a mesma √© erguida, ou hoisted, para o topo do escopo, no caso de variaveis somente a sua declara√ß√£o √© levada para o topo do escopo mas sua inicializa√ß√£o n√£o. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function nome(){
    var nome = &#34;Alex&#34;;
    console.log(nome + &#34; &#34; + sobreNome);
    var sobreNome = &#34;Miranda&#34;;
}
nome(); // Alex undefined
&lt;/pre&gt;

&lt;p&gt;O valor da vari√°vel sobreNome √© undefined, ou seja, ela esta sendo considerada na fun√ß√£o mas o seu valor n√£o.&lt;/p&gt;

&lt;p&gt;E √© assim que funciona o hoisting de vari√°vel. üòâ&lt;/p&gt;

&lt;p&gt;No caso de fun√ß√µes o hoisting ocorre de um jeito diferente. Tanto a sua declara√ß√£o quanto o seu escopo √© i√ßado&lt;/p&gt;

&lt;p&gt;para o topo. Olha que interessante:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;nome(); // Alex
function nome(){
    var nome = &#34;Alex&#34;;
    console.log(nome);
}
&lt;/pre&gt;

&lt;p&gt;Sim, a fun√ß√£o foi executada antes da sua declara√ß√£o por conta do hoisting. Por√©m, aqui vale um lembrete, uma das formas de declaramos fun√ß√µes em JavaScript √© armazenando elas em vari√°veis, nesse caso a regra para hoisting em vari√°veis entra em cena novamente. Vamos ver o que o nosso exemplo anterior retornaria neste caso:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;nome();
var nome = function(){
    var nome = &#34;Alex&#34;;
    console.log(nome);
}
&lt;/pre&gt;

&lt;p&gt;Declarando a fun√ß√£o desta forma o JavaScript retorna um erro dizendo que &amp;#8220;nome&amp;#8221; n√£o √© uma fun√ß√£o.&lt;/p&gt;

&lt;h2 id=&#34;closure&#34;&gt;Closure&lt;/h2&gt;

&lt;p&gt;A tradu√ß√£o para a Closure em portugu√™s seria clausura que quer dizer confinamento ou ambiente fechado. Para conseguir esse confinamento basta declarar uma fun√ß√£o dentro de outra, a fun√ß√£o externa confina a fun√ß√£o interna.&lt;/p&gt;

&lt;p&gt;O confinamento acontece por conta da regra do JavaScript referente a escopo. Sabemos que o escopo √© criado por fun√ß√µes, isso quer dizer que a fun√ß√£o externa cria um escopo em que a fun√ß√£o interna fica confinada podendo ser executada somente dentro desse escopo. As vari√°veis e par√¢metros da fun√ß√£o externa podem ser acessados pela fun√ß√£o interna.&lt;/p&gt;

&lt;p&gt;Vamos a um exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// fun√ß√£o externa
function lancamentoDeNota(nome, exercicio , nota){
    // fun√ß√£o interna
    function fechamento(){
        var mensagem = &#34;Avalia√ß√£o do exerc√≠cio : &#34; + exercicio;
        mensagem += &#34;\n Aluno: &#34; + nome;
        mensagem += &#34;\n Nota: &#34; + nota;
        console.log(mensagem)
    }
    // executa a fun√ß√£o interna
    fechamento();

} // fecha fun√ß√£o externa

lancamentoDeNota(&#34;Alex&#34;, &#34;Importando collections&#34;, &#34;10&#34;); // Avalia√ß√£o do exerc√≠cio : Importando collections Aluno: Alex Nota: 10
&lt;/pre&gt;

&lt;p&gt;Acabamos de ver um exemplo de closure em JavaScript, mas ainda temos uma diferen√ßa muito bacana na linguagem. Em JavaScript √© poss√≠vel escapar a fun√ß√£o interna do seu confinamento. Vamos avaliar o c√≥digo abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// fun√ß√£o externa
function lancamentoDeNota(nome, exercicio , nota){
    // fun√ß√£o interna
    function fechamento(){
        var mensagem = &#34;Avalia√ß√£o do exerc√≠cio: &#34; + exercicio;
        mensagem += &#34;\n Aluno: &#34; + nome;
        mensagem += &#34;\n Nota: &#34; + nota;
        console.log(mensagem)
    }
    // escapando a fun√ß√£o interna retornando ela de forma literal para fun√ß√£o externa. Malandragem √© pouco pro JS kkkk
    return fechamento;
}
var primeiroExercicio = lancamentoDeNota(&#34;Alex&#34;, &#34;Importando collections&#34;, &#34;10&#34;);
var segundoExercicio = lancamentoDeNota(&#34;Alex&#34;, &#34;Inserindo Pokemons&#34;, &#34;10&#34;);

primeiroExercicio(); // Avalia√ß√£o do exerc√≠cio : Importando collections Aluno: Alex Nota: 10
segundoExercicio(); // Avalia√ß√£o do exerc√≠cio : Importando Pokemons Aluno: Alex Nota: 10
&lt;/pre&gt;

&lt;p&gt;O return faz com que a fun√ß√£o interna seja retornada de forma literal podendo ser executada fora do confinamento.&lt;/p&gt;

&lt;h2 id=&#34;vari√°vel-global&#34;&gt;Vari√°vel Global&lt;/h2&gt;

&lt;p&gt;Vari√°veis globais s√£o todas aquelas definidas fora de alguma fun√ß√£o. Isso porque cada fun√ß√£o gera seu pr√≥prio escopo. A vari√°vel global pode ser acessada por qualquer fun√ß√£o. Fizemos isso segundo exemplo.&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;// Escopo global
var num = 0;

// Escopo criado para a fun√ß√£o imprimir
function imprimir(){
    num = 1; 
    console.log(num);
}

// Executar a fun√ß√£o e o que tem no escopo
imprimir(); // 1

// Acessando a vari√°vel do escopo global
console.log(num); // 1
&lt;/pre&gt;

&lt;p&gt;Todas as vari√°veis que n√£o forem declaradas com a palavra reservada &amp;#8216;var&amp;#8217; ser√£o consideradas parte do escopo&lt;/p&gt;

&lt;p&gt;global.&lt;/p&gt;

&lt;h2 id=&#34;vari√°vel-por-par√¢metro&#34;&gt;Vari√°vel por par√¢metro&lt;/h2&gt;

&lt;p&gt;Quando declaramos uma fun√ß√£o temos a op√ß√£o de indicar alguns par√¢metros para elas. Tais par√¢metros s√£o considerados como vari√°veis que recebem um valor na hora da execu√ß√£o da fun√ß√£o. Esses valores s√£o utilizados dentro da fun√ß√£o. Exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;function sub(num1, num2){
 console.log(num1-num2)
}
sub(10, 2) // 8
&lt;/pre&gt;

&lt;p&gt;Caso esse par√¢metro seja uma vari√°vel global o valor dela n√£o se altera. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var global = 12;
function sub(global, num2){
 console.log(global-num2);
}
sub(15, 2) // 13
console.log(global); // 12
&lt;/pre&gt;

&lt;h2 id=&#34;instancia√ß√£o-usando-uma-iife&#34;&gt;Instancia√ß√£o usando uma IIFE&lt;/h2&gt;

&lt;p&gt;IIFE √© a abrevia√ß√£o para Imediately Invoked Function Expression, que pode ser traduzida para Express√£o de Fun√ß√£o Invocada Imediatamente. Esse tipo de fun√ß√£o √© executada no mesmo momento que esta sendo interpretada, veja a sintaxe dela:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;(function(){
 // corpo da fun√ß√£o
}())
&lt;/pre&gt;

&lt;p&gt;Os parenteses que envolvem a fun√ß√£o fazem dela uma express√£o e os parenteses no final da declara√ß√£o executa a&lt;/p&gt;

&lt;p&gt;fun√ß√£o. Esse tipo de fun√ß√£o tamb√©m pode ser armazenada em uma vari√°vel. Dessa forma:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var nome = (function(){
 // corpo da fun√ß√£o
}())
&lt;/pre&gt;

&lt;p&gt;Como toda fun√ß√£o, a IIFE tamb√©m pode receber par√¢metros. Mas agora pense o seguinte, se ela √© chamada imediatamente em tempo de execu√ß√£o, como podemos passar os par√¢metros ? Vamos ver:&lt;/p&gt;

&lt;pre class=&#34;lang-javascript&#34;&gt;var nome = (function(nome){
 // corpo da fun√ß√£o
 console.log(&#34;Artigo escrito por: &#34; + nome); // Alex
}(&#34;Alex&#34;))
&lt;/pre&gt;

&lt;p&gt;Bem bacana n√© ? A IIFE √© um partner em JavaScript que evita polui√ß√£o no escopo global e com ela tamb√©m √© poss√≠vel modularizar o c√≥digo e deixar tudo mais organizado.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>