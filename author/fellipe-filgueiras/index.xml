<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fellipe Filgueiras on Tableless</title>
    <link>http://tableless.com.br/author/fellipe-filgueiras/index.xml</link>
    <description>Recent content in Fellipe Filgueiras on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="http://tableless.com.br/author/fellipe-filgueiras/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>JAVA – Estruturas de Repetição</title>
      <link>http://tableless.com.br/java-estruturas-de-repeticao/</link>
      <pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-estruturas-de-repeticao/</guid>
      <description>

&lt;p&gt;As estruturas de repetição também são conhecidas como laços (loops) e são utilizados para executar, repetidamente, uma instrução ou bloco de instrução enquanto determinada condição estiver sendo satisfeita.&lt;/p&gt;

&lt;p&gt;Qualquer que seja a estrutura de repetição, ela contém quatro elementos fundamentais: inicialização, condição, corpo e iteração. A inicialização compõe-se de todo código que determina a condição inicial da repetição. A condição é uma expressão booleana avaliada após cada leitura do corpo e determina se uma nova leitura deve ser feita ou se a estrutura de repetição deve ser encerrada. O corpo compõe-se de todas as instruções que são executadas repetidamente. A iteração é a instrução que deve ser executada depois do corpo e antes de uma nova repetição.&lt;/p&gt;

&lt;h2 id=&#34;while&#34;&gt;While&lt;/h2&gt;

&lt;p&gt;O termo while pode ser traduzido para o português como “enquanto”. Este termo é utilizado para construir uma estrutura de repetição que executa, repetidamente, uma única instrução ou um bloco delas “enquanto” uma expressão booleana for verdadeira.&lt;/p&gt;

&lt;p&gt;Veja que a inicialização precede o início da repetição. Isso significa que você deve definir o estado inicial dos elementos que serão utilizados nesse laço antes de seu cabeçalho. A palavra reservada while sempre será seguida de um par de parênteses, que delimitam a condição desta estrutura de repetição. Essa condição deve ser uma expressão booleana e, enquanto ela for verdadeira, esta estrutura continuará executando as instruções contidas no seu corpo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/while.bmp&#34;&gt;&lt;img class=&#34; size-full wp-image-49309 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/while.bmp&#34; alt=&#34;while&#34; width=&#34;599&#34; height=&#34;225&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;do-while&#34;&gt;Do-while&lt;/h2&gt;

&lt;p&gt;A estrutura de repetição do-while é uma variação da estrutura while. Existe uma diferença sutil, porém importante, entre elas. Em um laço while, a condição é testada antes da primeira execução das instruções que compõem seu corpo. Desse modo, se a condição for falsa na primeira vez em que for avaliada, as instrução desse laço não serão executadas nenhuma vez. Em um laço do-while, por outro lado, a condição somente é avaliada depois que suas instruções são executadas pela primeira vez, assim, mesmo que a condição desse laço seja falsa antes de ele iniciar, suas instruções serão executadas pelo menos uma vez.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/do-while.bmp&#34;&gt;&lt;img class=&#34; size-full wp-image-49310 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/do-while.bmp&#34; alt=&#34;do-while&#34; width=&#34;612&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;estrutura-for&#34;&gt;Estrutura For&lt;/h2&gt;

&lt;p&gt;O laço for é uma estrutura de repetição compacta. Seus elementos de inicialização, condição e iteração são reunidos na forma de um cabeçalho e o corpo é disposto em seguida.&lt;/p&gt;

&lt;p&gt;Veja a sintaxe geral de uma estrutura for:&lt;/p&gt;

&lt;p&gt;Observe que a inicialização, condição e iteração aparecem, entre parênteses, após a palavra reservada “for” e elas são separadas apenas por um ponto-e-vírgula. A instrução ou bloco de instruções que este tipo de laço repete são transcritos a partir da linha subsequente ao seu cabeçalho.&lt;/p&gt;

&lt;p&gt;O laço for e o laço while são apenas formas diferentes de uma mesma estrutura básica de repetição. Qualquer laço for pode ser transcrito em termos de um laço while e vice-versa. Do mesmo modo que em um laço while, se a condição de um laço for já é falsa logo na primeira avaliação que se fizer dela, as instruções contidas em seu corpo jamais serão executadas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/for.bmp&#34;&gt;&lt;img class=&#34; size-full wp-image-49311 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/for.bmp&#34; alt=&#34;for&#34; width=&#34;459&#34; height=&#34;157&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;quebras-de-laço&#34;&gt;Quebras de Laço&lt;/h2&gt;

&lt;p&gt;As quebras de laço são utilizadas para interromper o fluxo normal das estruturas de repetição while, do-while e for. Há dois tipos distintos de quebras de laço, representadas pelas palavras reservadas break e continue.&lt;/p&gt;

&lt;p&gt;Há situações em que é preciso interromper um laço antes que sua condição se torne falsa. É para isso que serve o break. Figurando dentro do bloco de instruções de um laço qualquer, essa instrução encerra a estrutura de repetição, desviando a execução do aplicativo para a linha seguinte ao final desse laço.&lt;/p&gt;

&lt;p&gt;Enquanto a instrução break é utilizada para encerrar um laço, a instrução continue serve para iniciar uma nova repetição em que todas as instruções tenham sido executadas. Em laços while e do-while, uma instrução continue desvia o fluxo de execução para a condição. Em um laço for, ela desvia o fluxo de execução para a iteração e, em seguida, a condição é lida novamente.&lt;/p&gt;

&lt;h2 id=&#34;enhanced-for&#34;&gt;Enhanced-for&lt;/h2&gt;

&lt;p&gt;O enhanced-for foi introduzido a partir do&amp;nbsp;Java 5, e é utilizado para realizar as varreduras em collections. Para cada iteração do for, o elemento da iteração é atribuído à variável. Utilizando o enhanced-for, você é obrigado a percorrer um array por exemplo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/06/enhanced-for.bmp&#34;&gt;&lt;img class=&#34; size-full wp-image-49312 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/06/enhanced-for.bmp&#34; alt=&#34;enhanced-for&#34; width=&#34;410&#34; height=&#34;204&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bom galera, essa foi uma passada rápida pelas estruturas de repetição que o java oferece, sugestões e críticas serão sempre bem recebidas, obrigado.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – Estruturas de Decisão</title>
      <link>http://tableless.com.br/java-estruturas-de-decisao/</link>
      <pubDate>Fri, 22 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-estruturas-de-decisao/</guid>
      <description>

&lt;p&gt;As estruturas de decisão são utilizadas para controlar o fluxo de execução dos aplicativos, possibilitando que a leitura das instruções siga caminhos alternativos em função da análise de determinadas condições. Com elas, é possível condicionar a leitura de uma instrução ou de um bloco delas a uma ou mais condições que precisam ser satisfeitas.&lt;/p&gt;

&lt;p&gt;Todos os aplicativos de exemplo precedentes executam suas instruções de forma linear, ou seja, todas elas são lidas sequencialmente, na ordem em que foram escritas no código. Com o uso de estruturas de decisão, alguns trechos dos programas somente serão executados sob determinadas condições.&lt;/p&gt;

&lt;h2 id=&#34;estrutura-if&#34;&gt;Estrutura if&lt;/h2&gt;

&lt;p&gt;A estrutura de decisão if é utilizada para impor uma ou mais condições que deverão ser satisfeitas para a execução de uma instrução ou bloco de instruções. A sua forma geral é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-java&#34;&gt;If (&amp;lt;condição&amp;gt;) &amp;lt;instrução ou bloco&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A condição sempre irá figurar entre parênteses, após a palavra reservada if, e deve ser uma expressão booleana que resulte em um valor true ou false. A instrução ou o bloco de instruções somente será executado caso o resultado dessa expressão seja true. Caso o resultado seja false, o fluxo de execução será desviado e a instrução ou o bloco de instruções não será executado.&lt;/p&gt;

&lt;p&gt;Havendo uma única instrução condicionada pela estrutura if, ela figura logo após a condição e termina com um ponto e vírgula. A sintaxe é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-java&#34;&gt;If(&amp;lt;Condição&amp;gt;) &amp;lt;Instrução&amp;gt;;
&lt;/pre&gt;

&lt;h2 id=&#34;estrutura-if-else&#34;&gt;Estrutura if-else&lt;/h2&gt;

&lt;p&gt;A estrutura de decisão if-else é uma variação da estrutura if. Ela é utilizada para impor uma ou mais condições que deverão ser satisfeitas para a execução de uma instrução ou bloco de instruções e possibilita a definição de uma instrução ou bloco de instruções a serem executados caso as condições não sejam satisfeitas. A sua forma geral é a seguinte:&lt;/p&gt;

&lt;pre class=&#34;lang-java&#34;&gt;If(&amp;lt;Condição&amp;gt;) &amp;lt;instrução ou bloco&amp;gt;

else &amp;lt;instrução ou bloco&amp;gt;
&lt;/pre&gt;

&lt;p&gt;A condição sempre irá figurar entre parênteses, após a palavra reservada if, e deve ser uma expressão booleana que resulte em um valor true ou false. A primeira instrução ou o bloco de instruções somente será executado caso o resultado dessa expressão seja true. Caso o resultado seja false, o fluxo de execução será desviado e a instrução ou o bloco posterior ao else será executado.&lt;/p&gt;

&lt;h2 id=&#34;equals&#34;&gt;Equals&lt;/h2&gt;

&lt;p&gt;O método equals é usado para a comparação. A classe String e as classes Wrapper sobrescrevem o equals para garantir que dois objetos desses tipos, com o mesmo conteúdo, possam ser considerados iguais. Para descobrir se as referências são iguais, deve-se utilizar o   “ == ” para que seja comparado os bits das variáveis.&lt;/p&gt;

&lt;p&gt;Toda comparação utilizando o equals irá verificar, primeiro se existe uma sobrescrita do mesmo nas classes comparadas. Caso não haja, o método padrão da classe Object é utilizado.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/05/equals-com-objeto.bmp&#34;&gt;&lt;img class=&#34; wp-image-48938 size-full aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/05/equals-com-objeto.bmp&#34; alt=&#34;&#34; width=&#34;456&#34; height=&#34;238&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O resultado será falso, pois as classes, apesar de terem os mesmos atributos e métodos, a referência é diferente, como eu disse mas acima, para descobrir se as referências são iguais, deve-se utilizar “ == ”.&lt;/p&gt;

&lt;p&gt;O equals também poderá ser utilizado para a comparação de Strings:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/05/equals-com-string.bmp&#34;&gt;&lt;img class=&#34; wp-image-48939 size-full aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/05/equals-com-string.bmp&#34; alt=&#34;&#34; width=&#34;527&#34; height=&#34;201&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nesse caso, a primeira instrução irá gerar uma resposta false, pois não estamos utilizando o método equalsIgnoreCase, que ignora as letras maiúsculas e minúsculas, portanto, a segunda instrução irá gerar uma resposta true.&lt;/p&gt;

&lt;h2 id=&#34;operador-ternário&#34;&gt;Operador Ternário&lt;/h2&gt;

&lt;p&gt;Esse código trata-se de um operador matemático, com um condicional. Em alguns casos, ambos podem ter comportamento um pouco diferente. Lembrando também que o ternário sempre deve retornar valor, e o valor será sempre do mesmo tipo, para ambos os lados da expressão.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/05/if-ternario.bmp&#34;&gt;&lt;img class=&#34; size-full wp-image-48941 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/05/if-ternario.bmp&#34; alt=&#34;operador ternario&#34; width=&#34;632&#34; height=&#34;288&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nesse caso, temos duas condições, essas duas condições são iguais, porém a de cima utiliza o operador ternário.&lt;/p&gt;

&lt;h2 id=&#34;switch&#34;&gt;SWITCH&lt;/h2&gt;

&lt;p&gt;A estrutura de decisão switch-case, ou simplesmente switch, é uma forma simples para se definir diversos desvios no código a partir de uma única variável ou expressão. Havendo uma variável com diversos valores possíveis e sendo necessário um tratamento específico para cada um deles, o uso da estrutura if-else se torna confuso e dificulta a leitura do código. Nesse caso, a clareza e a facilidade estão do lado da estrutura switch.&lt;/p&gt;

&lt;p&gt;A sintaxe geral da estrutura switch é a seguinte:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/05/switch.bmp&#34;&gt;&lt;img class=&#34; size-full wp-image-48942 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/05/switch.bmp&#34; alt=&#34;switch&#34; width=&#34;514&#34; height=&#34;408&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Se for utilizada uma expressão, ela deve retornar um tipo de dados compatível com todos os valores especificados através das declarações case. Por dedução, todas as declarações devem conter valores de um mesmo tipo. Caso esteja utilizada uma variável, seu tipo também deve ser compatível com os valores das declarações.&lt;/p&gt;

&lt;p&gt;Cada um dos valores especificados com as declarações case deve ser um valor literal exclusivo. Se houver algum valor duplicado, será gerado um erro no momento em que você tentar compilar seu código.&lt;/p&gt;

&lt;p&gt;A palavra reservada break é utilizada na estrutura switch para promover um desvio da execução para a linha posterior ao final de seu bloco. Geralmente, ele é utilizado como a última instrução de cada declaração case.&lt;/p&gt;

&lt;p&gt;A palavra default indica que caso nenhum dos cases seja utilizado, a instrução que se encontra no default será executada.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – Introdução a sua API</title>
      <link>http://tableless.com.br/java-introducao-a-sua-api/</link>
      <pubDate>Mon, 18 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-introducao-a-sua-api/</guid>
      <description>&lt;p&gt;A API do Java é composta por dois tipos de recursos distintos: classes e interfaces. Ela é como um bloco dividido em duas grandes partes, são centenas de Interfaces e milhares de classes que acompanham o kit de desenvolvimento do Java e que podem ser empregadas para a realização de diversos tipos de tarefas durante a construção de um programa.&lt;/p&gt;

&lt;p&gt;Na API do Java, não existem métodos ou quaisquer tipos de dados desgarrados. O seu caráter fortemente orientado a objetos obriga a declaração de todos os métodos dentro de uma classe ou de uma interface. Do mesmo modo, não é possível declarar uma variável ou constante fora do escopo de uma classe ou de uma interface. A representação de dados deve ser feita, necessariamente, através de atributos que pertencem a uma classe ou interface específica.&lt;/p&gt;

&lt;p&gt;As classes formam uma hierarquia dentro da API do Java, e a classe java.lang.Object é a raiz dessa hierarquia. Direta ou indiretamente, toda classe tem Object como a sua superclasse, assim, todos os métodos por ela implementados são herdados por todas as demais classes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Organização&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As classes e interfaces que compõem a API do Java estão divididas em pacotes, e cada pacote agrupa um conjunto de classes e interfaces que possuem propósitos comuns. Lembre-se de que um pacote também pode conter outros pacotes, de modo que eles acabam formando uma estrutura complexa de compartimentos.&lt;/p&gt;

&lt;p&gt;A estrutura dos pacotes que abriga as classes e interfaces de Java reflete apenas a estrutura de diretórios onde os seus arquivos compilados estão dispostos. Mas, na verdade, as classes e interfaces do JDK não estão armazenadas em uma estrutura de diretórios que tenha sido criada efetivamente. Elas se encontram em um arquivo compactado chamado rt.jar, que se encontra no diretório: \jre\lib.&lt;/p&gt;

&lt;p&gt;Assim como a localização de um arquivo no disco rígido compõe-se da identificação de todos os diretórios e subdiretórios e de seu nome, a localização de uma classe ou interface compõe-se da identificação do pacote raiz, de todos os sub pacotes e de seu nome. A classe String, por exemplo, está localizada no pacote lang e este pacote está contido no pacote java. Desse modo, a localização da classe String é escrita do seguinte modo: java.lang.String.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O pacote java&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O pacote que fora chamado de java contém os recursos fundamentais do Java. É nele que estão contidas as classes e interfaces essenciais à consecução dos seus desígnios enquanto linguagem de programação, e também recursos indispensáveis para a realização de tarefas extremamente importantes para a construção de quaisquer programas.&lt;/p&gt;

&lt;p&gt;O pacote java divide-se em 13 pacotes, e cada um deles contém classes e interfaces distribuídas em diversos sub pacotes. Conhecer cada um dos milhares de componentes contidos nesse pacote é uma meta que exigira muito tempo e esforço, e não se justifica. O que importa não é dominar todos os recursos disponíveis nesse e nos outros pacotes, mas tão somente saber utilizar aquelas classes e interfaces que precisam ser aplicadas para construir determinado tipo de aplicação que você deseja desenvolver.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Conteúdo do pacote java:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      &lt;strong&gt;Pacote&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      &lt;strong&gt;Descrição&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      applet
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê as classes necessárias para criar um applet e as classes que um applet usa para se comunicar com seu contexto.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      awt
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Contém classes e interfaces utilizadas para desenhar gráficos e imagens e construir GUIs.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      beans
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Contém classes relacionadas ao desenvolvimento de componentes beans baseados na arquitetura denominada como JavaBean.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      io
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê entrada e saída para o sistema através de fluxo, serialização e arquivos de sistema.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      lang
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes que são fundamentais ao desígnio de Java enquanto linguagem de programação.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      math
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes para executar aritmética de inteiros de precisão arbitrária e aritmética decimal de precisão.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      net
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes para implementação de aplicações de redes.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      nio
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Define “buffers”, que são recipientes para dados e proveem uma prévia dos outros pacotes NIO.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      rmi
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes e interfaces para implementar aplicativos que utilizem invocação remota de métodos (RMI – Remot Method Invocation.)
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      security
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes e interfaces para implementar procedimentos de segurança de informações.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      sql
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes e interfaces para acessar a processar dados armazenados em uma fonte de dados, normalmente um banco de dados relacional.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      text
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Provê classes e interfaces para controlar texto, datas, números e mensagens de modo independente de idiomas naturais.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      util
    &lt;/td&gt;
    
    &lt;td width=&#34;512&#34;&gt;
      Contém a estrutura de coleções, modelo de eventos, facilidades com data e hora, internacionalização e classes de utilidades diversas.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O pacote javax&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O pacote javax contém várias classes e interfaces que complementam aquelas dispostas no pacote java e outras que oferecem recursos totalmente novos. Em conjunto, esses dois pacotes são os recipientes onde se encontra a base de recursos da API do Java a ser utilizada para o desenvolvimento de uma enorme diversidade de programas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parte do conteúdo do pacote javax:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      &lt;strong&gt;Pacote&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      &lt;strong&gt;Descrição&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      acessibility
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Define um contrato entre componentes de interface do usuário e uma tecnologia que provê acesso a esses componentes.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      imageio
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Pacote principal de entrada e saída de imagem.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      naming
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Contém classes e interfaces para nomear acesso a serviços.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      print
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Contém as classes e interfaces principais para o serviço de impressão do Java.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      rmi
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Contém classes e interfaces adicionais para a implementação de invocação remota de métodos.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      security
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Provê uma estrutura para autenticação e autorização através de certificados e chaves públicas.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      sound
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Provê classes e interfaces para capturar, processamento e reprodução de áudio.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      sql
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Provê acesso a fonte de dados do lado do servidor.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      swing
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Provê um conjunto de componentes “leves” para a construção de GUIs que funcionam do mesmo modo em todas as plataformas.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      transaction
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Contém classes de exceção lançadas pelo Object Request Broker (ORB).
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;92&#34;&gt;
      xml
    &lt;/td&gt;
    
    &lt;td width=&#34;484&#34;&gt;
      Provê classes que permitem o processamento de documentos XML.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;É claro que novos pacotes tendem a ser adicionados ao pacote javax no futuro, assim como podem ser adicionados ao pacote java ou os outros pacotes que definem a organização da API do Java. O próprio pacote javax não existia na primeira versão do Java, tendo sido desenvolvido e agregado posteriormente.&lt;/p&gt;

&lt;p&gt;Nestes momentos, é preciso apenas ter em mente que a API do Java compõe-se de classes e interfaces organizadas em uma estrutura de pacotes. A descrição superficial dessas estruturas é suficiente, por enquanto, tendo em vista que recursos específicos serão analisados com maior riqueza de detalhes em momento oportuno.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recursos Essenciais&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Os recursos essenciais aos desígnios do Java estão contidos no pacote java.lang. É aí que se encontram os recursos necessários para a implementação de diversas das operações fundamentais que são realizadas para a construção de grandes diversidade de aplicações.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Operações com Textos: A classe String&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Texto é qualquer expressão composta por um conjunto de caracteres, incluindo as letras do alfabeto, os números, sinais de pontuação e todos os demais caracteres reconhecidos pelo padrão Unicode. Qualquer sequência de caracteres é, pois, um texto.&lt;/p&gt;

&lt;p&gt;São diversos os tipos de operações que precisam ser realizadas com textos durante a execução de programas. A captação, comparação, validação, manipulação e exibição de textos são exemplos de operações que precisam ser realizadas com uma frequência enorme. Isso faz com que a representação de textos seja fundamental para a construção dos mais diversos tipos de programas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Principais construtores da classe String:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;149&#34;&gt;
      &lt;strong&gt;Assinatura&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td width=&#34;427&#34;&gt;
      &lt;strong&gt;Descrição&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;149&#34;&gt;
      String()
    &lt;/td&gt;
    
    &lt;td width=&#34;427&#34;&gt;
      Cria uma string vazia.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;149&#34;&gt;
      String(char[] value)
    &lt;/td&gt;
    
    &lt;td width=&#34;427&#34;&gt;
      Cria uma string a partir de um vetor de caracteres representado pelo parâmetro chamado value.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;149&#34;&gt;
      String(byte[] bytes)
    &lt;/td&gt;
    
    &lt;td width=&#34;427&#34;&gt;
      Cria uma string a partir de um vetor de bytes  representado pelo parâmetro chamado byte.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;149&#34;&gt;
      String(String original)
    &lt;/td&gt;
    
    &lt;td width=&#34;427&#34;&gt;
      Cria uma string contendo a mesma sequência de caracteres de parâmetro chamado original.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Alguns métodos da classe String:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      &lt;strong&gt;Assinatura&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      &lt;strong&gt;Descrição&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      char charAt(int index)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna o caractere contido na posição especificada pelo parâmetro index.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      int compareTo(String anotherString)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Compara o texto de duas strings e retorna um número inteiro que define a ordem destes textos. (zero significa que são iguais).
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      int compareToIgnoreCase(String anotherString)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Realiza a mesma tarefa que a anterior, porém ignorando a diferença entre caracteres maiúsculos e minúsculos.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      boolean endWith(String suffix)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Testa se a string corrente termina com o sufixo especificado.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      int indexOf(String str)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna a posição inicial, na string corrente, da substring especificada pelo parâmetro str. Se a substring não for encontrada, o retorno é -1.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      int lastIndexOf(String str)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna a posição inicial, na string corrente, da última ocorrência da substring especificada pelo parâmetro str. Se a substring não for encontrada, o retorno é   -1.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      int length()
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna o número de caracteres contidos na string corrente.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      String replaceAll(String org, String replacement)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna uma string resultante da substituição, na string corrente, de cada ocorrência da substring especificada no parâmetro org pela substring especificada no parâmetro replacement.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      boolean startsWith(String prefix)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Testa se a string corrente começa com o prefixo especificado pelo parâmetro prefix.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      String substring(int begin, int end)
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna uma nova string com a sequência de caracteres que se encontra entre as posições especificadas pelos parâmetros begin e end.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      String toLowerCase()
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna uma nova string contendo todos os caracteres da string atual convertidos para minúsculo.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;300&#34;&gt;
      String toUpperCase()
    &lt;/td&gt;
    
    &lt;td width=&#34;276&#34;&gt;
      Retorna uma nova string contendo todos os caracteres da string atual convertidos para maiúsculo.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Operações Matemáticas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Assim como a manipulação de textos é uma operação comum em quaisquer tipos de programas, a realização de operações matemáticas é muito frequente na grande maioria deles. Isso justifica a dedicação do tempo necessário para o estudo dos recursos disponíveis para suportar esse tipo de operação.&lt;/p&gt;

&lt;p&gt;As operações matemáticas básicas são suportadas pela própria linguagem Java e podem ser realizadas com o uso de operadores. Soma, subtração, multiplicação e divisão são exemplos de operações matemáticas suportadas pela linguagem através de operadores.&lt;/p&gt;

&lt;p&gt;No entanto, existem diversas operações matemáticas que não encontram suporte na linguagem. Potência, raiz quadrada, logaritmo, operações trigonométricas e até operações de arredondamento são exemplos de operações que não podem ser realizadas exclusivamente com os recursos da linguagem, para realizá-las, é preciso recorrer aos métodos da classe java.lang.Math.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alguns métodos da classe Math:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      &lt;strong&gt;Assinatura&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      &lt;strong&gt;Descrição&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static double cell(double a)
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Retorna o próximo valor double que seja um número matemático inteiro.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static double floor(double a)
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Retorna o valor double anterior que seja um número matemático inteiro.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static double rint(double a)
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Arredonda o número informado e retorna-o na forma de um double.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static long round(double a)
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Arredonda o número informado e retorna-0 na forma de um long.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static double pow(double a, double b)
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Eleva um número à determinada potência.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static double sqrt(double a)
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Calcula a raiz quadrada de um número.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;243&#34;&gt;
      static double random()
    &lt;/td&gt;
    
    &lt;td width=&#34;333&#34;&gt;
      Retorna um número aleatório entre 0 e 1.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Perceba que todos os métodos listados são estáticos, por conterem o qualificador static em suas assinaturas. Isso significa que não é preciso instanciar um objeto da classe Math para fazer uso desses métodos, basta invocá-los a partir da própria classe, do mesmo modo como se faz com seus atributos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Valores Aleatórios&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Objetos da classe java.util.Random podem ser utilizados para gerar um fluxo de dados aleatório. Enquanto o método random() da classe Math somente é capaz de gerar números aleatórios entre zero e um, um objeto da classe Random pode ser usado para gerar diferentes tipos de dados aleatórios e em diferentes intervalos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Alguns métodos da classe java.util.Random.&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      &lt;strong&gt;Assinatura&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      &lt;strong&gt;Descrição&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      boolean nextBoolean()
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      Retorna um valor booleano aleatório.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      double nextDouble()
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      Retorna um valor aleatório entre 0,0 e 0,9 como um tipo double.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      float nextFloat()
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      Retorna um valor aleatório entre 0,0 e 0,9 como um tipo float.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      int nextInt()
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      Retorna um número inteiro aleatório.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      int nextInt(int n)
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      Retorna um número inteiro aleatório entre 0 e o valor especificado através do parâmetro n.
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;158&#34;&gt;
      long nextLong()
    &lt;/td&gt;
    
    &lt;td width=&#34;418&#34;&gt;
      Retorna um número inteiro longo aleatório.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – Tipos de dados</title>
      <link>http://tableless.com.br/java-tipos-de-dados/</link>
      <pubDate>Mon, 11 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-tipos-de-dados/</guid>
      <description>&lt;p&gt;No Java, existem algumas palavras reservadas para a representação dos tipos de dados básicos que precisam ser manipulados para a construção de programas. Estes tipos de dados são conhecidos como tipos primitivos.&lt;/p&gt;

&lt;p&gt;Pode-se dividir os tipos primitivos suportados pelo Java em função da natureza de seu conteúdo. Há quatro tipos primitivos para a representação de números inteiros, dois tipos primitivos para a representação de números fracionários, um tipo primitivo para representação de caracteres e um tipo primitivo para representação dos valores booleanos.&lt;/p&gt;

&lt;p&gt;Existem milhares de classes disponíveis na API do Java e todas são tipos de dados, porém uma classe pode armazenar diversos dados ao mesmo tempo em seus atributos, e realizar tarefas através de seus métodos. Um tipo primitivo por outro lado, só armazena um único dado e não contém quaisquer métodos para realizar tarefas.&lt;/p&gt;

&lt;p&gt;Já para representar textos o Java não possui um tipo primitivo, ele possui uma classe chamada String, que serve para esse propósito, essa classe pode ser usada de modo semelhante a um tipo primitivo e ainda conta com diversos métodos disponíveis nessa classe para realizar diversas operações com o dado armazenado.&lt;/p&gt;

&lt;p&gt;Também existem classes para representar cada um dos tipos primitivos. Sempre que for preciso realizar uma operação mais complexa com algum dado, você poderá armazená-la em um objeto da classe correspondente ao invés de utilizar um tipo primitivo. Assim, poderá fazer uso dos métodos disponíveis nessa classe para realizar diversas operações com o dado armazenado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DADOS NUMÉRICOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Tipos Inteiros:&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      Tipo
    &lt;/td&gt;
    
    &lt;td width=&#34;142&#34;&gt;
      Memória consumida
    &lt;/td&gt;
    
    &lt;td width=&#34;189&#34;&gt;
      Valor Mínimo
    &lt;/td&gt;
    
    &lt;td width=&#34;187&#34;&gt;
      Valor Máximo
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      byte
    &lt;/td&gt;
    
    &lt;td width=&#34;142&#34;&gt;
      1 byte
    &lt;/td&gt;
    
    &lt;td width=&#34;189&#34;&gt;
      -128
    &lt;/td&gt;
    
    &lt;td width=&#34;187&#34;&gt;
      127
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      short
    &lt;/td&gt;
    
    &lt;td width=&#34;142&#34;&gt;
      2 byte
    &lt;/td&gt;
    
    &lt;td width=&#34;189&#34;&gt;
      -32.768
    &lt;/td&gt;
    
    &lt;td width=&#34;187&#34;&gt;
      32.767
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      int
    &lt;/td&gt;
    
    &lt;td width=&#34;142&#34;&gt;
      4 bytes
    &lt;/td&gt;
    
    &lt;td width=&#34;189&#34;&gt;
      -2.147.483.648
    &lt;/td&gt;
    
    &lt;td width=&#34;187&#34;&gt;
      2.147.483.647
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;64&#34;&gt;
      long
    &lt;/td&gt;
    
    &lt;td width=&#34;142&#34;&gt;
      8 bytes
    &lt;/td&gt;
    
    &lt;td width=&#34;189&#34;&gt;
      -9.223.372.036.854.775.808
    &lt;/td&gt;
    
    &lt;td width=&#34;187&#34;&gt;
      9.223.372.036.854.775.807
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Obs: A declaração de um número inteiro longo deve ser feita utilizando-se a letra L como sufixo. &lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Números que podem conter partes fracionárias podem ser representados por dois tipos:&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;td width=&#34;83&#34;&gt;
      Tipo
    &lt;/td&gt;
    
    &lt;td width=&#34;148&#34;&gt;
      Memória Consumida
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      Valor mínimo
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      Valor máximo
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      Precisão
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;83&#34;&gt;
      float
    &lt;/td&gt;
    
    &lt;td width=&#34;148&#34;&gt;
      4 bytes
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      -3,4028E + 38
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      3,4028E + 38
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      6 – 7 dígitos
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr&gt;
    &lt;td width=&#34;83&#34;&gt;
      double
    &lt;/td&gt;
    
    &lt;td width=&#34;148&#34;&gt;
      8 bytes
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      -1,7976E + 308
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      1,7976E + 308
    &lt;/td&gt;
    
    &lt;td width=&#34;115&#34;&gt;
      15 dígitos
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Apesar de o tipo float ocupar metade da memória consumida por um tipo double, ele é menos utilizado. Ele sofre de uma limitação que compromete seu uso em determinadas situações: somente mantém uma precisão decimal entre 6 e 7 dígitos.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Obs: A declaração de um número como um float, deve ser feito utilizando a letra F como sufixo. &lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DADOS TEXTUAIS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;É possível representar dois tipos de elementos textuais em Java: caracteres e textos. A representação de um caractere solitário é feita pelo tipo char e a representação de textos é feita pela classe String.&lt;/p&gt;

&lt;p&gt;Enquanto o tipo de char representa apenas um caractere, a representação de textos deverá ser feita pela classe String. Essa classe pode ser utilizada de forma similar aos tipos primitivos, mais os valores literais desse tipo são transcritos entre aspas e não entre apóstrofos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DADOS LÓGICOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O tipo lógico é representado, em Java, pelo tipo booleano. Este tipo pode armazenar um de dois valores possíveis: true ou false. Ele é empregado para realizar testes lógicos em conjunto com operadores relacionais e dentro de estruturas de decisão e repetição. O tipo boolean do Java equivale ao tipo boolean do Pascal.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VARIÁVEIS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Uma variável representa a unidade básica de armazenamento temporário de dados e compõe-se de um tipo, um identificador e um escopo. Seu objetivo é armazenar um dado de determinado tipo primitivo para que possa ser recuperado e aplicado em operações posteriores.&lt;/p&gt;

&lt;p&gt;Para compreender como funciona o uso de variáveis é preciso analisar como elas são criadas, de que modo recebem e armazenam dados e como estes são recuperados. Também é importante entender onde &lt;span style=&#34;text-decoration: underline&#34;&gt;elas&lt;/span&gt; podem ser declaradas e onde podem ser utilizadas, tendo em vista seu escopo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CONSTANTES&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As constantes são unidades básicas de armazenamento de dados que não devem sofrer alterações ao longo da execução do aplicativo. O uso de constantes é menos frequente que o uso de variáveis. No entanto, há situações em que elas são requeridas e, por isso, é indispensável entender o que são, para que servem e como podem ser utilizadas.&lt;/p&gt;

&lt;p&gt;A declaração de uma constante contém apenas um elemento a mais que a declaração de uma variável: a palavra reservada final. Assim como as variáveis, as constantes compõem-se de um tipo, um identificador e um escopo. Veja a sintaxe que determina como declarar e inicializar uma constante:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;final &amp;lt; tipo &amp;gt; &amp;lt; identificador &amp;gt; = &amp;lt; valor &amp;gt;;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mas enquanto a declaração e a inicialização de variáveis podem ser feitas em instruções distintas, toda constante deve ser declarada e inicializada em uma única instrução e, depois disso, não lhe pode ser atribuído outro valor.&lt;/p&gt;

&lt;p&gt;Além de tudo que foi dito sobre constantes, é importante observar uma convenção no momento de declará-las: devem ser utilizadas somente letras maiúsculas para seu identificador. A aderência a essa convenção torna o código-fonte muito mais legível, facilitando a distinção entre variáveis e constantes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – Principais características</title>
      <link>http://tableless.com.br/java-principais-caracteristicas/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-principais-caracteristicas/</guid>
      <description>&lt;p&gt;A simplicidade é uma de suas mais importantes características. É isso que possibilita que a sua aprendizagem possa ocorrer sem necessidade de treinamento intensos ou larga experiência anterior. Programadores com conhecimento das linguagens C e C++ encontrarão muitas semelhanças destas com o Java e o assimilarão de forma ainda mais rápida. Além disso, o código escrito com o Java é muito mais limpo do que aquele escrito em C ou C++.&lt;/p&gt;

&lt;p&gt;Java é orientado a objetos e, com exceção dos tipos primitivos, tudo é representado na forma de objetos. Até mesmo os tipos primitivos podem ser encapsulados em objetos sempre que isso for necessário. Os programas são compostos por classes, que representam categorias de objetos e podem herdar atributos e métodos de outras classes. A ausência de herança múltipla é compensada com uma solução muito melhor: o uso de interfaces, onde uma classe pode herdar características de uma superclasse e ainda implementar métodos de uma ou mais interfaces. Toda a variável ou método pertence a uma classe ou objeto e só pode ser invocada através dessa classe ou objeto. Isso reforça seu forte caráter orientado a objeto.&lt;/p&gt;

&lt;p&gt;O Java também garante a confiabilidade dos programas produzidos. O processo de compilação elimina uma gama enorme de possíveis problemas e uma checagem dinâmica (realizada em tempo de execução) contorna muitas situações que poderiam gerar erros.&lt;/p&gt;

&lt;p&gt;A confiabilidade dos programas escritos com o Java também é incrementada com um mecanismo eficiente para contornar situações inesperadas que podem ocorrer em tempo de execução. Essas condições excepcionais, chamas exceções, podem ser devidamente tratadas para evitar que o programa aborte, mesmo frente a situações de erro.&lt;/p&gt;

&lt;p&gt;A segurança é outro ponto muito forte do Java. Um programa sempre é verificado antes de ser executado. Essa verificação também é realizada nos navegadores e visa impedir que os applets possam provocar quaisquer danos ao computador do usuário. Ademais, como o Java não permite acesso direto à memória, impede seu uso para desenvolvimento de vírus.&lt;/p&gt;

&lt;p&gt;O Java também, é mais dinâmico que o C/C++. Ele foi projetado para se adaptar facilmente a ambientes em constante evolução (como a Internet). A inclusão de novos métodos e atributos a classes existentes pode ser feita livremente e o tipo de objeto pode ser pesquisado em tempo de execução.&lt;/p&gt;

&lt;p&gt;Como se não bastasse tudo isso, o Java contém recursos que permitem o desenvolvimento de sistemas extremamente robustos. Dentre estes recursos, destaca-se o suporte a multiprocessamento, que possibilita a um programa a realização de mais de uma tarefa ao mesmo tempo. O resultado disso é o aumento da sensibilidade interativa dos programas e seu comportamento em tempo real.&lt;/p&gt;

&lt;p&gt;Além de todas as vantagens anteriores, o Java ainda oferece facilidades para programação de sistemas cliente-servidor e sistemas distribuídos. Sua API contém uma biblioteca de classes e interfaces muito rica para se trabalhar com sockets, TCP/IP, RMI e muitos outros recursos correlatos.&lt;/p&gt;

&lt;p&gt;Devido à diversas características que o Java possui, a sua tecnologia tem provocado mudanças significativas nos processos de engenharia de software e tende a alterar até o modo como os programas são produzidos, distribuídos e utilizados.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – Como plataforma</title>
      <link>http://tableless.com.br/java-como-plataforma/</link>
      <pubDate>Thu, 30 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-como-plataforma/</guid>
      <description>&lt;p&gt;Uma plataforma é uma estrutura que possibilita a execução de softwares aplicativos. Basicamente, o que você precisa para rodar um aplicativo são um computador e um sistema operacional instalado nele. Mas os sistemas operacionais são concebidos para determinadas arquiteturas de computadores e são incompatíveis com todas as demais. Por isso, os próprios sistemas operacionais são utilizados para identificar as plataformas.&lt;/p&gt;

&lt;p&gt;Do mesmo modo que os sistemas operacionais são compatíveis apenas com determinado tipo de computador, os programas compilados com as tecnologias tradicionais somente são compatíveis com um único sistema operacional, e isso tira o sono de um desenvolvedor quando ele escreve um programa e compila em C++ para executar no Windows, e o mesmo não será possível executar em outra plataforma.&lt;/p&gt;

&lt;p&gt;O Java supera essa dificuldade, o programa escrito em Java pode ser executado em qualquer sistema operacional e, por conseguinte, em qualquer arquitetura de computador. E é exatamente isso que se refere a expressão adotada pela Sun Microsystems: “Escreva uma vez. Execute em qualquer lugar.”&lt;/p&gt;

&lt;p&gt;Para entender como é possível, basta realizar uma análise comparativa entre os processos de desenvolvimento, compilação e execução de programas com as tecnologias tradicionais e com o Java.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/04/imagem2.jpg&#34;&gt;&lt;img class=&#34; size-full wp-image-48241 aligncenter&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/04/imagem2.jpg&#34; alt=&#34;imagem&#34; width=&#34;567&#34; height=&#34;394&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note que o processo de compilação do Java gera uma representação intermediária do código (bytecodes), que pode ser interpretada por qualquer sistema operacional que tenha uma JVM (Java Virtual Machine – Máquina Virtual Java), e é essa JVM que garante que o que foi escrito em Java seja executado em qualquer sistema operacional.&lt;/p&gt;

&lt;p&gt;Dessa forma e de outras particularidades, a plataforma Java se distingue claramente das tecnologias de desenvolvimento de software tradicionais.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – O caminho do aprendizado</title>
      <link>http://tableless.com.br/java-o-caminho-aprendizado/</link>
      <pubDate>Thu, 16 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-o-caminho-aprendizado/</guid>
      <description>&lt;p&gt;Para entender o que é o Java, é preciso compreender três elementos que quando estão juntos, se torna possível o desenvolvimento de um sistema, são eles: Uma linguagem de programação, um ambiente de desenvolvimento e uma interface de programas aplicativos (Applications Programming Interface – API).&lt;/p&gt;

&lt;p&gt;Uma linguagem é composta por um conjunto de palavras e símbolos utilizados pelos programadores para escrever cada parte de um programa. Além disso, ela também define regras de sintaxe que precisam ser observadas. No Java, a linguagem é utilizada para produzir diversos elementos de um programa, tais como: classes, interfaces, atributos, métodos, variáveis, constantes, estruturas de decisão e estruturas de repetição.&lt;/p&gt;

&lt;p&gt;O ambiente de desenvolvimento é o conjunto de ferramentas necessárias para o desenvolvimento de softwares. O kit padrão do Java contém um conjunto de considerável de ferramentas, tais como: um compilador (javac), um interpretador de aplicativos (java), um visualizador de applets (appletviewer) e um gerador de documentação (javadoc). Também existem várias IDEs (Integrated Development Environment – Ambiente de Desenvolvimento Integrado) disponíveis que facilitam o processo de desenvolvimento de software, como a  IDE eclipse, que é uma das IDEs mais utilizadas pelos desenvolvedores.&lt;/p&gt;

&lt;p&gt;Porém os softwares desenvolvidos em Java não resultam somente da junção de um ambiente de desenvolvimento e de uma linguagem de programação. A isso se soma um extenso conjunto de componentes, que formam sua API. O Java contém dois tipos fundamentais de componentes em sua API: as classes e as interfaces , uma pessoa que queira estudar Java, deverá passar a maior parte do seu tempo estudando a sua API do que aprender a lidar com a linguagem e com um ambiente de desenvolvimento.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;O termo interface não deve ser confundido com “Interface gráfica”. Do mesmo modo que uma classe, uma interface pode abrigar atributos e métodos. Para evitar mal entendidos, as referências à “Interface Gráfica” são feitas através da sigla GUI (Graphic User Interface – Interface Gráfica de Usuário).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Como a API Java contém diversas classes e interfaces para o desenvolvimento de software, o desenvolvedor poderá se concentrar apenas na construção dos componentes que atenderão às necessidades do sistema que está sendo desenvolvido.&lt;/p&gt;

&lt;p&gt;Sendo assim, pode-se dizer que existem três partes distintas para se aprender acerca do Java: A linguagem de programação, a segunda diz respeito ao funcionamento das ferramentas que compõem o seu ambiente de desenvolvimento, e a terceira é o extenso conjunto de classes e interfaces que compõem a sua API.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/04/imagem1.jpg&#34;&gt;&lt;img class=&#34;aligncenter wp-image-48148 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/04/imagem1.jpg&#34; alt=&#34;&#34; width=&#34;623&#34; height=&#34;456&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pode-se perceber claramente que “linguagem Java” é uma expressão que não representa todo o caminho a ser trilhado. Para se tornar um desenvolvedor Java, é preciso estudar tanto a linguagem quanto sua API e um ambiente de desenvolvimento. Assim, o mais adequado é assumir o conceito de Java como um conjunto de tecnologias que podem ser aplicadas ao desenvolvimento de software e não apenas como uma linguagem.&lt;/p&gt;

&lt;p&gt;Ao tratar do Java tão somente como uma linguagem de programação, ignora-se o segredo de seu sucesso: a produtividade possibilitada por sua extensa API e um ambiente de execução que permite que seus programas sejam executados nos principais sistemas operacionais.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA – A ORIGEM</title>
      <link>http://tableless.com.br/java-origem/</link>
      <pubDate>Tue, 07 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/java-origem/</guid>
      <description>&lt;p&gt;Nossa história começa em 1991, quando um grupo de empregados da Sun Microsystems iniciaram um projeto para pequenos dispositivos eletrônicos de consumo, tais como o  PDA (Personal Digital Assistant), o projeto recebeu o nome de Projeto Green, e James Gosling assumiu sua coordenação.&lt;/p&gt;

&lt;p&gt;A ideia era possibilitar a criação de programas portáveis que pudessem ser executados em diversos dispositivos. Mais a equipe teria que desenvolver programas específicos para cada tipo de dispositivo, dai surgiu a ideia de desenvolver um sistema operacional que permitiria a utilização de seus programas pelos mais diversos tipos de equipamento. A nova linguagem foi batizada de Oak (carvalho), uma referência ao carvalho que James Gosling visualizava a partir de seu escritório. O sistema operacional que foi desenvolvido, foi chamado de GreenOS, e junto com ele foi construída uma interface gráfica padronizada.&lt;/p&gt;

&lt;p&gt;Após  ter um sistema operacional e uma interface gráfica, a equipe desenvolveu um avançado PDA chamado de Star7, a Sun Microsystems participou de uma competição pública para o desenvolvimento de uma tecnologia para TV a Cabo interativa, onde seria aplicado o Star7, no entanto ela perdeu essa competição, mesmo sendo um produto de alta qualidade o mercado ainda não estava preparado para o Star7. Perto de cortar o financiamento do projeto, a Sun decidiu abandonar a ênfase nos dispositivos eletrônicos e se voltar para a internet que já começava a crescer.&lt;/p&gt;

&lt;p&gt;O nome da linguagem desenvolvida pelo projeto Green foi mudada de Oak para Java, que  foi uma homenagem à uma ilha da Indonésia de onde os Norte-Americanos importavam o café que era consumido pela equipe de James Gosling. Ate 1994, não havia uma aplicação definida para o Java. Foi quando Jonathan Payne e Patrick Naughton criaram um novo navegador para Web que podia executar programas escritos em Java (applets), batizado de Web Runner. E em 1996, em uma iniciativa inédita, a Sun Microsystems resolveu disponibilizar gratuitamente um kit de desenvolvimento de software para a comunidade, que ficou conhecido como Java Developer`s Kit (JDK). Desde então a aceitação da tecnologia Java cresceu rapidamente entre empresas e desenvolvedores. A Sun Microsystems lançou o JDK 1.1 com melhorias significativas para o desenvolvimento de aplicações gráficas e distribuídas. Depois disso, a empresa continuou lançando novas versões gratuitas com novas melhorias e recursos.&lt;/p&gt;

&lt;p&gt;Em abril de 2009, a Oracle ofereceu US$ 7,4 bilhões pela aquisição da Sun Microsystems e a proposta foi aceita. Essa aquisição deu à Oracle a propriedade de vários produtos, incluindo o Java e o sistema operacional Solaris. Em comunicado, a Oracle afirmou que o Java foi o software mais importante adquirido ao longo de sua história. Muitas especulações foram feitas a cerca do futuro do Java depois de passar a ser propriedade da Oracle. Mais com certeza essa aquisição contribuiu muito para que o Java tivesse um salto qualitativo.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>