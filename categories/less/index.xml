<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Less on Tableless</title>
    <link>http://tableless.com.br/categories/less/index.xml</link>
    <description>Recent content in Less on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="http://tableless.com.br/categories/less/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sass vs. LESS vs. Stylus: Batalha dos Pré-processadores</title>
      <link>http://tableless.com.br/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</link>
      <pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar:&lt;/p&gt;

&lt;h2 id=&#34;sintaxe&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Essa sintaxe não é por causa de ser mais antiga e sim pois no início o &lt;strong&gt;Sass&lt;/strong&gt; era parte de um outro pré-processador chamado &lt;strong&gt;Haml&lt;/strong&gt; criado por desenvolvedores &lt;strong&gt;Ruby&lt;/strong&gt;, e por causa disso as folhas de estilo escritas com &lt;strong&gt;Sass&lt;/strong&gt; utilizavam uma sintaxe como a do &lt;strong&gt;Ruby&lt;/strong&gt;, sem chaves, ponto e vírgula e controlado por identação.&lt;/p&gt;

&lt;h3 id=&#34;stylus&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-1&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-1&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-1&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-1&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-2&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-2&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-2&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Como mencionado nos comentários, o LESS tem suporte a herança e pode ser feita com a seguinte sintaxe:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p {
        &amp;:extend(.block);
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;h2 id=&#34;importação&#34;&gt;Importação&lt;/h2&gt;

&lt;p&gt;Na comunidade CSs, importar CSS é visto com maus olhos por utilizar diversas chamadas HTTP. Importar com um pré-processador funciona de forma diferente no entanto. Se você importar um arquivo com qualquer um dos três pré-processadores, ele irá literalmente pegar todo o conteúdo do arquivo durante a importação e gerar apenas um arquivo. Lembre-se que arquivos .css comuns importados compilam com o código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;file.css&#34;;
&lt;/pre&gt;

&lt;p&gt;Lembre-se também que mixins e variáveis podem ser importadas e usadas em sua folha de estilo principal. Importação faz com que possamos criar arquivos separados para uma melhor organização.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-1&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* arquivo.{extensao} */
body {
    background: #eee;
}
&lt;/pre&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
@import &#34;arquivo.{extensao}&#34;;
 
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-3&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;h2 id=&#34;introdução-1&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;-&amp;gt;Pré-processadores produzem CSS que funciona em todos os browsers&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Eles fazem isso compilando o código que escrevemos em CSS puro que pode ser usado em qualquer browser de agora até a era das pedras. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar&lt;/p&gt;

&lt;h2 id=&#34;sintaxe-1&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador CSS é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less-1&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-3&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis-1&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass-2&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-3&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-4&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-4&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento-1&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-2&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-5&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins-1&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-3&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-4&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-5&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-6&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança-1&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus-1&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus-1&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-5&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less-1&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
body {
    background: #eee;
}
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h2 id=&#34;funções-de-cores&#34;&gt;Funções de Cores&lt;/h2&gt;

&lt;p&gt;Funções de cores são funções nativas que transformam uma cor por compilação. Podem ser extremamente úteis para criar gradientes, escurecer cores no &amp;#8220;hover&amp;#8221; de elementos e muito mais.&lt;/p&gt;

&lt;h3 id=&#34;sass-4&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten($color, 10%); /* retorna uma cor 10% mais clara que $color */
darken($color, 10%);  /* retorna uma cor 10% mais escura $color */
 
saturate($color, 10%);   /* retorna uma cor 10% mais saturada que $color */
desaturate($color, 10%); /* retorna uma cor 10% menos saturada que $color */
 
grayscale($color);  /* retorna $color na escala de cinza */
complement($color); /* retorna cor complementar de $color */
invert($color);     /* retorna cor inversa de $color */
 
mix($color1, $color2, 50%); /* mistura $color1 com $color2 com um peso de 50% */
&lt;/pre&gt;

&lt;p&gt;Essas é apenas uma pequena lista de funções de cores disponíveis no Sass. A lista completa das funções de cores disponíveis no Sass pode ser encontrada na &lt;a href=&#34;http://sass-lang.com/documentation/Sass/Script/Functions.html&#34; target=&#34;_blank&#34;&gt;documentação do Sass&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Funções de cores podem ser usadas em qualquer lugar que uma cor é válida no CSS. Veja um exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$color: #0982C1;
 
h1 {
    background: $color;
    border: 3px solid darken($color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-6&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(@color, 10%); /* retorna uma cor 10% mais clara que @color */
darken(@color, 10%);  /* retorna uma cor 10% mais escura @color */
 
saturate(@color, 10%);   /* retorna uma cor 10% mais saturada que @color */
desaturate(@color, 10%); /* retorna uma cor 10% menos saturada que @color */
 
spin(@color, 10); /* retorna uma cor 10 graus acima na matiz/tonalidade que @color */
spin(@color, -10); /* retorna uma cor 10 graus abaixo na matiz/tonalidade que @color */
 
mix(@color1, @color2); /* mistura @color1 com @color2 */
&lt;/pre&gt;

&lt;p&gt;A lista de todas as funções disponíveis no LESS pode encontrada na &lt;a href=&#34;http://lesscss.org/#-color-functions&#34; target=&#34;_blank&#34;&gt;documentação LESS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no LESS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@color: #0982C1;
 
h1 {
    background: @color;
    border: 3px solid darken(@color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-6&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(color, 10%); /* retorna uma cor 10% mais clara que &#39;color&#39; */
darken(color, 10%);  /* retorna uma cor 10% mais escura &#39;color&#39; */
 
saturate(color, 10%);   /* retorna uma cor 10% mais saturada que &#39;color&#39; */
desaturate(color, 10%); /* retorna uma cor 10% menos saturada que &#39;color&#39; */
&lt;/pre&gt;

&lt;p&gt;A lista completa de todas funções de cores disponíveis no Stylus pode ser encontrada na &lt;a href=&#34;http://stylus-lang.com/docs/bifs.html&#34; target=&#34;_blank&#34;&gt;documentação Stylus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no Stylus:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;color = #0982C1
 
h1
    background color
    border 3px solid darken(color, 50%)
&lt;/pre&gt;

&lt;h2 id=&#34;operações&#34;&gt;Operações&lt;/h2&gt;

&lt;p&gt;Fazer cálculos no CSS é bastante útil e agora totalmente possível. É bem simples e é dessa maneira que fazemos:&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-3&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: (14px/2);
    top: 50px + 100px;
    right: 100px - 50px;
    left: 10 * 10;
}
&lt;/pre&gt;

&lt;h2 id=&#34;aplicações-práticas&#34;&gt;Aplicações Práticas&lt;/h2&gt;

&lt;p&gt;Nós falamos de diversas funcionalidades e novas coisas que pré-processadores podem fazer, mas não mostramos nada na prática ainda. Veja uma pequena lista de aplicações no mundo real em que um pré-processador é um salva-vidas.&lt;/p&gt;

&lt;h3 id=&#34;vendor-prefixes&#34;&gt;Vendor Prefixes&lt;/h3&gt;

&lt;p&gt;Essa é uma das principais razões para se usar um pré-processador e por um motivo bom &amp;#8211; economia gigante de tempo e lágrimas. Criar um mixin para cuidar dos vendor prefixes é fácil e nos salva de uma codificação repetitiva e dolorosa. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-5&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin border-radius($values) {
    -webkit-border-radius: $values;
        -moz-border-radius: $values;
            border-radius: $values;
}
 
div {
    @include border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-7&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.border-radius(@values) {
    -webkit-border-radius: @values;
        -moz-border-radius: @values;
            border-radius: @values;
}
 
div {
    .border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-7&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;border-radius(values) {
    -webkit-border-radius: values;
        -moz-border-radius: values;
            border-radius: values;
}
 
div {
    border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-7&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;div {
    -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
            border-radius: 10px;
}
&lt;/pre&gt;

&lt;h3 id=&#34;texto-3d&#34;&gt;Texto 3D&lt;/h3&gt;

&lt;p&gt;Simular um texto 3D utilizando diversos text-shadows é uma grande ideia. O único problema é que mudar a cor depois de criar é difícil e incômodo. Usando mixins e funções de cores, podemos criar um texto 3D e mudar sua cor sem nenhuma dificuldade.&lt;/p&gt;

&lt;h4 id=&#34;sass-6&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin text3d($color) {
    color: $color;
    text-shadow: 1px 1px 0px darken($color, 5%),
            2px 2px 0px darken($color, 10%),
            3px 3px 0px darken($color, 15%),
            4px 4px 0px darken($color, 20%),
            4px 4px 2px #000;
}
 
h1 {
    font-size: 32pt;
    @include text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-8&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.text3d(@color) {
    color: @color;
    text-shadow: 1px 1px 0px darken(@color, 5%),
            2px 2px 0px darken(@color, 10%),
            3px 3px 0px darken(@color, 15%),
            4px 4px 0px darken(@color, 20%),
            4px 4px 2px #000;
}
 
span {
    font-size: 32pt;
    .text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-8&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;text3d(color)
    color: color
    text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000
span
    font-size: 32pt
    text3d(#0982c1)
&lt;/pre&gt;

&lt;p&gt;Escolhi escrever os &amp;#8220;text-shadows&amp;#8221; do Stylus em apenas uma linha pois omiti as chaves.&lt;/p&gt;

&lt;h4 id=&#34;css-compilado-8&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;span {
    font-size: 32pt;
    color: #0982c1;
    text-shadow: 1px 1px 0px #097bb7, 
            2px 2px 0px #0875ae, 
            3px 3px 0px #086fa4, 
            4px 4px 0px #07689a, 
            4px 4px 2px #000;
}
&lt;/pre&gt;

&lt;h4 id=&#34;resultado-final&#34;&gt;Resultado Final&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.tutsplus.com/net/uploads/legacy/1144_preprocshootout/text3d.png&#34; alt=&#34;Texto 3D&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;colunas&#34;&gt;Colunas&lt;/h3&gt;

&lt;p&gt;Usar operações numéricas e variáveis para colunas é uma ideia que tive da primeira vez que estava brincando com pré-processadores CSS. Declarando a largura desejada em uma variável, podemos facilmente alterá-la sem precisar de nenhum cálculo mental. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-7&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$siteWidth: 1024px;
$gutterWidth: 20px;
$sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: $siteWidth;
}
.content {
    float: left;
    width: $siteWidth - ($sidebarWidth+$gutterWidth);
}
.sidebar {
    float: left;
    margin-left: $gutterWidth;
    width: $sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-9&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@siteWidth: 1024px;
@gutterWidth: 20px;
@sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: @siteWidth;
}
.content {
    float: left;
    width: @siteWidth - (@sidebarWidth+@gutterWidth);
}
.sidebar {
    float: left;
    margin-left: @gutterWidth;
    width: @sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-9&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;siteWidth = 1024px;
gutterWidth = 20px;
sidebarWidth = 300px;
 
body {
    margin: 0 auto;
    width: siteWidth;
}
.content {
    float: left;
    width: siteWidth - (sidebarWidth+gutterWidth);
}
.sidebar {
    float: left;
    margin-left: gutterWidth;
    width: sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-9&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: 0 auto;
    width: 1024px;
}
.content {
    float: left;
    width: 704px;
}
.sidebar {
    float: left;
    margin-left: 20px;
    width: 300px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;peculiaridades-notáveis&#34;&gt;Peculiaridades Notáveis&lt;/h2&gt;

&lt;p&gt;Existem algumas peculiaridades ao usar um pré-processador CSS. Irei falar de algumas engraçadas, mas se você está realmente interessado em encontrar todas elas eu recomendo você vasculhar toda a documentação, ou melhor, começar a usar um pré-processador na sua codificação diária.&lt;/p&gt;

&lt;h3 id=&#34;relatório-de-erros&#34;&gt;Relatório de Erros&lt;/h3&gt;

&lt;p&gt;Se você já escreveu CSS por uma boa quantia de tempo, tenho certeza que você já chegou a um ponto onde você tinha um erro em algum lugar e simplesmente não conseguia o encontrar. Se você é como eu, provavelmente passou a tarde toda arrancando os cabelos fora e comentando diversas coisas para caçar o erro.&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS relatam os erros. Simples assim. Se tem alguma coisa errada em seu códigom ele te fala onde e, se você estiver com sorte até mesmo o porquê. Você pode dar uma olhada &lt;a href=&#34;http://tjholowaychuk.com/post/5002088731/stylus-vs-sass-vs-less-error-reporting&#34; target=&#34;_blank&#34;&gt;nesse post&lt;/a&gt; caso esteja interessado em ver como os erros são relatados em diferentes pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;comentários&#34;&gt;Comentários&lt;/h3&gt;

&lt;p&gt;Quando um pré-processador CSS está compilando, qualquer comentário escrito com barras duplas &amp;#8220;//&amp;#8221; é excluído e qualquer comentários escrito com barra e asterisco &amp;#8220;/* */&amp;#8221; não é alterado. Dito isso, use comentários com barras duplas para comentários que você queira na versão não compilada e comentários com barra e asterisco para comentários que serão visíveis após a compilação.&lt;/p&gt;

&lt;p&gt;Observação: Se você compilar os arquivos, minificando-os, todos comentários são excluídos.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Cada um dos pré-processadores que falamos (Sass, LESS e Stylus) possui um modo único de realizar a mesma tarefa &amp;#8211; dando a nós desenvolvedor a habilidade de usar funcionalidades úteis mantendo a compatibilidade entre browsers e um código limpo.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mesmo não sendo uma exigência para o desenvolvimento, pré-processadores podem economizar muito tempo e tem funcionalidades bastante úteis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu aconselho todos vocês a utilizar e testar a maior quantidade de pré-processadores possível, pois assim você poderá escolher efetivamente um favorito e saber o porquê ele é seu favorito dentre tantos outros. Se você ainda não testou usar nenhum pré-processador para escrever seu CSS, eu recomendo grandemente a você testar.&lt;/p&gt;

&lt;p&gt;Você tem alguma funcionalidade de seu pré-processador favorito que não foi mencionada? Há algo que algum pré-processador possa fazer e outros não? Conte-nos nos comentários abaixo!&lt;/p&gt;

&lt;p&gt;Traduzido e adaptado de: &lt;a href=&#34;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320&#34;&gt;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout&amp;#8211;net-24320&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Workflow Front-end</title>
      <link>http://tableless.com.br/workflow-front-end/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/workflow-front-end/</guid>
      <description>

&lt;p&gt;O desenvolvimento em html, javascript e CSS é uma forma mágica de se construir um mundo novo a cada linha de código. Os mágicos do front-end precisam de cartolas para que retirem seus coelhos. Essas cartolas e varinhas mágicas devem ser escolhidas a dedo, para que a mágica aconteça de forma suave e agradável à plateia.&lt;/p&gt;

&lt;p&gt;Cada mágico tem sua técnica, portanto o objetivo não é estabelecer um padrão imutável, mas estabelecer diretrizes que possam servir de auxílio a qualquer ilusionista. Vamos entender magia.&lt;/p&gt;

&lt;h2 id=&#34;baralho&#34;&gt;Baralho&lt;/h2&gt;

&lt;p&gt;Todo mágico possui um baralho. Com ele é possível fazer um número imenso de ilusões. Tão versátil quanto um baralho, deve ser o editor de texto a ser usado pelo desenvolvedor.&lt;/p&gt;

&lt;p&gt;Vamos falar de dois editores: Edge Code e Sublime Text.&lt;/p&gt;

&lt;p&gt;O Edge Code tem como objetivo permitir o foco no trabalho, para isso ele tem uma interface propositalmente simples. Uma mágica que adoro nele é poder editar conteúdo de um arquivo por meio de outro com base em uma relação específica – ou seja, tenho no arquivo html uma marcação que faz referência a uma classe CSS, clicando com o botão direito nessa classe e selecionando quick edit podemos editar o CSS do arquivo externo com base no arquivo html. Esse baralho tem muito mais mágicas.&lt;/p&gt;

&lt;p&gt;O Sublime Text tem tantos recursos que possibilitam uma produtividade imensa. Quando você acessa &lt;a href=&#34;http://www.sublimetext.com/&#34;&gt;http://www.sublimetext.com/&lt;/a&gt;, nota-se o foco em mostrar o quão produtivo o Sublime Text é. Uma mágica de produtividade é a possibilidade de selecionar um texto que se repete em um arquivo html por meio da tecla de atalho Ctrl+d e alterar todos ao mesmo tempo. Adoro isso.&lt;/p&gt;

&lt;h2 id=&#34;cartola&#34;&gt;Cartola&lt;/h2&gt;

&lt;p&gt;O NodeJS permite que mágicas que eram feitas somente no palco – navegador –, possam ser feitas atrás das cortinas – servidor. No entanto essas mágicas são cada vez mais complexas, gerando uma dependência de recursos que necessitariam de outra ferramenta mágica para gerenciá-las.&lt;/p&gt;

&lt;p&gt;Essa outra ferramenta mágica é nossa cartola. Dela tiramos tudo que é necessário para fazermos o show. Duas cartolas não podem deixar de serem conhecidas: NPM e Bower.&lt;/p&gt;

&lt;p&gt;O NPM é o que todo gerenciador de dependências precisa ser: instalador de pacotes, gerenciador de versão e gerenciador de dependências.&lt;/p&gt;

&lt;p&gt;O Bower é o que o NPM é, mas para componentes front-end.&lt;/p&gt;

&lt;p&gt;Se este é o cenário, então é bom termos duas cartolas, cada uma fazendo seu tipo de mágica: NPM no desenvolvimento com Grunt, Gulp, JSHint, etc; e Bower para componentes front-end.&lt;/p&gt;

&lt;h2 id=&#34;assistentes&#34;&gt;Assistentes&lt;/h2&gt;

&lt;p&gt;Assistentes de palco são vitais no contexto de muitas mágicas. Além de distrair quem vê o espetáculo, elas embelezam o ambiente. Elas são o CSS da ilusão.&lt;/p&gt;

&lt;p&gt;Frameworks de estilo podem agilizar muito um trabalho, porque muitas das preocupações iniciais do projeto, podem ser deixadas de lado pela adoção de um padrão, que já respondeu a todas elas. Nossas assistentes de palco são: Bootstrap e Pure.&lt;/p&gt;

&lt;p&gt;Bootstrap é de longe a ferramenta mais popular para atribuição de estilo aos projetos. Pontos positivos: variedade de componentes, utilizado por grandes empresas que contribuem com o projeto e boa documentação. Ele é a assistente que sabe como as mágicas são feitas.&lt;/p&gt;

&lt;p&gt;Pure tem como objetivo fornecer estilo totalmente independente de qualquer javascript e de uma maneira muito leve. É uma assistente magrinha que faz seu trabalho bem feito.&lt;/p&gt;

&lt;p&gt;É inquestionável que a aparência faz muita diferença.&lt;/p&gt;

&lt;h2 id=&#34;caixas-e-lâminas&#34;&gt;Caixas e lâminas&lt;/h2&gt;

&lt;p&gt;Na mágica da mulher cortada ao meio, uma mulher entra numa caixa e o mágico enfia uma lâmina no meio da caixa, e ela é separada em duas partes. As mãos, a cabeça e os pés continuam se mexendo. Quando uso pré-processadores CSS me sinto separado um corpo ao meio, mas ao mesmo tempo confiando que ele irá unir as partes e no final teremos um corpo inteiro.&lt;/p&gt;

&lt;p&gt;É claro que escrever CSS puro gerará menos código que o uso errôneo de mixins em SASS. Mas devemos medir a relação de custo e benefício em relação a produtividade (após a curva de aprendizagem ser superada) e qualidade do nosso código, para podermos escolher aquilo que é melhor para o projeto &amp;#8211; espetáculo. Nossas caixas e lâminas para separarem corpos podem ser: LESS e SASS.&lt;/p&gt;

&lt;p&gt;As características da LESS que devem ser sempre destacadas são, em sua maioria, comuns aos pré-processadores. Mas devem ser ditas aqui:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Variáveis: valores que são usados em vários lugares podem ser reutilizados por todo o estilo do projeto, e quando uma alteração for necessária, poderá ser feita com muita facilidade.&lt;/li&gt;
&lt;li&gt;Mixins: servem ao mesmo propósito das variáveis – a reutilização –, mas sendo usadas para classes completas. Podendo incluir uma classe dentro de outra classe, como se fosse uma propriedade.&lt;/li&gt;
&lt;li&gt;Aninhamento: a possibilidade de aninhar seletores dentro de outros seletores é um truque que me encanta muito. Porque ele criará os seletores longos por conta própria e você ficará com o trabalho de apenas construir a hierarquia a seletores por meio de aninhamento.&lt;/li&gt;
&lt;li&gt;Operações: executar operações com propriedades e cores por meio do CSS é tão fora de cogitação que se torna muito surpreendente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SASS faz tudo isso descrito acima, e faz antes de o LESS ter feito. Mas a consideração que deve ser feita é: LESS tem uma sintaxe mais simples, que leva a uma curva de aprendizagem menor, e quando essa curva atinge uma boa inclinação, ela é mais produtiva.&lt;/p&gt;

&lt;h2 id=&#34;automatização&#34;&gt;Automatização&lt;/h2&gt;

&lt;p&gt;Muitas coisas precisam ser feitas, que não necessariamente são observadas, mas tem valor. Isso se aplica a tudo na vida. Montar o palco para o espetáculo, preparar e limpar as ferramentas, checar se tudo está apto para funcionamento, etc. Concatenar arquivos, minificar código, realizar o deploy, etc.&lt;/p&gt;

&lt;p&gt;Estas tarefas podem continuar a serem feitas, mas sem o trabalho que normalmente se tem para as suas execuções. A ferramenta a ser usada neste caso é o Grunt.&lt;/p&gt;

&lt;p&gt;Com o Grunt você pode automatizar tarefas para serem executadas via linha de comando. Basta ter o NodeJS e configurar as tarefas a serem automatizadas.&lt;/p&gt;

&lt;h2 id=&#34;qualidade&#34;&gt;Qualidade&lt;/h2&gt;

&lt;p&gt;Uma mágica bem feita pode ser repetida diversas vezes, e ainda causará boas impressões. Isso se deve a qualidade com que a mágica foi feita. Existe a melhor maneira de executá-la, e quando isso é feito, tudo flui muito bem. Escrever códigos javascript e css com qualidade &amp;#8211; o que inclui boas práticas de sintaxe e construção – é um desafio, porque escrever sem boas práticas também funciona.&lt;/p&gt;

&lt;p&gt;Para verificar a qualidade do nosso código temos: JSLint, JSHint e CSSLint.&lt;/p&gt;

&lt;p&gt;JSLint realiza uma busca com foco em erros de sintaxe e erros estruturais.&lt;/p&gt;

&lt;p&gt;JSHint é um fork do JSLint com uma melhoria que permite customizações, ele permite flexibilidade.&lt;/p&gt;

&lt;p&gt;CSSLint tem o objetivo de verificar além da sintaxe a performance do CSS.&lt;/p&gt;

&lt;h2 id=&#34;enfim&#34;&gt;Enfim&lt;/h2&gt;

&lt;p&gt;Cada mágico tem um conjunto de mágicas que são apresentadas. Mas todos tem o mesmo objetivo: encantar. Todo desenvolvedor precisa encantar a todos para ter seu trabalho reconhecido. Essas ferramentas, e muitas outras, podem fazer a diferença. Então faça a diferença.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Em um relacionamento sério com generators front-end – Parte 2</title>
      <link>http://tableless.com.br/em-um-relacionamento-serio-com-generators-front-end-parte-2/</link>
      <pubDate>Wed, 10 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://tableless.com.br/em-um-relacionamento-serio-com-generators-front-end-parte-2/</guid>
      <description>

&lt;h1 id=&#34;o-início&#34;&gt;O início&lt;/h1&gt;

&lt;p&gt;O objetivo desse post não é para fazer com que os desenvolvedores só usem esta ferramenta, e sim para apresentar opções de desenvolvimentos ágeis que podem ser úteis no seu dia a dia. É uma ferramenta a qual lhe oferece um stack completo de estrutura de projeto, basta você saber como usar e para que vai usar.&lt;/p&gt;

&lt;h3 id=&#34;o-yeoman&#34;&gt;O Yeoman&lt;/h3&gt;

&lt;p&gt;O Yeoman é considerado uma ferramenta web de andaimes para criação de webapp modernos, nele você consegue montar um esquema de trabalho facilitando seu desenvolvimento. Seu fluxo de trabalho é composto por 3 ferramentas melhorando sua produtividade e satisfação.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;YO &amp;#8211; Conjunto de geradores que nos permite prototipar&lt;/li&gt;
&lt;li&gt;Gruntjs &amp;#8211; Gerencia suas tarefas de forma automatizadas&lt;/li&gt;
&lt;li&gt;Bower &amp;#8211; Gerencia suas dependências aplicadas no projeto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS: São ferramentas que por padrão já vem com o Yeoman, porém temos a opção de usar o Gulp para gerenciar nossas tarefas.&lt;/p&gt;

&lt;h3 id=&#34;ta-me-convence&#34;&gt;Ta, me convence!&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/convence.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46124&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/convence.jpg&#34; alt=&#34;convence&#34; width=&#34;477&#34; height=&#34;275&#34; srcset=&#34;uploads/2014/12/convence.jpg 477w, uploads/2014/12/convence-241x139.jpg 241w, uploads/2014/12/convence-400x230.jpg 400w&#34; sizes=&#34;(max-width: 477px) 100vw, 477px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O Yeoman sendo uma ferramenta completa, pode proporcionar para você formas práticas e ágeis de desenvolvimento com menos tempo e com boa qualidade. Alguns criticam, outros elogiam, mas você só saberá o resultado se positivo ou negativo, quando usar esse brinquedinho.&lt;/p&gt;

&lt;p&gt;Penso o seguinte: Uma ferramenta nova no marcado ou até mesmo uma antiga com novas versões e novas features, precisam ser exploradas para saber o que a mesma pode nos proporcionar. Por isso nunca se intimide com novas tecnologias e sim aproveite para ganhar conhecimentos.&lt;/p&gt;

&lt;h3 id=&#34;dicas-importantes-antes-de-praticar&#34;&gt;Dicas importantes antes de praticar&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/dica.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46127&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/dica.jpg&#34; alt=&#34;dica&#34; width=&#34;400&#34; height=&#34;245&#34; srcset=&#34;uploads/2014/12/dica.jpg 400w, uploads/2014/12/dica-226x139.jpg 226w&#34; sizes=&#34;(max-width: 400px) 100vw, 400px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Antes de mais nada já saiba que não ter medo do terminal é um diferencial. Sacanagem Hahaha. Mas é importante saber que a maioria das configurações e monitoramento serão via terminal, por isso é bom entender e interpretar cada linha de comando digitada.&lt;/p&gt;

&lt;p&gt;Lembrando que para usar o Yeoman é preciso ter Nodejs instalado em sua máquina, por isso se você não tem essa plataforma, baixe &lt;a href=&#34;http://nodejs.org/download/&#34;&gt;aqui&lt;/a&gt;, instale e parte para a próxima etapa. Após a instalação do nodejs o resto é mágica!&lt;/p&gt;

&lt;p&gt;Uma observação válida a ser feita é o seguinte: Você que desenvolve com Mac OS ou Linux *-* por padrão já vem instalado o Ruby e para quem desenvolve em windows é preciso instalar os dois: Nodejs e Ruby. Você pode baixar o ruby bem &lt;a href=&#34;https://www.ruby-lang.org/pt/downloads/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;vendo-teorias-na-prática&#34;&gt;Vendo teorias na prática&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/vendo-tv.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46128&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/vendo-tv.jpg&#34; alt=&#34;vendo-tv&#34; width=&#34;381&#34; height=&#34;315&#34; srcset=&#34;uploads/2014/12/vendo-tv.jpg 381w, uploads/2014/12/vendo-tv-168x139.jpg 168w&#34; sizes=&#34;(max-width: 381px) 100vw, 381px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Conforme comentado acima, precisa ter nodejs instalado, por isso instale e após a instalação seguia os passos seguintes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Digite o código abaixo via linha de comando na raiz do seu projeto. O mesmo instala o Yo, Gruntjs e Bower de forma global, podendo usar também Gulp. &lt;pre class=&#34;lang-html&#34;&gt;npm install -g yo grunt-cli bower&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instale o generator da aplicação, nesse caso o generator escolhido para uso é o &amp;#8220;webapp&amp;#8221;. &lt;pre class=&#34;lang-html&#34;&gt;npm install generator-webapp&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inicie a aplicação com YO. &lt;pre class=&#34;lang-html&#34;&gt;yo webapp&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O comando &amp;#8220;generator-webapp&amp;#8221; é o gerador de aplicações web padrão que será um projeto contendo HTML5 Boilerplate , jQuery , Modernizr e Bootstrap . Você vai ter uma opção durante as instruções interativas para não incluir muitos destes.&lt;/p&gt;

&lt;h3 id=&#34;mas-o-que-vem-depois&#34;&gt;Mas o que vem depois?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/01.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46228&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/01.jpg&#34; alt=&#34;01&#34; width=&#34;338&#34; height=&#34;190&#34; srcset=&#34;uploads/2014/12/01.jpg 400w, uploads/2014/12/01-247x139.jpg 247w&#34; sizes=&#34;(max-width: 338px) 100vw, 338px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Após o processo de instalação seguida passo a passo, a ferramenta já pode ser usada para criar suas aplicações. Você vai perceber que o YO já te retorna uma estrutura de pasta bem completa com tudo que você precisa e ainda alguns recursos a mais. Veja abaixo!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-raiz.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46230&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-raiz.jpg&#34; alt=&#34;estrutura raiz&#34; width=&#34;193&#34; height=&#34;269&#34; srcset=&#34;uploads/2014/12/estrutura-raiz.jpg 233w, uploads/2014/12/estrutura-raiz-99x139.jpg 99w&#34; sizes=&#34;(max-width: 193px) 100vw, 193px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Analisando a estrutura, digo o seguinte:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A pasta &lt;strong&gt;app&lt;/strong&gt; é onde vai rodar toda sua aplicação em modo de desenvolvimento. É lá que você cria seus arquivos HTML / CSS / JavaScript e entre outros. Mas essa pasta vamos ver com detalhes já já.&lt;/li&gt;
&lt;li&gt;A pasta &lt;strong&gt;bower_componnets&lt;/strong&gt; é criada pelo bower, onde você vai baixar e usar componentes como bootstrap, AngularJS, Backbone e entre outros e por padrão ele já traz o jQuery para você. Caso você não goste do nome “bower_componentes” você tem a opção de criar uma pasta como “libs” ou “componentes” e apontar seus componentes baixados para está nova pasta, só precisa criar um arquivo “.bowerrc” e lá você aponta para tal pasta. Exemplo: { app/libs ou app/componentes }&lt;/li&gt;
&lt;li&gt;A pasta &lt;strong&gt;node_modules&lt;/strong&gt; são os módulos instalados pelo nodejs, lá você vai ver alguns plugins do Gruntjs instalados por padrão, podendo ainda instalar outros plugins.&lt;/li&gt;
&lt;li&gt;Os arquivos &lt;strong&gt;Gruntfile&lt;/strong&gt; e &lt;strong&gt;Bower.json&lt;/strong&gt; são de configurações de componentes, onde o Gruntfile armazena todas as tarefas automatizadas do gruntjs como: minificação, compilação e otimização. Já o bower.json é um arquivo simples que retorna dados importantes dos componentes gerenciados no bower e armazena os componentes usados e suas versões.&lt;/li&gt;
&lt;li&gt;Os outros arquivos são de configuração da ferramenta, incluindo os arquivos ocultos.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-tal-pasta-app-da-minha-aplicação&#34;&gt;A tal pasta APP da minha aplicação&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/02.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46231&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/02.jpg&#34; alt=&#34;02&#34; width=&#34;355&#34; height=&#34;239&#34; srcset=&#34;uploads/2014/12/02.jpg 425w, uploads/2014/12/02-206x139.jpg 206w, uploads/2014/12/02-400x269.jpg 400w&#34; sizes=&#34;(max-width: 355px) 100vw, 355px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Enfim chegamos a pasta de desenvolvimento, é aqui que começa toda a sua aplicação, você não precisa mexer em nenhuma outra pasta, tudo que você precisa mexer e criar vai ser dentro deste diretório, beleza? Veja como funciona a estrutura da pasta e logo após vamos ver funcionando e depois daremos o &lt;strong&gt;build&lt;/strong&gt; *-*&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-app.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46232&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-app.jpg&#34; alt=&#34;estrutura-app&#34; width=&#34;134&#34; height=&#34;277&#34; srcset=&#34;uploads/2014/12/estrutura-app.jpg 154w, uploads/2014/12/estrutura-app-67x139.jpg 67w&#34; sizes=&#34;(max-width: 134px) 100vw, 134px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Acredito que detalhar essa estrutura não tem tanta necessidade, pois as pastas e arquivos já falam por si, não é mesmo? Mas qualquer dúvida pode deixar seu comentário que responderei com prazer.&lt;/p&gt;

&lt;p&gt;Bom, você já instalou as ferramentas (Yo/Gruntjs/bower), já instalou o generator que será usado (generator-webapp) e executou o “yo” que retornou essa estrutura de pasta. Agora para ver como funciona é simples. Execute o comando abaixo, ele vai criar um server local para você ir debugando sua aplicação e vendo como ela está se comportanto no browser e o mais legal é que você não precisa dar F5, pois por padrão já vem instalado o “livereload” plugin do grunt que atualiza automaticamente sua aplicação no browser  =)&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;grunt server&lt;/pre&gt;

&lt;p&gt;Após isso você criar sua aplicação normalmente, usando como ponto de partida o arquivo index.html e os diretórios presentes.&lt;/p&gt;

&lt;h3 id=&#34;e-se-eu-quiser-baixar-outros-componentes-e-plugins&#34;&gt;*&lt;strong&gt;&lt;em&gt;&lt;em&gt;E se eu quiser baixar outros componentes e plugins?&lt;/em&gt;&lt;/em&gt;&lt;/strong&gt;*&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/03.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46233&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/03.jpg&#34; alt=&#34;03&#34; width=&#34;335&#34; height=&#34;216&#34; srcset=&#34;uploads/2014/12/03.jpg 400w, uploads/2014/12/03-215x139.jpg 215w&#34; sizes=&#34;(max-width: 335px) 100vw, 335px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;É uma boa pergunta e simples de responder. Para baixar outro componente como por exemplo AngularJS vamos usar o Bower, nosso gerenciador de componentes. E para baixar um novo plugin como por exemplo JSHINT vamos usar o Gruntjs que gerencia nossas tarefas. Os comandos abaixo mostra como baixar componentes e plugins.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Baixando componentes&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&#34;lang-html&#34;&gt;bower install [nome do componente]&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Baixando plugins&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&#34;lang-html&#34;&gt;npm install [nome do plugin] --save-dev&lt;/pre&gt;

&lt;h3 id=&#34;e-meu-ambiente-de-produção&#34;&gt;E meu ambiente de produção?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/04.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46234&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/04.jpg&#34; alt=&#34;04&#34; width=&#34;363&#34; height=&#34;252&#34; srcset=&#34;uploads/2014/12/04.jpg 392w, uploads/2014/12/04-200x139.jpg 200w&#34; sizes=&#34;(max-width: 363px) 100vw, 363px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chegamos ao nosso momento de build da aplicação. O yeoman compila todos os arquivos da pasta app e nos retorna uma pasta chamada “dist” é lá que encontram seus arquivos de produção prontos para serem usados e testados. Lembrando que qualquer alteração não poderá ser feita na pasta “dist” e sim em “app”.&lt;/p&gt;

&lt;p&gt;Dando o build no projeto e gerando meu diretório de produção:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;grunt build&lt;/pre&gt;

&lt;h3 id=&#34;visão-geral&#34;&gt;Visão geral&lt;/h3&gt;

&lt;p&gt;Hoje aprendemos realmente a usar o yeoman, desde seus conceitos até o modo de produção, é só seguir os passos e dicas. E por falar em dica, lá vai uma dica para melhorar mais ainda a sua transferência de arquivos para o ambiente de produção.&lt;/p&gt;

&lt;p&gt;Ao dar o build ele gera o diretório “dist” contendo nele os arquivos de produção. Já que estamos automatizando tudo, evite o uso do FTP e sim faça deploy =) Abaixo segue algumas referências de um módulo do grunt que você pode acrescentar em sua aplicação e deixá-la mais interessante. Assim você miniminiza retrabalhos. Estou falando de [rsync][12].&lt;/p&gt;

&lt;p&gt;Links de referência Yeoman que podem complementar o Post&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;http://yeoman.io/&#34;&gt;Site oficial do yeoman&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;https://github.com/yeoman/yeoman&#34;&gt;Projeto yeoman no github para contribuição&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;http://blog.caelum.com.br/experimente-o-yeoman-em-seu-workflow-de-projetos-front-end/&#34;&gt;Outro Post de referência explicativo e conceitual&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;http://pt.slideshare.net/pedropolisenso/em-um-relacionamento-srio-com-generators-front-end&#34;&gt;Palestra sobre generators (yeoman)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;considerações-finais&#34;&gt;Considerações finais&lt;/h3&gt;

&lt;p&gt;Chegamos ao final desse capítulo tentando expor as qualidades que o Yeoman pode nos dar e sua forma de uso. No próximo capítulo teremos nosso amigo Beto Muniz (&lt;a href=&#34;https://twitter.com/obetomuniz&#34;&gt;@obetomuniz&lt;/a&gt;) falando sobre Slush dentro da série. Não perca os próximos capítulos da série, onde no 4º capítulo finalizaremos com algumas dicas, apresentaremos projetos que foram criados a parir de um desses generators e mostrar como criar seu próprio generator. Valeu =]&lt;/p&gt;

&lt;p&gt;[12]: Ao%20dar o build ele gera o diretório “dist” contendo nele os arquivos de produção. Já que estamos automatizando tudo, jamais em toda sua vida use FTP e sim faça deploy =) Abaixo segue algumas referências de um módulo do grunt que você pode acrescentar em sua aplicação e deixá-la mais interessante. Assim você miniminiza retrabalhos. Estou falando de rsync&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>