<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sass on Tableless</title>
    <link>https://tableless.github.io/hugo-public/categories/sass/index.xml</link>
    <description>Recent content in Sass on Tableless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <atom:link href="https://tableless.github.io/hugo-public/categories/sass/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bulma: framework CSS baseado em flexbox</title>
      <link>https://tableless.github.io/hugo-public/bulma-framework-css-baseado-em-flexbox/</link>
      <pubDate>Tue, 28 Jun 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/bulma-framework-css-baseado-em-flexbox/</guid>
      <description>

&lt;blockquote&gt;
&lt;p&gt;&amp;#8220;Inspirado pelo Bootstrap, o Bulma visa oferecer a todos a alegria de fazer o design do site, com a simplicidade do flexbox e a elegância de Sass.&amp;#8221; &amp;#8211; &lt;a href=&#34;http://jgthms.com/&#34;&gt;Jeremy Thomas&lt;/a&gt;, criador do projeto Bulma.io.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Como o título diz, o &lt;a href=&#34;http://bulma.io/&#34;&gt;Bulma&lt;/a&gt; é um framework CSS baseado na tecnologia flexbox, que já tem uma grande &lt;a href=&#34;http://caniuse.com/#search=flexbox&#34;&gt;compatibilidade&lt;/a&gt; entre os navegadores. O pacote contém todos os elementos mais comuns como botões, formulários, menus, tabelas, títulos, notificações, barras de progresso e um simples sistema de grid (basta adicionar uma coluna, o resize das colunas é automático).&lt;/p&gt;

&lt;p&gt;Vou mostrar alguns exemplos para que você possa entender o poder do Bulma.&lt;/p&gt;

&lt;p&gt;Primeiramente, faremos a instalação que não precisa de nada mais que um link para o arquivo de estilos do Bulma:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdnjs.cloudflare.com/ajax/libs/bulma/0.0.26/css/bulma.css&#34;&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Claro que você pode baixar e deixar no seu diretório local, e também baixar com o NPM: &lt;code&gt;npm install bulma&lt;/code&gt;; mas o que quero mostrar é que tudo que você precisa é apenas de um arquivo de CSS.&lt;/p&gt;

&lt;p&gt;Baixando com o NPM você terá como personalizar facilmente com SASS.&lt;/p&gt;

&lt;p&gt;O Bulma não vem com nenhum pacote de icon-fonts acoplado, então, caso você pretenda usar algum, como o Font Awesome, você deve inserí-lo também.&lt;/p&gt;

&lt;h2 id=&#34;o-grid&#34;&gt;O Grid&lt;/h2&gt;

&lt;p&gt;Lembrando: como o Bulma foi baseado no Bootstrap, uma das semelhanças é o sistema de grid com 12 colunas.&lt;/p&gt;

&lt;p&gt;Como falei, o grid funciona de forma muito simples. Tudo que você precisa é ter uma &lt;code&gt;div&lt;/code&gt; com a classe &lt;code&gt;.columns&lt;/code&gt; e suas filhas &lt;code&gt;.column&lt;/code&gt;, como no exemplo abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;div class=&#34;columns&#34;&amp;gt;
  &amp;lt;div class=&#34;column&#34;&amp;gt;.column&amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;column&#34;&amp;gt;.column&amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;column&#34;&amp;gt;.column&amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;column&#34;&amp;gt;.column&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Você pode entender melhor como funciona com &lt;a href=&#34;http://codepen.io/gabsprates/full/PNVJrP/&#34;&gt;esse exemplo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Mas e se você quiser que uma coluna ocupe o espaço de duas? Ou três? Ou quatro? Simples!!!&lt;/p&gt;

&lt;p&gt;Podemos utilizar as classes &lt;code&gt;is-2&lt;/code&gt;, &lt;code&gt;is-3&lt;/code&gt;, &lt;code&gt;is-4&lt;/code&gt;, &lt;code&gt;is-5&lt;/code&gt;, &lt;code&gt;is-6&lt;/code&gt;, &lt;code&gt;is-7&lt;/code&gt;, &lt;code&gt;is-8&lt;/code&gt;, &lt;code&gt;is-9&lt;/code&gt;, &lt;code&gt;is-10&lt;/code&gt; e &lt;code&gt;is-11&lt;/code&gt; para especificar qual a área ocupada pela &lt;code&gt;.column&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para entender melhor, aconselho a dar uma olhada &lt;a href=&#34;http://bulma.io/documentation/grid/columns/&#34;&gt;neste&lt;/a&gt; e &lt;a href=&#34;http://bulma.io/documentation/grid/tiles/&#34;&gt;neste&lt;/a&gt; links.&lt;/p&gt;

&lt;h2 id=&#34;hero&#34;&gt;Hero&lt;/h2&gt;

&lt;p&gt;Você já teve problemas com alinhar elementos verticalmente ao centro? O Bulma é um verdadeiro herói para essas situações! Veja este exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;section class=&#34;hero is-large&#34;&amp;gt;
    &amp;lt;div class=&#34;hero-body&#34;&amp;gt;
      &amp;lt;div class=&#34;container&#34;&amp;gt;
        &amp;lt;h1 class=&#34;title&#34;&amp;gt;
          Título
        &amp;lt;/h1&amp;gt;
        &amp;lt;h2 class=&#34;subtitle&#34;&amp;gt;
          Exemplo do uso do hero
        &amp;lt;/h2&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/section&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Aqui o Bulma centraliza os títulos na vertical, qualquer conteúdo seria alinhado também. &lt;a href=&#34;http://bulma.io/documentation/layout/hero/&#34;&gt;Clique aqui&lt;/a&gt; mais exemplos.&lt;/p&gt;

&lt;h2 id=&#34;level&#34;&gt;Level&lt;/h2&gt;

&lt;p&gt;Por último, quero falar um pouco sobre as navbars. Veja esse código:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;nav class=&#34;level&#34;&amp;gt;
    &amp;lt;p class=&#34;level-item has-text-centered&#34;&amp;gt;
      &amp;lt;a class=&#34;link is-info&#34;&amp;gt;Home&amp;lt;/a&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p class=&#34;level-item has-text-centered&#34;&amp;gt;
      &amp;lt;a class=&#34;link is-info&#34;&amp;gt;Menu&amp;lt;/a&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p class=&#34;level-item has-text-centered&#34;&amp;gt;
      &amp;lt;img src=&#34;http://bulma.io/images/bulma.png&#34; alt=&#34;&#34; style=&#34;height: 33px;&#34;&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p class=&#34;level-item has-text-centered&#34;&amp;gt;
      &amp;lt;a class=&#34;link is-info&#34;&amp;gt;Reservations&amp;lt;/a&amp;gt;
    &amp;lt;/p&amp;gt;
    &amp;lt;p class=&#34;level-item has-text-centered&#34;&amp;gt;
      &amp;lt;a class=&#34;link is-info&#34;&amp;gt;Contact&amp;lt;/a&amp;gt;
    &amp;lt;/p&amp;gt;
  &amp;lt;/nav&amp;gt;

&lt;/pre&gt;

&lt;p&gt;Ele gera uma navbar em que os elementos são divididos com a largura igual e com alinhamento vertical no centro, mesmo com imagem ou até mesmo um &lt;code&gt;form&lt;/code&gt;, ele manteria esse alinhamento.&lt;/p&gt;

&lt;p&gt;Veja mais &lt;a href=&#34;http://bulma.io/documentation/components/level/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;enfim-8230&#34;&gt;Enfim&amp;#8230;&lt;/h2&gt;

&lt;p&gt;Estes foram alguns exemplos do poder do Bulma mas há muito mais que você pode conferir na própria &lt;a href=&#34;http://bulma.io/documentation/overview/start/&#34;&gt;documentação do projeto&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Existem vários componentes legais, como cards, menus, paginação, mensagens, e várias outras coisas fáceis de usar e simples de compreender.&lt;/p&gt;

&lt;p&gt;Isso é tudo pessoal (:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sass vs. LESS vs. Stylus: Batalha dos Pré-processadores</title>
      <link>https://tableless.github.io/hugo-public/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</link>
      <pubDate>Mon, 28 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/sass-vs-less-vs-stylus-batalha-dos-pre-processadores/</guid>
      <description>

&lt;h2 id=&#34;introdução&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar:&lt;/p&gt;

&lt;h2 id=&#34;sintaxe&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Essa sintaxe não é por causa de ser mais antiga e sim pois no início o &lt;strong&gt;Sass&lt;/strong&gt; era parte de um outro pré-processador chamado &lt;strong&gt;Haml&lt;/strong&gt; criado por desenvolvedores &lt;strong&gt;Ruby&lt;/strong&gt;, e por causa disso as folhas de estilo escritas com &lt;strong&gt;Sass&lt;/strong&gt; utilizavam uma sintaxe como a do &lt;strong&gt;Ruby&lt;/strong&gt;, sem chaves, ponto e vírgula e controlado por identação.&lt;/p&gt;

&lt;h3 id=&#34;stylus&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-1&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-1&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-1&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-1&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-2&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-2&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-2&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Observação pessoal:&lt;/strong&gt; Como mencionado nos comentários, o LESS tem suporte a herança e pode ser feita com a seguinte sintaxe:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p {
        &amp;:extend(.block);
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;h2 id=&#34;importação&#34;&gt;Importação&lt;/h2&gt;

&lt;p&gt;Na comunidade CSs, importar CSS é visto com maus olhos por utilizar diversas chamadas HTTP. Importar com um pré-processador funciona de forma diferente no entanto. Se você importar um arquivo com qualquer um dos três pré-processadores, ele irá literalmente pegar todo o conteúdo do arquivo durante a importação e gerar apenas um arquivo. Lembre-se que arquivos .css comuns importados compilam com o código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;file.css&#34;;
&lt;/pre&gt;

&lt;p&gt;Lembre-se também que mixins e variáveis podem ser importadas e usadas em sua folha de estilo principal. Importação faz com que possamos criar arquivos separados para uma melhor organização.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-1&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* arquivo.{extensao} */
body {
    background: #eee;
}
&lt;/pre&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
@import &#34;arquivo.{extensao}&#34;;
 
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-3&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;h2 id=&#34;introdução-1&#34;&gt;Introdução&lt;/h2&gt;

&lt;p&gt;-&amp;gt;Pré-processadores produzem CSS que funciona em todos os browsers&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS3 são linguagens criadas com um único propósito de adicionar funcionalidades legais e criativas para o CSS sem quebrar a compatibilidade entre browsers. Eles fazem isso compilando o código que escrevemos em CSS puro que pode ser usado em qualquer browser de agora até a era das pedras. Os pré-processadores disponibilizam milhares de funcionalidades, e nesse artigo iremos falar sobre as mais utilizadas e conhecidas e algumas nem tanto conhecidas. Vamos começar&lt;/p&gt;

&lt;h2 id=&#34;sintaxe-1&#34;&gt;Sintaxe&lt;/h2&gt;

&lt;p&gt;A parte mais importante ao escrever códigos utilizando um pré-processador CSS é entender a sua sintaxe. Felizmente para nós, a sintaxe é (ou pode ser) idêntica à do CSS puro para os três pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-less-1&#34;&gt;Sass e LESS&lt;/h3&gt;

&lt;p&gt;Ambos utilizam o a sintaxe padrão do CSS. Isso faz com que seja extremamente fácil converter um arquivo CSS já existente para qualquer um deles. Sass utiliza arquivos com extensão .scss e LESS com extensão .less. Uma configuração básica de um arquivo Sass ou LESS pode ser como abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.scss ou style.less */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ter notado, isso é apenas CSS puro, que compila perfeitamente em ambos pré-processadores (Sass e LESS).&lt;/p&gt;

&lt;p&gt;É importante notar que Sass também tem uma sintaxe mais antiga, que omite ponto e vírgula e as chaves. Ainda pode ser usado, mas como é uma sintaxe antiga, não iremos utilizá-la depois deste exemplo. A sintaxe utiliza arquivos com a extensão .sass e são da seguinte maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.sass */
h1 {
    color: #0982c1;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-3&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;A sintaxe para o Stylus é muito mais adaptável. Utiliza arquivos com extensão .styl, aceita a sintaxe padrão do CSS, porém também aceita algumas variações onde chaves, dois-pontos e ponto e vírgula são todos opcionais. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* style.styl */
h1 {
    color: #0982c1;
}
/* omitindo chaves */
h1
    color: #0982c1;

/* omitindo dois-pontos e ponto e vírgula
h1
    color: #0982c1
&lt;/pre&gt;

&lt;p&gt;Utilizar diferentes variações em um mesmo arquivo também é válido, então o seguinte código seria compilado sem erros.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;h1 {
    color #0982c1
}
h2
    font-size: 1.2em
&lt;/pre&gt;

&lt;h2 id=&#34;variáveis-1&#34;&gt;Variáveis&lt;/h2&gt;

&lt;p&gt;Variáveis podem ser declaradas e usadas através das folhas de estilo. Elas podem ter qualquer valor que seja um valor em CSS (por exemplo: cores, números [unidades também], ou texto), e podem ser referenciadas em qualquer lugar das nossas folhas de estilo.&lt;/p&gt;

&lt;h3 id=&#34;sass-2&#34;&gt;Sass&lt;/h3&gt;

&lt;p&gt;Variáveis em Sass tem seu nome começado o símbolo &amp;#8220;$&amp;#8221; e o nome e o seu valor são separados com dois-pontos, assim como uma propriedade CSS.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$mainColor: #0982c1;
$siteWidth: 1024px;
$borderStyle: dotted;

body {
    color: $mainColor;
    border: 1px $borderStyle $mainColor;
    max-width: $siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-3&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;Varíaves em LESS são praticamente iguais as variáveis no Sass, exceto por começarem seus nomes com o símbolo &amp;#8220;@&amp;#8221;.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mainColor: #0982c1;
@siteWidth: 1024px;
@borderStyle: dotted;

body {
    color: @mainColor;
    border: 1px @borderStyle @mainColor;
    max-width: @siteWidth;
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-4&#34;&gt;Stylus&lt;/h3&gt;

&lt;p&gt;Variáveis em Stylus não precisam começar com nenhum símbolo, porém ele permite a utilização do símbolo &amp;#8220;$&amp;#8221;. Como sempre, o ponto e vírgula para finalizar não é necessário, mas um sinal de igual entre o nome da variável e seu valor é. Uma coisa importante para se notar é que na versão 0.22.4 do Stylus variáveis com nome começados com o símbolo &amp;#8220;@&amp;#8221; são compiladas, porém não aplicam seu valor quando referenciadas. Em oturas palavras, não faça isso.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;mainColor = #0982c1;
siteWidth = 1024px;
$borderStyle = dotted;

body
    color mainColor
    border 1px $borderStyle mainColor
    max-width siteWidth
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-4&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Cada um dos arquivos acima irão compilar no mesmo CSS. Você pode usar sua imaginação para ver quão úteis variáveis podem ser. Não precisaremos mais ao mudar uma cor reescrever a mesma vinte vezes, ou querer mudar a largura de nosso site e ter de procurar por todo o site para fazer isso. Aqui está o CSS depois de compilado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    color: #0982c1;
    border: 1px dotted #0982c1;
    max-width: 1024px.
}
&lt;/pre&gt;

&lt;h2 id=&#34;aninhamento-1&#34;&gt;Aninhamento&lt;/h2&gt;

&lt;p&gt;Se precisarmos referenciar múltiplos elementos com o mesmo pai em nosso CSS, pode ser entediante ficar digitanto o pai toda vez.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;p&gt;Ao invés disso, usando um pré-processador, podemos escrever os seletores filhos dentro das chaves do elemento pai. O símbolo &amp;#8220;&amp;amp;&amp;#8221; é usado para referenciar o seletor pai.&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-2&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;p&gt;Todos os três pré-processdores utilizam a mesma sintaxe para aninhar seletores.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;

    nav {
        height: 25px;

        a {
            color: #0982c1;

            &amp;:hover {
                text-decoration: underline;
            }
        }
    }
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-5&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Abaixo está o CSS compilado do código escrito acima. Está exatamente igual ao mostrado no começo &amp;#8211; que conveniente!&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;section {
    margin: 10px;
}
section nav {
    height: 25px;
}
section nav a {
    color: #0982c1;
}
section nav a:hover {
    text-decoration: underline;
}
&lt;/pre&gt;

&lt;h2 id=&#34;mixins-1&#34;&gt;Mixins&lt;/h2&gt;

&lt;p&gt;Mixins são funções que permitem reusar propriedades através de nossas folhas de estilo. Ao invés de procurar por todas nossas folhas de estilo e mudar uma propriedade várias vezes, podemos apenas mudar dentro de nosso mixin. Isso pode ser realmente útil para estilização de elementos específicos e para &amp;#8220;vendor prefixes&amp;#8221; (moz-*, o-*, etc). Quando os mixins são chamados de dentro de um seletor CSS, os argumentos são reconhecidos e os estilos dentro do mixin são aplicados ao seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-3&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Sass chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
@mixin error($borderWidth: 2px) {
    border: $borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    @include error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    @include error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-4&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em LESS chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
.error(@borderWidth: 2px) {
    border: @borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    .error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    .error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-5&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;/* Mixin em Stylus chamado error com argumento $borderWidth opcional, caso não seja fornecido, utiliza o valor padrão de 2px; */
error(borderWidth = 2px) {
    border: borderWidth solid #f00;
    color: #f00;
}

.generic-error {
    padding: 20px;
    margin: 4px;
    error(); /* Aplica estilos do mixin error */
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    error(5px); /* Aplica estilos do mixin error com argumento $borderWidth = 5px */
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-6&#34;&gt;CSS Compilado&lt;/h3&gt;

&lt;p&gt;Todos pré-processadores irão compilar o mesmo código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.generic-error {
    padding: 20px;
    margin: 4px;
    border: 2px solid #f00;
    color: #f00;
}
.login-error {
    left: 12px;
    position: absolute;
    top: 20px;
    border: 5px solid #f00;
    color: #f00;
}
&lt;/pre&gt;

&lt;h2 id=&#34;herança-1&#34;&gt;Herança&lt;/h2&gt;

&lt;p&gt;Quando estamos escrevendo CSS da velha maneira, nós usaríamos o seguinte código para aplicar o mesmo estilo para múltiplos elementos de uma só vez:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;p,
u,
ol {
    /* estilos aqui */
}
&lt;/pre&gt;

&lt;p&gt;Isso funciona perfeitamente, mas se depois precisássemos de estilizar os elementos individualmente, outro seletor deveria ser criado para cada um e rapidamente poderia ficar cada vez mais bagunçado e difícil de manter. Podemos utilizar herança para resolver isso. Herança é a habilidade de outros seletores CSS herdarem as propriedades de outro seletor.&lt;/p&gt;

&lt;h3 id=&#34;sass-e-stylus-1&#34;&gt;Sass e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}

p {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    @extend .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-sass-e-stylus-1&#34;&gt;CSS Compilado (Sass e Stylus)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block, p, ul, ol {
    margin: 10px 5px;
    padding: 2px;
}
p {
    border: 1px solid #eee;
}
ul, ol {
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-5&#34;&gt;LESS&lt;/h3&gt;

&lt;p&gt;LESS não tem suporte a herança de estilos como Sass e Stylus. Ao invés de adicionar diversos seletores para um grupo de propriedades, ele trata herança como um mixin sem argumentos e importa os estilos para dentro de seus próprios seletores. O problema disso é que propriedades são repetidas em sua folha de estilo compilada. Abaixo segue como deve-se utilizar:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
 
p {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    border: 1px solid #eee;
}
ul, ol {
    .block; /* Herda estilos do seletor &#39;.block&#39; */
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;h3 id=&#34;css-compilado-less-1&#34;&gt;CSS Compilado (LESS)&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.block {
    margin: 10px 5px;
    padding: 2px;
}
p {
    margin: 10px 5px;
    padding: 2px;
    border: 1px solid #eee;
}
ul,
ol {
    margin: 10px 5px;
    padding: 2px;
    color: #333;
    text-transform: uppercase;
}
&lt;/pre&gt;

&lt;p&gt;Como você pode ver, os estilos do seletor .block foram inseridas nos seletores que queríamos aplicar a herança. É importante notar que a prioridade das propriedades pode se tornar um problema, então devemos ter bastante cautela.&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;reset.css&#34;;
body {
    background: #eee;
}
p {
    background: #0982c1;
}
&lt;/pre&gt;

&lt;h2 id=&#34;funções-de-cores&#34;&gt;Funções de Cores&lt;/h2&gt;

&lt;p&gt;Funções de cores são funções nativas que transformam uma cor por compilação. Podem ser extremamente úteis para criar gradientes, escurecer cores no &amp;#8220;hover&amp;#8221; de elementos e muito mais.&lt;/p&gt;

&lt;h3 id=&#34;sass-4&#34;&gt;Sass&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten($color, 10%); /* retorna uma cor 10% mais clara que $color */
darken($color, 10%);  /* retorna uma cor 10% mais escura $color */
 
saturate($color, 10%);   /* retorna uma cor 10% mais saturada que $color */
desaturate($color, 10%); /* retorna uma cor 10% menos saturada que $color */
 
grayscale($color);  /* retorna $color na escala de cinza */
complement($color); /* retorna cor complementar de $color */
invert($color);     /* retorna cor inversa de $color */
 
mix($color1, $color2, 50%); /* mistura $color1 com $color2 com um peso de 50% */
&lt;/pre&gt;

&lt;p&gt;Essas é apenas uma pequena lista de funções de cores disponíveis no Sass. A lista completa das funções de cores disponíveis no Sass pode ser encontrada na &lt;a href=&#34;http://sass-lang.com/documentation/Sass/Script/Functions.html&#34; target=&#34;_blank&#34;&gt;documentação do Sass&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Funções de cores podem ser usadas em qualquer lugar que uma cor é válida no CSS. Veja um exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$color: #0982C1;
 
h1 {
    background: $color;
    border: 3px solid darken($color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;less-6&#34;&gt;LESS&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(@color, 10%); /* retorna uma cor 10% mais clara que @color */
darken(@color, 10%);  /* retorna uma cor 10% mais escura @color */
 
saturate(@color, 10%);   /* retorna uma cor 10% mais saturada que @color */
desaturate(@color, 10%); /* retorna uma cor 10% menos saturada que @color */
 
spin(@color, 10); /* retorna uma cor 10 graus acima na matiz/tonalidade que @color */
spin(@color, -10); /* retorna uma cor 10 graus abaixo na matiz/tonalidade que @color */
 
mix(@color1, @color2); /* mistura @color1 com @color2 */
&lt;/pre&gt;

&lt;p&gt;A lista de todas as funções disponíveis no LESS pode encontrada na &lt;a href=&#34;http://lesscss.org/#-color-functions&#34; target=&#34;_blank&#34;&gt;documentação LESS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no LESS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@color: #0982C1;
 
h1 {
    background: @color;
    border: 3px solid darken(@color, 50%);
}
&lt;/pre&gt;

&lt;h3 id=&#34;stylus-6&#34;&gt;Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;lighten(color, 10%); /* retorna uma cor 10% mais clara que &#39;color&#39; */
darken(color, 10%);  /* retorna uma cor 10% mais escura &#39;color&#39; */
 
saturate(color, 10%);   /* retorna uma cor 10% mais saturada que &#39;color&#39; */
desaturate(color, 10%); /* retorna uma cor 10% menos saturada que &#39;color&#39; */
&lt;/pre&gt;

&lt;p&gt;A lista completa de todas funções de cores disponíveis no Stylus pode ser encontrada na &lt;a href=&#34;http://stylus-lang.com/docs/bifs.html&#34; target=&#34;_blank&#34;&gt;documentação Stylus&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de como usar uma função de cores no Stylus:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;color = #0982C1
 
h1
    background color
    border 3px solid darken(color, 50%)
&lt;/pre&gt;

&lt;h2 id=&#34;operações&#34;&gt;Operações&lt;/h2&gt;

&lt;p&gt;Fazer cálculos no CSS é bastante útil e agora totalmente possível. É bem simples e é dessa maneira que fazemos:&lt;/p&gt;

&lt;h3 id=&#34;sass-less-e-stylus-3&#34;&gt;Sass, LESS e Stylus&lt;/h3&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: (14px/2);
    top: 50px + 100px;
    right: 100px - 50px;
    left: 10 * 10;
}
&lt;/pre&gt;

&lt;h2 id=&#34;aplicações-práticas&#34;&gt;Aplicações Práticas&lt;/h2&gt;

&lt;p&gt;Nós falamos de diversas funcionalidades e novas coisas que pré-processadores podem fazer, mas não mostramos nada na prática ainda. Veja uma pequena lista de aplicações no mundo real em que um pré-processador é um salva-vidas.&lt;/p&gt;

&lt;h3 id=&#34;vendor-prefixes&#34;&gt;Vendor Prefixes&lt;/h3&gt;

&lt;p&gt;Essa é uma das principais razões para se usar um pré-processador e por um motivo bom &amp;#8211; economia gigante de tempo e lágrimas. Criar um mixin para cuidar dos vendor prefixes é fácil e nos salva de uma codificação repetitiva e dolorosa. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-5&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin border-radius($values) {
    -webkit-border-radius: $values;
        -moz-border-radius: $values;
            border-radius: $values;
}
 
div {
    @include border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-7&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.border-radius(@values) {
    -webkit-border-radius: @values;
        -moz-border-radius: @values;
            border-radius: @values;
}
 
div {
    .border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-7&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;border-radius(values) {
    -webkit-border-radius: values;
        -moz-border-radius: values;
            border-radius: values;
}
 
div {
    border-radius(10px);
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-7&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;div {
    -webkit-border-radius: 10px;
        -moz-border-radius: 10px;
            border-radius: 10px;
}
&lt;/pre&gt;

&lt;h3 id=&#34;texto-3d&#34;&gt;Texto 3D&lt;/h3&gt;

&lt;p&gt;Simular um texto 3D utilizando diversos text-shadows é uma grande ideia. O único problema é que mudar a cor depois de criar é difícil e incômodo. Usando mixins e funções de cores, podemos criar um texto 3D e mudar sua cor sem nenhuma dificuldade.&lt;/p&gt;

&lt;h4 id=&#34;sass-6&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin text3d($color) {
    color: $color;
    text-shadow: 1px 1px 0px darken($color, 5%),
            2px 2px 0px darken($color, 10%),
            3px 3px 0px darken($color, 15%),
            4px 4px 0px darken($color, 20%),
            4px 4px 2px #000;
}
 
h1 {
    font-size: 32pt;
    @include text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-8&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.text3d(@color) {
    color: @color;
    text-shadow: 1px 1px 0px darken(@color, 5%),
            2px 2px 0px darken(@color, 10%),
            3px 3px 0px darken(@color, 15%),
            4px 4px 0px darken(@color, 20%),
            4px 4px 2px #000;
}
 
span {
    font-size: 32pt;
    .text3d(#0982c1);
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-8&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;text3d(color)
    color: color
    text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000
span
    font-size: 32pt
    text3d(#0982c1)
&lt;/pre&gt;

&lt;p&gt;Escolhi escrever os &amp;#8220;text-shadows&amp;#8221; do Stylus em apenas uma linha pois omiti as chaves.&lt;/p&gt;

&lt;h4 id=&#34;css-compilado-8&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;span {
    font-size: 32pt;
    color: #0982c1;
    text-shadow: 1px 1px 0px #097bb7, 
            2px 2px 0px #0875ae, 
            3px 3px 0px #086fa4, 
            4px 4px 0px #07689a, 
            4px 4px 2px #000;
}
&lt;/pre&gt;

&lt;h4 id=&#34;resultado-final&#34;&gt;Resultado Final&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://cdn.tutsplus.com/net/uploads/legacy/1144_preprocshootout/text3d.png&#34; alt=&#34;Texto 3D&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;colunas&#34;&gt;Colunas&lt;/h3&gt;

&lt;p&gt;Usar operações numéricas e variáveis para colunas é uma ideia que tive da primeira vez que estava brincando com pré-processadores CSS. Declarando a largura desejada em uma variável, podemos facilmente alterá-la sem precisar de nenhum cálculo mental. Veja como fazer:&lt;/p&gt;

&lt;h4 id=&#34;sass-7&#34;&gt;Sass&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;$siteWidth: 1024px;
$gutterWidth: 20px;
$sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: $siteWidth;
}
.content {
    float: left;
    width: $siteWidth - ($sidebarWidth+$gutterWidth);
}
.sidebar {
    float: left;
    margin-left: $gutterWidth;
    width: $sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;less-9&#34;&gt;LESS&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@siteWidth: 1024px;
@gutterWidth: 20px;
@sidebarWidth: 300px;
 
body {
    margin: 0 auto;
    width: @siteWidth;
}
.content {
    float: left;
    width: @siteWidth - (@sidebarWidth+@gutterWidth);
}
.sidebar {
    float: left;
    margin-left: @gutterWidth;
    width: @sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;stylus-9&#34;&gt;Stylus&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;siteWidth = 1024px;
gutterWidth = 20px;
sidebarWidth = 300px;
 
body {
    margin: 0 auto;
    width: siteWidth;
}
.content {
    float: left;
    width: siteWidth - (sidebarWidth+gutterWidth);
}
.sidebar {
    float: left;
    margin-left: gutterWidth;
    width: sidebarWidth;
}
&lt;/pre&gt;

&lt;h4 id=&#34;css-compilado-9&#34;&gt;CSS Compilado&lt;/h4&gt;

&lt;pre class=&#34;lang-css&#34;&gt;body {
    margin: 0 auto;
    width: 1024px;
}
.content {
    float: left;
    width: 704px;
}
.sidebar {
    float: left;
    margin-left: 20px;
    width: 300px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;peculiaridades-notáveis&#34;&gt;Peculiaridades Notáveis&lt;/h2&gt;

&lt;p&gt;Existem algumas peculiaridades ao usar um pré-processador CSS. Irei falar de algumas engraçadas, mas se você está realmente interessado em encontrar todas elas eu recomendo você vasculhar toda a documentação, ou melhor, começar a usar um pré-processador na sua codificação diária.&lt;/p&gt;

&lt;h3 id=&#34;relatório-de-erros&#34;&gt;Relatório de Erros&lt;/h3&gt;

&lt;p&gt;Se você já escreveu CSS por uma boa quantia de tempo, tenho certeza que você já chegou a um ponto onde você tinha um erro em algum lugar e simplesmente não conseguia o encontrar. Se você é como eu, provavelmente passou a tarde toda arrancando os cabelos fora e comentando diversas coisas para caçar o erro.&lt;/p&gt;

&lt;p&gt;Pré-processadores CSS relatam os erros. Simples assim. Se tem alguma coisa errada em seu códigom ele te fala onde e, se você estiver com sorte até mesmo o porquê. Você pode dar uma olhada &lt;a href=&#34;http://tjholowaychuk.com/post/5002088731/stylus-vs-sass-vs-less-error-reporting&#34; target=&#34;_blank&#34;&gt;nesse post&lt;/a&gt; caso esteja interessado em ver como os erros são relatados em diferentes pré-processadores.&lt;/p&gt;

&lt;h3 id=&#34;comentários&#34;&gt;Comentários&lt;/h3&gt;

&lt;p&gt;Quando um pré-processador CSS está compilando, qualquer comentário escrito com barras duplas &amp;#8220;//&amp;#8221; é excluído e qualquer comentários escrito com barra e asterisco &amp;#8220;/* */&amp;#8221; não é alterado. Dito isso, use comentários com barras duplas para comentários que você queira na versão não compilada e comentários com barra e asterisco para comentários que serão visíveis após a compilação.&lt;/p&gt;

&lt;p&gt;Observação: Se você compilar os arquivos, minificando-os, todos comentários são excluídos.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Cada um dos pré-processadores que falamos (Sass, LESS e Stylus) possui um modo único de realizar a mesma tarefa &amp;#8211; dando a nós desenvolvedor a habilidade de usar funcionalidades úteis mantendo a compatibilidade entre browsers e um código limpo.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Mesmo não sendo uma exigência para o desenvolvimento, pré-processadores podem economizar muito tempo e tem funcionalidades bastante úteis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu aconselho todos vocês a utilizar e testar a maior quantidade de pré-processadores possível, pois assim você poderá escolher efetivamente um favorito e saber o porquê ele é seu favorito dentre tantos outros. Se você ainda não testou usar nenhum pré-processador para escrever seu CSS, eu recomendo grandemente a você testar.&lt;/p&gt;

&lt;p&gt;Você tem alguma funcionalidade de seu pré-processador favorito que não foi mencionada? Há algo que algum pré-processador possa fazer e outros não? Conte-nos nos comentários abaixo!&lt;/p&gt;

&lt;p&gt;Traduzido e adaptado de: &lt;a href=&#34;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320&#34;&gt;http://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout&amp;#8211;net-24320&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bootstrap 4 Alpha</title>
      <link>https://tableless.github.io/hugo-public/bootstrap-4-alpha/</link>
      <pubDate>Thu, 27 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/bootstrap-4-alpha/</guid>
      <description>

&lt;p&gt;Já faz um tempo que o Bootstrap vem dominando a web. Dificilmente vemos um desenvolvedor que não o conheça, e boa parte da comunidade web já ouviu falar ou já usou o framework.&lt;/p&gt;

&lt;p&gt;Agora a equipe do Bootstrap &lt;a href=&#34;http://blog.getbootstrap.com/2015/08/19/bootstrap-4-alpha/&#34; target=&#34;_blank&#34;&gt;anunciou&lt;/a&gt; sua nova versão, o &lt;strong&gt;Bootstrap 4 Alpha&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/08/bs4-alpha.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-50861 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/08/bs4-alpha.png&#34; alt=&#34;Homepage do Bootstrap 4 Alpha&#34; width=&#34;2360&#34; height=&#34;1588&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O framework está repleto de novidades. Algumas delas são:&lt;/p&gt;

&lt;h2 id=&#34;mudança-de-less-para-sass&#34;&gt;Mudança de Less para Sass&lt;/h2&gt;

&lt;p&gt;O Bootstrap compila mais rápido do que nunca &amp;#8211; graças a Libsass &amp;#8211; e agora se juntaram a esta grande e crescente comunidade de desenvolvedores Sass.&lt;/p&gt;

&lt;h2 id=&#34;melhoria-no-sistema-de-grids&#34;&gt;Melhoria no sistema de Grids&lt;/h2&gt;

&lt;p&gt;Foi adicionado uma nova grid, que causará grande melhora nos dispositivos móveis. Também ocorreu uma remodelagem completa nos &lt;em&gt;mixins&lt;/em&gt; semânticos.&lt;/p&gt;

&lt;h2 id=&#34;novas-opções-para-personalização&#34;&gt;Novas opções para personalização&lt;/h2&gt;

&lt;p&gt;&lt;span id=&#34;ouHighlight__33_42TO37_45&#34; class=&#34;highlight&#34;&gt;Ao invés de &lt;/span&gt;&lt;span id=&#34;ouHighlight__44_53TO47_53&#34; class=&#34;&#34;&gt;separar &lt;/span&gt;&lt;span id=&#34;ouHighlight__81_89TO79_88&#34; class=&#34;&#34;&gt;gradientes&lt;/span&gt;&lt;span id=&#34;noHighlight_0.481113150017336&#34;&gt;,&lt;/span&gt; &lt;span id=&#34;noHighlight_0.6814724979922175&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__92_102TO91_100&#34;&gt;transições&lt;/span&gt;&lt;span id=&#34;noHighlight_0.811446403618902&#34;&gt;,&lt;/span&gt; &lt;span id=&#34;noHighlight_0.30436457856558263&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__105_111TO103_109&#34; class=&#34;&#34;&gt;sombras&lt;/span&gt; &lt;span id=&#34;noHighlight_0.6863153295125812&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__114_116TO111_111&#34; class=&#34;&#34;&gt;e&lt;/span&gt;&lt;span id=&#34;noHighlight_0.2496850637253374&#34;&gt; outras personalizações &lt;/span&gt;&lt;span id=&#34;ouHighlight__123_124TO124_127&#34;&gt;para&lt;/span&gt; &lt;span id=&#34;noHighlight_0.19514952460303903&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__126_126TO129_131&#34; class=&#34;&#34;&gt;uma&lt;/span&gt; &lt;span id=&#34;noHighlight_0.7088381128851324&#34;&gt;folha de &lt;/span&gt;&lt;span id=&#34;ouHighlight__137_146TO142_148&#34; class=&#34;&#34;&gt;estilos&lt;/span&gt; &lt;span id=&#34;noHighlight_0.2908061526250094&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__128_135TO150_157&#34; class=&#34;&#34;&gt;à parte (&lt;/span&gt;&lt;span id=&#34;ouHighlight__148_151TO159_162&#34;&gt;como&lt;/span&gt;&lt;span id=&#34;noHighlight_0.5787958002183586&#34;&gt; era na &lt;/span&gt;&lt;span id=&#34;ouHighlight__153_154TO164_165&#34;&gt;versão 3)&lt;/span&gt;&lt;span id=&#34;noHighlight_0.5214279058855027&#34;&gt;,&lt;/span&gt; &lt;span id=&#34;noHighlight_0.4220451375003904&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__169_171TO176_180&#34; class=&#34;&#34;&gt;todas&lt;/span&gt; &lt;span id=&#34;noHighlight_0.918515301309526&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__173_177TO182_186&#34; class=&#34;&#34;&gt;essas&lt;/span&gt; &lt;span id=&#34;noHighlight_0.7640828147996217&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__179_185TO188_193&#34; class=&#34;&#34;&gt;opções&lt;/span&gt;&lt;span id=&#34;noHighlight_0.4096155730076134&#34;&gt; foram colocadas &lt;/span&gt;&lt;span id=&#34;ouHighlight__187_190TO195_196&#34; class=&#34;&#34;&gt;em&lt;/span&gt; &lt;span id=&#34;noHighlight_0.4232193084899336&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__197_205TO198_206&#34;&gt;variáveis&lt;/span&gt; &lt;span id=&#34;noHighlight_0.7291480258572847&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__192_195TO208_211&#34;&gt;Sass&lt;/span&gt;&lt;span id=&#34;noHighlight_0.5328994235023856&#34;&gt;.&lt;/span&gt; &lt;span id=&#34;noHighlight_0.3506186828017235&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__208_211TO214_218&#34;&gt;Quer&lt;/span&gt;&lt;span id=&#34;noHighlight_0.761297364719212&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__221_231TO220_229&#34;&gt;transições&lt;/span&gt; &lt;span id=&#34;noHighlight_0.18227634043432772&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__213_219TO231_236&#34;&gt;padrões &lt;/span&gt;&lt;span id=&#34;ouHighlight__233_234TO238_239&#34;&gt;em&lt;/span&gt; &lt;span id=&#34;noHighlight_0.11960533494129777&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__236_245TO241_244&#34;&gt;tudo&lt;/span&gt; &lt;span id=&#34;noHighlight_0.48817266849800944&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__247_248TO246_247&#34;&gt;ou&lt;/span&gt; &lt;span id=&#34;noHighlight_0.5429222423117608&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__253_259TO249_257&#34; class=&#34;&#34;&gt;desativar&lt;/span&gt;&lt;span id=&#34;noHighlight_0.7604012105148286&#34;&gt; os &lt;/span&gt;&lt;span id=&#34;ouHighlight__269_275TO259_264&#34; class=&#34;&#34;&gt;cantos&lt;/span&gt; &lt;span id=&#34;noHighlight_0.0033320076763629913&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__261_267TO266_277&#34; class=&#34;&#34;&gt;arredondados&lt;/span&gt;&lt;span id=&#34;noHighlight_0.18449167720973492&#34;&gt;?&lt;/span&gt; &lt;span id=&#34;noHighlight_0.15296318451873958&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__278_283TO280_284&#34; class=&#34;&#34;&gt;Basta&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8132120880763978&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__285_290TO286_293&#34; class=&#34;&#34;&gt;atualizar&lt;/span&gt;&lt;span id=&#34;noHighlight_0.07241212041117251&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__292_292TO295_297&#34; class=&#34;&#34;&gt;a &lt;/span&gt;&lt;span id=&#34;ouHighlight__294_301TO299_306&#34; class=&#34;&#34;&gt;variável&lt;/span&gt; &lt;span id=&#34;noHighlight_0.25222062366083264&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__303_305TO308_308&#34; class=&#34;&#34;&gt;e&lt;/span&gt; &lt;span id=&#34;noHighlight_0.570360544603318&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__307_315TO310_318&#34; class=&#34;&#34;&gt;recompilar.&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;todos-os-plugins-foram-reescritos&#34;&gt;Todos os plugins foram reescritos&lt;/h2&gt;

&lt;p&gt;Cada plugin foi reescrito com ES6 para aproveitar as mais recentes melhoras do JavaScript. A versão 4 ve&lt;span id=&#34;ouHighlight__132_135TO153_155&#34; class=&#34;&#34;&gt;m&lt;/span&gt; &lt;span id=&#34;noHighlight_0.36849321285262704&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__151_154TO157_159&#34; class=&#34;&#34;&gt;com &lt;/span&gt;&lt;span id=&#34;noHighlight_0.8874966793227941&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__160_166TO161_167&#34; class=&#34;&#34;&gt;suporte&lt;/span&gt;&lt;span id=&#34;noHighlight_0.3962369414512068&#34;&gt; para &lt;em&gt;Universal Module Definition&lt;/em&gt; (&lt;/span&gt;&lt;span id=&#34;ouHighlight__156_158TO169_171&#34; class=&#34;&#34;&gt;&lt;a href=&#34;https://github.com/umdjs/umd&#34; target=&#34;_blank&#34;&gt;UMD&lt;/a&gt;)&lt;/span&gt;&lt;span id=&#34;noHighlight_0.18047267338261008&#34;&gt;,&lt;/span&gt; &lt;span id=&#34;noHighlight_0.9055605356115848&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__186_192TO174_180&#34; class=&#34;&#34;&gt;métodos&lt;/span&gt; &lt;span id=&#34;noHighlight_0.08181263506412506&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__169_175TO182_190&#34; class=&#34;&#34;&gt;genéricos&lt;/span&gt; &lt;span id=&#34;noHighlight_0.145829914836213&#34;&gt;de &lt;/span&gt;&lt;span id=&#34;ouHighlight__177_184TO195_204&#34; class=&#34;&#34;&gt;subdivisão&lt;/span&gt;&lt;span id=&#34;noHighlight_0.30580205423757434&#34;&gt; e&lt;/span&gt;&lt;span id=&#34;noHighlight_0.6392135077621788&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__207_214TO207_217&#34; class=&#34;&#34;&gt;verificação&lt;/span&gt; &lt;span id=&#34;noHighlight_0.9670881452038884&#34;&gt;de &lt;/span&gt;&lt;span id=&#34;ouHighlight__202_205TO222_225&#34; class=&#34;&#34;&gt;tipo&lt;/span&gt; &lt;span id=&#34;noHighlight_0.7507147502619773&#34;&gt;de &lt;/span&gt;&lt;span id=&#34;ouHighlight__195_200TO230_234&#34; class=&#34;&#34;&gt;opção, entre outros&lt;/span&gt;&lt;span id=&#34;noHighlight_0.8302771004382521&#34;&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;melhor-documentação&#34;&gt;Melhor documentação&lt;/h2&gt;

&lt;p&gt;Toda a documentação foi reescrita em Markdown; foram adicionados alguns plugins úteis para simplificar os exemplos. Também foram colocados trechos de códigos para agilizar o trabalho.&lt;/p&gt;

&lt;h2 id=&#34;fim-do-suporte-ao-ie8&#34;&gt;Fim do suporte ao IE8&lt;/h2&gt;

&lt;p&gt;&lt;span id=&#34;ouHighlight__0_6TO0_8&#34; class=&#34;&#34;&gt;O&lt;/span&gt;&lt;span id=&#34;noHighlight_0.7597462392877787&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__12_18TO12_18&#34; class=&#34;&#34;&gt;suporte&lt;/span&gt;&lt;span id=&#34;noHighlight_0.15465820394456387&#34;&gt; ao &lt;/span&gt;&lt;span id=&#34;ouHighlight__8_10TO23_25&#34; class=&#34;&#34;&gt;IE8&lt;/span&gt;&lt;span id=&#34;noHighlight_0.509343218524009&#34;&gt; foi abandonado &lt;/span&gt;&lt;span id=&#34;ouHighlight__20_22TO27_27&#34; class=&#34;&#34;&gt;e&lt;/span&gt;&lt;span id=&#34;noHighlight_0.4135255643632263&#34;&gt; as unidades de medida mudaram para &lt;/span&gt;&lt;span id=&#34;ouHighlight__33_35TO43_45&#34; class=&#34;&#34;&gt;REM &lt;/span&gt;&lt;span id=&#34;ouHighlight__37_39TO47_47&#34; class=&#34;&#34;&gt;e&lt;/span&gt; &lt;span id=&#34;noHighlight_0.45592652703635395&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__41_42TO49_50&#34;&gt;EM&lt;/span&gt;&lt;span id=&#34;noHighlight_0.115584553219378&#34;&gt;.&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8139501307159662&#34;&gt;O&lt;/span&gt;&lt;span id=&#34;ouHighlight__51_58TO62_69&#34; class=&#34;&#34;&gt; fim d&lt;/span&gt;&lt;span id=&#34;noHighlight_0.5428129727952182&#34;&gt;o &lt;/span&gt;&lt;span id=&#34;ouHighlight__60_66TO73_79&#34; class=&#34;&#34;&gt;suporte&lt;/span&gt;&lt;span id=&#34;noHighlight_0.9242240693420172&#34;&gt;,&lt;/span&gt;&lt;span id=&#34;noHighlight_0.3814675039611757&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__76_80TO92_100&#34; class=&#34;&#34;&gt;significa&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8024199057836086&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__82_83TO102_104&#34; class=&#34;&#34;&gt;que&lt;/span&gt; &lt;span id=&#34;noHighlight_0.6282858841586858&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__85_87TO106_109&#34; class=&#34;&#34;&gt;pode-se&lt;/span&gt; &lt;span id=&#34;noHighlight_0.12069125333800912&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__89_105TO111_120&#34; class=&#34;&#34;&gt;aproveitar&lt;/span&gt; &lt;span id=&#34;noHighlight_0.06503489147871733&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__107_109TO122_123&#34; class=&#34;&#34;&gt;as&lt;/span&gt; &lt;span id=&#34;noHighlight_0.5774596999399364&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__111_114TO125_132&#34; class=&#34;&#34;&gt;melhores&lt;/span&gt; &lt;span id=&#34;noHighlight_0.5065434332937002&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__116_120TO134_139&#34;&gt;partes&lt;/span&gt; &lt;span id=&#34;noHighlight_0.9085071054287255&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__122_123TO141_142&#34;&gt;do&lt;/span&gt;&lt;span id=&#34;noHighlight_0.2688959944061935&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__125_127TO144_146&#34;&gt;CSS&lt;/span&gt; &lt;span id=&#34;noHighlight_0.34350621490739286&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__129_135TO148_150&#34;&gt;sem &lt;/span&gt;&lt;span id=&#34;ouHighlight__137_141TO152_156&#34; class=&#34;&#34;&gt;o uso de &lt;/span&gt;&lt;span id=&#34;ouHighlight__158_160TO170_172&#34; class=&#34;&#34;&gt;CSS&lt;/span&gt; &lt;span id=&#34;noHighlight_0.566822367021814&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__162_166TO174_178&#34; class=&#34;&#34;&gt;hacks&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8859184393659234&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__168_169TO180_181&#34; class=&#34;&#34;&gt;ou&lt;/span&gt; &lt;span id=&#34;noHighlight_0.11384950415231287&#34;&gt;&lt;/span&gt;_&lt;span id=&#34;ouHighlight__171_179TO183_194&#34; class=&#34;&#34;&gt;fallbacks&lt;/span&gt;_&lt;span id=&#34;noHighlight_0.8839674249757081&#34;&gt;.&lt;/span&gt; &lt;span id=&#34;noHighlight_0.7743959142826498&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;_&lt;span id=&#34;ouHighlight__182_187TO197_202&#34; class=&#34;&#34;&gt;Pixels&lt;/span&gt; &lt;span id=&#34;noHighlight_0.37850770237855613&#34;&gt;&lt;/span&gt;_&lt;span id=&#34;ouHighlight__194_197TO204_208&#34; class=&#34;&#34;&gt;foram&lt;/span&gt; &lt;span id=&#34;noHighlight_0.46460154722444713&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__199_205TO210_217&#34; class=&#34;highlight&#34;&gt;trocados&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8350909308064729&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__207_209TO219_221&#34; class=&#34;&#34;&gt;por&lt;/span&gt; &lt;span id=&#34;noHighlight_0.6744522778317332&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__211_214TO223_226&#34; class=&#34;&#34;&gt;REMS &lt;/span&gt;&lt;span id=&#34;ouHighlight__216_218TO228_228&#34; class=&#34;&#34;&gt;e&lt;/span&gt; &lt;span id=&#34;noHighlight_0.28712224145419896&#34;&gt;EMS, &lt;/span&gt;&lt;span id=&#34;ouHighlight__224_240TO234_246&#34; class=&#34;&#34;&gt;eventualmente&lt;/span&gt;&lt;span id=&#34;noHighlight_0.32065628934651613&#34;&gt; para&lt;/span&gt;&lt;span id=&#34;noHighlight_0.47396003059111536&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__245_248TO250_255&#34; class=&#34;&#34;&gt;tornar&lt;/span&gt; &lt;span id=&#34;noHighlight_0.46526208659633994&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__293_296TO257_261&#34; class=&#34;&#34;&gt;ainda&lt;/span&gt; &lt;span id=&#34;noHighlight_0.6913347935769707&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__298_303TO263_272&#34; class=&#34;&#34;&gt;mais fácil&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8071073237806559&#34;&gt;a &lt;/span&gt;&lt;span id=&#34;ouHighlight__261_270TO276_285&#34; class=&#34;&#34;&gt;tipografia&lt;/span&gt; &lt;span id=&#34;noHighlight_0.17413580045104027&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__250_259TO287_296&#34; class=&#34;&#34;&gt;responsiva&lt;/span&gt; &lt;span id=&#34;noHighlight_0.8454670906066895&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__272_274TO298_298&#34;&gt;e&lt;/span&gt; &lt;span id=&#34;noHighlight_0.6733989510685205&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__286_291TO300_314&#34; class=&#34;&#34;&gt;dimensionamento &lt;/span&gt;&lt;span id=&#34;noHighlight_0.3753285778220743&#34;&gt;do &lt;/span&gt;&lt;span id=&#34;ouHighlight__276_284TO319_328&#34; class=&#34;&#34;&gt;componente&lt;/span&gt;&lt;span id=&#34;noHighlight_0.21270700567401946&#34;&gt;.&lt;/span&gt; &lt;span id=&#34;noHighlight_0.9447224051691592&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;ouHighlight__306_307TO331_332&#34; class=&#34;&#34;&gt;Se&lt;/span&gt; &lt;span id=&#34;noHighlight_0.3133630729280412&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__309_311TO334_337&#34; class=&#34;&#34;&gt;você &lt;/span&gt;&lt;span id=&#34;ouHighlight__313_316TO339_346&#34; class=&#34;&#34;&gt;precisar&lt;/span&gt; &lt;span id=&#34;noHighlight_0.47584015876054764&#34;&gt;de &lt;/span&gt;&lt;span id=&#34;ouHighlight__322_328TO351_357&#34; class=&#34;&#34;&gt;suporte&lt;/span&gt;&lt;span id=&#34;noHighlight_0.22770247887820005&#34;&gt; ao &lt;/span&gt;&lt;span id=&#34;ouHighlight__318_320TO362_364&#34; class=&#34;&#34;&gt;IE8&lt;/span&gt;&lt;span id=&#34;noHighlight_0.4113714068662375&#34;&gt;,&lt;/span&gt;&lt;span id=&#34;noHighlight_0.914000281598419&#34;&gt; vai ter que &lt;/span&gt;&lt;span id=&#34;ouHighlight__331_334TO367_374&#34; class=&#34;&#34;&gt;continuar&lt;/span&gt;&lt;span id=&#34;noHighlight_0.2844633760396391&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__336_340TO376_381&#34; class=&#34;&#34;&gt;usando&lt;/span&gt;&lt;span id=&#34;noHighlight_0.9633060169871897&#34;&gt; o&lt;/span&gt;&lt;span id=&#34;noHighlight_0.42434997437521815&#34;&gt; &lt;/span&gt;&lt;span id=&#34;ouHighlight__342_350TO388_396&#34; class=&#34;&#34;&gt;Bootstrap v3&lt;/span&gt;&lt;span id=&#34;noHighlight_0.24006641446612775&#34;&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;ouHighlight__27_34TO18_26&#34; class=&#34;&#34;&gt;Também foram adicionados controles&lt;/span&gt; &lt;span id=&#34;noHighlight_0.05131633346900344&#34;&gt;de &lt;/span&gt;&lt;span id=&#34;ouHighlight__22_25TO31_40&#34; class=&#34;&#34;&gt;formulários&lt;/span&gt; &lt;span id=&#34;noHighlight_0.37164003239013255&#34;&gt;&lt;/span&gt;&lt;span id=&#34;ouHighlight__15_20TO42_54&#34; class=&#34;&#34;&gt;personalizados&lt;/span&gt;&lt;span id=&#34;noHighlight_0.46348911290988326&#34;&gt;,&lt;/span&gt; &lt;span id=&#34;noHighlight_0.749728238210082&#34;&gt;classes de &lt;/span&gt;_&lt;span id=&#34;ouHighlight__37_42TO57_62&#34; class=&#34;&#34;&gt;margin &lt;/span&gt;_&lt;span id=&#34;ouHighlight__44_46TO64_64&#34;&gt;e&lt;/span&gt; &lt;span id=&#34;noHighlight_0.9394099384080619&#34;&gt;&lt;/span&gt;_&lt;span id=&#34;ouHighlight__48_54TO66_72&#34;&gt;padding&lt;/span&gt;_&lt;span id=&#34;noHighlight_0.7057353919371963&#34;&gt;, e &lt;/span&gt;&lt;span id=&#34;ouHighlight__77_83TO83_89&#34;&gt;novos utilitários de classes em geral&lt;/span&gt;&lt;span id=&#34;noHighlight_0.3223601672798395&#34;&gt;.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;O lançamento da versão final será dividido em quatro etapas: lançamento de algumas versões Alpha, depois mais duas versões betas, fase de testes em ambiente de produção, e então a esperada versão final. Vale lembrar que o suporte a versão 3 continuará, recebendo apenas atualizações críticas e melhorias na documentação.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quando nós lançamos Bootstrap 3, imediatamente paramos todo o apoio para v2.x, causando muita dor para todos os nossos usuários. Isso foi um erro que não vai acontecer novamente. Em um futuro próximo, manteremos o Bootstrap 3 com correções de bugs críticos e melhorias de documentação. Os docs da v3 também continuarão hospedados após a liberação final da v4.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2015/08/Capturar.png&#34;&gt;&lt;img class=&#34;alignnone wp-image-50866 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/08/Capturar.png&#34; alt=&#34;Temas para os criadores que utilizam o Bootstrap 4&#34; width=&#34;1349&#34; height=&#34;671&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Além de lançar o Bootstrap 4, também foi anunciado outro projeto: o &lt;strong&gt;Bootstrap Official Themes&lt;/strong&gt;, que são alguns temas criados pelos próprios criadores do &lt;em&gt;framework&lt;/em&gt;. Existem três temas disponíveis para &lt;em&gt;dashboards&lt;/em&gt;, marketing de um produto e outro para aplicações.&lt;/p&gt;

&lt;p&gt;Infelizmente, todos os três são pagos (cada tema custa $99). Ainda não foi divulgado se os temas poderão ser gratuitos no futuro.&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Criando Layouts com Susy Framework</title>
      <link>https://tableless.github.io/hugo-public/criando-layouts-com-susy-framework/</link>
      <pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/criando-layouts-com-susy-framework/</guid>
      <description>

&lt;p&gt;Com a alta demanda e prazos cada vez menores somos obrigados a trabalhar cada vez mais rápido e isso serve de incentivo para que novos frameworks sejam feitos buscando melhorar a qualidade no desenvolvimento. Um desses frameworks é o Susy e nesse artigo vamos conhecer e dar os primeiros passos com ele.&lt;/p&gt;

&lt;h2 id=&#34;o-que-é-susy&#34;&gt;O que é Susy?&lt;/h2&gt;

&lt;p&gt;Susy é um framework que permite criar grids de acordo com as necessidades do seu site. Diferente de outros como Bootstrap e Foundation, você não vai precisar importar um arquivo cheio de classes em que vai usar apenas algumas delas. O Susy trabalha direto no estilo das classes que você definiu e personalizou.&lt;/p&gt;

&lt;p&gt;Para começar a usá-lo você precisa ter o Sass instalado e o mínimo de conhecimento sobre ele. Não vou me aprofundar em Sass, pois não é o foco desse artigo, mas para quem tiver alguma dúvida a respeito pode ver uma série de &lt;a href=&#34;http://goo.gl/PmuwuA&#34; target=&#34;_blank&#34;&gt;artigos&lt;/a&gt; aqui mesmo no Tableless.&lt;/p&gt;

&lt;p&gt;Agora que já sabemos do que se trata vamos começar a desenvolver nosso layout com Susy.&lt;/p&gt;

&lt;h2 id=&#34;criando-seu-primeiro-layout-com-susy&#34;&gt;Criando seu primeiro layout com Susy&lt;/h2&gt;

&lt;p&gt;Assumindo que você já tem o Sass instalado, vamos instalar o Susy. Abra o prompt de comando e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;gem install susy&lt;/pre&gt;

&lt;p&gt;Após concluir a instalação vamos criar uma pasta para o projeto e dentro dela um arquivo index.html, uma pasta css e uma pasta scss com um arquivo style.scss dentro dela.&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-50233&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/07/estrutura-de-pastas.jpg&#34; alt=&#34;Learning Susy&#34; width=&#34;617&#34; height=&#34;76&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;iniciando-o-desenvolvimento&#34;&gt;Iniciando o desenvolvimento&lt;/h2&gt;

&lt;p&gt;Vamos construir o seguinte layout:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone size-full wp-image-50282&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2015/07/layout.png&#34; alt=&#34;layout&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Primeiramente vamos iniciar o Sass para que nosso código possa ser compilado. Abra a pasta do projeto na linha de comando e digite:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;sass --watch scss:css -r susy&lt;/pre&gt;

&lt;p&gt;Feito isso um arquivo style.css foi criado dentro da pasta css. Vamos adiciona-lo no head no html:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;link rel=&#34;stylesheet&#34; href=&#34;css/style.css&#34;&amp;gt;&lt;/pre&gt;

&lt;p&gt;Vamos adicionar o normalize ao nosso projeto&lt;/p&gt;

&lt;p&gt;Para usar o Susy no projeto temos apenas que adicionar a seguinte linha no style.scss:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@import &#34;susy&#34;;&lt;/pre&gt;

&lt;h3 id=&#34;susy-map&#34;&gt;Susy Map&lt;/h3&gt;

&lt;p&gt;Susy Map é um conjunto de instruções que são declaradas no início do projeto.  O grid é gerado de acordo com as informações declaradas nele. Abaixo temos o Map do nosso projeto, vamos adiciona-lo no style.scss, mais informações podem ser adicionadas , mas para nosso projeto é o suficiente. As linhas estão comentadas informando o que cada uma faz.&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$susy:(
    columns: 8, // número de colunas do grid
    container: 1140px, // largura do container
    debug: (image: show), // exibe as colunas do grid
);&lt;/pre&gt;

&lt;p&gt;Vou adicionar o código completo, mas somente as funções do Susy serão explicadas. Então vamos começar! No HTML, vamos adicionar o header da página:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;header class=&#34;site-header&#34;&amp;gt;
    &amp;lt;div class=&#34;container&#34;&amp;gt;
        &amp;lt;div class=&#34;logo&#34;&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Logo&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;nav class=&#34;menu&#34;&amp;gt;
            &amp;lt;ul&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;About&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Photos&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Contact&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;/ul&amp;gt;
        &amp;lt;/nav&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/header&amp;gt;&lt;/pre&gt;

&lt;p&gt;Vamos adicionar o estilo dele:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;.container {
    @include container(); // inclui na classe o container definido no Susy Map
}
.logo {
    float: left;
    padding: 0.9375rem;
    line-height: 2rem;
    font-size: 1.5rem;
}
nav {
    float: right;
    li {
        list-style: none;
        float: left;
        margin-left: 2rem;
        line-height: 2rem;
    }
}&lt;/pre&gt;

&lt;p&gt;Depois do header vamos inserir o banner no html:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;div class=&#34;container&#34;&amp;gt;
    &amp;lt;img src=&#34;img/banner.jpg&#34; class=&#34;banner&#34;&amp;gt;
&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;Agora o estilo do banner:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;img {
    width:100%;
}
.banner {
    @include span(8 of 8);
    margin: gutter() 0;
    height: 100%;
}&lt;/pre&gt;

&lt;p&gt;O &amp;#8220;@include span (8 of 8)&amp;#8221; é uma função do Susy que diz que o banner irar ocupar 8 colunas das 8 declaradas no Susy Map, mas não é só isso, reparem que no margin adicionamos um valor &amp;#8220;gutter()&amp;#8221;, isso é outra função do Susy que adiciona o valor que existe entre os grids, pode ver como o espaço que está entre o header e o banner é o mesmo que está entre as 8 colunas que definimos no grids.&lt;/p&gt;

&lt;p&gt;Agora vamos adicionar o conteúdo do layout:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;div class=&#34;container&#34;&amp;gt;
    &amp;lt;div class=&#34;sidebar&#34;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Fortaleza&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Natal&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Recife&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;a href=&#34;#&#34;&amp;gt;Salvador&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&#34;content&#34;&amp;gt;
        &amp;lt;div class=&#34;content-item&#34;&amp;gt;&amp;lt;img src=&#34;img/001.jpg&#34;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&#34;content-item&#34;&amp;gt;&amp;lt;img src=&#34;img/002.jpg&#34;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&#34;content-item&#34;&amp;gt;&amp;lt;img src=&#34;img/003.jpg&#34;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&#34;content-item&#34;&amp;gt;&amp;lt;img src=&#34;img/004.jpg&#34;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&#34;content-item&#34;&amp;gt;&amp;lt;img src=&#34;img/005.jpg&#34;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&#34;content-item&#34;&amp;gt;&amp;lt;img src=&#34;img/006.jpg&#34;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/pre&gt;

&lt;p&gt;E o estilo delas:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;.sidebar {
    @include span (2 of 8);
    ul {
        margin: 0;
        padding: 1.2rem;
    }
    li {
        list-style: none;
        font-size: 1.1rem;
        border-bottom: 2px dotted #c6c6c6;
        &amp;:last-child {
            border:none;
        }
    }   
    a {
        display: block;
        padding: 1rem .5rem;
        color: #333;
        line-height: 2;
        text-decoration: none;
    }
}
.content {
    @include span (6 of 8 last);
}
.content-item {
    @include gallery(2 of 6);
    margin-bottom: gutter();
}&lt;/pre&gt;

&lt;p&gt;Repare nos includes que acabamos de usar. Na mesma linha usamos 2 colunas para o sidebar e as 6 para o content, veja que adicionamos um last no final do include na classe content, esse last serve para dizer que são as ultimas colunas da linha. O espaço entre os grids é feito com um margin-right e o last serve parar remover esse margin-right do ultimo item do grid. Olha lá o aquivo style.css para entender melhor o que está sendo feito.&lt;/p&gt;

&lt;p&gt;O footer não tem muito o que falar, então vamos apenas adicionar o código:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;footer class=&#34;site-footer&#34;&amp;gt;
    &amp;lt;div class=&#34;container&#34;&amp;gt;
        &amp;lt;p&amp;gt;Copyright © 2015 - Desenvolvido por Felipe César para o Tableless&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/footer&amp;gt;&lt;/pre&gt;

&lt;p&gt;E o estilo:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;.site-footer {
    margin-top: 2rem;
    padding: 0.6rem 0;
    color: #fff;
}&lt;/pre&gt;

&lt;p&gt;Por fim vamos apenas remover do Susy Map a linha que exibe os grids:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;debug: (image: show),&lt;/pre&gt;

&lt;p&gt;Pronto, finalizamos o nosso layout, fácil não é?! Esse projeto foi bem simples apenas para apresentar o framework e mostrar como funciona, mas não pare por aí, faça o &lt;a href=&#34;https://github.com/felipecesr/layout-susy-framework&#34; target=&#34;_blank&#34;&gt;download do código&lt;/a&gt;, brinque com ele, acesse a documentação do &lt;a href=&#34;http://susydocs.oddbird.net/en/latest/&#34; target=&#34;_blank&#34;&gt;Susy&lt;/a&gt; e conheça outros recursos que podem te ajudar bastante no desenvolvimento.&lt;/p&gt;

&lt;p&gt;Espero que tenham gostado do artigo, bons estudos!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Grid simples com SASS</title>
      <link>https://tableless.github.io/hugo-public/grid-simples-com-sass/</link>
      <pubDate>Wed, 29 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/grid-simples-com-sass/</guid>
      <description>&lt;p&gt;Algumas vezes você vai preferir usar um sistema de grid feito por você e não algum framework do mercado como o Bootstrap ou o Foundation. Isso tem suas vantagens e desvantagens. Mas se você preferir um grid presonalizado, fazer isso com SASS é mole.&lt;/p&gt;

&lt;p&gt;Existe uma série de soluções em SASS aí fora. Algumas mais completas que essa, mas essa acaba ganhando por ser muito simples, com menos recursos, mas muito funcional para projetos pequenos.&lt;/p&gt;

&lt;p&gt;O HTML básico de exemplo será esse:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;div class=&#34;container&#34;&amp;gt;
  &amp;lt;div class=&#34;grid-4&#34;&amp;gt;Coluna de 4&amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;grid-4&#34;&amp;gt;Coluna de 4&amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;grid-4&#34;&amp;gt;Coluna de 4&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Primeiro, como qualquer sistema de grid em SASS, defina as variáveis que comandarão o gerenciamento do Grid.&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$grid-gutter: 10px // espaçamento entre as colunas
$grid-columns: 12 // Quantidade de colunas
$grid-max: 980px // Tamanho do container

// Código básico das colunas do grid
[class*=&#34;grid-&#34;]
  float: left
  padding: 0 $grid-gutter
  margin-bottom: 20px
&lt;/pre&gt;

&lt;p&gt;Agora basta fazer um &lt;code&gt;for&lt;/code&gt; simples no SASS. Esse for vai calcular a largura de todas as colunas, que no nosso exemplo tem apenas 12:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@for $i from 1 through $grid-columns
  .grid-#{$i}
    width: 100% / $grid-columns * $i
&lt;/pre&gt;

&lt;p&gt;O output desse &lt;code&gt;for&lt;/code&gt; é algo mais ou menos assim:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.grid-1 {
  width: 8.33333%;
}

.grid-2 {
  width: 16.66667%;
}

.grid-3 {
  width: 25%;
}

.grid-4 {
  width: 33.33333%;
}

.grid-5 {
  width: 41.66667%;
}

.grid-6 {
  width: 50%;
}

.grid-7 {
  width: 58.33333%;
}

.grid-8 {
  width: 66.66667%;
}

.grid-9 {
  width: 75%;
}

.grid-10 {
  width: 83.33333%;
}

.grid-11 {
  width: 91.66667%;
}

.grid-12 {
  width: 100%;
}
&lt;/pre&gt;

&lt;p&gt;O resultado você pode ver abaixo:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Workflow Front-end</title>
      <link>https://tableless.github.io/hugo-public/workflow-front-end/</link>
      <pubDate>Wed, 21 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/workflow-front-end/</guid>
      <description>

&lt;p&gt;O desenvolvimento em html, javascript e CSS é uma forma mágica de se construir um mundo novo a cada linha de código. Os mágicos do front-end precisam de cartolas para que retirem seus coelhos. Essas cartolas e varinhas mágicas devem ser escolhidas a dedo, para que a mágica aconteça de forma suave e agradável à plateia.&lt;/p&gt;

&lt;p&gt;Cada mágico tem sua técnica, portanto o objetivo não é estabelecer um padrão imutável, mas estabelecer diretrizes que possam servir de auxílio a qualquer ilusionista. Vamos entender magia.&lt;/p&gt;

&lt;h2 id=&#34;baralho&#34;&gt;Baralho&lt;/h2&gt;

&lt;p&gt;Todo mágico possui um baralho. Com ele é possível fazer um número imenso de ilusões. Tão versátil quanto um baralho, deve ser o editor de texto a ser usado pelo desenvolvedor.&lt;/p&gt;

&lt;p&gt;Vamos falar de dois editores: Edge Code e Sublime Text.&lt;/p&gt;

&lt;p&gt;O Edge Code tem como objetivo permitir o foco no trabalho, para isso ele tem uma interface propositalmente simples. Uma mágica que adoro nele é poder editar conteúdo de um arquivo por meio de outro com base em uma relação específica – ou seja, tenho no arquivo html uma marcação que faz referência a uma classe CSS, clicando com o botão direito nessa classe e selecionando quick edit podemos editar o CSS do arquivo externo com base no arquivo html. Esse baralho tem muito mais mágicas.&lt;/p&gt;

&lt;p&gt;O Sublime Text tem tantos recursos que possibilitam uma produtividade imensa. Quando você acessa &lt;a href=&#34;http://www.sublimetext.com/&#34;&gt;http://www.sublimetext.com/&lt;/a&gt;, nota-se o foco em mostrar o quão produtivo o Sublime Text é. Uma mágica de produtividade é a possibilidade de selecionar um texto que se repete em um arquivo html por meio da tecla de atalho Ctrl+d e alterar todos ao mesmo tempo. Adoro isso.&lt;/p&gt;

&lt;h2 id=&#34;cartola&#34;&gt;Cartola&lt;/h2&gt;

&lt;p&gt;O NodeJS permite que mágicas que eram feitas somente no palco – navegador –, possam ser feitas atrás das cortinas – servidor. No entanto essas mágicas são cada vez mais complexas, gerando uma dependência de recursos que necessitariam de outra ferramenta mágica para gerenciá-las.&lt;/p&gt;

&lt;p&gt;Essa outra ferramenta mágica é nossa cartola. Dela tiramos tudo que é necessário para fazermos o show. Duas cartolas não podem deixar de serem conhecidas: NPM e Bower.&lt;/p&gt;

&lt;p&gt;O NPM é o que todo gerenciador de dependências precisa ser: instalador de pacotes, gerenciador de versão e gerenciador de dependências.&lt;/p&gt;

&lt;p&gt;O Bower é o que o NPM é, mas para componentes front-end.&lt;/p&gt;

&lt;p&gt;Se este é o cenário, então é bom termos duas cartolas, cada uma fazendo seu tipo de mágica: NPM no desenvolvimento com Grunt, Gulp, JSHint, etc; e Bower para componentes front-end.&lt;/p&gt;

&lt;h2 id=&#34;assistentes&#34;&gt;Assistentes&lt;/h2&gt;

&lt;p&gt;Assistentes de palco são vitais no contexto de muitas mágicas. Além de distrair quem vê o espetáculo, elas embelezam o ambiente. Elas são o CSS da ilusão.&lt;/p&gt;

&lt;p&gt;Frameworks de estilo podem agilizar muito um trabalho, porque muitas das preocupações iniciais do projeto, podem ser deixadas de lado pela adoção de um padrão, que já respondeu a todas elas. Nossas assistentes de palco são: Bootstrap e Pure.&lt;/p&gt;

&lt;p&gt;Bootstrap é de longe a ferramenta mais popular para atribuição de estilo aos projetos. Pontos positivos: variedade de componentes, utilizado por grandes empresas que contribuem com o projeto e boa documentação. Ele é a assistente que sabe como as mágicas são feitas.&lt;/p&gt;

&lt;p&gt;Pure tem como objetivo fornecer estilo totalmente independente de qualquer javascript e de uma maneira muito leve. É uma assistente magrinha que faz seu trabalho bem feito.&lt;/p&gt;

&lt;p&gt;É inquestionável que a aparência faz muita diferença.&lt;/p&gt;

&lt;h2 id=&#34;caixas-e-lâminas&#34;&gt;Caixas e lâminas&lt;/h2&gt;

&lt;p&gt;Na mágica da mulher cortada ao meio, uma mulher entra numa caixa e o mágico enfia uma lâmina no meio da caixa, e ela é separada em duas partes. As mãos, a cabeça e os pés continuam se mexendo. Quando uso pré-processadores CSS me sinto separado um corpo ao meio, mas ao mesmo tempo confiando que ele irá unir as partes e no final teremos um corpo inteiro.&lt;/p&gt;

&lt;p&gt;É claro que escrever CSS puro gerará menos código que o uso errôneo de mixins em SASS. Mas devemos medir a relação de custo e benefício em relação a produtividade (após a curva de aprendizagem ser superada) e qualidade do nosso código, para podermos escolher aquilo que é melhor para o projeto &amp;#8211; espetáculo. Nossas caixas e lâminas para separarem corpos podem ser: LESS e SASS.&lt;/p&gt;

&lt;p&gt;As características da LESS que devem ser sempre destacadas são, em sua maioria, comuns aos pré-processadores. Mas devem ser ditas aqui:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Variáveis: valores que são usados em vários lugares podem ser reutilizados por todo o estilo do projeto, e quando uma alteração for necessária, poderá ser feita com muita facilidade.&lt;/li&gt;
&lt;li&gt;Mixins: servem ao mesmo propósito das variáveis – a reutilização –, mas sendo usadas para classes completas. Podendo incluir uma classe dentro de outra classe, como se fosse uma propriedade.&lt;/li&gt;
&lt;li&gt;Aninhamento: a possibilidade de aninhar seletores dentro de outros seletores é um truque que me encanta muito. Porque ele criará os seletores longos por conta própria e você ficará com o trabalho de apenas construir a hierarquia a seletores por meio de aninhamento.&lt;/li&gt;
&lt;li&gt;Operações: executar operações com propriedades e cores por meio do CSS é tão fora de cogitação que se torna muito surpreendente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SASS faz tudo isso descrito acima, e faz antes de o LESS ter feito. Mas a consideração que deve ser feita é: LESS tem uma sintaxe mais simples, que leva a uma curva de aprendizagem menor, e quando essa curva atinge uma boa inclinação, ela é mais produtiva.&lt;/p&gt;

&lt;h2 id=&#34;automatização&#34;&gt;Automatização&lt;/h2&gt;

&lt;p&gt;Muitas coisas precisam ser feitas, que não necessariamente são observadas, mas tem valor. Isso se aplica a tudo na vida. Montar o palco para o espetáculo, preparar e limpar as ferramentas, checar se tudo está apto para funcionamento, etc. Concatenar arquivos, minificar código, realizar o deploy, etc.&lt;/p&gt;

&lt;p&gt;Estas tarefas podem continuar a serem feitas, mas sem o trabalho que normalmente se tem para as suas execuções. A ferramenta a ser usada neste caso é o Grunt.&lt;/p&gt;

&lt;p&gt;Com o Grunt você pode automatizar tarefas para serem executadas via linha de comando. Basta ter o NodeJS e configurar as tarefas a serem automatizadas.&lt;/p&gt;

&lt;h2 id=&#34;qualidade&#34;&gt;Qualidade&lt;/h2&gt;

&lt;p&gt;Uma mágica bem feita pode ser repetida diversas vezes, e ainda causará boas impressões. Isso se deve a qualidade com que a mágica foi feita. Existe a melhor maneira de executá-la, e quando isso é feito, tudo flui muito bem. Escrever códigos javascript e css com qualidade &amp;#8211; o que inclui boas práticas de sintaxe e construção – é um desafio, porque escrever sem boas práticas também funciona.&lt;/p&gt;

&lt;p&gt;Para verificar a qualidade do nosso código temos: JSLint, JSHint e CSSLint.&lt;/p&gt;

&lt;p&gt;JSLint realiza uma busca com foco em erros de sintaxe e erros estruturais.&lt;/p&gt;

&lt;p&gt;JSHint é um fork do JSLint com uma melhoria que permite customizações, ele permite flexibilidade.&lt;/p&gt;

&lt;p&gt;CSSLint tem o objetivo de verificar além da sintaxe a performance do CSS.&lt;/p&gt;

&lt;h2 id=&#34;enfim&#34;&gt;Enfim&lt;/h2&gt;

&lt;p&gt;Cada mágico tem um conjunto de mágicas que são apresentadas. Mas todos tem o mesmo objetivo: encantar. Todo desenvolvedor precisa encantar a todos para ter seu trabalho reconhecido. Essas ferramentas, e muitas outras, podem fazer a diferença. Então faça a diferença.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Em um relacionamento sério com generators front-end – Parte 2</title>
      <link>https://tableless.github.io/hugo-public/em-um-relacionamento-serio-com-generators-front-end-parte-2/</link>
      <pubDate>Wed, 10 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/em-um-relacionamento-serio-com-generators-front-end-parte-2/</guid>
      <description>

&lt;h1 id=&#34;o-início&#34;&gt;O início&lt;/h1&gt;

&lt;p&gt;O objetivo desse post não é para fazer com que os desenvolvedores só usem esta ferramenta, e sim para apresentar opções de desenvolvimentos ágeis que podem ser úteis no seu dia a dia. É uma ferramenta a qual lhe oferece um stack completo de estrutura de projeto, basta você saber como usar e para que vai usar.&lt;/p&gt;

&lt;h3 id=&#34;o-yeoman&#34;&gt;O Yeoman&lt;/h3&gt;

&lt;p&gt;O Yeoman é considerado uma ferramenta web de andaimes para criação de webapp modernos, nele você consegue montar um esquema de trabalho facilitando seu desenvolvimento. Seu fluxo de trabalho é composto por 3 ferramentas melhorando sua produtividade e satisfação.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;YO &amp;#8211; Conjunto de geradores que nos permite prototipar&lt;/li&gt;
&lt;li&gt;Gruntjs &amp;#8211; Gerencia suas tarefas de forma automatizadas&lt;/li&gt;
&lt;li&gt;Bower &amp;#8211; Gerencia suas dependências aplicadas no projeto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS: São ferramentas que por padrão já vem com o Yeoman, porém temos a opção de usar o Gulp para gerenciar nossas tarefas.&lt;/p&gt;

&lt;h3 id=&#34;ta-me-convence&#34;&gt;Ta, me convence!&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/convence.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46124&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/convence.jpg&#34; alt=&#34;convence&#34; width=&#34;477&#34; height=&#34;275&#34; srcset=&#34;uploads/2014/12/convence.jpg 477w, uploads/2014/12/convence-241x139.jpg 241w, uploads/2014/12/convence-400x230.jpg 400w&#34; sizes=&#34;(max-width: 477px) 100vw, 477px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;O Yeoman sendo uma ferramenta completa, pode proporcionar para você formas práticas e ágeis de desenvolvimento com menos tempo e com boa qualidade. Alguns criticam, outros elogiam, mas você só saberá o resultado se positivo ou negativo, quando usar esse brinquedinho.&lt;/p&gt;

&lt;p&gt;Penso o seguinte: Uma ferramenta nova no marcado ou até mesmo uma antiga com novas versões e novas features, precisam ser exploradas para saber o que a mesma pode nos proporcionar. Por isso nunca se intimide com novas tecnologias e sim aproveite para ganhar conhecimentos.&lt;/p&gt;

&lt;h3 id=&#34;dicas-importantes-antes-de-praticar&#34;&gt;Dicas importantes antes de praticar&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/dica.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46127&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/dica.jpg&#34; alt=&#34;dica&#34; width=&#34;400&#34; height=&#34;245&#34; srcset=&#34;uploads/2014/12/dica.jpg 400w, uploads/2014/12/dica-226x139.jpg 226w&#34; sizes=&#34;(max-width: 400px) 100vw, 400px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Antes de mais nada já saiba que não ter medo do terminal é um diferencial. Sacanagem Hahaha. Mas é importante saber que a maioria das configurações e monitoramento serão via terminal, por isso é bom entender e interpretar cada linha de comando digitada.&lt;/p&gt;

&lt;p&gt;Lembrando que para usar o Yeoman é preciso ter Nodejs instalado em sua máquina, por isso se você não tem essa plataforma, baixe &lt;a href=&#34;http://nodejs.org/download/&#34;&gt;aqui&lt;/a&gt;, instale e parte para a próxima etapa. Após a instalação do nodejs o resto é mágica!&lt;/p&gt;

&lt;p&gt;Uma observação válida a ser feita é o seguinte: Você que desenvolve com Mac OS ou Linux *-* por padrão já vem instalado o Ruby e para quem desenvolve em windows é preciso instalar os dois: Nodejs e Ruby. Você pode baixar o ruby bem &lt;a href=&#34;https://www.ruby-lang.org/pt/downloads/&#34;&gt;aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;vendo-teorias-na-prática&#34;&gt;Vendo teorias na prática&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/vendo-tv.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-46128&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/vendo-tv.jpg&#34; alt=&#34;vendo-tv&#34; width=&#34;381&#34; height=&#34;315&#34; srcset=&#34;uploads/2014/12/vendo-tv.jpg 381w, uploads/2014/12/vendo-tv-168x139.jpg 168w&#34; sizes=&#34;(max-width: 381px) 100vw, 381px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Conforme comentado acima, precisa ter nodejs instalado, por isso instale e após a instalação seguia os passos seguintes.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Digite o código abaixo via linha de comando na raiz do seu projeto. O mesmo instala o Yo, Gruntjs e Bower de forma global, podendo usar também Gulp. &lt;pre class=&#34;lang-html&#34;&gt;npm install -g yo grunt-cli bower&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instale o generator da aplicação, nesse caso o generator escolhido para uso é o &amp;#8220;webapp&amp;#8221;. &lt;pre class=&#34;lang-html&#34;&gt;npm install generator-webapp&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inicie a aplicação com YO. &lt;pre class=&#34;lang-html&#34;&gt;yo webapp&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O comando &amp;#8220;generator-webapp&amp;#8221; é o gerador de aplicações web padrão que será um projeto contendo HTML5 Boilerplate , jQuery , Modernizr e Bootstrap . Você vai ter uma opção durante as instruções interativas para não incluir muitos destes.&lt;/p&gt;

&lt;h3 id=&#34;mas-o-que-vem-depois&#34;&gt;Mas o que vem depois?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/01.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46228&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/01.jpg&#34; alt=&#34;01&#34; width=&#34;338&#34; height=&#34;190&#34; srcset=&#34;uploads/2014/12/01.jpg 400w, uploads/2014/12/01-247x139.jpg 247w&#34; sizes=&#34;(max-width: 338px) 100vw, 338px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Após o processo de instalação seguida passo a passo, a ferramenta já pode ser usada para criar suas aplicações. Você vai perceber que o YO já te retorna uma estrutura de pasta bem completa com tudo que você precisa e ainda alguns recursos a mais. Veja abaixo!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-raiz.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46230&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-raiz.jpg&#34; alt=&#34;estrutura raiz&#34; width=&#34;193&#34; height=&#34;269&#34; srcset=&#34;uploads/2014/12/estrutura-raiz.jpg 233w, uploads/2014/12/estrutura-raiz-99x139.jpg 99w&#34; sizes=&#34;(max-width: 193px) 100vw, 193px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Analisando a estrutura, digo o seguinte:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A pasta &lt;strong&gt;app&lt;/strong&gt; é onde vai rodar toda sua aplicação em modo de desenvolvimento. É lá que você cria seus arquivos HTML / CSS / JavaScript e entre outros. Mas essa pasta vamos ver com detalhes já já.&lt;/li&gt;
&lt;li&gt;A pasta &lt;strong&gt;bower_componnets&lt;/strong&gt; é criada pelo bower, onde você vai baixar e usar componentes como bootstrap, AngularJS, Backbone e entre outros e por padrão ele já traz o jQuery para você. Caso você não goste do nome “bower_componentes” você tem a opção de criar uma pasta como “libs” ou “componentes” e apontar seus componentes baixados para está nova pasta, só precisa criar um arquivo “.bowerrc” e lá você aponta para tal pasta. Exemplo: { app/libs ou app/componentes }&lt;/li&gt;
&lt;li&gt;A pasta &lt;strong&gt;node_modules&lt;/strong&gt; são os módulos instalados pelo nodejs, lá você vai ver alguns plugins do Gruntjs instalados por padrão, podendo ainda instalar outros plugins.&lt;/li&gt;
&lt;li&gt;Os arquivos &lt;strong&gt;Gruntfile&lt;/strong&gt; e &lt;strong&gt;Bower.json&lt;/strong&gt; são de configurações de componentes, onde o Gruntfile armazena todas as tarefas automatizadas do gruntjs como: minificação, compilação e otimização. Já o bower.json é um arquivo simples que retorna dados importantes dos componentes gerenciados no bower e armazena os componentes usados e suas versões.&lt;/li&gt;
&lt;li&gt;Os outros arquivos são de configuração da ferramenta, incluindo os arquivos ocultos.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;a-tal-pasta-app-da-minha-aplicação&#34;&gt;A tal pasta APP da minha aplicação&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/02.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46231&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/02.jpg&#34; alt=&#34;02&#34; width=&#34;355&#34; height=&#34;239&#34; srcset=&#34;uploads/2014/12/02.jpg 425w, uploads/2014/12/02-206x139.jpg 206w, uploads/2014/12/02-400x269.jpg 400w&#34; sizes=&#34;(max-width: 355px) 100vw, 355px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Enfim chegamos a pasta de desenvolvimento, é aqui que começa toda a sua aplicação, você não precisa mexer em nenhuma outra pasta, tudo que você precisa mexer e criar vai ser dentro deste diretório, beleza? Veja como funciona a estrutura da pasta e logo após vamos ver funcionando e depois daremos o &lt;strong&gt;build&lt;/strong&gt; *-*&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-app.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46232&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/estrutura-app.jpg&#34; alt=&#34;estrutura-app&#34; width=&#34;134&#34; height=&#34;277&#34; srcset=&#34;uploads/2014/12/estrutura-app.jpg 154w, uploads/2014/12/estrutura-app-67x139.jpg 67w&#34; sizes=&#34;(max-width: 134px) 100vw, 134px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Acredito que detalhar essa estrutura não tem tanta necessidade, pois as pastas e arquivos já falam por si, não é mesmo? Mas qualquer dúvida pode deixar seu comentário que responderei com prazer.&lt;/p&gt;

&lt;p&gt;Bom, você já instalou as ferramentas (Yo/Gruntjs/bower), já instalou o generator que será usado (generator-webapp) e executou o “yo” que retornou essa estrutura de pasta. Agora para ver como funciona é simples. Execute o comando abaixo, ele vai criar um server local para você ir debugando sua aplicação e vendo como ela está se comportanto no browser e o mais legal é que você não precisa dar F5, pois por padrão já vem instalado o “livereload” plugin do grunt que atualiza automaticamente sua aplicação no browser  =)&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;grunt server&lt;/pre&gt;

&lt;p&gt;Após isso você criar sua aplicação normalmente, usando como ponto de partida o arquivo index.html e os diretórios presentes.&lt;/p&gt;

&lt;h3 id=&#34;e-se-eu-quiser-baixar-outros-componentes-e-plugins&#34;&gt;*&lt;strong&gt;&lt;em&gt;&lt;em&gt;E se eu quiser baixar outros componentes e plugins?&lt;/em&gt;&lt;/em&gt;&lt;/strong&gt;*&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/03.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46233&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/03.jpg&#34; alt=&#34;03&#34; width=&#34;335&#34; height=&#34;216&#34; srcset=&#34;uploads/2014/12/03.jpg 400w, uploads/2014/12/03-215x139.jpg 215w&#34; sizes=&#34;(max-width: 335px) 100vw, 335px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;É uma boa pergunta e simples de responder. Para baixar outro componente como por exemplo AngularJS vamos usar o Bower, nosso gerenciador de componentes. E para baixar um novo plugin como por exemplo JSHINT vamos usar o Gruntjs que gerencia nossas tarefas. Os comandos abaixo mostra como baixar componentes e plugins.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Baixando componentes&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&#34;lang-html&#34;&gt;bower install [nome do componente]&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Baixando plugins&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&#34;lang-html&#34;&gt;npm install [nome do plugin] --save-dev&lt;/pre&gt;

&lt;h3 id=&#34;e-meu-ambiente-de-produção&#34;&gt;E meu ambiente de produção?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/12/04.jpg&#34;&gt;&lt;img class=&#34;alignnone  wp-image-46234&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/12/04.jpg&#34; alt=&#34;04&#34; width=&#34;363&#34; height=&#34;252&#34; srcset=&#34;uploads/2014/12/04.jpg 392w, uploads/2014/12/04-200x139.jpg 200w&#34; sizes=&#34;(max-width: 363px) 100vw, 363px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chegamos ao nosso momento de build da aplicação. O yeoman compila todos os arquivos da pasta app e nos retorna uma pasta chamada “dist” é lá que encontram seus arquivos de produção prontos para serem usados e testados. Lembrando que qualquer alteração não poderá ser feita na pasta “dist” e sim em “app”.&lt;/p&gt;

&lt;p&gt;Dando o build no projeto e gerando meu diretório de produção:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;grunt build&lt;/pre&gt;

&lt;h3 id=&#34;visão-geral&#34;&gt;Visão geral&lt;/h3&gt;

&lt;p&gt;Hoje aprendemos realmente a usar o yeoman, desde seus conceitos até o modo de produção, é só seguir os passos e dicas. E por falar em dica, lá vai uma dica para melhorar mais ainda a sua transferência de arquivos para o ambiente de produção.&lt;/p&gt;

&lt;p&gt;Ao dar o build ele gera o diretório “dist” contendo nele os arquivos de produção. Já que estamos automatizando tudo, evite o uso do FTP e sim faça deploy =) Abaixo segue algumas referências de um módulo do grunt que você pode acrescentar em sua aplicação e deixá-la mais interessante. Assim você miniminiza retrabalhos. Estou falando de [rsync][12].&lt;/p&gt;

&lt;p&gt;Links de referência Yeoman que podem complementar o Post&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;http://yeoman.io/&#34;&gt;Site oficial do yeoman&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;https://github.com/yeoman/yeoman&#34;&gt;Projeto yeoman no github para contribuição&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;http://blog.caelum.com.br/experimente-o-yeoman-em-seu-workflow-de-projetos-front-end/&#34;&gt;Outro Post de referência explicativo e conceitual&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;#8211; &lt;a href=&#34;http://pt.slideshare.net/pedropolisenso/em-um-relacionamento-srio-com-generators-front-end&#34;&gt;Palestra sobre generators (yeoman)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;considerações-finais&#34;&gt;Considerações finais&lt;/h3&gt;

&lt;p&gt;Chegamos ao final desse capítulo tentando expor as qualidades que o Yeoman pode nos dar e sua forma de uso. No próximo capítulo teremos nosso amigo Beto Muniz (&lt;a href=&#34;https://twitter.com/obetomuniz&#34;&gt;@obetomuniz&lt;/a&gt;) falando sobre Slush dentro da série. Não perca os próximos capítulos da série, onde no 4º capítulo finalizaremos com algumas dicas, apresentaremos projetos que foram criados a parir de um desses generators e mostrar como criar seu próprio generator. Valeu =]&lt;/p&gt;

&lt;p&gt;[12]: Ao%20dar o build ele gera o diretório “dist” contendo nele os arquivos de produção. Já que estamos automatizando tudo, jamais em toda sua vida use FTP e sim faça deploy =) Abaixo segue algumas referências de um módulo do grunt que você pode acrescentar em sua aplicação e deixá-la mais interessante. Assim você miniminiza retrabalhos. Estou falando de rsync&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Em um relacionamento sério com generators front-end – Parte 1</title>
      <link>https://tableless.github.io/hugo-public/em-um-relacionamento-serio-com-generators-front-end-parte-1/</link>
      <pubDate>Wed, 29 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/em-um-relacionamento-serio-com-generators-front-end-parte-1/</guid>
      <description>

&lt;h2 id=&#34;conceitos-e-visão-geral&#34;&gt;Conceitos e visão geral&lt;/h2&gt;

&lt;p&gt;Generators front-end tem o seguinte conceito no geral: &lt;strong&gt;É uma ferramenta web de andaimes para criar webapp modernos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Baseado nesse conceito, entendemos que o uso dessa ferramenta permite que você crie suas aplicações de forma automatizada, gerenciável e com o tempo muito mais aproveitado.&lt;/p&gt;

&lt;p&gt;Ultimamente os devs front-end buscam melhorar seu workflow. Cada um tem seu jeito de trabalhar, porém temos algo em comum: detestamos ter retrabalho, queremos praticidade e sempre queremos automatizar tudo. Afinal, “somos preguiçosos”.&lt;/p&gt;

&lt;h2 id=&#34;quando-sei-que-devo-usar-um-generator&#34;&gt;Quando sei que devo usar um generator?&lt;/h2&gt;

&lt;p&gt;Acho que essa pergunta faz sentido. Mas é importante lembrar que cada projeto/aplicação vai ter sua necessidade específica, correto? Nem tudo que aprendemos temos que colocar nos projetos que estamos criando. Assim como um mestre do jogo de damas sabe a hora certa de usar a dama e assim como um oportunista sabe a hora certa de agir.&lt;/p&gt;

&lt;p&gt;Precisamos aprender usar ferramentas, tecnologias e linguagens de acordo com a necessidade do projeto.&lt;/p&gt;

&lt;p&gt;Generator é legal? Claro! O uso dessa ferramenta pode lhe auxiliar em diversas formas. Os recursos trazidos, por padrão, é o grande pulo do gato, pois acabam sendo um ganha tempo no desenvolvimento, em vez de você pensar em uma estrutura ele já gera um stack baseado em algo funcional.&lt;/p&gt;

&lt;p&gt;Aqui na série iremos falar de dois generators: &lt;strong&gt;Yeoman e Slush&lt;/strong&gt; =)&lt;/p&gt;

&lt;h2 id=&#34;sem-enrolação-vamos-de-referências&#34;&gt;Sem enrolação, vamos de referências!&lt;/h2&gt;

&lt;p&gt;[## Conceitos e visão geral&lt;/p&gt;

&lt;p&gt;Generators front-end tem o seguinte conceito no geral: &lt;strong&gt;É uma ferramenta web de andaimes para criar webapp modernos.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Baseado nesse conceito, entendemos que o uso dessa ferramenta permite que você crie suas aplicações de forma automatizada, gerenciável e com o tempo muito mais aproveitado.&lt;/p&gt;

&lt;p&gt;Ultimamente os devs front-end buscam melhorar seu workflow. Cada um tem seu jeito de trabalhar, porém temos algo em comum: detestamos ter retrabalho, queremos praticidade e sempre queremos automatizar tudo. Afinal, “somos preguiçosos”.&lt;/p&gt;

&lt;h2 id=&#34;quando-sei-que-devo-usar-um-generator-1&#34;&gt;Quando sei que devo usar um generator?&lt;/h2&gt;

&lt;p&gt;Acho que essa pergunta faz sentido. Mas é importante lembrar que cada projeto/aplicação vai ter sua necessidade específica, correto? Nem tudo que aprendemos temos que colocar nos projetos que estamos criando. Assim como um mestre do jogo de damas sabe a hora certa de usar a dama e assim como um oportunista sabe a hora certa de agir.&lt;/p&gt;

&lt;p&gt;Precisamos aprender usar ferramentas, tecnologias e linguagens de acordo com a necessidade do projeto.&lt;/p&gt;

&lt;p&gt;Generator é legal? Claro! O uso dessa ferramenta pode lhe auxiliar em diversas formas. Os recursos trazidos, por padrão, é o grande pulo do gato, pois acabam sendo um ganha tempo no desenvolvimento, em vez de você pensar em uma estrutura ele já gera um stack baseado em algo funcional.&lt;/p&gt;

&lt;p&gt;Aqui na série iremos falar de dois generators: &lt;strong&gt;Yeoman e Slush&lt;/strong&gt; =)&lt;/p&gt;

&lt;h2 id=&#34;sem-enrolação-vamos-de-referências-1&#34;&gt;Sem enrolação, vamos de referências!&lt;/h2&gt;

&lt;p&gt;][1] &lt;a href=&#34;http://tableless.com.br/wp-content/uploads/2014/10/011.jpg&#34;&gt;&lt;img class=&#34;aligncenter wp-image-44906 size-full&#34; src=&#34;http://tableless.com.br/wp-content/uploads/2014/10/011.jpg&#34; alt=&#34;01&#34; width=&#34;400&#34; height=&#34;326&#34; srcset=&#34;uploads/2014/10/011.jpg 400w, uploads/2014/10/011-170x139.jpg 170w&#34; sizes=&#34;(max-width: 400px) 100vw, 400px&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alguns desenvolvedores fronts end optam pelo uso dessa ferramenta pela facilidade e praticidade que a mesma oferece. Usando o Yeoman você terá como gerenciador de tarefas o Gruntjs, podendo optar pelo Gulpjs sem o maior problema. Usando o Slush você vai usar o Gulpjs e seus plugins, apenas isso.&lt;/p&gt;

&lt;p&gt;É claro que vai existir vantagens e desvantagens de ambas as partes e também aquela dúvida de qual generator usar. Isso vai depender da forma em que pensa: Exemplo: Se você sentir que, futuramente, vai necessitar de um suporte, veja quem tem a maior comunidade, ou se sentir necessidade de praticidade veja qual generator vai pelo caminho mais curto no sentido de criação.&lt;/p&gt;

&lt;h2 id=&#34;considerações-finais&#34;&gt;Considerações finais&lt;/h2&gt;

&lt;p&gt;Usar generators ou não, vai da necessidade de cada profissional, podendo ser uma experiência bem legal o uso da mesma. Você pode estar e acompanhando os próximos capítulos, onde falaremos mais a fundo e colocaremos a mão na massa. Ah só mais uma coisa, no capítulo 3 teremos a participação do nosso amigo Beto Muniz (&lt;a href=&#34;https://twitter.com/obetomuniz&#34; target=&#34;_blanck&#34;&gt;@obetomuniz&lt;/a&gt;) falando, especificamente de Slush.&lt;/p&gt;

&lt;p&gt;Nos vemos no 2º Capítulo =)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Usando seletores aninhados do SASS com cuidado</title>
      <link>https://tableless.github.io/hugo-public/nesting-selectors-sass/</link>
      <pubDate>Mon, 22 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/nesting-selectors-sass/</guid>
      <description>&lt;p&gt;Não é só por que você está usando um pré-processador que as boas práticas de escrita de CSS devem ser ignoradas. Imagine o código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;main class=&#34;wrap&#34;&amp;gt;
    &amp;lt;div class=&#34;content&#34;&amp;gt;
        &amp;lt;article&amp;gt;
            &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
        &amp;lt;/article&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/main&amp;gt;
&lt;/pre&gt;

&lt;p&gt;E você já deve ter visto um seletor desse tipo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.wrap .content article p strong {
  color: #ccc;
}
&lt;/pre&gt;

&lt;p&gt;Escrever seletores assim é um tiro no pé. O CSS fica ruim de entender e o trabalho de cascata do CSS &amp;#8211; que é o que faz o CSS tão especial &amp;#8211; pode se perder, já que você vai precisar fazer um outro seletor, mais específico, para sobreescrever essa formatação caso necessário.&lt;/p&gt;

&lt;p&gt;Há outro exemplo mais comum, que é muito visto quando tentamos separar a estrutura e o estilo visual dos elementos. Fica algo assim:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;div class=&#34;features&#34;&amp;gt;
  &amp;lt;div class=&#34;box rounded bordered bg-blue&#34;&amp;gt;
    &amp;lt;h1&amp;gt;Título&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;box rounded bordered bg-blue&#34;&amp;gt;
    &amp;lt;h1&amp;gt;Título&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&#34;box rounded bordered bg-blue&#34;&amp;gt;
    &amp;lt;h1&amp;gt;Título&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;É claro que é muito difícil escrever um seletor e um código HTML dessa forma consciente. Você vai perceber que está fazendo alguma burrice e vai pensar duas vezes antes de continuar. Assim espero. Mas quando usamo um pré-processador, é bastante comum nessa armadilha por causa dos seletores aninhados, ou em um termo mais bonito em inglês &lt;strong&gt;nested selectors&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Veja um exemplo de &lt;strong&gt;nested selector&lt;/strong&gt;:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;.features {
  background-color: #cccccc;
  .box {
    border-radius: 3px;
    border: 1px solid #666666;
    background-color: white;
    p {
      font-size: 1rem;
      line-height: 1.2;
      color: #333333;
    }
  }
}
&lt;/pre&gt;

&lt;p&gt;Coisa linda. Não é necessário repetir o início do seletor a cada elemento que você quer formatar dentro de &lt;code&gt;.features&lt;/code&gt;, o SASS fará isso pra você. Veja o output desse código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.features {
  background-color: #ccc;
}
.features .box {
  border-radius: 3px;
  border: 1px solid #666;
  background-color: white;
}
.features .box p {
  font-size: 1rem;
  line-height: 1.2;
  color: #333;
}
&lt;/pre&gt;

&lt;p&gt;Até aqui tudo gerenciável. Mas suponha que você tenha o código abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-html&#34;&gt;&amp;lt;div class=&#34;container&#34;&amp;gt;
  &amp;lt;div class=&#34;content&#34;&amp;gt;
    &amp;lt;div class=&#34;features&#34;&amp;gt;
      &amp;lt;div class=&#34;box rounded bordered bg-blue&#34;&amp;gt;
        &amp;lt;h1&amp;gt;T&amp;iacute;tulo&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&#34;box rounded bordered bg-blue&#34;&amp;gt;
        &amp;lt;h1&amp;gt;T&amp;iacute;tulo&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&#34;box rounded bordered bg-blue&#34;&amp;gt;
        &amp;lt;h1&amp;gt;T&amp;iacute;tulo&amp;lt;/h1&amp;gt;
        &amp;lt;p&amp;gt;Lorem &amp;lt;strong&amp;gt;ipsum dolor sit amet&amp;lt;/strong&amp;gt;. Officia rem sed fuga consequatur rerum.&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Aí você faça algo assim usando SASS:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  max-width: 1200px;
  margin: 0 auto;

  .content {
    padding: 0 20px;

    .features {
      background-color: #ccc;

      .box {
        border-radius: 5px;

        p {
          color: #333;

          strong {
            background-color: #fff;
          }
        }
      }
    }
  }
}
&lt;/pre&gt;

&lt;p&gt;O código final será desse jeito:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container {
  max-width: 1200px;
  margin: 0 auto;
}

.container .content {
  padding: 0 20px;
}

.container .content .features {
  background-color: #ccc;
}

.container .content .features .box {
  border-radius: 5px;
}

.container .content .features .box p {
  color: #333;
}

.container .content .features .box p strong {
  background-color: #fff;
}
&lt;/pre&gt;

&lt;p&gt;Não é incomum acontecer isso quando você está aprendendo a usar pré-processadores, mas isso pode acontecer facilmente em grandes projetos. Existem muitos problemas ao produzirmos código assim, mas os principais motivos são a geração de código inútil, aumentando o tamanho do seu arquivo final e principalmente a quebra da especificidade e a herança do código CSS. A briga de &lt;code&gt;!important&lt;/code&gt; vai acontecer e você vai passar a metade do tempo resolvendo conflitos de formatação. Isso pode sempre ficar pior conforme você aninha cada vez mais os seletores. &lt;strong&gt;O segredo aqui é usar no máximo 3 aninhamentos&lt;/strong&gt;. Há lugares que &lt;a href=&#34;http://thesassway.com/beginner/the-inception-rule&#34;&gt;aconselham até 4 aninhamentos&lt;/a&gt;, mas aí eu acho muito. Um código bem feito naturalmente vai ter entre 2 ou 3 aninhamentos. Você não precisa começar a formatar os elementos iniciando seu seletor sempre do elemento pai. No nosso exemplo, tudo ficaria mais higienizado se fizessemos um código assim:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  max-width: 1200px;
  margin: 0 auto;
}
.content {
  padding: 0 20px;
}

.features {
  background-color: #ccc;

  .box {
    border-radius: 5px;

    p {
      color: #333;

      strong {
        background-color: #fff;
      }
    }
  }
}
&lt;/pre&gt;

&lt;p&gt;O código gerado ficaria assim:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container {
  max-width: 1200px;
  margin: 0 auto;
}

.content {
  padding: 0 20px;
}

.features {
  background-color: #ccc;
}

.features .box {
  border-radius: 5px;
}

.features .box p {
  color: #333;
}

.features .box p strong {
  background-color: #fff;
}
&lt;/pre&gt;

&lt;p&gt;Dependendo do caso, talvez até daria para tirar o aninhamento de &lt;code&gt;.features&lt;/code&gt;. Ficaria assim:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  max-width: 1200px;
  margin: 0 auto;
}

.content {
  padding: 0 20px;
}

.features {
  background-color: #ccc;
}

.box {
  border-radius: 5px;

  p {
    color: #333;

    strong {
      background-color: #fff;
    }
  }
}
&lt;/pre&gt;

&lt;p&gt;Se você seguir as boas práticas de CSS que já falamos &lt;a href=&#34;http://tableless.com.br/oocss-smacss-bem-dry-css-afinal-como-escrever-css/&#34; title=&#34;OOCSS, SMACSS, BEM, DRY CSS: afinal, como escrever CSS?&#34;&gt;aqui&lt;/a&gt; e &lt;a href=&#34;http://tableless.com.br/6-estrategias-para-melhorar-a-organizacao-do-seu-css-2/&#34; title=&#34;6 estratégias para melhorar a organização do seu CSS&#34;&gt;aqui&lt;/a&gt; você estará a salvo.&lt;/p&gt;

&lt;p&gt;Sugiro duas ferramentas interessantes para testar códigos SASS. Um deles é o &lt;a href=&#34;http://sassmeister.com/&#34;&gt;SaasMeister&lt;/a&gt;, que converte código SASS em código CSS normal. E o outro é o &lt;a href=&#34;http://sasstoscss.com/&#34;&gt;ScssConverter&lt;/a&gt;, que converte código SASS para SCSS.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Usando condicionais no Sass – Control Directives</title>
      <link>https://tableless.github.io/hugo-public/usando-condicionais-sass-control-directives/</link>
      <pubDate>Mon, 25 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/usando-condicionais-sass-control-directives/</guid>
      <description>

&lt;p&gt;Ter a possibilidade de usar condicionais no CSS é uma daquelas coisas que fazem os pré-processadores de CSS tão sensuais.&lt;/p&gt;

&lt;p&gt;No Sass essas condicionais são chamadas de &lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#control_directives__expressions&#34; title=&#34;Control Directives&#34;&gt;**Diretivas de controle**&lt;/a&gt;, ou em inglês, que é mais chique, &amp;#8220;Control Directives&amp;#8221;. As funções são &lt;strong&gt;@if&lt;/strong&gt;, &lt;strong&gt;@for&lt;/strong&gt;, &lt;strong&gt;@each&lt;/strong&gt; e &lt;strong&gt;@while&lt;/strong&gt;. São as condicionais tradicionais que estamos acostumados a usar nas outras linguagens.&lt;/p&gt;

&lt;h2 id=&#34;if&#34;&gt;@if&lt;/h2&gt;

&lt;p&gt;Se algo for qualquer coisa diferente de falso, execute determinado comando.&lt;/p&gt;

&lt;p&gt;Um uso bastante simples é da própria documentação do Sass:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$type: monster;
p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
&lt;/pre&gt;

&lt;p&gt;Como era de se esperar, existe um &lt;strong&gt;@else&lt;/strong&gt; para nos dar todo o apoio. Esse exemplo acima é bastante simples. Se você tem uma variável qualquer, no nosso caso &lt;strong&gt;monster&lt;/strong&gt;, e essa variável pode mudar de valor em determinado lugar do código. Se mudar, há uma série de condições ali.&lt;/p&gt;

&lt;p&gt;Um exemplo mais real:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$color1: #f9f9f9;
p {
    @if (lightness($color1) &amp;lt; 30) {
    background-color: white
    } @else {
    background-color: black
    }
}
&lt;/pre&gt;

&lt;p&gt;Ali estamos medindo a quantidade de branco que há na variável &lt;strong&gt;$color1&lt;/strong&gt;, que irá receber um código de cor. Se for menor que 30% de luz (claridade), background black no elemento, caso contrário, background white.&lt;/p&gt;

&lt;h2 id=&#34;for&#34;&gt;@for&lt;/h2&gt;

&lt;p&gt;Inicia uma variável e executa uma ação, incrementando essa variável um determinado número de vezes. Para cada repetição, um a variável de contador é usada para ajustar o código de saída.&lt;/p&gt;

&lt;p&gt;Muito útil. Para você fazer códigos como o de baixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.item-1 {
  width: 10px;
  font-size: 10px; 
}
.item-2 {
  width: 20px;
  font-size: 20px; 
}
.item-3 {
  width: 30px;
  font-size: 30px; 
}
.item-4 {
  width: 40px;
  font-size: 40px; 
}
&lt;/pre&gt;

&lt;p&gt;Você faria uma condição assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@for $i from 1 through 4 {
  .item-#{$i} { 
        width: 10px * $i; 
        font-size: 10px * $i;
    }
}
&lt;/pre&gt;

&lt;p&gt;Outro truque interessante é que se você colocar o primeiro número maior que o segundo, assim: &lt;code&gt;@for $i from 4 through 1&lt;/code&gt;, a função irá decrementar em vez de incrementar a variável. O resultado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.item-4 {
  width: 40px;
  font-size: 40px; 
}

.item-3 {
  width: 30px;
  font-size: 30px; 
}

.item-2 {
  width: 20px;
  font-size: 20px; 
}

.item-1 {
  width: 10px;
  font-size: 10px; 
}
&lt;/pre&gt;

&lt;p&gt;Simple like that.&lt;/p&gt;

&lt;h2 id=&#34;each&#34;&gt;@each&lt;/h2&gt;

&lt;p&gt;Define uma variável para item de uma lista de valores, produzindo blocos de código utilizando os valores da lista.&lt;/p&gt;

&lt;p&gt;Neste artigo fala sobre &lt;a href=&#34;http://tableless.com.br/utilizando-maps-sass/&#34;&gt;Maps Structure do Sass&lt;/a&gt;, e dá uma boa noção do que o &lt;strong&gt;@each&lt;/strong&gt; pode fazer. Mas um exemplo rápido. Para um código assim:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.tema-azul body {
  background-color: #0176bb;
}

.tema-vermelho body {
  background-color: #e3413e;
}

.tema-amarelo body {
  background-color: #f8e042;
}
&lt;/pre&gt;

&lt;p&gt;Você teria um Sass assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$cores: (
  azul: #0176bb, 
  vermelho: #e3413e, 
  amarelo: #f8e042
);

@each $tema, $cor in $cores {
  .tema-#{tema} body {
     background-color: $cor;
  }
}
&lt;/pre&gt;

&lt;p&gt;Você gerencia basicamente um bloco de CSS e as variáveis para adicionar ou remover cores.&lt;/p&gt;

&lt;h2 id=&#34;while&#34;&gt;@while&lt;/h2&gt;

&lt;p&gt;Repete um determinado bloco e código enquanto determinado estado for verdadeiro.&lt;/p&gt;

&lt;p&gt;O exemplo mais bacana que pode ser mostrado aqui é a criação de um grid básico. Para ter um código como este abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.column-grid-1{
  width: 60px;
}

.column-grid-2 {
  width: 150px;
}

.column-grid-3 {
  width: 240px;
}

.column-grid-4 {
  width: 330px;
}

.column-grid-5 {
  width: 420px;
}

.column-grid-6 {
  width: 510px;
}

.column-grid-7 {
  width: 600px;
}

.column-grid-8 {
  width: 690px;
}

.column-grid-9 {
  width: 780px;
}

.column-grid-10 {
  width: 870px;
}

.column-grid-11 {
  width: 960px;
}

.column-grid-12 {
  width: 1050px; 
}

&lt;/pre&gt;

&lt;p&gt;O código seria algo mais ou menos assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$i: 1
$column-width: 60px

@while $i &amp;lt; 13 {
  .grid-#{$i} { 
    column-width: $column-width; 
   }
  $column-width: $column-width + 90px;
  $i: $i + 1;
}
&lt;/pre&gt;

&lt;p&gt;Claro, para fazer um grid um pouco mais complexo, usando porcentagens, guardando o valor do gutter em uma variável, roas e etc você precisa de um pouco mais. &lt;a href=&#34;http://bjorkoy.com/2010/05/css-grids-with-sass/&#34;&gt;Veja esse artigo aqui&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Eu não gosto de usar pré-processadores. &lt;a href=&#34;http://tableless.com.br/pre-processadores-usar-ou-nao-usar/&#34;&gt;Eu já falei disso aqui há muito tempo&lt;/a&gt;. Se você for fazer um site simples, sem muitas grandes ambições, nada muito complicado, talvez não seja necessário usar um Sass da vida. Contudo, em várias ocasiões, ter essas e outras funções que citamos aqui, o ganho na produtividade é enorme. Aí sim esses penduricalhos começam a valer a pena. 😉&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Instalando SASS na máquina – video</title>
      <link>https://tableless.github.io/hugo-public/instalando-sass-na-maquina-video/</link>
      <pubDate>Mon, 18 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/instalando-sass-na-maquina-video/</guid>
      <description>

&lt;p&gt;Se você quiser usar um pré-processador em seus projetos, aqui vão instruções simples para você começar agora. Darei mais atenção para quem usa Mac porque é o sistema que eu uso. Mas no Windows as instruções são quase as mesmas, principalmente se você for usar algum sistema que gerencia os assets. Também estou abordando aqui apenas o SASS, nada de LESS, Style ou qualquer outro pré-processador. Depois desse disclaimer, vamos ao que interessa.&lt;/p&gt;

&lt;h2 id=&#34;iniciando&#34;&gt;Iniciando&lt;/h2&gt;

&lt;p&gt;Um pré-processador precisa ser pré-processado (!) antes do código resultante seja renderizado pelo browser. Isso quer dizer que o browser nunca (nunca diga nunca) vai ler direto seu código SASS e renderizar seu código. Por isso, você precisa de um parser, que vai ler seu SASS, salvar em um arquivo CSS para seu browser renderizar o CSS.&lt;/p&gt;

&lt;p&gt;O SASS é uma GEM do Ruby, logo, invariavelmente você vai precisar do Ruby. Por isso, existem duas maneiras de você usar um Pré-processador sem se preocupar em preparar seu ambiente e rodar SASS com tranquilidade. A primeira forma é usando alguma aplicação que vai ler e parsar seus arquivos SASS, sem a necessidade do Ruby no ambiente. Claro, você vai precisar esperar alguns segundos para dar um refresh na página. Isso acontece por que o aplicativo está parseando seu código.&lt;/p&gt;

&lt;p&gt;A outra maneira é a melhor, você não tem esse delay de segundos, mas é mais complicada para quem não está acostumado com Terminal. Mesmo assim, é tão fácil, tão fácil, que eu sugiro que você tente primeiro fazer funcionar o SASS pelo terminal, se conseguir, tente usar a aplicação.&lt;/p&gt;

&lt;h2 id=&#34;scout&#34;&gt;Scout&lt;/h2&gt;

&lt;p&gt;Existem várias aplicações que compilam SASS e outras linguagens como CoffeeScript, TypeScript, LESS, Stylus e etc. A maioria deles é pago, mas muito bons. Se você preferir pagar, sugiro que use o mais famoso que é o &lt;a href=&#34;http://incident57.com/codekit/&#34;&gt;CodeKit&lt;/a&gt;. Mas se você não quer pagar nada, sugiro o Scout.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&#34;http://mhs.github.io/scout-app/&#34;&gt;Scout&lt;/a&gt; (tem para Windows e Mac) é um compilador para exclusivo SASS/Compass e ele tem um único objetivo, ler seus arquivos SASS, parsear, compilar e por fim salvar em uma pasta no formato CSS.&lt;/p&gt;

&lt;p&gt;Fiz um vídeo mudo (sou tímido) que mostra como adicionar um projeto no Scout. Basicamente você escolhe a pasta do projeto e indica quais as pastas onde ele vai encontrar os arquivos SASS e onde ele vai salvar os arquivos .CSS. Normalmente eu escolho sempre a mesma pasta, mas você pode escolher uma outra pasta que vai salvar os arquivos CSS finais. Veja abaixo o vídeo:&lt;/p&gt;

&lt;p&gt;Se você quiser testar outra aplicação em vez do Scout, experimente o &lt;a href=&#34;http://koala-app.com&#34;&gt;Koala&lt;/a&gt;. Ele também é free e compila outros pré-processadores como o LESS e CoffeeScript.&lt;/p&gt;

&lt;h2 id=&#34;usando-o-terminal&#34;&gt;Usando o terminal&lt;/h2&gt;

&lt;p&gt;Para usar no terminal, você precisa ter na máquina Ruby e a gem do Sass instalada. Feito isso, você vigia a pasta com os arquivos SASS com o comando abaixo:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;sass --watch [diretório dos arquivos SASS]
&lt;/pre&gt;

&lt;p&gt;Simples assim.&lt;/p&gt;

&lt;p&gt;Se você quiser avançar e já leu sobre Compass e sua facilidade de usar CSS3, você usá-lo para vigiar sua pasta. Para iniciar o projeto:&lt;/p&gt;

&lt;pre class=&#34;lang-shell&#34;&gt;compass create [nome do projeto]
&lt;/pre&gt;

&lt;p&gt;Se você já tiver a pasta do projeto, basta fazer o mesmo comando. Ele vai criar dentro da pasta uma pasta chamada &lt;strong&gt;sass&lt;/strong&gt;, com os arquivos SASS, uma pasta &lt;strong&gt;stylesheet&lt;/strong&gt;, que é onde vai ficar o código CSS resultante do SASS. Ele vai criar também um arquivo &lt;strong&gt;config.rb&lt;/strong&gt;, que é onde fica as configurações do seu projeto.&lt;/p&gt;

&lt;p&gt;Quando tiver feito esse comando acima, e claro, ter linkado o CSS no seu arquivo HTML, você pode começar digitar o comando &lt;strong&gt;compass watch&lt;/strong&gt;, que vai vigiar a pasta stylesheets procurando por arquivos SASS e transformando-os em CSS.&lt;/p&gt;

&lt;p&gt;Abaixo, veja outro vídeo mudo, onde eu crio o projeto e modifico o &lt;strong&gt;config.rb&lt;/strong&gt; do Compass para que a estrutura de pastas fique do jeito que eu gosto, geralmente para mudar a estrutura de pastas, inserindo as pastas de stylesheets, imagens e javascripts para dentro da pasta &lt;strong&gt;assets&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Eu vou tentar melhorar ainda mais esse passo a passo com o tempo. Não encontrei nenhum lugar onde ensinasse exatamente como fazer para rodar SASS na máquina sem estar em um projeto Ruby. Isso era uma dificuldade para devs novatos que querem experimentar as maravilhosas peripécias do SASS.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Utilizando Map Structure do Sass</title>
      <link>https://tableless.github.io/hugo-public/utilizando-maps-sass/</link>
      <pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/utilizando-maps-sass/</guid>
      <description>

&lt;p&gt;O Sass é um pré-processador usado para melhorar sua produtividade ao codificar CSS. Dentre as várias funcionalidades, existe uma chamada &lt;code&gt;maps&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;O &lt;code&gt;maps&lt;/code&gt; é como um array de variáveis. Ela guarda uma série de chaves com valores. A sintaxe é bastante comum, veja:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$map: (
  key1: value1, 
  key2: value2, 
  key3: value3
);
&lt;/pre&gt;

&lt;p&gt;A primeira vista se parece com Json, né?&lt;/p&gt;

&lt;p&gt;A ideia é que você consiga pegar o valor de qualquer chave que está dentro do seu mapa e usar em momentos onde você irá repetir bastante código.&lt;/p&gt;

&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;

&lt;p&gt;No exemplo abaixo, vou mostrar uma situação muito comum ao desenvolvermos um site com variação de temas de cores. Na maneira normal, você faria um código basicamente assim:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.tema-azul body {
  background-color: #0176bb;
}

.tema-vermelho body {
  background-color: #e3413e;
}

.tema-amarelo body {
  background-color: #f8e042;
}
&lt;/pre&gt;

&lt;p&gt;Usando o mapa do SASS, a primeira coisa que faríamos seria separar as cores em variáveis, assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$cores: (
  azul: #0176bb, 
  vermelho: #e3413e, 
  amarelo: #f8e042
);
&lt;/pre&gt;

&lt;p&gt;E faríamos uma função dessa forma:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@each $tema, $cor in $cores {
  .tema-#{tema} body {
     background-color: $cor;
  }
}
&lt;/pre&gt;

&lt;p&gt;O &lt;code&gt;$tema&lt;/code&gt; seria cada uma das chaves, no nosso caso &lt;code&gt;azul&lt;/code&gt;, &lt;code&gt;vermelho&lt;/code&gt; e &lt;code&gt;amarelo&lt;/code&gt;. O &lt;code&gt;$cor&lt;/code&gt; seria cada um dos valores dos temas, ou seja, os valores hexadecimais. A função &lt;code&gt;@each&lt;/code&gt; está dizendo assim: a cada valor dos temas (azul, vermelho, amarelo) que encontrar no mapa &lt;code&gt;$cores&lt;/code&gt;, repita o bloco de código.&lt;/p&gt;

&lt;p&gt;Isso resultaria no seguinte código:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.tema-azul body {
  background-color: #0176bb;
}

.tema-vermelho body {
  background-color: #e3413e;
}

.tema-amarelo body {
  background-color: #f8e042;
}
&lt;/pre&gt;

&lt;p&gt;Isso salva vidas. Agora vamos complicar mais. Normalmente um tema é composto de mais cores. Para isso o mapa vai ficar parecido isso:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;$cores: (
  azul: (
    color1: #0176bb, 
    color2: #23aad0,
    color3: #edf7fd
  ),
  vermelho: (
    color1: #e3413e, 
    color2: #1f518c,
    color3: #f8e042
  ),
  amarelo: (
    color1: #4a5269, 
    color2: #fc7d74,
    color3: #4a5269
  )
);
&lt;/pre&gt;

&lt;p&gt;O código do &lt;code&gt;@each&lt;/code&gt; não mudará muito, mas precisaremos guardar cada uma dessas cores dentro de uma variável que será usada no código final. Ficará assim:&lt;/p&gt;

&lt;pre class=&#34;lang-sass&#34;&gt;@each $tema, $cor in $cores {
  $color1: map-get($cor, color1);
  $color2: map-get($cor, color2);
  $color3: map-get($cor, color3);
}
&lt;/pre&gt;

&lt;p&gt;Explicando: a cada &lt;code&gt;$tema&lt;/code&gt; (azul, vermelho e amarelo) que há no mapa &lt;code&gt;$cores&lt;/code&gt;, ele vai gravar as variáveis &lt;code&gt;$color1&lt;/code&gt;, &lt;code&gt;$color2&lt;/code&gt; e &lt;code&gt;$color3&lt;/code&gt;. A função &lt;code&gt;map-get&lt;/code&gt; vai pegar o valor específico de cada variável &lt;code&gt;color1&lt;/code&gt;, &lt;code&gt;color2&lt;/code&gt; e &lt;code&gt;color3&lt;/code&gt; de cada tema e irá guardar. O código CSS fica assim:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@each $tema, $cor in $cores {
  $color1: map-get($cor, color1);
  $color2: map-get($cor, color2);
  $color3: map-get($cor, color3);

  .color-#{$tema} {
    body {
      background-color: $color1;
    }

    .header {
      background-color: $color2;
    }

    .menu a {
      background-color: $color3;
    }

  }
}
&lt;/pre&gt;

&lt;p&gt;Ele vai repetir o bloco acima uma vez para cada tema de cor. No nosso caso, 3 vezes: uma para azul, vermelho e amarelo.&lt;/p&gt;

&lt;p&gt;Novamente: isso salva vidas.&lt;/p&gt;

&lt;p&gt;A única coisa que você vai gerenciar depois são as variáveis para modificar ou inserir novas cores.&lt;/p&gt;

&lt;p&gt;Veja abaixo um exemplo mais completo, mostrando o código final do CSS gerado:&lt;/p&gt;

&lt;p class=&#34;sassmeister&#34; data-gist-id=&#34;9fc788894331313ce485&#34; data-height=&#34;480&#34;&gt;
  &lt;a href=&#34;http://sassmeister.com/gist/9fc788894331313ce485&#34;&gt;Play with this gist on SassMeister.&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://viget.com/extend/sass-maps-are-awesome&#34;&gt;O pessoal do Viget explorou outro problema&lt;/a&gt; para resolver. Na verdade, as implicações são diversas. A qualquer momento que você tiver um bloco de código repetitivo e que depende de muitas variações, o &lt;code&gt;maps&lt;/code&gt; é indicado.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SASS: Mixin ou Placeholder?</title>
      <link>https://tableless.github.io/hugo-public/sass-mixin-ou-placeholder/</link>
      <pubDate>Sun, 16 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/sass-mixin-ou-placeholder/</guid>
      <description>

&lt;p&gt;Se é um tema que sempre vejo a respeito da utilização ou não, é sobre o uso de pré processadores CSS. Alguns &lt;em&gt;devs&lt;/em&gt; que costumo seguir e ler os artigos, e que pra mim são algumas das nossas referências, apontam as suas considerações sobre o tema. O Miller Medeiros, em um &lt;a href=&#34;http://blog.millermedeiros.com/the-problem-with-css-pre-processors/&#34;&gt;post&lt;/a&gt; mostra alguns pontos negativos na utilização de pré processadores. O Jean Carlos Emer em um outro &lt;a href=&#34;http://tableless.com.br/css-steroids/&#34; title=&#34;CSS on steroids&#34;&gt;post&lt;/a&gt; mostra as reais vantagens de se utilizar um pré-processador. O Diego Eis, em um outro &lt;a href=&#34;http://tableless.com.br/pre-processadores-usar-ou-nao-usar/&#34; title=&#34;Pré processadores: usar ou não usar?&#34;&gt;post&lt;/a&gt; faz uma conclusão muito boa sobre a utilização ou não:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pré processadores podem ajudar como também podem maltratar bastante. Basta um escorregão para que seu projeto vire um inferno. &amp;#8211; Diego Eis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A utilização ou não de um pré processador fica a seu critério mas, se você já utiliza nos seus projetos ou está pensando em usar, você sabe o que são um &lt;strong&gt;placeholder&lt;/strong&gt; e um &lt;strong&gt;mixin&lt;/strong&gt;? Se sim, sabe qual a principal diferença entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um &lt;a href=&#34;http://www.sitepoint.com/sass-mixin-placeholder/&#34;&gt;artigo&lt;/a&gt; do &lt;a href=&#34;https://twitter.com/HugoGiraudel&#34; title=&#34;Perfil do twitter do desenvolvedor Hugo Giraudel&#34;&gt;Hugo Giraudel&lt;/a&gt;, um dev front-end francês, no &lt;a href=&#34;http://www.sitepoint.com/&#34; title=&#34;Link do website SitePoint&#34;&gt;SitePoint&lt;/a&gt; que trata exatamente sobre esse assunto.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Quando comecei a trabalhar com SASS cerca de um ano e meio atrás, uma coisa que me levou tempo para entender foi a diferença entre &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins&#34;&gt;incluir um mixin&lt;/a&gt;&lt;/em&gt; e &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders&#34;&gt;estender um placeholder&lt;/a&gt;&lt;/em&gt;. Na verdade, até mesmo a noção de &lt;em&gt;placeholder&lt;/em&gt; era uma espécie de magia negra vodu naquela época.&lt;/p&gt;

&lt;p&gt;Se você estiver em uma situação semelhante, não se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um &lt;em&gt;mixin&lt;/em&gt;, e quando usar um &lt;em&gt;placeholder do SASS&lt;/em&gt;. Você vai entender que ambos tem diferentes finalidades e não devem ser confundidas.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro pré-processador CSS, seja Stylus, LESS, ou outro que você venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteúdo deste artigo para a ferramenta de sua escolha&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos &lt;strong&gt;placeholder e mixins do SASS&lt;/strong&gt;, então vamos fazer isso já.&lt;/p&gt;

&lt;h2 id=&#34;entendendo-o-mixin&#34;&gt;Entendendo o mixin&lt;/h2&gt;

&lt;p&gt;Um mixin é uma diretiva que permite que você defina várias regras com diversos argumentos. Pense nisso como uma função que irá retornar conteúdo CSS ao invés de um valor. Aqui está a definição de &lt;em&gt;mixin&lt;/em&gt; da &lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;referência do SASS&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote cite=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;
  &lt;p&gt;
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes não semânticas como &lt;i&gt;.float-left&lt;/i&gt;. Mixins podem também conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem até mesmo possuírem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agora que cobrimos a terminologia, vamos dizer que você encontra algumas declarações que são repetidas várias vezes ao longo da sua folha de estilos. Você que está familiarizado com o conceito de DRY (&lt;a href=&#34;http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself&#34;&gt;Don&amp;#8217;t Repeat Yourself&lt;/a&gt;), sabe que a repetição de código é ruim. Para corrigir isso, você pode escrever um mixin para todas aquelas declarações repetidas:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Se você não passar um argumento para um mixin, você pode omitir os parênteses. Na verdade, você pode até omiti-los na definição do &lt;code&gt;@mixin&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com este mixin recém-criado, você não precisa repetir aquelas três linhas de código cada vez que precisar centralizar um elemento; você simplesmente inclui o mixin. Muito prático, não é?!&lt;/p&gt;

&lt;p&gt;Algumas vezes você vai querer um mixin para construir o que você chamaria de &lt;em&gt;shorthand&lt;/em&gt; para algumas propriedades. Por exemplo, largura e altura. Você não está cansado de escrever as duas linhas várias e várias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
&lt;/pre&gt;

&lt;p&gt;Muito simples, não é? Note como deixamos o parâmetro &lt;code&gt;$height&lt;/code&gt; ser opcional e, por padrão assumir o mesmo valor do parâmetro &lt;code&gt;$width&lt;/code&gt; na assinatura do mixin. Agora, sempre que você precisar definir as dimensões para um elemento, você pode simplesmente fazer isso:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Um outro bom exemplo de mixin seria &lt;a href=&#34;http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/&#34;&gt;este aqui&lt;/a&gt; que eu fiz para evitar de escrever as posições &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; e &lt;code&gt;bottom&lt;/code&gt; toda vez que quiser utilizar um sistema de posicionamento diferente do estático.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;conhecendo-seu-placeholder&#34;&gt;Conhecendo seu Placeholder&lt;/h2&gt;

&lt;p&gt;Placeholders são um tipo de coisa estranha. Eles são classes que não são retornadas quando o seu SCSS é compilado. Você deve então pensar: &lt;em&gt;&amp;#8220;Qual é o sentido disso?&amp;#8221;&lt;/em&gt;. Na verdade, o ponto seria minímo senão fosse a expressão &lt;code&gt;@extend&lt;/code&gt;. Mas vamos por partes. Essa é a forma que você escreve um placeholder:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota do editor: Como um placeholder, um mixin é igualmente inútil, a menos que seja referenciado, assim essa seção não está dizendo que eles são diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareça similar com um bloco de declaração CSS, não será gerado por conta própria.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Basicamente você escreve exatamente como uma classe &lt;code&gt;CSS&lt;/code&gt; exceto pelo símbolo % ao invés do ponto. Além disso, segue as mesmas &lt;a href=&#34;http://www.w3.org/TR/html401/types.html#type-cdata&#34;&gt;regras de nomenclatura&lt;/a&gt; das classes.&lt;/p&gt;

&lt;p&gt;Agora, se você tentar compilar seu SCSS, você não vai ver esse pedaço de código no arquivo gerado. Como eu disse: &lt;strong&gt;placeholders não são compilados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Então, por agora, esse placeholder é totalmente inútil. Você não consegue fazer qualquer uso dele a não ser que você veja o &lt;code&gt;@extend&lt;/code&gt;. Um &lt;code&gt;@extend&lt;/code&gt; tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usá-lo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Ao fazer isso, o arquivo SASS vai pegar o conteúdo do placeholder &lt;code&gt;%center&lt;/code&gt; e aplicá-lo no &lt;code&gt;.container&lt;/code&gt; (mesmo que isso não aconteça exatamente assim &amp;#8211; mas isso não é importante agora). Como eu disse, você também pode &lt;em&gt;estender&lt;/em&gt; seletores CSS já existentes (além de placeholders SCSS) dessa maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
&lt;/pre&gt;

&lt;p&gt;Esse é um caso muito comum para o uso do &lt;code&gt;@extend&lt;/code&gt;. Nesse caso, pedimos para a classe &lt;code&gt;.table-zebra&lt;/code&gt; se comportar exatamente como a classe &lt;code&gt;.table&lt;/code&gt; e então adicionamos as regras específicas da classe &lt;code&gt;.table-zebra&lt;/code&gt;. &lt;em&gt;Estender&lt;/em&gt; seletores é bastante conveniente quando você desenvolve seu site ou aplicação em componentes modulares.&lt;/p&gt;

&lt;h2 id=&#34;qual-utilizar&#34;&gt;Qual utilizar?&lt;/h2&gt;

&lt;p&gt;Então, a pergunta permanece: o que você deve usar? Bem, como tudo em nossa área: &lt;strong&gt;depende&lt;/strong&gt;. Depende do contexto e, em uma outra análise, do que você está querendo fazer.&lt;/p&gt;

&lt;p&gt;O melhor conselho seria: se você precisa de variáveis, utilize o mixin. Caso contrário, use o placeholder. Há duas razões para isso:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primeiro, você não pode usar variáveis em um placeholder. Na verdade, até pode, mas você não consegue &lt;em&gt;passar&lt;/em&gt; uma variável em um placeholder para gerar um conteúdo específico de CSS, como você faria em um mixin.&lt;/li&gt;
&lt;li&gt;Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando você os utiliza sem variáveis contextuais. Simplificando: o SASS vai duplicar a saída de um mixin toda vez que você o utilizá-lo, resultando não apenas em CSS duplicado, mas também em uma folha de estilos maior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considere o primeiro exemplo desse artigo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
&lt;/pre&gt;

&lt;p&gt;O CSS compilado seria esse:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Observou o CSS duplicado? Ele não é tão prejudicial se forem apenas três linhas duplicadas, mas se você tiver muitos mixins que são usados várias vezes em um projeto, essas três linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, só que dessa vez utilizando o placeholder?&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Agora, esse é o CSS gerado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Muito melhor! A compilação leva vantagem &lt;a href=&#34;http://reference.sitepoint.com/css/selectorgrouping&#34;&gt;agrupando seletores&lt;/a&gt;, sem nenhum estilo repetido. Assim, sempre que você quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas não mudarão, é uma boa idéia &lt;em&gt;estender&lt;/em&gt; um placeholder. Isso resultará em um código CSS compilado muito mais limpo.&lt;/p&gt;

&lt;p&gt;Por outro lado, se você precisa escrever as mesmas propriedades em vários lugares mas com valores diferentes (tamanho, cores, etc), um mixin é o melhor caminho a seguir. Agora se você possui ambos, um grupo de valores fixos e outro de valores variáveis, você deve tentar usar uma combinação dos dois.&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
&lt;/pre&gt;

&lt;p&gt;Neste caso, o mixin está &lt;em&gt;estendendo&lt;/em&gt; o placeholder para os valores fixos em vez de jogá-los diretamente em seu corpo. Isso gera um CSS mais limpo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É isso. Espero ter deixado claro não só o que são mixins e placeholders, mas também quando você deve usá-los e qual os efeitos sobre o CSS compilado.&lt;/p&gt;

&lt;p&gt;Se você tiver alguma coisa a acrescentar sobre suas experiências com essas &lt;em&gt;features&lt;/em&gt; dos pré-processadores de CSS, sinta-se livre para compartilhar nos comentários.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Texto traduzido e adaptado do [Se é um tema que sempre vejo a respeito da utilização ou não, é sobre o uso de pré processadores CSS. Alguns &lt;em&gt;devs&lt;/em&gt; que costumo seguir e ler os artigos, e que pra mim são algumas das nossas referências, apontam as suas considerações sobre o tema. O Miller Medeiros, em um &lt;a href=&#34;http://blog.millermedeiros.com/the-problem-with-css-pre-processors/&#34;&gt;post&lt;/a&gt; mostra alguns pontos negativos na utilização de pré processadores. O Jean Carlos Emer em um outro &lt;a href=&#34;http://tableless.com.br/css-steroids/&#34; title=&#34;CSS on steroids&#34;&gt;post&lt;/a&gt; mostra as reais vantagens de se utilizar um pré-processador. O Diego Eis, em um outro &lt;a href=&#34;http://tableless.com.br/pre-processadores-usar-ou-nao-usar/&#34; title=&#34;Pré processadores: usar ou não usar?&#34;&gt;post&lt;/a&gt; faz uma conclusão muito boa sobre a utilização ou não:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pré processadores podem ajudar como também podem maltratar bastante. Basta um escorregão para que seu projeto vire um inferno. &amp;#8211; Diego Eis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A utilização ou não de um pré processador fica a seu critério mas, se você já utiliza nos seus projetos ou está pensando em usar, você sabe o que são um &lt;strong&gt;placeholder&lt;/strong&gt; e um &lt;strong&gt;mixin&lt;/strong&gt;? Se sim, sabe qual a principal diferença entre eles e quando usar um ou outro? Navegando um dia pela internet, achei um &lt;a href=&#34;http://www.sitepoint.com/sass-mixin-placeholder/&#34;&gt;artigo&lt;/a&gt; do &lt;a href=&#34;https://twitter.com/HugoGiraudel&#34; title=&#34;Perfil do twitter do desenvolvedor Hugo Giraudel&#34;&gt;Hugo Giraudel&lt;/a&gt;, um dev front-end francês, no &lt;a href=&#34;http://www.sitepoint.com/&#34; title=&#34;Link do website SitePoint&#34;&gt;SitePoint&lt;/a&gt; que trata exatamente sobre esse assunto.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Quando comecei a trabalhar com SASS cerca de um ano e meio atrás, uma coisa que me levou tempo para entender foi a diferença entre &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixins&#34;&gt;incluir um mixin&lt;/a&gt;&lt;/em&gt; e &lt;em&gt;&lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#placeholders&#34;&gt;estender um placeholder&lt;/a&gt;&lt;/em&gt;. Na verdade, até mesmo a noção de &lt;em&gt;placeholder&lt;/em&gt; era uma espécie de magia negra vodu naquela época.&lt;/p&gt;

&lt;p&gt;Se você estiver em uma situação semelhante, não se preocupe, porque eu vou tentar iluminar o caminho. Hoje vamos aprender para que exatamente serve um &lt;em&gt;mixin&lt;/em&gt;, e quando usar um &lt;em&gt;placeholder do SASS&lt;/em&gt;. Você vai entender que ambos tem diferentes finalidades e não devem ser confundidas.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nota: Enquanto pretendo falar sobre SASS, esse artigo pode ser aplicado a qualquer outro pré-processador CSS, seja Stylus, LESS, ou outro que você venha a usar. Essas tecnologias geralmente fazem a mesma coisa, portanto fique a vontade para adaptar o conteúdo deste artigo para a ferramenta de sua escolha&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Primeiro devemos fazer um breve resumo sobre o que estamos falando quando nos referimos aos &lt;strong&gt;placeholder e mixins do SASS&lt;/strong&gt;, então vamos fazer isso já.&lt;/p&gt;

&lt;h2 id=&#34;entendendo-o-mixin-1&#34;&gt;Entendendo o mixin&lt;/h2&gt;

&lt;p&gt;Um mixin é uma diretiva que permite que você defina várias regras com diversos argumentos. Pense nisso como uma função que irá retornar conteúdo CSS ao invés de um valor. Aqui está a definição de &lt;em&gt;mixin&lt;/em&gt; da &lt;a href=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;referência do SASS&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote cite=&#34;http://sass-lang.com/documentation/file.SASS_REFERENCE.html#mixin-content&#34;&gt;
  &lt;p&gt;
    Mixins permitem definir estilos que podem ser reutilizados em toda a folha de estilo, sem a necessidade de recorrer a classes não semânticas como &lt;i&gt;.float-left&lt;/i&gt;. Mixins podem também conter regras completas de CSS e quaisquer outras coisas permitidas em um documento SASS. Eles podem até mesmo possuírem argumentos que lhe permitem produzir uma ampla variedade de estilos com poucos mixins.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Agora que cobrimos a terminologia, vamos dizer que você encontra algumas declarações que são repetidas várias vezes ao longo da sua folha de estilos. Você que está familiarizado com o conceito de DRY (&lt;a href=&#34;http://en.wikipedia.org/wiki/Don&#39;t_repeat_yourself&#34;&gt;Don&amp;#8217;t Repeat Yourself&lt;/a&gt;), sabe que a repetição de código é ruim. Para corrigir isso, você pode escrever um mixin para todas aquelas declarações repetidas:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center() {
    display: block;
    margin-left: auto;
    margin-right: auto;
}

.container {
    @include center();
    /* Outros estilos aqui... */
}

/* Outros estilos... */

.image-cover {
    @include center;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Se você não passar um argumento para um mixin, você pode omitir os parênteses. Na verdade, você pode até omiti-los na definição do &lt;code&gt;@mixin&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Com este mixin recém-criado, você não precisa repetir aquelas três linhas de código cada vez que precisar centralizar um elemento; você simplesmente inclui o mixin. Muito prático, não é?!&lt;/p&gt;

&lt;p&gt;Algumas vezes você vai querer um mixin para construir o que você chamaria de &lt;em&gt;shorthand&lt;/em&gt; para algumas propriedades. Por exemplo, largura e altura. Você não está cansado de escrever as duas linhas várias e várias vezes? Especialmente quando ambas tem o mesmo valor? Bem, vamos lidar com isso usando um mixin!&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin size($width, $height: $width) {
    width: $width;
    height: $height;
}
&lt;/pre&gt;

&lt;p&gt;Muito simples, não é? Note como deixamos o parâmetro &lt;code&gt;$height&lt;/code&gt; ser opcional e, por padrão assumir o mesmo valor do parâmetro &lt;code&gt;$width&lt;/code&gt; na assinatura do mixin. Agora, sempre que você precisar definir as dimensões para um elemento, você pode simplesmente fazer isso:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.icon {
    @include size(32px);
}

.cover {
    @include size(100%, 10em);
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota: Um outro bom exemplo de mixin seria &lt;a href=&#34;http://hugogiraudel.com/2013/08/05/offsets-sass-mixin/&#34;&gt;este aqui&lt;/a&gt; que eu fiz para evitar de escrever as posições &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt; e &lt;code&gt;bottom&lt;/code&gt; toda vez que quiser utilizar um sistema de posicionamento diferente do estático.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;conhecendo-seu-placeholder-1&#34;&gt;Conhecendo seu Placeholder&lt;/h2&gt;

&lt;p&gt;Placeholders são um tipo de coisa estranha. Eles são classes que não são retornadas quando o seu SCSS é compilado. Você deve então pensar: &lt;em&gt;&amp;#8220;Qual é o sentido disso?&amp;#8221;&lt;/em&gt;. Na verdade, o ponto seria minímo senão fosse a expressão &lt;code&gt;@extend&lt;/code&gt;. Mas vamos por partes. Essa é a forma que você escreve um placeholder:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
    display: block;
    margin-left: auto;
    margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Nota do editor: Como um placeholder, um mixin é igualmente inútil, a menos que seja referenciado, assim essa seção não está dizendo que eles são diferentes nesse aspecto, mas apenas esclarecendo que mesmo que se pareça similar com um bloco de declaração CSS, não será gerado por conta própria.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Basicamente você escreve exatamente como uma classe &lt;code&gt;CSS&lt;/code&gt; exceto pelo símbolo % ao invés do ponto. Além disso, segue as mesmas &lt;a href=&#34;http://www.w3.org/TR/html401/types.html#type-cdata&#34;&gt;regras de nomenclatura&lt;/a&gt; das classes.&lt;/p&gt;

&lt;p&gt;Agora, se você tentar compilar seu SCSS, você não vai ver esse pedaço de código no arquivo gerado. Como eu disse: &lt;strong&gt;placeholders não são compilados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Então, por agora, esse placeholder é totalmente inútil. Você não consegue fazer qualquer uso dele a não ser que você veja o &lt;code&gt;@extend&lt;/code&gt;. Um &lt;code&gt;@extend&lt;/code&gt; tem como objetivo herdar as propriedades de um seletor CSS / SCSS placeholder. Aqui como usá-lo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.container {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Ao fazer isso, o arquivo SASS vai pegar o conteúdo do placeholder &lt;code&gt;%center&lt;/code&gt; e aplicá-lo no &lt;code&gt;.container&lt;/code&gt; (mesmo que isso não aconteça exatamente assim &amp;#8211; mas isso não é importante agora). Como eu disse, você também pode &lt;em&gt;estender&lt;/em&gt; seletores CSS já existentes (além de placeholders SCSS) dessa maneira:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;.table-zebra {
  @extend .table;

  tr:nth-of-type(even) {
    background: rgba(0,0,0,.5);
  }
}
&lt;/pre&gt;

&lt;p&gt;Esse é um caso muito comum para o uso do &lt;code&gt;@extend&lt;/code&gt;. Nesse caso, pedimos para a classe &lt;code&gt;.table-zebra&lt;/code&gt; se comportar exatamente como a classe &lt;code&gt;.table&lt;/code&gt; e então adicionamos as regras específicas da classe &lt;code&gt;.table-zebra&lt;/code&gt;. &lt;em&gt;Estender&lt;/em&gt; seletores é bastante conveniente quando você desenvolve seu site ou aplicação em componentes modulares.&lt;/p&gt;

&lt;h2 id=&#34;qual-utilizar-1&#34;&gt;Qual utilizar?&lt;/h2&gt;

&lt;p&gt;Então, a pergunta permanece: o que você deve usar? Bem, como tudo em nossa área: &lt;strong&gt;depende&lt;/strong&gt;. Depende do contexto e, em uma outra análise, do que você está querendo fazer.&lt;/p&gt;

&lt;p&gt;O melhor conselho seria: se você precisa de variáveis, utilize o mixin. Caso contrário, use o placeholder. Há duas razões para isso:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Primeiro, você não pode usar variáveis em um placeholder. Na verdade, até pode, mas você não consegue &lt;em&gt;passar&lt;/em&gt; uma variável em um placeholder para gerar um conteúdo específico de CSS, como você faria em um mixin.&lt;/li&gt;
&lt;li&gt;Segundo, a forma como o SASS lida com os mixins, os torna muito incovenientes quando você os utiliza sem variáveis contextuais. Simplificando: o SASS vai duplicar a saída de um mixin toda vez que você o utilizá-lo, resultando não apenas em CSS duplicado, mas também em uma folha de estilos maior.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considere o primeiro exemplo desse artigo:&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;@mixin center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @include center;
}

.image-cover {
  @include center;
}
&lt;/pre&gt;

&lt;p&gt;O CSS compilado seria esse:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Observou o CSS duplicado? Ele não é tão prejudicial se forem apenas três linhas duplicadas, mas se você tiver muitos mixins que são usados várias vezes em um projeto, essas três linhas podem facilmente se tornarem 300. E se reformularmos nosso exemplo, só que dessa vez utilizando o placeholder?&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.container {
  @extend %center;
}

.image-cover {
  @extend %center;
}
&lt;/pre&gt;

&lt;p&gt;Agora, esse é o CSS gerado:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.container, .image-cover {
  display: block;
  margin-left: auto;
  margin-right: auto;
}
&lt;/pre&gt;

&lt;p&gt;Muito melhor! A compilação leva vantagem &lt;a href=&#34;http://reference.sitepoint.com/css/selectorgrouping&#34;&gt;agrupando seletores&lt;/a&gt;, sem nenhum estilo repetido. Assim, sempre que você quiser evitar a escrever as mesmas propriedades diversas vezes, sabendo que elas não mudarão, é uma boa idéia &lt;em&gt;estender&lt;/em&gt; um placeholder. Isso resultará em um código CSS compilado muito mais limpo.&lt;/p&gt;

&lt;p&gt;Por outro lado, se você precisa escrever as mesmas propriedades em vários lugares mas com valores diferentes (tamanho, cores, etc), um mixin é o melhor caminho a seguir. Agora se você possui ambos, um grupo de valores fixos e outro de valores variáveis, você deve tentar usar uma combinação dos dois.&lt;/p&gt;

&lt;pre class=&#34;lang-scss&#34;&gt;%center {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

@mixin skin($color, $size) {
  @extend %center;
  background: $color;
  height: $size;
}

a { @include skin(pink, 10em) }
b { @include skin(blue, 90px) }
&lt;/pre&gt;

&lt;p&gt;Neste caso, o mixin está &lt;em&gt;estendendo&lt;/em&gt; o placeholder para os valores fixos em vez de jogá-los diretamente em seu corpo. Isso gera um CSS mais limpo:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;a, b {
  margin-left: auto;
  margin-right: auto;
  display: block;
}

a {
  background: pink;
  height: 10em;
}

b {
  background: blue;
  height: 90px;
}
&lt;/pre&gt;

&lt;h2 id=&#34;conclusão-1&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É isso. Espero ter deixado claro não só o que são mixins e placeholders, mas também quando você deve usá-los e qual os efeitos sobre o CSS compilado.&lt;/p&gt;

&lt;p&gt;Se você tiver alguma coisa a acrescentar sobre suas experiências com essas &lt;em&gt;features&lt;/em&gt; dos pré-processadores de CSS, sinta-se livre para compartilhar nos comentários.&lt;/p&gt;

&lt;p&gt;—&lt;/p&gt;

&lt;p&gt;Texto traduzido e adaptado do]&lt;a href=&#34;http://www.sitepoint.com/sass-mixin-placeholder/&#34;&gt;4&lt;/a&gt; escrito pelo &lt;a href=&#34;https://twitter.com/HugoGiraudel&#34; title=&#34;Perfil do twitter&#34;&gt;Hugo Giraudel&lt;/a&gt; em 30 de janeiro de 2014.&lt;/p&gt;

&lt;p&gt;Tradução autorizada pelo &lt;a href=&#34;http://www.sitepoint.com/&#34;&gt;SitePoint&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Qualquer erro ou sugestão de melhoria na tradução, é bem vinda! 🙂&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Utilizando Mixins em pré-processadores CSS</title>
      <link>https://tableless.github.io/hugo-public/utilizando-mixins-em-css-preprocessors/</link>
      <pubDate>Mon, 13 Jan 2014 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/utilizando-mixins-em-css-preprocessors/</guid>
      <description>&lt;p&gt;Recentemente respondi à uma enquete (não me perguntem aonde, eu esqueci! :-() onde era perguntado sobre como lidávamos com prefixos proprietários em nossos códigos CSS. Até aquele momento apenas cerca de 9% dos participantes usavam Pré-processadores e cerca de 26% escreviam os &lt;a href=&#34;http://tableless.com.br/prefixos-dos-browsers-a-web-precisa-de-voce/&#34; title=&#34;Prefixos dos browsers: A web precisa de você&#34;&gt;prefixos do browsers&lt;/a&gt; “na unha”.&lt;/p&gt;

&lt;p&gt;Pré-processadores de CSS ainda não são um comum para algumas pessoas, mas eu, particularmente, defendo o uso devido à organização e redução de trabalho na escrita de folhas de estilo, proporcionado entre outros, pelo encadeamento e os “mixins”, algo como “associação interna”, que funcionam melhores que muitos analgésicos para dores de cabeça causadas pelo retrabalho.&lt;/p&gt;

&lt;p&gt;Considero o dilema dos prefixos proprietários como o maior motivo para utilizarmos mixins, já que eles estão em processo de adaptação, sofrem recorrentes mudanças e em um curto prazo (&lt;span style=&#34;text-decoration: line-through&#34;&gt;com um pouco de fé&lt;/span&gt;) serão removidos para dar lugar à normalização (se quiser entender mais, recomendo o artigo &lt;a title=&#34;Prefixos dos browsers: A web precisa de você&#34; href=&#34;http://tableless.com.br/prefixos-dos-browsers-a-web-precisa-de-voce/&#34; target=&#34;_blank&#34;&gt;&amp;#8220;Prefixos dos browsers: A web precisa de você&amp;#8221;&lt;/a&gt;). Para você que só acredita vendo, prefixos proprietários são mais ou menos assim:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.elemento1 {
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  -ms-border-radius: 10px;
  -o-border-radius: 10px;
  border-radius: 10px;
}
.elemento2 {
  -webkit-border-radius: 12px;
  -moz-border-radius: 12px;
  -ms-border-radius: 12px;
  -o-border-radius: 12px;
  border-radius: 12px;
}
&lt;/pre&gt;

&lt;p&gt;A grande dificuldade surge na manutenção de extensos arquivos CSS, com inúmeras referências à estes prefixos e que precisam ser alterados. No caso de um CSS puro, a melhor alternativa é abrir um editor de texto e procurar todas as ocorrências para altera-las uma a uma, agora, considerando a utilização de pré-processadores, como o &lt;a title=&#34;LESS CSS&#34; href=&#34;http://lesscss.org/&#34; target=&#34;_blank&#34;&gt;LESS&lt;/a&gt; e o &lt;a title=&#34;SASS LANG&#34; href=&#34;http://sass-lang.com/&#34; target=&#34;_blank&#34;&gt;SASS&lt;/a&gt; (de certa forma maduros), o uso de mixins pode ser adotado para concentrar a necessidade de mudança em apenas um trecho do código.&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;line-height: 1.5em&#34;&gt;Exemplo LESS:&lt;/span&gt;&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.border-radius (@radius) {
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
  -ms-border-radius: @radius;
  -o-border-radius: @radius;
  border-radius: @radius;
}
.elemento1 {
 .border-radius(10px);
}
.elemento2 {
 .border-radius(12px);
}&lt;/pre&gt;

&lt;p&gt;Exemplo SASS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;@mixin border-radius ($radius) {
  -webkit-border-radius: $radius;
  -moz-border-radius: $radius;
  -ms-border-radius: $radius;
  -o-border-radius: $radius;
  border-radius: $radius;
}
.elemento1 {
 @include border-radius(10px);
}
.elemento2 {
 @include border-radius(12px);
}
&lt;/pre&gt;

&lt;p&gt;Este é um exemplo simples de mixins, em uma utilização mais aprofundada é possível trabalhar mais variáveis, valores padrões e até mesmo sobrecarga.&lt;/p&gt;

&lt;p&gt;Deixando de lado o padrão de escrita de cada pré-processador, ambos resultam no seguinte código CSS:&lt;/p&gt;

&lt;pre class=&#34;lang-css&#34;&gt;.elemento1 {
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  -ms-border-radius: 10px;
  -o-border-radius: 10px;
  border-radius: 10px;
}
.elemento2 {
  -webkit-border-radius: 12px;
  -moz-border-radius: 12px;
  -ms-border-radius: 12px;
  -o-border-radius: 12px;
  border-radius: 12px;
}
&lt;/pre&gt;

&lt;p&gt;Os mixins podem ser reutilizados e reescritos, deixando um código organizado e de fácil manutenção, no entanto, eu não seria imprudente a ponto de recomendar a utilização de pré-processadores aos sete ventos. É extremamente necessário uma avaliação do projeto e suas reais necessidades da utilização de uma ferramenta dessas, que, dependendo das proporções e finalidades do CSS, acabam apenas por aumentar a complexidade do desenvolvimento.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Turbinando as Media Queries</title>
      <link>https://tableless.github.io/hugo-public/turbinando-media-queries/</link>
      <pubDate>Thu, 12 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://tableless.github.io/hugo-public/turbinando-media-queries/</guid>
      <description>

&lt;p&gt;Media Queries são uma das ferramenta mais importante do CSS pra quem se preocupa com Web Design Responsivo. Com uma ajudinha dos pré-processadores as media queries podem ficar ainda melhores. Neste artigo vamos turbinar as Media Queries usando um pouco das opções que o SASS nos oferece para ajudar na organização, manutenção e garantir legibilidade ao nosso código.&lt;/p&gt;

&lt;p&gt;Nota: os exemplos deste post serão todos em SASS com a sintaxe do &lt;code&gt;.scss&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;breakpoints-em-variáveis&#34;&gt;Breakpoints em variáveis&lt;/h2&gt;

&lt;p&gt;Se você já usou algum pré-processador, sem dúvida já usou variáveis.&lt;/p&gt;

&lt;pre class=&#34;lang-css prettyprint linenums&#34;&gt;// width
$bp-smallest: 10em;
$bp-small: 30em;
$tp-small-1: 37.5em;
&lt;/pre&gt;

&lt;p&gt;Dessa forma, você consegue manter seus breakpoints sob controle e replicá-los de forma concisa e prática. Como estamos falando de organização de código, consistência na nomenclatura é muito importante, então vamos dar uma olhada na que adotei para mim. Você pode criar a sua e se tiver em uma equipe, é bom que todos da equipe concordem com uma mesma nomenclatura:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;bp&lt;/strong&gt;: Breakpoints são pontos onde a mudança interfere amplamente no layout (redução/aumento de colunas, posição de elementos importantes, etc)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tp&lt;/strong&gt;: Tweakpoints são para mudanças menores, que interferem em apenas um elemento&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Facilita a leitura se colocar juntamente com a sigla uma característica (no caso, &lt;strong&gt;small&lt;/strong&gt;). Além disso, Tweakpoints costumam ter uma ocorrência maior que Breakpoints, por isso numerá-los é uma boa forma de manter o controle.&lt;/p&gt;

&lt;h2 id=&#34;media-features-em-variáveis&#34;&gt;Media Features em variáveis&lt;/h2&gt;

&lt;p&gt;Outra forma de trabalhar com variáveis em suas Media Queries é armazenar toda a &lt;strong&gt;media feature&lt;/strong&gt; como uma &lt;code&gt;string&lt;/code&gt;. Por exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css prettyprint linenums&#34;&gt;// width
$bp-w-small: &#39;(min-width: 30em)&#39;;
$tp-w-small-1: &#39;(min-width: 37.5em)&#39;;

// height
$bp-h-small: &#39;(min-height: 10em)&#39;;
&lt;/pre&gt;

&lt;p&gt;Essa técnica tem maior legibilidade das variáveis. Utilizei os mesmos valores no exemplo acima, mas antes não era possível perceber que uma delas era utilizada para a altura da viewport e as outras duas para a largura.&lt;/p&gt;

&lt;p&gt;Com relação à nomenclatura, uma pequena alteração para auxiliar na legibilidade (uma vez que a string não aparecerá ao longo do seu código de desenvolvimento), coloquei um &lt;code&gt;h&lt;/code&gt; para height e um &lt;code&gt;w&lt;/code&gt; para width.&lt;/p&gt;

&lt;p&gt;Lembrando que, nesse caso é preciso escapar envolvendo a variável com &lt;code&gt;#{}&lt;/code&gt; quando inserí-la no código para garantir que seu valor não seja interpretado pelo compilador.&lt;/p&gt;

&lt;pre class=&#34;lang-css prettyprint linenums&#34;&gt;@media #{$bp-w-small} {
        /*--styles--*/
}

@media #{$tp-w-small-1} {
        /*--styles--*/
}

@media #{$bp-h-small} {
    /*--styles--*/
}
&lt;/pre&gt;

&lt;h2 id=&#34;media-queries-com-mixins&#34;&gt;Media Queries com mixins&lt;/h2&gt;

&lt;p&gt;Outra maneira de lidar com suas media queries é colocando-as em um &lt;code&gt;mixin&lt;/code&gt; e selecionando a partir de condicionais (&lt;code&gt;@if&lt;/code&gt;). Segue o exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css prettyprint linenums&#34;&gt;$bp-width-small : &#34;(min-width: 24em)&#34;;
$tp-height-small : 10em;

@mixin mq($breakpoint) {
    @if $breakpoint == $tp-height-small {
        @media (max-height: $tp-height-small) {
                @content;
        }
    }
    @if $breakpoint == $bp-width-small {
        @media #{$bp-width-small} {
                @content;
        }
    }
    @if $breakpoint == 50 {
        @media (max-width: 50em) {
                @content;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Outro ponto positivo de utilizar as Media Queries envolvidas em &lt;code&gt;mixin&lt;/code&gt; é de oferecer uma CSS como fallback para navegadores que não suportam Media Queries. Para isso, é só estabeler mais um condicional. Veja o exemplo:&lt;/p&gt;

&lt;pre class=&#34;lang-css prettyprint linenums&#34;&gt;$bp-width-small : &#34;(min-width: 24em)&#34;;
$tp-height-small : 10em;

$mediaqueries: true;

@mixin mq($breakpoint) {
    @if $mediaqueries == true {
        @if $breakpoint == $tp-height-small {
                @media (max-height: $tp-height-small) {
                        @content;
            }
        }
        @if $breakpoint == #{$bp-width-small} {
                @media #{$bp-width-small} {
                        @content;
            }
        }
        @if $breakpoint == 50 {
                @media (max-width: 50em) {
                        @content;
                }
        }
    }

}
&lt;/pre&gt;

&lt;p&gt;Nesse caso, o compilador vai avaliar se a variável &lt;code&gt;$mediaqueries&lt;/code&gt; é &lt;code&gt;true&lt;/code&gt; ou &lt;code&gt;false&lt;/code&gt;. Caso seja &lt;code&gt;true&lt;/code&gt;, significa que há suporte para Media Queries e portanto, ele vai compilar o mixin; se for &lt;code&gt;false&lt;/code&gt; ele ignora a declaração do &lt;code&gt;mixin&lt;/code&gt; e compila o restante do código sem Media Queries.&lt;/p&gt;

&lt;p&gt;Espero que o post tenha sido útil e ajudado a ilustrar um pouco melhor as facilidades que um pré-processador pode trazer para o seu workflow. Você já usa alguma técnica dessa em seus projetos?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>